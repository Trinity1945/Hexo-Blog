

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#857d85">
  <meta name="author" content="liziyuan">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL高级一、Mysql逻辑架构1、整体架构 连接层最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级">
<meta property="og:url" content="http://example.com/2022/09/05/MySQL%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="九黎城">
<meta property="og:description" content="MySQL高级一、Mysql逻辑架构1、整体架构 连接层最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/mysql.png">
<meta property="article:published_time" content="2022-09-05T01:12:24.000Z">
<meta property="article:modified_time" content="2022-09-05T01:43:03.983Z">
<meta property="article:author" content="liziyuan">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/mysql.png">
  
  
  
  <title>MySQL高级 - 九黎城</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>bigMouse</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL高级"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-05 09:12" pubdate>
          2022年9月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          239 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL高级</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p>
<table>
<thead>
<tr>
<th>Management Serveices &amp; Utilities</th>
<th>系统管理和控制工具</th>
</tr>
</thead>
<tbody><tr>
<td>SQL Interface</td>
<td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td>
</tr>
<tr>
<td>Parser</td>
<td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td>
</tr>
<tr>
<td>Optimizer</td>
<td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td>
</tr>
<tr>
<td>Cache 和 Buffer</td>
<td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td>
</tr>
</tbody></table>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MylSAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁（不适合高并发）</td>
<td>行锁（适合高并发操作）</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引，还缓存真实数据。对内存要求较高</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p>
<h1 id="二、性能与JOIN"><a href="#二、性能与JOIN" class="headerlink" title="二、性能与JOIN"></a>二、性能与JOIN</h1><h2 id="1、性能下降原因"><a href="#1、性能下降原因" class="headerlink" title="1、性能下降原因"></a>1、性能下降原因</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p><strong>单值索引</strong></p>
<p>创建语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_表名_字段名 ON 表名(字段名);Copy<br></code></pre></td></tr></table></figure>

<p><strong>复合索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_表名_字段名1字段名2... ON 表名(字段名1, 字段名2 ...);Copy<br></code></pre></td></tr></table></figure>

<h3 id="关联太多JOIN"><a href="#关联太多JOIN" class="headerlink" title="关联太多JOIN"></a>关联太多JOIN</h3><p>内连接、外连接的表不要过多</p>
<h3 id="服务器调优及参数设置"><a href="#服务器调优及参数设置" class="headerlink" title="服务器调优及参数设置"></a>服务器调优及参数设置</h3><h2 id="2、SQL执行加载顺序"><a href="#2、SQL执行加载顺序" class="headerlink" title="2、SQL执行加载顺序"></a>2、SQL执行加载顺序</h2><h3 id="手写顺序"><a href="#手写顺序" class="headerlink" title="手写顺序"></a>手写顺序</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112248.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938114.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p>
<p>下面是经常出现的查询顺序：</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112330.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938074.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112343.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938224.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814191644.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938193.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="3、7种JOIN"><a href="#3、7种JOIN" class="headerlink" title="3、7种JOIN"></a>3、7种JOIN</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938270.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>CREATE TABLE `t_emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, empno INT NOT NULL, PRIMARY KEY (`id`), KEY `idx_dept_id` (`deptId`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;风清扬&#x27;,90,1,100001);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;岳不群&#x27;,50,1,100002);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;令狐冲&#x27;,24,1,100003);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;洪七公&#x27;,70,2,100004);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;乔峰&#x27;,35,2,100005);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;灭绝师太&#x27;,70,3,100006);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;周芷若&#x27;,20,3,100007);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张三丰&#x27;,100,4,100008);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张无忌&#x27;,25,5,100009);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;韦小宝&#x27;,18,NULL,100010);Copy<br></code></pre></td></tr></table></figure>

<h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><ul>
<li>笛卡尔积</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_dept, t_emp;Copy<br></code></pre></td></tr></table></figure>

<p>t_dept共20条记录，t_emp共6条记录。两表共同查询后共120条记录</p>
<ul>
<li>内连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a INNER JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153140.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938633.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>左外连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153254.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938412.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>右外连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>左外连接<strong>取左表的独有部分</strong></li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153909.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938516.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>右外连接<strong>取右表的独有部分</strong></li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>注意</strong>：判断字段是否为NULL时，<strong>不能使用’&#x3D;’</strong></p>
<p>因为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">= NULLCopy<br></code></pre></td></tr></table></figure>

<p>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IS NULLCopy<br></code></pre></td></tr></table></figure>

<p>来进行判空</p>
<ul>
<li>全外连接</li>
</ul>
<p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.deptId = b.id<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>查询两表独有内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.deptId = b.id WHERE b.id IS NULL<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.deptId = b.id WHERE a.deptId IS NULL;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h2><ul>
<li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p>
<p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p>
</li>
<li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938615.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录</li>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li>
</ul>
<h2 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li>
</ul>
<h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [UNIQUE] INDEX [indexName] ON table_name(column);Copy<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX [indexName] ON table_name;Copy<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW INDEX FROM table_name;Copy<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>单值索引</p>
<ul>
<li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name) --单值索引<br>);<br><br>--单独创建单值索引<br>CREATE INDEX idx_customer_name ON customer(customer_name);Copy<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li><p>定义：索引列的值必须唯一，但允许有空值</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no) --唯一索引<br>);<br><br>--单独创建唯一索引<br>CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);Copy<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>主键索引</p>
<ul>
<li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id) --主键索引<br>);<br><br>--单独创建主键索引<br>ALTER TABLE customer ADD PRIMARY KEY customer(customer_no);<br><br>--删除主键索引<br>ALTER TABLE customer DROP PRIMARY KEY;<br><br>--修改建主键索引<br>必须先删除掉(drop)原索引，再新建(add)索引Copy<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>复合索引</p>
<ul>
<li><p>定义：即一个索引包含多个列</p>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no), --唯一索引<br>KEY (customer_no,customer_name) --复合索引<br>);<br><br>--单独创建复合索引<br>CREATE INDEX idx_no_name ON customer(customer_no,customer_name);Copy<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>树的内容参照<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#B%E6%A0%91%E3%80%81B-%E5%92%8CB-%E6%A0%91">JAVA数据结构 B树、B+树和B*树</a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153029.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938560.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153043.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938623.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li>
<li>在 B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li>
</ul>
<p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ul>
<li>B+树的磁盘读写代价更低<ul>
<li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li>
</ul>
</li>
<li>B+树的查询效率更加稳定<ul>
<li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li>
</ul>
</li>
</ul>
<h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822173605.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938608.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p>
<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822185520.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938584.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p>
<table>
<thead>
<tr>
<th>a（主键）</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>a</td>
</tr>
</tbody></table>
<p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p>
<p>根据这个特点，可以看出复合索引具有以下使用方法</p>
<ul>
<li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p>
</li>
<li><p>覆盖索引的同时，可以带上主键字段，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT a, b, c, d FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p>
</li>
<li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p>
<ul>
<li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age &gt; 1;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938598.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后映射到全表中的对应记录上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age &gt; 80;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938821.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT age, name FROM t_emp WHERE age &gt; 1;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938841.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
</li>
<li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT id, age, name, deptId FROM t_emp ;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938863.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<h2 id="5、索引的使用场景"><a href="#5、索引的使用场景" class="headerlink" title="5、索引的使用场景"></a>5、索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul>
<li>主键自动建立唯一索引</li>
<li>频繁作为<strong>查询条件</strong>的字段应该创建索引</li>
<li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引</li>
<li>单键&#x2F;组合索引的选择问题，<strong>组合索引性价比更高</strong></li>
<li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li>
<li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li>
</ul>
<h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul>
<li>表<strong>记录太少</strong>（有无索引差别不大）</li>
<li>经常<strong>增删改</strong>的表或者字段</li>
<li>Where 条件里用不到的字段不创建索引</li>
<li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li>
</ul>
<h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p>
<h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--EXPLAIN + SQL语句，如：<br>EXPLAIN SELECT * FROM person;Copy<br></code></pre></td></tr></table></figure>

<p><strong>Explain 执行后返回的信息：</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815171636.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938872.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="3、表头字段介绍"><a href="#3、表头字段介绍" class="headerlink" title="3、表头字段介绍"></a>3、表头字段介绍</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>INSERT INTO t1(content) VALUES(CONCAT(&#x27;t1_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t2(content) VALUES(CONCAT(&#x27;t2_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t3(content) VALUES(CONCAT(&#x27;t3_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t4(content) VALUES(CONCAT(&#x27;t4_&#x27;,FLOOR(1+RAND()*1000)));Copy<br></code></pre></td></tr></table></figure>

<h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<ul>
<li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.id = t3.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938880.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p>
</li>
<li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT t2.id FROM t2 WHERE t2.id = <br>(SELECT t1.id FROM t1 WHERE t1.id = <br>(SELECT t3.id FROM t3)<br>);Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938889.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p>
</li>
<li><p><strong>id相同又不同</strong>： 执行顺序为</p>
<ul>
<li>id不同时，值较大的先执行</li>
<li>id相同时，从上至下执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM (SELECT t3.id FROM t3) s1, t2 WHERE s1.id = t2.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938548.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p>
<ul>
<li>其中dervied<strong>2</strong> 的 2，为 id &#x3D; 2</li>
</ul>
</li>
</ul>
<h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p>
<table>
<thead>
<tr>
<th>select_type 属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td>
</tr>
<tr>
<td>DEPEDENT SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td><strong>无法使用缓存</strong>的子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表<strong>获取结果</strong>的SELECT</td>
</tr>
</tbody></table>
<ul>
<li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p>
<ul>
<li>都是 WHERE 后面的条件，SUBQUERY 是单个值（&#x3D;），DEPEDENT SUBQUERY 是一组值（IN）</li>
</ul>
</li>
<li><p>UNCACHEABLE SUBQUERY</p>
<ul>
<li>当使用了**@@来引用系统变量**的时候，不会使用缓存</li>
</ul>
</li>
<li><p>UNION 和 UNION RESULT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp a LEFT JOIN  t_dept b ON a.deptId = b.id WHERE b.id IS NULL<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN  t_dept b ON a.deptId = b.id WHERE a.deptId IS NULL;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938582.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p>
<h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all<br><br>--常见的顺序为<br>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; allCopy<br></code></pre></td></tr></table></figure>

<p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SYSTEM</td>
<td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td>
</tr>
<tr>
<td>CONST</td>
<td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td>
</tr>
<tr>
<td>EQ_REF</td>
<td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>REF</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td>
</tr>
<tr>
<td>RANGE</td>
<td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td>
</tr>
<tr>
<td>INDEX</td>
<td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td>
</tr>
<tr>
<td>ALL</td>
<td>Full Table Scan，将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<ul>
<li><p>REF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，且用到了&#x27; = &#x27;<br>EXPLAIN SELECT * FROM t_emp WHERE deptId = 3;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938590.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>RANGE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询<br>EXPLAIN SELECT * FROM t_emp WHERE deptId &gt; 3;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938633.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>INDEX</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，查找了整张表时，用到了索引<br>EXPLAIN SELECT deptId FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938678.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>ALL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中name为非索引<br>EXPLAIN SELECT name FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938683.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p>
<h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE id = 1 AND deptId = 1;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938315.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p>
<p>有以下两种解释</p>
<ul>
<li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li>
<li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li>
</ul>
<p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中id和deptId都为索引<br>EXPLAIN SELECT id, deptId FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938353.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938345.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p>
<p><strong>ken_len 越长，说明索引使用的越充分</strong></p>
<h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938332.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p>
<p><strong>验证</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--先删除索引<br>DROP INDEX idx_dept_id ON t_emp;<br><br>--查找<br>EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;<br><br>--再创建索引<br>CREATE INDEX idx_dept_id ON t_emp(deptId);<br><br>--查找<br>EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;Copy<br></code></pre></td></tr></table></figure>

<p><strong>结果如下</strong></p>
<ul>
<li><p>未使用索引时，一共需要查询26行</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938356.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>使用索引后，一共需要查询6行</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938337.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p>
<ul>
<li><p><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）</p>
<ul>
<li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li>
<li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li>
</ul>
<p><strong>演示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--创建符合索引<br>CREATE INDEX idx_emp_empno_age ON t_emp(empno, age);<br><br>--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY age;<br><br>--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY empno;<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY empno, age;Copy<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938860.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938839.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938905.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p><strong>Using temporary</strong></p>
<ul>
<li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li>
<li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li>
</ul>
<p><strong>演示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）<br>CREATE INDEX idx_emp_empno_age ON t_emp(empno, age);<br><br>----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 GROUP BY empno;<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 GROUP BY empno, age;Copy<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938892.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938898.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p><strong>重要结论</strong></p>
<p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降</p>
<ul>
<li><p><strong>Using index</strong></p>
<ul>
<li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">key：实际用到的索引——覆盖索引</a>，避免访问了表的数据行，<strong>效率不错</strong>！</li>
<li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li>
<li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li>
</ul>
<p><strong>演示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询 age 字段，使用了WHERE<br>EXPLAIN SELECT age FROM t_emp WHERE age &gt;100000;<br><br>--查询 empno 和 age 字段，未使用WHERE<br>EXPLAIN SELECT empno, age FROM t_emp;<br><br>--查询 empno 和 name 字段 （name字段不是索引）<br>EXPLAIN SELECT empno, name FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938889.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938242.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938255.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>Using where</p>
<ul>
<li>表明使用了 where 过滤</li>
</ul>
</li>
<li><p>Using join buffer</p>
<ul>
<li>使用了连接缓存</li>
</ul>
</li>
<li><p>impossible where</p>
<ul>
<li>where 子句的值总是 false，不能用来获取任何元组</li>
</ul>
</li>
<li><p>select tables optimized away</p>
<ul>
<li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li>
</ul>
</li>
</ul>
<h1 id="五、单表查询优化"><a href="#五、单表查询优化" class="headerlink" title="五、单表查询优化"></a>五、单表查询优化</h1><h2 id="1、全值匹配很快捷"><a href="#1、全值匹配很快捷" class="headerlink" title="1、全值匹配很快捷"></a>1、全值匹配很快捷</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--建立符合索引（age, deptId, name）<br>CREATE INDEX idx_emp_ade ON t_emp(age, deptId, NAME);<br><br>--查找<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br><br>--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = &#x27;风清扬&#x27; AND age = 90;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938279.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938299.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938328.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938306.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p>
<p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p>
<h2 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--先删除之前创建的单值索引<br>DROP INDEX idx_dept_id ON t_emp; <br><br>--查询，未按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = &#x27;风清扬&#x27;;<br><br>--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）<br>EXPLAIN SELECT empno FROM t_emp WHERE  age = 90 AND name = &#x27;风清扬&#x27;;<br><br>--查询，完全按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938683.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938654.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938681.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938299.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938306.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p>
<p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p>
<p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p>
<h2 id="3、索引列上不计算"><a href="#3、索引列上不计算" class="headerlink" title="3、索引列上不计算"></a>3、索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--直接查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND NAME = &#x27;风清扬&#x27;;<br><br>--使用MySQL函数查询<br>EXPLAIN SELECT empno FROM t_emp WHERE LEFT(age,2) = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938706.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938691.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p>
<p><strong>结论：等号左边无计算</strong></p>
<h2 id="4、范围之后全失效"><a href="#4、范围之后全失效" class="headerlink" title="4、范围之后全失效"></a>4、范围之后全失效</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age &gt; 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId &gt; 1 AND NAME = &#x27;风清扬&#x27;;<br><br>--未使用范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938727.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938093.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938122.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p>
<p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p>
<p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p>
<h2 id="5、覆盖索引多使用"><a href="#5、覆盖索引多使用" class="headerlink" title="5、覆盖索引多使用"></a>5、覆盖索引多使用</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询所有字段<br>EXPLAIN SELECT * FROM t_dept WHERE id = 1;<br><br>--查询索引字段<br>EXPLAIN SELECT id FROM t_dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938153.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938097.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p>
<h2 id="6、使用不等会失效"><a href="#6、使用不等会失效" class="headerlink" title="6、使用不等会失效"></a>6、使用不等会失效</h2><p>在使用<strong>不等于(!&#x3D; 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--SQL语句中有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age != 90;<br>EXPLAIN SELECT * FROM t_emp WHERE age &lt;&gt; 90;<br><br>--SQL语句中没有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age = 90;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938138.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938109.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938519.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论：尽量不要使用不等于</strong></p>
<h2 id="7、使用NULL值要小心"><a href="#7、使用NULL值要小心" class="headerlink" title="7、使用NULL值要小心"></a>7、使用NULL值要小心</h2><p>在使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IS NULL<br>或者<br>IS NOT NULLCopy<br></code></pre></td></tr></table></figure>

<p>时，可能会导致索引失效</p>
<p>但是如果<strong>允许字段为空</strong>，则</p>
<ul>
<li>IS NULL 不会导致索引失效</li>
<li>IS NOT NULL 会导致索引失效</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938561.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age IS NULL;<br><br>EXPLAIN SELECT * FROM t_emp WHERE age IS NOT NULL;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938508.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938495.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="8、模糊查询加右边"><a href="#8、模糊查询加右边" class="headerlink" title="8、模糊查询加右边"></a>8、模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--创建单值索引<br>CREATE INDEX idx_emp_name ON t_emp(NAME);<br><br>--进行模糊查询<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;风%&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风%&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938493.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938511.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938493.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p>
<p>其他情况均失效了</p>
<p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT name FROM t_emp WHERE name LIKE &#x27;%风&#x27;;<br>EXPLAIN SELECT name FROM t_emp WHERE name LIKE &#x27;风%&#x27;;<br><br>EXPLAIN SELECT NAME FROM t_emp WHERE name LIKE &#x27;%风%&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938970.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938973.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938970.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p>
<h2 id="9、字符串加单引号"><a href="#9、字符串加单引号" class="headerlink" title="9、字符串加单引号"></a>9、字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p>
<p><strong>用于查询的表</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938997.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--使用了单引号<br>EXPLAIN SELECT card_id FROM person WHERE card_id = &#x27;1&#x27;;<br><br>--未使用单引号，发生自动类型转换<br>EXPLAIN SELECT card_id FROM person WHERE card_id = 1;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938977.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938982.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="10、尽量不用or查询"><a href="#10、尽量不用or查询" class="headerlink" title="10、尽量不用or查询"></a>10、尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--使用or进行查询<br>EXPLAIN SELECT * FROM t_emp WHERE age = 90 OR NAME = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938142.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全职匹配我最爱，最左前缀要遵守</p>
<p>带头大哥不能死，中间兄弟不能断</p>
<p>索引列上少计算，范围之后全失效</p>
<p>LIKE 百分写最右，覆盖索引不写*</p>
<p>不等空值还有 OR，索引影响要注意</p>
<p>VARCHAR 引号不可丢，SQL 优化有诀窍</p>
<h1 id="六、关联查询优化"><a href="#六、关联查询优化" class="headerlink" title="六、关联查询优化"></a>六、关联查询优化</h1><p><strong>建表语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `class` (<br>`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`id`)<br>);<br>CREATE TABLE IF NOT EXISTS `book` (<br>`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`bookid`)<br>);<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));Copy<br></code></pre></td></tr></table></figure>

<h2 id="1、LEFT-JOIN优化"><a href="#1、LEFT-JOIN优化" class="headerlink" title="1、LEFT JOIN优化"></a>1、LEFT JOIN优化</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--未建立索引时的左外连接查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>--左表（class）建立索引<br>CREATE INDEX idx_class_card ON class(card);<br><br>--再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>--去掉左表索引<br>DROP INDEX idx_class_card ON class;<br><br>--右表建立索引<br>CREATE INDEX idx_book_card ON book(card);<br><br>--再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938628.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938642.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938566.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论</strong></p>
<ul>
<li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li>
<li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li>
</ul>
<h2 id="2、INNER-JOIN优化"><a href="#2、INNER-JOIN优化" class="headerlink" title="2、INNER JOIN优化"></a>2、INNER JOIN优化</h2><p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br>EXPLAIN SELECT * FROM book INNER JOIN class ON book.card = class.card;<br><br>--删除book表中的几条记录<br>DELETE FROM book WHERE bookid&lt;10;<br><br>--再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br><br>--删除book表card字段索引，给class表的card字段添加索引<br>DROP INDEX idx_book_card ON book;<br>CREATE INDEX idx_class_card ON class(card);<br><br>--再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938441.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938747.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938492.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p>
<p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p>
<h2 id="3、RIGHT-JOIN优化"><a href="#3、RIGHT-JOIN优化" class="headerlink" title="3、RIGHT JOIN优化"></a>3、RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p>
<h1 id="七、排序分组优化"><a href="#七、排序分组优化" class="headerlink" title="七、排序分组优化"></a>七、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p>
<p><strong>索引信息</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938834.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="1、ORDER-BY-优化"><a href="#1、ORDER-BY-优化" class="headerlink" title="1、ORDER BY 优化"></a>1、ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--不满足索引覆盖时进行排序查询<br>EXPLAIN SELECT empno FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br><br>--按照复合索引顺序进行排序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId, name;<br><br>--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name;<br><br>--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name, age;<br><br>--排序时部分(age)升序，部分(deptId)降序，发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age ASC, deptId DESC;<br><br>--排序时都为降序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age DESC, deptId DESC;<br><br>--排序时，在前面的字段为常量时（非范围）<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age = 50 ORDER BY deptId, name;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age = 50 AND deptId&gt;10000 ORDER BY deptId, name;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938871.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938108.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938113.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938262.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938280.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938421.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938553.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论</strong>：</p>
<p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p>
<ul>
<li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li>
<li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li>
<li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li>
<li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li>
</ul>
<h3 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h3><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p>
<ul>
<li>双路排序<ul>
<li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li>
<li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li>
</ul>
</li>
<li>单路排序<ul>
<li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li>
<li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。也就是<strong>本来想省一次 I&#x2F;O 操作，反而导致了大量的 I&#x2F;O 操作，反而得不偿失</strong></li>
</ul>
</li>
<li>优化Using filesort<ul>
<li>增大 sort_butter_size 参数的设置<ul>
<li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li>
</ul>
</li>
<li>增大 max_length_for_sort_data 参数的设置<ul>
<li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li>
<li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。（1024-8192 之间调整）</li>
</ul>
</li>
<li>减少 select 后面的查询的字段<ul>
<li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938659.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="2、GROUP-BY-优化"><a href="#2、GROUP-BY-优化" class="headerlink" title="2、GROUP BY 优化"></a>2、GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p>
<h1 id="八、截取查询分析"><a href="#八、截取查询分析" class="headerlink" title="八、截取查询分析"></a>八、截取查询分析</h1><h2 id="1、慢日志查询"><a href="#1、慢日志查询" class="headerlink" title="1、慢日志查询"></a>1、慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li>
<li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li>
<li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p>
<p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p>
<table>
<thead>
<tr>
<th>SQL 语句</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td>
<td>查看慢查询日志是否开启</td>
<td>默认情况下 slow_query_log 的值为 OFF</td>
</tr>
<tr>
<td>set global slow_query_log&#x3D;1</td>
<td>开启慢查询日志</td>
<td></td>
</tr>
<tr>
<td>SHOW VARIABLES LIKE ‘long_query_time%’</td>
<td>查看慢查询设定阈值</td>
<td>单位：秒</td>
</tr>
<tr>
<td>set long_query_time&#x3D;1</td>
<td>设定慢查询阈值</td>
<td>单位：秒</td>
</tr>
</tbody></table>
<p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p>
<h2 id="2、批量数据脚本"><a href="#2、批量数据脚本" class="headerlink" title="2、批量数据脚本"></a>2、批量数据脚本</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--dept 部门表<br>CREATE TABLE `dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, ceo INT NULL , PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br><br>-- emp 员工表<br>CREATE TABLE `emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `empno` INT NOT NULL , `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, PRIMARY KEY (`id`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;Copy<br></code></pre></td></tr></table></figure>

<h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询<br>SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;<br><br>--设置<br>SET GLOBAL log_bin_trust_function_creators=1;Copy<br></code></pre></td></tr></table></figure>

<h3 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h3><h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a><strong>随机产生字符串</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾<br>DELIMITER $$<br>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br>BEGIN<br>DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;<br>DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;<br>DECLARE i INT DEFAULT 0;<br>WHILE i &lt; n DO<br>SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br>SET i = i + 1;<br>END WHILE;<br>RETURN return_str;<br>END $$Copy<br></code></pre></td></tr></table></figure>

<p>如果要<strong>删除函数</strong>，则执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FUNCTION rand_string;Copy<br></code></pre></td></tr></table></figure>

<h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>SET i = FLOOR(from_num +RAND()*(to_num -from_num+1)) ;<br>RETURN i;<br>END$$Copy<br></code></pre></td></tr></table></figure>

<p>如果要<strong>删除函数</strong>，则执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop function rand_num;Copy<br></code></pre></td></tr></table></figure>

<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE insert_emp( START INT , max_num INT )<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>#set autocommit =0 把 autocommit 设置成 0<br>SET autocommit = 0;<br>REPEAT<br>SET i = i + 1;<br>INSERT INTO emp (empno, NAME ,age ,deptid ) VALUES ((START+i) ,rand_string(6) , rand_num(30,50),rand_num(1,10000));<br>UNTIL i = max_num<br>END REPEAT;<br>COMMIT;<br>END$$<br><br>--删除<br>-- DELIMITER ;<br>-- drop PROCEDURE insert_emp;Copy<br></code></pre></td></tr></table></figure>

<h4 id="创建往-dept-表中插入数据的存储过程"><a href="#创建往-dept-表中插入数据的存储过程" class="headerlink" title="创建往 dept 表中插入数据的存储过程"></a>创建往 dept 表中插入数据的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 dept 表添加随机数据<br>DELIMITER $$<br>CREATE PROCEDURE `insert_dept`( max_num INT )<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>SET autocommit = 0;<br>REPEAT<br>SET i = i + 1;<br>INSERT INTO dept ( deptname,address,ceo ) VALUES (rand_string(8),rand_string(10),rand_num(1,500000));<br>UNTIL i = max_num<br>END REPEAT;<br>COMMIT;<br>END$$<br><br>--删除<br>-- DELIMITER ;<br>-- drop PROCEDURE insert_dept;Copy<br></code></pre></td></tr></table></figure>

<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><h4 id="添加数据到部门表"><a href="#添加数据到部门表" class="headerlink" title="添加数据到部门表"></a>添加数据到部门表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 dept 表添加 1 万条数据<br>DELIMITER ;<br>CALL insert_dept(10000);Copy<br></code></pre></td></tr></table></figure>

<h4 id="添加数据到员工表"><a href="#添加数据到员工表" class="headerlink" title="添加数据到员工表"></a>添加数据到员工表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 emp 表添加 50 万条数据<br>DELIMITER ;<br>CALL insert_emp(100000,500000);Copy<br></code></pre></td></tr></table></figure>

<h3 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h3><h4 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))<br>BEGIN<br>DECLARE done INT DEFAULT 0;<br>DECLARE ct INT DEFAULT 0;<br>DECLARE _index VARCHAR(200) DEFAULT &#x27;&#x27;;<br>DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE<br>table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name &lt;&gt;&#x27;PRIMARY&#x27; ;<br>DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;<br>OPEN _cur;<br>FETCH _cur INTO _index;<br>WHILE _index&lt;&gt;&#x27;&#x27; DO<br>SET @str = CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename );<br>PREPARE sql_str FROM @str ;<br>EXECUTE sql_str;<br>DEALLOCATE PREPARE sql_str;<br>SET _index=&#x27;&#x27;;<br>FETCH _cur INTO _index;<br>END WHILE;<br>CLOSE _cur;<br>END$$Copy<br></code></pre></td></tr></table></figure>

<h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);Copy<br></code></pre></td></tr></table></figure>

<h1 id="九、MySQL锁机制"><a href="#九、MySQL锁机制" class="headerlink" title="九、MySQL锁机制"></a>九、MySQL锁机制</h1><h2 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--展示表是否加锁<br>SHOW OPEN TABLES;<br><br>--加锁 read (读锁) write (写锁)<br>LOCK TABLE table1 read(write), table2 read(write)...<br><br>--全部解锁<br>UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure>

<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul>
<li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul>
<li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li>
<li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li>
<li>如果要修改被锁表的信息<ul>
<li>主机A如果对表进行修改，<strong>会修改失败</strong></li>
<li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>演示</strong></p>
<ul>
<li><p>给dept表加锁并查询状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE dept READ;<br><br>SHOW OPEN TABLES;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151441.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938648.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p><strong>读取</strong></p>
<ul>
<li><p>两个客户端分别读取dept表的信息，都能读出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure>
</li>
<li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152614.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938180.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>其他客户端读取度其他表信息，读取成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152714.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938420.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p><strong>修改</strong></p>
<ul>
<li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151654.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938322.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>客户端B对表中内容进行修改，进入阻塞状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151737.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938378.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li><p>从客户端A解锁后，客户端B修改成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151818.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938314.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p>
<ul>
<li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，知道读锁被释放</strong></li>
<li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li>
<li>如果要修改被锁表的信息<ul>
<li>主机A如果对表进行修改，修改成功</li>
<li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li>
</ul>
</li>
</ul>
<p><strong>演示</strong></p>
<ul>
<li><p>给dept表加上写锁并查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE dept WRITE;<br><br>SHOW OPEN TABLES;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153259.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938569.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p><strong>读取</strong></p>
<ul>
<li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM dept;<br><br>SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153403.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938735.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153437.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938732.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li><p>其他表读取该表信息，进入阻塞状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM dept;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153517.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938756.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>释放后，读取成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>修改</strong></p>
<ul>
<li><p>客户端A修改<strong>该表</strong>内容，修改成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE dept WHERE id = 2;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153637.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938259.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp WHERE id = 2;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153710.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938371.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp WHERE id = 2;Copy<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p>
<h2 id="2、行锁"><a href="#2、行锁" class="headerlink" title="2、行锁"></a>2、行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础</strong></a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果两个客户端<strong>对同一条记录进行修改</strong></p>
<ul>
<li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li>
<li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li>
</ul>
<p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p>
<p><strong>修改同一条记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--关闭自动提交<br>SET autocommit = 0;<br><br>--客户端A、B查询id=2的记录<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端A进行修改操作（将年龄改为了80），但未提交<br>UPDATE t_emp SET age = 80 WHERE id = 2;<br><br>--客户端A进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端B进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端B进行修改（客户端A未提交）<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>--客户端A提交<br>COMMIT;<br><br>--客户端B提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure>

<p><strong>对应结果</strong></p>
<p>客户端A查询结果</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>客户端B查询结果</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>客户端A修改后A查询</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938408.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>客户端A修改后B查询</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938426.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>客户端A提交后，B修改成功</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938662.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>修改不同记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--客户端A对id=2的年龄进行修改<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>--客户端B对id=3的年龄进行修改<br>UPDATE t_emp SET age = 30 WHERE id = 3;<br><br>--客户端A，B分别提交<br>COMMIT;<br>COMMIT;Copy<br></code></pre></td></tr></table></figure>

<p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p>
<h3 id="索引失效-1"><a href="#索引失效-1" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p>
<p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p>
<p>所以要<strong>避免索引失效</strong></p>
<h3 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p>
<p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询表记录，此处没有id=2的记录<br>SELECT * FROM t_emp;<br><br>--客户端A进行范围查询，但是范围内没有id=2的记录<br>UPDATE t_emp SET deptId = 1 WHERE id&gt;1 AND id &lt; 6;<br><br>--客户端B进行插入数据，插入一条id=2的记录<br>INSERT t_emp VALUES(2, &#x27;岳不群&#x27;, 11, 2, 100002); <br><br>--客户端A提交<br>COMMIT;<br><br>--客户端B提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938709.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>客户端B进入阻塞状态</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938768.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>提交后，插入成功</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938793.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>结论</strong>：可以看到表中本来<strong>没有id&#x3D;2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p>
<h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br><br>--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推<br>SELECT * FROM t_emp WHERE id = 1 FOR UPDATE;<br><br>--进行修改操作<br>UPDATE t_emp SET NAME = &#x27;风车车&#x27; WHERE id = 1;<br><br>--提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure>

<p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p>
<h1 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li>
<li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938811.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li>
<li><strong>从服务器</strong>可以使用 <a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li>
<li>增加冗余，提高可用性</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938832.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/mysql/" class="category-chain-item">mysql</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/mysql/">#mysql</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL高级</div>
      <div>http://example.com/2022/09/05/MySQL高级/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>liziyuan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月5日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/05/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/" title="从输入URL到浏览器显示页面的流程">
                        <span class="hidden-mobile">从输入URL到浏览器显示页面的流程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      
<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本网站由 <img src="img/you.png" srcset="/img/loading.gif" lazyload width="45px" />提供CDN加速/云存储服务</a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
