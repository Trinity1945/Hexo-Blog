

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#857d85">
  <meta name="author" content="liziyuan">
  <meta name="keywords" content="">
  
    <meta name="description" content="NoSQL什么是NoSQLNoSQL全称是Not only SQL(不仅仅是SQL)，它属于非关系型数据库（Not-Relational DB）。 NoSQl的存储结构主要有两个特点：  数据之间是无关系的：关系型数据库有主外键约束，而NoSQL弱化了这个概念 数据的结构是松散的、可变的：在关系型数据库中，如果表有5个“列”。那么最多只能存储5个列的值；而在NoSQL中没有所谓固定的列数，甚至连“">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2022/09/07/NoSQL/index.html">
<meta property="og:site_name" content="九黎城">
<meta property="og:description" content="NoSQL什么是NoSQLNoSQL全称是Not only SQL(不仅仅是SQL)，它属于非关系型数据库（Not-Relational DB）。 NoSQl的存储结构主要有两个特点：  数据之间是无关系的：关系型数据库有主外键约束，而NoSQL弱化了这个概念 数据的结构是松散的、可变的：在关系型数据库中，如果表有5个“列”。那么最多只能存储5个列的值；而在NoSQL中没有所谓固定的列数，甚至连“">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/18.jpg">
<meta property="article:published_time" content="2022-09-07T01:12:24.000Z">
<meta property="article:modified_time" content="2022-09-07T02:13:44.785Z">
<meta property="article:author" content="liziyuan">
<meta property="article:tag" content="NoSQL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/18.jpg">
  
  
  
  <title>Redis - 九黎城</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>bigMouse</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-07 09:12" pubdate>
          2022年9月7日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          87k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          729 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><p>NoSQL全称是Not only SQL(不仅仅是SQL)，它属于非关系型数据库（Not-Relational DB）。</p>
<p>NoSQl的存储结构主要有两个特点：</p>
<ul>
<li>数据之间是无关系的：关系型数据库有主外键约束，而NoSQL弱化了这个概念</li>
<li>数据的结构是松散的、可变的：在关系型数据库中，如果表有5个“列”。那么最多只能存储5个列的值；而在NoSQL中没有所谓固定的列数，甚至连“列”的概念都没有，所以存储数据的类型、数据的多少都是可变的，是不固定的。</li>
</ul>
<blockquote>
<p>NoSQL是一类数据库的统称。并不是某一个具体的数据库产品名称，就像关系型数据库管理系统(Relational Database Management System,RDBMS)一样</p>
</blockquote>
<p>RDBMS包括Oracle、MySQL以及MS SQL Server,NoSQL包括Redis、MangoDB等。</p>
<h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL"></a>为什么使用NoSQL</h2><p>RDBMS的缺点如下：</p>
<ul>
<li>因为RDBMS无法应对每秒上万次的读写请求，无法处理大量集中的高并发操作，所以在电商项目中，不是从RDBMS中直接读取数据来展示给客户，而是先将数据放入类似Redis的NoSQL中进行保存，实现缓存的作用，再从Redis中加载数据展示给客户，以减少对RDBMS的访问，提高运行效率。</li>
<li>表中存储信息是有限制的。</li>
</ul>
<blockquote>
<p>列数有限：常见的RDBMS允许一张表最大支持的列数是有限制的，其中Oracle最多支持1000列</p>
<p>行数有限：在RDBMS中，如果一张表中的行数达到百万级别时，那么读写的速度会呈断崖式下降</p>
</blockquote>
<p>在使用RDBMS时，面对海量数据必须使用主从复制、分库分表。这样的系统架构是难以维护的，其维护成本较高，因为它增加了程序员在开发和运维时的工作量，而且在海量数据下使用Select查询语句效率极低，查询时间会呈指数级增长。</p>
<ul>
<li>RDBMS无法简单地通过增加硬件、服务器节点地方式来提高系统性能，因为性能得瓶颈在RDBMS上，而不是在高性能服务器上。</li>
<li>关系型数据库大多时收费的，而且对硬件的要求较高，。软件和硬件的使用成本比较大，但NoSQL可以解决上面四个问题。</li>
<li>NoSQL支持每秒上万次的读写。</li>
<li>数据存储格式灵活。</li>
<li>在单机的环境下NoSQL性能就很好，在多台计算机的环境下性能更高。</li>
<li>NoSQL大多数时免费的、开源的。</li>
</ul>
<p>NoSQL有自己的优势和使用场景，在软件公司中应用比较多。</p>
<h2 id="NoSQL的优势"><a href="#NoSQL的优势" class="headerlink" title="NoSQL的优势"></a>NoSQL的优势</h2><p>NoSQL的优势可以总结为如下4点：</p>
<ul>
<li><p>面对海量数据时依然保持良好性能。</p>
<blockquote>
<p>NoSQL具有非常良好的读写性能，尤其在面对海量数据时表现同样优秀。这得益于它的非关系性和结构简单。Redis的作者在设计Redis时，最先考虑的就是性能。</p>
</blockquote>
</li>
<li><p>灵活的数据格式</p>
<blockquote>
<p>使用NoSQL时不需要创建列，它的数据格式比较灵活。</p>
</blockquote>
</li>
<li><p>高可用</p>
<blockquote>
<p>NoSQL具有主从复制、支持集群的特点，大大增加了软件项目的高可用性。如果某一台计算机宕机，那么其他的计算机会接手任务，不至于出现系统无法访问的情况。</p>
</blockquote>
</li>
<li><p>低成本</p>
<blockquote>
<p>这是大多数NoSQL共有的特点，因为多数NoSQL时免费开源的，所以没有高昂的授权成本。</p>
</blockquote>
<p>RDBMS和NoSQL都有各自的优势和使用场景，两者需要结合使用。让关系型数据库关注在关系上，让NoSQL关注在存储上。</p>
<p>“一针见血”总结NoSQL优势：因为RDBMS太慢，所以用NoSQL!</p>
</li>
</ul>
<h2 id="NoSQL的劣势"><a href="#NoSQL的劣势" class="headerlink" title="NoSQL的劣势"></a>NoSQL的劣势</h2><p>一个事务有优势就有劣势，NoSQL的劣势可以总结为如下5点：</p>
<ul>
<li>数据之间是无关系的。</li>
<li>不支持标准的SQL，没有工人的NoSQL标准。</li>
<li>没有关系型数据库的约束，如主键约束、主外键约束和取值范围约束等，大多数也没有索引的概念。</li>
<li>没有事务回滚的概念，由于优先考虑性能，因此不能完全实现ACID特性。</li>
<li>没有丰富的数据类型</li>
</ul>
<h2 id="Redis介绍及使用场景"><a href="#Redis介绍及使用场景" class="headerlink" title="Redis介绍及使用场景"></a>Redis介绍及使用场景</h2><p>​		Redis的作者是萨尔瓦托雷 · 圣菲利波（Salvatore Sanfilippo），他来自意大利的西西里岛，被称为Redis之父。</p>
<p>​		Redis全称是Remote Dictionary Server,它是现阶段极为流行的NoSQL之一，它以键-值（Key-Value）对的形式在内存中保存数据。Redis的读写性能非常高，如果硬件环境非常优秀，可以实现每秒插入10万条记录，因此Redis常用于存储、缓存等场景。</p>
<p>​		Redis可以将内存中的数据持久化到硬盘上，防止因为出现断电、死机等问题造成数据丢失，还支持Key超时、发布订阅、流水线（批处理）以及Lua脚本等。</p>
<p>​	Redis主要有如下特点：</p>
<ul>
<li>速度快：Redis中的数据被放入内存，读写速度快。Redis使用C语言实现，更接近底层。Redis是”单线程模型“，避免了因抢锁而影响运行效率，但Redis6.0 开始支持”多线程模型“，运行命令时还是遵守单线程模型。</li>
<li>使用简单，运行稳定：Redis使用key-value对组织数据，学习成本非常低，就像学习Java中的HashMap一样简单，并且Redis的源代码已经经过了大量优化，在速度和稳定性上非常优秀。曾经有人评价Redis的源代码是艺术和技术的集成者。</li>
<li>功能丰富：支持五种常见的基本数据类型，分别是字符串(String)、散列(Hash)、列表(List)、集合(Set)和有序集合（Sorted Set).</li>
<li>支持多种客户端：可以使用Java、C、C++、PHP、Python以及Node.js等编程语言来对Redis进行操作。</li>
<li>支持持久化：可以将内存中的数据持久化到硬盘上，达到数据备份的目的。</li>
<li>支持主从复制：实现Redis服务的副本，保证数据的完整性。</li>
<li>支持分布式：从Redis3.0 开始正式支持分布式，实现多台服务器共同工作。</li>
<li>支持高可用：哨兵模式就是解决方案。</li>
</ul>
<p>Redis在软件系统的位置如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706515.png" srcset="/img/loading.gif" lazyload alt="image-20220324155750136"></p>
<h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p><a target="_blank" rel="noopener" href="https://redis.io/download/">Redis官网下载</a></p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706516.png" srcset="/img/loading.gif" lazyload alt="image-20220324191257115"></p>
<ol>
<li>上传至home目录下，进入文件夹解压</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf redis-6.2.6.tar.gz<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>安装gcc</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum intall gcc<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>进入Redis解压后目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make install<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706517.png" srcset="/img/loading.gif" lazyload alt="image-20220324192118224"></p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706518.png" srcset="/img/loading.gif" lazyload alt="image-20220324192151792"></p>
<ol start="4">
<li>复制配置文件，Redis安装目录为usr&#x2F;local&#x2F;bin,进入目录新建配置文件夹</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> zconfig<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>复制一份redis解压后的配置文件到zconfig中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /opt/redis-6.2.6/redis.conf zconfig<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>Redis默认不是后台启动，进入配置文件修改为默认后台启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim redis.conf <br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706519.png" srcset="/img/loading.gif" lazyload alt="image-20220324192931493"></p>
<ol start="7">
<li>使用对应配置文件（zconfig）启动redis</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server zconfig/redis.conf<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706520.png" srcset="/img/loading.gif" lazyload alt="image-20220324193048767"></p>
<ol start="8">
<li>使用redis-cli连接测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -p 6379<br></code></pre></td></tr></table></figure>

<ol start="9">
<li>查看redis的进程是否开启</li>
</ol>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706521.png" srcset="/img/loading.gif" lazyload alt="image-20220324193526768"></p>
<ol start="10">
<li><p>如何关闭redis服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdouwn<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706522.png" srcset="/img/loading.gif" lazyload alt="image-20220324193708071"></p>
</li>
</ol>
<p><font style="color:red">扩展：</font>更改Redis服务端口</p>
<ol>
<li><p>在命令行中指定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server --port 8888<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用如下命令指定端口的Redis服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -p 8888 shutdown<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong>是一个压力测试工具！</p>
<p>官方自带的性能测试工具！</p>
<p>redis-benchmark命令参数！</p>
<p>redis性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>-h</strong></td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>-p</strong></td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>-s</strong></td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>-c</strong></td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>-n</strong></td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>-d</strong></td>
<td align="left">以字节的形式指定 SET&#x2F;GET 值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>-k</strong></td>
<td align="left">1&#x3D;keep alive 0&#x3D;reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>-r</strong></td>
<td align="left">SET&#x2F;GET&#x2F;INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>-P</strong></td>
<td align="left">通过管道传输 <numreq> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>-q</strong></td>
<td align="left">强制退出 redis。仅显示 query&#x2F;sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>–csv</strong></td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">***-l*（L 的小写字母）**</td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>-t</strong></td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">***-I*（i 的大写字母）**</td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>简单测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试 100个并发连接 100000请求</span><br>redis-benchmark -h localhost -p 6379 -c 100 -n 100000<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706523.png" srcset="/img/loading.gif" lazyload alt="image-20220324195927432"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis有16个数据库</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706524.png" srcset="/img/loading.gif" lazyload alt="image-20220324200558479"></p>
<p>默认使用的是第0个</p>
<p>可以使用<font style="color:blue">select</font>进行切换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; select 3<br>OK<br>127.0.0.1:6379[3]&gt; <br></code></pre></td></tr></table></figure>

<p>查看当前数据库的键值队的数量<font style="color:blue">DBSIZE</font></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; DBSIZE<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706526.png" srcset="/img/loading.gif" lazyload alt="image-20220324200915061"></p>
<p>清除当前数据库<font style="color:blue">flushdb</font></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; keys *<br>(empty array)<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706527.png" srcset="/img/loading.gif" lazyload alt="image-20220324201248741"></p>
<p>清楚全部数据库的内容<font style="color:blue">FLUSHALL</font></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; FLUSHALL<br>OK<br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706528.png" srcset="/img/loading.gif" lazyload alt="image-20220324201358068"></p>
<blockquote>
<p>Redis是单线程的！</p>
<p>Redis的瓶颈是根据机器的内存和网络带宽。</p>
</blockquote>
<p><strong>Redis 为社么单线程还这么块？</strong></p>
<ol>
<li>误区1：高性能的服务器一定比单线程效率高？</li>
<li>误区2：多线程（CPU上下文会切换）一定比单线程效率高？</li>
</ol>
<p><strong>核心：</strong>redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率是最高的，多线陈（CPU上下文会切换：耗时操作）对于内存系统来说，如果没有上下文切换效率就是最高的？多次读写都是在一个CPU上的，在内存情况下，这就是最佳的方案。</p>
<h1 id="Redis的五大-数据类型"><a href="#Redis的五大-数据类型" class="headerlink" title="Redis的五大 数据类型"></a>Redis的五大 数据类型</h1><h2 id="Connection类型命令"><a href="#Connection类型命令" class="headerlink" title="Connection类型命令"></a>Connection类型命令</h2><ul>
<li><p>echo命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>echo message</p>
</blockquote>
<p>该命令用于输出指定的消息message</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a b c&quot;</span><br><span class="hljs-string">&quot;a b c&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> abc<br><span class="hljs-string">&quot;abc&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;true&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> <span class="hljs-literal">false</span><br><span class="hljs-string">&quot;false&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> 123<br><span class="hljs-string">&quot;123&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">echo</span> null<br><span class="hljs-string">&quot;null&quot;</span><br></code></pre></td></tr></table></figure>


</li>
<li><p>ping命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>ping</p>
</blockquote>
<p>客户端向Redis服务器发送ping命令，用于测试于Redis服务器的连接是否有效。如果连接到Redis服务器，则会返回pong命令；如果连接不到Redis服务器，则会出现如下异常。</p>
<p>Could not connect to Redis at 127.0.0.1:6739: Connection refused</p>
<p>使用ping命令可以实现自定义“心跳”，检测Redis服务器中实例的存活情况</p>
<p><strong>测试案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs b">127.0.0.1:6379&gt; ping<br>PONG<br></code></pre></td></tr></table></figure>
</li>
<li><p>quit命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>quit</p>
</blockquote>
<p>该命令用于请求Redis服务器断开与当前客户端的连接</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; quit<br>[root@iZwz91ojxikfjqb3lvllllZ bin]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>select命令</p>
<p>Redis没有数据库名称，而是使用索引代替</p>
<p>使用格式如下：</p>
<blockquote>
<p>select index</p>
</blockquote>
<p>该命令用于选择目标数据库，数据库索引index用数字值指定，以0作为起始索引值，默认使用0号数据库。</p>
<p>​		Redis默认有16个数据库配置。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a 0<br>OK<br>127.0.0.1:6379&gt; select 1<br>OK<br>127.0.0.1:6379[1]&gt; <span class="hljs-built_in">set</span> a 1<br>OK<br>127.0.0.1:6379[1]&gt; get a<br><span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379[1]&gt; select 0<br>OK<br>127.0.0.1:6379&gt; get a<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>swapdb命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>swapdb index index</p>
</blockquote>
<p>该命令用于交换两个数据库的索引</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushall<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> username username0<br>OK<br>127.0.0.1:6379&gt; get username<br><span class="hljs-string">&quot;username0&quot;</span><br>127.0.0.1:6379&gt; select 1<br>OK<br>127.0.0.1:6379[1]&gt; <span class="hljs-built_in">set</span> username username1<br>OK<br>127.0.0.1:6379[1]&gt; get username<br><span class="hljs-string">&quot;username1&quot;</span><br>127.0.0.1:6379[1]&gt; swapdb 0 1<br>OK<br>127.0.0.1:6379[1]&gt; get username<br><span class="hljs-string">&quot;username0&quot;</span><br>127.0.0.1:6379[1]&gt; select 0<br>OK<br>127.0.0.1:6379&gt; get username<br><span class="hljs-string">&quot;username1&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Redis-key</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bas">127.0.0.1:6379&gt; keys *  #查看所有的key<br>(empty array)<br>127.0.0.1:6379&gt; FLUSHALL<br>OK<br>127.0.0.1:6379&gt; exits name  #判断当前key是否存在<br>(error) ERR unknown command `exits`, with args beginning with: `name`, <br>127.0.0.1:6379&gt; exists name<br>(integer) 0<br>127.0.0.1:6379&gt; set name zhang<br>OK<br>127.0.0.1:6379&gt; expore name 10<br>(error) ERR unknown command `expore`, with args beginning with: `name`, `10`, <br>127.0.0.1:6379&gt; expire name 10   #设置key的过期时间单位是s秒<br>(integer) 1<br>127.0.0.1:6379&gt; ttl name  #查看该key的过期剩余时间单位是s秒<br>(integer) 6<br>127.0.0.1:6379&gt; ttl name<br>(integer) 4<br>127.0.0.1:6379&gt; ttl name<br>(integer) 3<br>127.0.0.1:6379&gt; ttl name<br>(integer) 2<br>127.0.0.1:6379&gt; ttl name<br>(integer) 0<br>127.0.0.1:6379&gt; get name<br>(nil)<br>127.0.0.1:6379&gt; get age<br>(nil)<br>127.0.0.1:6379&gt; type name  #c查看key的类型<br>string<br></code></pre></td></tr></table></figure>

<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>​		String类型的命令主要用于处理字符串，可以处理JSON或XML等类型的复杂字符串，可以处理整数、浮点数，甚至是二进制的数据，包括视频、音频和图片等资源。每一个Key对应的value最大可以存储512M的数据。</p>
<p>​		String数据类型常用于存储JSON字符串，使用方式是将数据库中的数据使用JDBC存入实体类，然后将实体类转成JSON字符串保存在Redis的String数据类型中，以后获取这条数据时，直接从Redis中获取，速度比RDBMS快得多。</p>
<p>​		String数据类型的存储形式如图：</p>
<p>​			<img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706529.png" srcset="/img/loading.gif" lazyload alt="image-20220324214315381"></p>
<ul>
<li><p>append命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>append key value</p>
</blockquote>
<p>如果key已经存在并且是一个字符串，则append命令将value追加到key原来值的末尾；如果key不存在，则等同于执行set key value</p>
<p>​		返回值代表操作后的字符串长度。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; append name world<br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;helloworld&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>incr命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>incr key</p>
</blockquote>
<p>​		该命令用于将key对应的整数值自加1.如果key不存在，那么key的value会先被初始化为0，然后执行incr命令。如果value包括错误的类型，或者字符串的value不能表示为整数，那么返回一个错误。value的限制是64位（bit）有符号整数。</p>
<p>​      incr命令是一个针对字符串的命令，因为Redis没有专用的整数类型，所以key中存储的字符串被解释为10进制64bit有符号整数来执行incr命令。</p>
<p>Redis使用单线程模型，如果有两个客户端同时执行incr命令时不会出现错误的结果。不同客户端发送的命令按执行的顺序进入Redis服务器的命令队列中，Redis命令从命令队列中按顺序执行命令。不会出现多条命令同时执行的情况，而是一条接着一条按顺序执行。这就可能出现如果某一个命令需要花费大量的时间来执行，则其他命令会阻塞，影响系统运行效率。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;username&quot;</span><br>127.0.0.1:6379&gt; incr name<br>(error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 3<br>OK<br>127.0.0.1:6379&gt; incr key1<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>incrby命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>incrby key increment</p>
</blockquote>
<p>该命令用于将key对应的value加上增量increment。</p>
<p>如果key不存在，那么key的value会被初始化为0，然后执行incrby命令。</p>
<p>如果value包括错误的数据类型，或字符串的value不能表示成整数，那么返回一个错误。</p>
<p>value的限制时64bit有符号整数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; incrby key1 5<br>(<span class="hljs-built_in">integer</span>) 9<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;9&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>incrbyfloat命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>incrbyfloat key inctement</p>
</blockquote>
<p>​      该命令用于为key对应的value加上浮点数增量increment。</p>
<p>​      如果key不存在，那么incrbyfloat命令会先将key的value设为0，再执行加法操作。</p>
<p>​      如果命令执行成功，那么key的value会被更新为（执行加法之后的）新的value，并且新value会以字符串的形式返回给调用者。</p>
<p>​        无论是key的value，还是增量increment，都可以使用像2.0e、3e5、90e-2这样的指数符号（Exponential Notation)来表示。但是，执行incrbyfloat命令之后的value总是以一个数字、一个小数点（可选的）和一个任意位的小数部分组成（如：3.14、68.354）。小数部分最后的0会被删除，如果有需要的话，还会浮点数改为整数（如3.0会被保存为3）。</p>
<p>​      除此之外，无论加法计算所得到的浮点数的实际精度有多长，incrbyfloat命令的计算精度为小数点的后17位。</p>
<p><font style="color:red">注意：</font>Redis中的整数和浮点数都以字符串形式保存，它们都属于字符串类型</p>
<p>如果key的value不能转换成数字，则执行incr、incrby、incrbyfloat 等数字计算命令会出现异常，如value是List或Set数据类型，或者存储的value是abc或123abc等，都不能正确执行incr、incrby、incrbyfloat 等命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> mykey 100<br>OK<br>127.0.0.1:6379&gt; get mykey<br><span class="hljs-string">&quot;100&quot;</span><br>127.0.0.1:6379&gt; incrbyfloat mykey 19.123<br><span class="hljs-string">&quot;119.123&quot;</span><br>127.0.0.1:6379&gt; get mykey<br><span class="hljs-string">&quot;119.123&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>decr命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>decr by</p>
</blockquote>
<p>该命令用于将key对应的整数值自减1.如果key不存在，那么key的value会被初始化为0，然后执行decr命令。如果value包括错误的类型，或字符串的value不能表示为整数，那么返回一个错误。value的限制是64bit有符号整数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> username usernamevalue<br>OK<br>127.0.0.1:6379&gt; get username<br><span class="hljs-string">&quot;usernamevalue&quot;</span><br>127.0.0.1:6379&gt; decr username<br>(error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> num1 100<br>OK<br>127.0.0.1:6379&gt; decr num1<br>(<span class="hljs-built_in">integer</span>) 99<br>127.0.0.1:6379&gt; decr num1<br>(<span class="hljs-built_in">integer</span>) 98<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>decrby命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>decrby key decrement</p>
</blockquote>
<p>该命令用于将key对应的value减去减量decrement。</p>
<p>如果key不存在，那么key的value会被初始化为0，然后执行decrby命令。</p>
<p>如果value包括错误的类型，或字符串的value不能表示为整数，那么返回一个错误。value的限制是64bit有符号整数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key11 100<br>OK<br>127.0.0.1:6379&gt; get key11<br><span class="hljs-string">&quot;100&quot;</span><br>127.0.0.1:6379&gt; decrby key11 4<br>(<span class="hljs-built_in">integer</span>) 96<br>127.0.0.1:6379&gt; get key11<br><span class="hljs-string">&quot;96&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>set和get命令</p>
<p>set命令的使用格式如下：</p>
<blockquote>
<p>set key value [Ex seconds] [PX milliseconds] [NX|XX]</p>
</blockquote>
<p>该命令用于将字符串的value关联到key。如果key已经拥有旧value，则将新的value覆盖旧的value。对某个带有生存空间（Time To Live，TTL)的key来说，当set命令成功在这个key上执行，这个key原有的TTL将被清楚。</p>
<p>set命令的行为可以通过一系列参数来修改：</p>
<ul>
<li>EX second:设置key的TTL为second（单位为s）。set key EX second的运行效果等同于setex key second value。</li>
<li>PX millisecond:设置key的TTL为millisecond(单位是ms).set key value PX millisecond的运行效果等同于psetex key millisecond value。</li>
<li>NX：只在key不存在时，才对key进行设置操作，常用于添加操作。set key value NX的效果等同于setnx key value。</li>
<li>XX：只在key已经存在时，才对key进行设置操作，常用于更新操作。</li>
</ul>
<p>get命令的使用格式如下：</p>
<blockquote>
<p>get key</p>
</blockquote>
<p>获取key对应的value 。如果key不存在，则返回特殊值nil；如果key存在，并且key对应的value不是字符串，则返回错误，因为get命令只处理字符串。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;name&quot;</span><br>2) <span class="hljs-string">&quot;num1&quot;</span><br>3) <span class="hljs-string">&quot;username&quot;</span><br>4) <span class="hljs-string">&quot;key1&quot;</span><br>5) <span class="hljs-string">&quot;key11&quot;</span><br>6) <span class="hljs-string">&quot;mykey&quot;</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;helloworld&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> num1 world<br>OK<br>127.0.0.1:6379&gt; get num1<br><span class="hljs-string">&quot;world&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>strlen命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>strlen key</p>
</blockquote>
<p>该命令用于返回key所存储字符串的长度。当key存储的不是字符串时，返回一个错误。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; strlen name<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; strlen username<br>(<span class="hljs-built_in">integer</span>) 13<br>127.0.0.1:6379&gt; get username<br><span class="hljs-string">&quot;usernamevalue&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>setrange命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>setrange key offset value</p>
</blockquote>
<p>该命令用value从偏移量offset开始将给定key所存储的字符串进行覆盖。offset以B为单位，值从0开始。</p>
<p>如果给定key原来存储的字符串长度比offset小（如字符串只有5个字符长，但是设置的offset是10），那么源字符串和offset之间的空白将用零字节（Zero Bytes，即\x00)来填充。</p>
<p><font style="color:red">注意：</font>能使用的最大offset是$2 ^ {29}$-1(536870911)，因为Redis字符串的大小被限制在512MB以内，如果需要使用比这更大的空间，可以使用多个key。</p>
<p>当生成一个很长的字符串时，Redis需要分配内存空间，该操作有可能会造成服务器阻塞（blok）。</p>
<p>setrange和getrange命令可以将字符串作为线性数组，这是一个非常快速和高效的存储结构。</p>
<p>返回值代表被setrange命令修改之后字符串的长度。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushall<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a 12345<br>OK<br>127.0.0.1:6379&gt; setrange a 7 678<br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; get a<br><span class="hljs-string">&quot;12345\x00\x00678&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>getrange命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>getrange key start end</p>
</blockquote>
<p>该命令用于返回key中字符串的子字符串，字符串的截取范围由start和end两个偏移量决定（包括start和end在内）。start和end以B为单位，值从0开始。</p>
<p>负数偏移量表示从字符串末尾开始计数，-1表示最后一个字符，-2表示倒数第二个字符，以此类推。</p>
<p>返回值就是截取出的子字符串。该命令的作用和java中的subString()方法相识。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a 123456789<br>OK<br>127.0.0.1:6379&gt; getrange a 0 4<br><span class="hljs-string">&quot;12345&quot;</span><br>127.0.0.1:6379&gt; getrange a 0 100<br><span class="hljs-string">&quot;123456789&quot;</span><br>127.0.0.1:6379&gt; getrange a 0 -1<br><span class="hljs-string">&quot;123456789&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>setbit和getbit命令</p>
<p>setbit命令使用格式如下：</p>
<blockquote>
<p>setbit key offset value</p>
</blockquote>
<p>该命令用于将key存储的value作为二进制，然后在指定offset上的位设置值。</p>
<p>位的值取决于value，可以时0，也可以是1.当key不存在时，自动生成一个新的字符串。</p>
<p>字符串会进行伸展（Grown）以确保它可以将value保存在指定的offset上。当字符串进行伸展时，空白位置以0填充。</p>
<p>offset必须大于或等于0，并且小于$2 ^{32}$(位映射被限制在512MB之内)。对使用大offset的setbit命令来说，内存分配可能造成Redis服务器被阻塞。</p>
<p>返回值代表指定offset原来存储位对应的值。</p>
<p>getbit命令的使用格式如下：</p>
<blockquote>
<p>getbit key offset</p>
</blockquote>
<p>该命令用于将key存储的value作为二进制，获取指定offset上的位值。</p>
<p>当offset比字符串的长度大，或者key不存在时，返回0。</p>
<p>如果想在Redis中将存储的汉字正确显示出来，需要在执行redis-cli命令时添加 –raw参数。命令如下：</p>
<blockquote>
<p>redis-cli -p 7777 -a accp –raw</p>
</blockquote>
<p><strong>测试用例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 中<br>OK<br>127.0.0.1:6379&gt; getbit key1 7<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 7 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key1 15<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 15 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key1 23<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; setbit key1 23 0<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;\xe5\xb9\xac&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bitcount命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bitcount key [start] [end]</p>
</blockquote>
<p>该命令用于计算给定字符串转换成二进制后值为1的位的个数。一般情况下，给定的整个字符串都会被计数，通过指定额外的star或end参数，可以在指定的字符范围内进行计数。</p>
<p>start和end参数的设置和getrange命令类似，都可以使用负数值，如-1表示最后一个字节，-2表示倒数第二个字节，依此类推。参数start和end代表字节，不是位。</p>
<p>不存在的key被当成空字符串来处理，因此对一个不存在的key执行bitcount命令，结果为0。</p>
<p>可以使用bitcount命令统计出某个人一年内登录网站的总次数。</p>
<p><strong>测试用例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> username 中<br>OK<br>127.0.0.1:6379&gt; bitcount username<br>(<span class="hljs-built_in">integer</span>) 13<br>127.0.0.1:6379&gt; bitcount username 0 0<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; bitcount username 0 1<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bitop命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bitop operation destkey key [key ….]</p>
</blockquote>
<p>该命令用于将一个或多个key中的字符串转换成二进制，并对这些转化后的key进行位运算，然后将计算结果保存到destkey上。</p>
<p>operation可以是and、or、xor、not这四种操作中的任意一种。</p>
<ul>
<li><p>bitop and destkey key [key ….]。</p>
<p>对一个或多个key求逻辑并，然后将结果保存到destkey。</p>
</li>
<li><p>bitop or destkey key [key ….]。</p>
<p>对一个或多个key求逻辑或，然后将结果保存到destkey。</p>
</li>
<li><p>bitop xor destkey key [key ….]。</p>
<p>对一个或多个key求逻辑异或，然后将结果保存到destkey。XOR操作是指如果a和b两个值不相同，则异或结果为1；如果a和b两个值相同，则异或结果为0；</p>
</li>
<li><p>bitop not destkey key。</p>
<p>对给定key求逻辑非，1转换成0、0转换成 1，然后将结果保存到destkey</p>
</li>
</ul>
<p>除not操作之外，其他操作都可以接收一个或多个key作为参数。</p>
<p>当bitop命令处理不同长度字符串时，较短的字符串所缺少的部分会被看作0。</p>
<p>空的key也被看作是包括0的字符串。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setbit key2 0 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 1 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 3 0   <span class="hljs-comment">#以上生成二进制数1010</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key3 0 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key3 1 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key3 2 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key3 3 1  <span class="hljs-comment">#以上生成二进制数1001</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitop and key4 key2 key3  <span class="hljs-comment">#对两个二进制数进行and操作，结果在key4</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit key4 0<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit key4 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key4 2<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key4 3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>



<ul>
<li><p>or操作</p>
<p>or操作对一个或多个key求逻辑或，然后保存到destkey</p>
</li>
<li><p>xor操作</p>
<p>xor操作对一个或多个key求逻辑异或，然后将结果保存到destkey,xor操作是指如果a和b两个值不相同，则异或结果为1；如果a和b两个值相同，则异或结果为0；</p>
</li>
<li><p>not操作</p>
<p>not操作对给定的key求逻辑非，1转换成0、0转换成1，然后将结果保存到destkey。</p>
</li>
<li><p>and操作对一个或多个key求逻辑并，然后将结果保存到destkey。</p>
</li>
</ul>
</li>
<li><p>getset命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>getset key value</p>
</blockquote>
<p>该命令用于原子性（Atomic）地将给定的key的新值赋为value，并返回key的旧值。</p>
<p>原子性是指不可分割的操作或命令。也就是赋值新值和返回值这两个操作不能其他的命令所干扰，这两个操作都完成了，才会执行其他的命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;key2&quot;</span><br>2) <span class="hljs-string">&quot;key4&quot;</span><br>3) <span class="hljs-string">&quot;key8&quot;</span><br>4) <span class="hljs-string">&quot;key3&quot;</span><br>5) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; getset key2 keyvalue2<br><span class="hljs-string">&quot;\xa0&quot;</span><br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;keyvalue2&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>msetnx命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>metnx key value [key value]</p>
</blockquote>
<p>该命令用于同时设置一个或多个key-value对，当且仅当所有给定的key都不存在时，才会批量执行set命令；即使只有一个给定的key存在，msetnx，命令也会拒绝执行所有给定key的set命令。</p>
<p>msetnx命令是原子性的，所有key-value对可以全被设置，也可以全不被设置。</p>
<p>当所有给定key都成功设置是返回1.如果所有给定key都设置失败（至少有一个key已经存在），那么返回0。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; msetnx name lily age 12 sex male<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;key2&quot;</span><br>2) <span class="hljs-string">&quot;name&quot;</span><br>3) <span class="hljs-string">&quot;sex&quot;</span><br>4) <span class="hljs-string">&quot;key4&quot;</span><br>5) <span class="hljs-string">&quot;key8&quot;</span><br>6) <span class="hljs-string">&quot;age&quot;</span><br>7) <span class="hljs-string">&quot;key3&quot;</span><br>8) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;lily&quot;</span><br>127.0.0.1:6379&gt; get age<br><span class="hljs-string">&quot;12&quot;</span><br>127.0.0.1:6379&gt; get sex<br><span class="hljs-string">&quot;male&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>mset命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>mset key value [key value]</p>
</blockquote>
<p>该命令用于同时设置一个或多个key-value对。</p>
<p>如果某个给定key已经存在，那么mset命令会用新值覆盖原来的旧值。如果这不是所希望的效果，请考虑使用msetnx命令，它只会在所有给定key都不存在的情况下才执行set命令。</p>
<p>mset命令是一个原子性命令，所有给定key都会在同一时间内设置，客户端不会看到某些key已更新，而其他key保持不变的效果。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; mset username tom pssword 123456<br>OK<br>127.0.0.1:6379&gt; get username<br><span class="hljs-string">&quot;tom&quot;</span><br>127.0.0.1:6379&gt; get pssword<br><span class="hljs-string">&quot;123456&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>mget命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>mget key [key ….]</p>
</blockquote>
<p>该命令用于返回所有（一个或多个）给定key的value值。</p>
<p>如果给定的多个key中某个key不存在，那么这个key返回特殊值nil</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; mget username pssword address<br>1) <span class="hljs-string">&quot;tom&quot;</span><br>2) <span class="hljs-string">&quot;123456&quot;</span><br>3) (nil)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bitfield命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bitfield key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FALL]</p>
</blockquote>
<p>前文介绍过setbit和getbit命令，这两个命只会对一个位进行操作，而bitfield命令可以将多个位当成一个“组”，对这个组中的数据进行操作。</p>
<p>bitfield命令可以将一个Redis字符串看作一个由二进制组成的数组，可以对数组中的数据进行“分组”访问。如将数组中的“某一部分数据”当作整数，对这个整数进行加法和减法操作，并且这些操作可以通过设置某些参数妥善地处理计算时出现地溢出情况。</p>
<p>注意一下几点：</p>
<ul>
<li>使用get命令对超出字符串当前范围地二进制进行访问（包括key不存在地情况）超出部分地二进制位的值将被当作0。</li>
<li>使用set子命令或incrby子命令对超出字符串当前范围地二进制进行访问将导致字符串被扩展，被扩展的部分会使用值为0的二进制进行位进行填充。在对字符串进行扩展时，命令会根据字符串目前已有的最远端二进制位计算出执行操作所需要的最小长度。</li>
</ul>
<p>以下是bitfield命令支持的子命令：</p>
<ul>
<li><p>get type offset：返回指定offset处的type的值</p>
</li>
<li><p>set type offset value：对指定offset处设置type的值，并返回它的旧值。</p>
</li>
<li><p>incrby type offset increment：对指定offset处的type进行加法操作，并返回它的旧值。</p>
<p>用户可以通过increment参数传入负值来实现相应的减法操作，并返回它的旧值。</p>
</li>
<li><p>overflow [WRAP|SAT|FAIL]：可以改变之后执行的increby子命令在发生溢出情况时的行为。</p>
</li>
</ul>
<p>当对offset处的数据进行操作时，可以在type的前面添加 i 来表示有符号整数，如使用i16来表示16位长的有符号整数。或者使用 u 来表示无符号整数，如可以使用u8来表示8位长的无符号整数。</p>
<p>bitfield命令最大支持64位长的有符号整数个63位长的无符号整数，其中无符号整数的63位长度限制是由于Redis协议目前还无法返回64位长的无符号整数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; clear<br>127.0.0.1:6379&gt; bitfield key19 <span class="hljs-built_in">set</span> i8 0 -123<br>1) (<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 0<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit key19 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 2<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 4<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 5<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit key19 6<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit key19 7<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bitfield key19 <span class="hljs-built_in">set</span> i8 0 -124<br>1) (<span class="hljs-built_in">integer</span>) -123<br>127.0.0.1:6379&gt; bitfield key19 get i8 0<br>1) (<span class="hljs-built_in">integer</span>) -124<br>127.0.0.1:6379&gt; bitfield key19 incrby i8 0 20<br>1) (<span class="hljs-built_in">integer</span>) -104<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>使用#方便处理“组数据”</p>
<p>用户有两种方法来设置offse。</p>
<ul>
<li><p>如果用户给定的offset是一个没有任何前缀的数字，那么这个数字指示的就是以0为开始的offset，也就是 位所对应的索引值。</p>
</li>
<li><p>如果用户给定的是一个带有#的offset，那么命令将使用这个offset于&#x3D;与被设置的数字类型的长度相乘，从而计算出正真的offset，如下命令：</p>
<p>bitfield mystring set i8 #0 100 i8 #1 200</p>
<p>命令会把mystring里面第一个i8长度的二级制位的值设置为100，并把第二个i8长度的二进制的值设置为200.当把key对应的value当作数组来使用，并且数组中存储的都是固定长度的整数时，使用#可以免去手动计算二进制位所在的offset的麻烦。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; clear<br>127.0.0.1:6379&gt; bitfield a <span class="hljs-built_in">set</span> i8 <span class="hljs-comment">#0 10</span><br>1) (<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitfield a <span class="hljs-built_in">set</span> i8 <span class="hljs-comment">#1 20</span><br>1) (<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitfield a get i8 <span class="hljs-comment">#0</span><br>1) (<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; bitfield a get i8 <span class="hljs-comment">#1</span><br>1) (<span class="hljs-built_in">integer</span>) 20<br>127.0.0.1:6379&gt; bitfield a incrby i8 <span class="hljs-comment">#0 40</span><br>1) (<span class="hljs-built_in">integer</span>) 50<br>127.0.0.1:6379&gt; bitfield a get i8 <span class="hljs-comment">#0</span><br>1) (<span class="hljs-built_in">integer</span>) 50<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>overflow子命令的测试</p>
<p>用户可以通过overflow子命令结合以下3个参数来决定在执行自增或自减操作时遇到的向上溢出（Overflow）或者向下溢出（Underflow）时的行为。</p>
<ul>
<li>WRAP：使用环绕（Wrap Around）方法处理有符号整数和无符号整数的溢出情况。对无符号整数来说，类似于将始终指针向前拨或向后拨。对有符号整数来说，上溢将导致数字重新从最小的负值开始计算，而下溢将导致数字重新从最大的正数开始计算。比如我们对一个值为127的i8执行加1操作，那么将得到结果-128。在默认情况下，incrby命令使用WRAP来处理溢出情况。</li>
<li>SAT：使用饱和计算（Saturation Arithmetic）方法处理溢出情况，也就是说，下溢计算的结果为最小的整数，而上溢计算的结果为最大的整数值。举个例子，如果我们对一个值为120的i8整数执行加10操作，那么命令的结果将为i8类型所能存储的最大整数127。与此相反，如果一个针对i8整数的计算结果造成了下溢，那么这个i8整数将被设置为-127。</li>
<li>FAIL：在这一方法下，命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; bitfield a <span class="hljs-built_in">set</span> i8 <span class="hljs-comment">#0 120</span><br>1) (<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitfield a overflow wrap incrby i8 <span class="hljs-comment">#0 10</span><br>1) (<span class="hljs-built_in">integer</span>) -126<br>127.0.0.1:6379&gt; bitfield a get i8 <span class="hljs-comment">#0</span><br>1) (<span class="hljs-built_in">integer</span>) -126<br>127.0.0.1:6379&gt; bitfield b <span class="hljs-built_in">set</span> i8 <span class="hljs-comment">#0 -120</span><br>1) (<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitfield b overflow wrap incrby i8 <span class="hljs-comment">#0 -10</span><br>1) (<span class="hljs-built_in">integer</span>) 126<br>127.0.0.1:6379&gt; bitfield a get i8 <span class="hljs-comment">#0</span><br>1) (<span class="hljs-built_in">integer</span>) -126<br>127.0.0.1:6379&gt; <br>127.0.0.1:6379&gt; bitfield c overflow sat incrby i8 <span class="hljs-comment">#0 10</span><br>1) (<span class="hljs-built_in">integer</span>) 127<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bitpos命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bitpos key bit [start] [end]</p>
</blockquote>
<p>该命令用于返回设置为1或0的第一个位的索引值。</p>
<p>注意：参数start、end中的值以B（字节）为单位，而不是bit(位)</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; setbit key1 0 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 1 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 2 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 3 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 4 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 5 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 6 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key1 7 0  <span class="hljs-comment">#key1的二级制值是0000000</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 0 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 1 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 3 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 4 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 5 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 6 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit key2 7 1  <span class="hljs-comment">#key2的二级制值是11111111</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitpos key1 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; bitpos key1 1<br>(<span class="hljs-built_in">integer</span>) -1<br>127.0.0.1:6379&gt; bitpos key2 0<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; bitpos key2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>处理慢查询</p>
<p>当key对应的value存储大量数据，查询时会减慢Redis的响应速度，导致Redis发生阻塞，最终可能会引起整个Redis服务器不可用，所以要找到那些导致慢查询的有关命令。</p>
<p>在redis.conf配置文件中，主要有两处与慢查询有关的配置。</p>
<ul>
<li><p>slowlog-log-slower-than：当命令执行时间（不包括排队时间）超时时会被记录下来，单位是us。如下命令就可以记录执行时间超过30ms的命令。</p>
<p>config set slowlog-log-slower-than 30000</p>
<p>上面的这个命令也可以在redis.conf配置文件中进行配置。</p>
</li>
<li><p>slowlog-max-len：可以记录慢查询命令的总数。通过以下命令可以记录最近200条慢查询命令。</p>
<p>config set slowlog-max-len 200</p>
<p>上面这个命令也可以在redis.conf配置中进行配置。</p>
<p>可以使用如下两条命令获取慢查询的命令。</p>
<ul>
<li>slowlog get[len]：获取指定长度的慢查询列表。</li>
<li>slowlog reset：清空慢查询日志队列。</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; slowlog get<br>(empty array)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Hash类型命令"><a href="#Hash类型命令" class="headerlink" title="Hash类型命令"></a>Hash类型命令</h2><p>Redis中的Hash映射是key和value的映射，其中value包括“field-value对”的映射。</p>
<p>Hash数据类型的存储形式如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706530.png" srcset="/img/loading.gif" lazyload alt="image-20220325114223843"></p>
<p>Hash数据类型保持key-value对结构，它的key-value对个数最多为2^32-1个。Hash数据类型中的key与普通的key一样，具有TTL的功能，但field没有这个功能。</p>
<ul>
<li><p>hset和hget命令</p>
<p>hset命令的使用格式如下：</p>
<blockquote>
<p>hset key field value</p>
</blockquote>
<p>该命令作用和Java中的HashMap.put(key,value)方法相似。</p>
<p>hget命令的使用格式如下：</p>
<blockquote>
<p>hget key field</p>
</blockquote>
<p>该命令作用和Java中的HashMap.get(key)相似。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget key1 a<br>(nil)<br>127.0.0.1:6379&gt; hset key1 a aa<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget key1 a<br><span class="hljs-string">&quot;aa&quot;</span><br>127.0.0.1:6379&gt; hset key1 a aaNewValue<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; hget key1 a<br><span class="hljs-string">&quot;aaNewValue&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hmset和hmget命令</p>
<p>hmset命令使用格式如下：</p>
<blockquote>
<p>hmset key field vlaue [field value….]</p>
</blockquote>
<p>该命令用于批量添加field和value。</p>
<p>hmget命令使用格式如下;</p>
<blockquote>
<p>hmget key field [field…]</p>
</blockquote>
<p>该命令用于批量获取field对应的value。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hmset key1 a aa b bb c cc<br>OK<br>127.0.0.1:6379&gt; hmget key1 a b c<br>1) <span class="hljs-string">&quot;aa&quot;</span><br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hlen命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hlen key</p>
</blockquote>
<p>该命令用于返回field的个数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmset key1 a aa b bb c cc<br>OK<br>127.0.0.1:6379&gt; hmget key1 a b c<br>1) <span class="hljs-string">&quot;aa&quot;</span><br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; hlen key1<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hdel命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hdel key field [field…]</p>
</blockquote>
<p>该命令用于删除key中的field。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hdel key1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hmget key1 a b c<br>1) (nil)<br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hexists命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hexists key field</p>
</blockquote>
<p>如果key对应的value中包含指定的field，则返回1；否则返回0。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmget key1 a b c<br>1) (nil)<br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; hexists key1 a<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; hexists key1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hincrby和hincrbyfloat命令</p>
<p>hincrby命令使用格式如下：</p>
<blockquote>
<p>hincrby key field increment</p>
</blockquote>
<p>该命令用于对field的值进行整数自增increment，field的范围是64bit有符号整数。</p>
<p>hincrbyfloat命令使用格式如下：</p>
<blockquote>
<p>hincrbyfloat key field increment</p>
</blockquote>
<p>该命令用于对field的值进行浮点数自增increment。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hset key1 a 123<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hincrby key1 a 1000<br>(<span class="hljs-built_in">integer</span>) 1123<br>127.0.0.1:6379&gt; hget key1 a<br><span class="hljs-string">&quot;1123&quot;</span><br>127.0.0.1:6379&gt; hincrbyfloat key1 a 0.234<br><span class="hljs-string">&quot;1123.23399999999999999&quot;</span><br>127.0.0.1:6379&gt; hget key1 a<br><span class="hljs-string">&quot;1123.23399999999999999&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hgetall命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hgetall key</p>
</blockquote>
<p>该命令用于取得所有field和对应的value。如果field和value个数很多，则该命令会阻塞Redis服务器。建议field的个数不要超过500。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmset key1 a aa b bb c cc<br>OK<br>127.0.0.1:6379&gt; hgetall key1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;aa&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>4) <span class="hljs-string">&quot;bb&quot;</span><br>5) <span class="hljs-string">&quot;c&quot;</span><br>6) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hkeys和hvals命令</p>
<p>hkeys命令使用格式如下：</p>
<blockquote>
<p>hkeys key</p>
</blockquote>
<p>该命令用于取得所有的field，field应该称为hfields更恰当。</p>
<p>hvals命令的使用格式如下：</p>
<blockquote>
<p>hvals key</p>
</blockquote>
<p>该命令用于取得key对应的所有value</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmset key1 a aa b bb c cc<br>OK<br>127.0.0.1:6379&gt; hkeys key1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; hvals key1<br>1) <span class="hljs-string">&quot;aa&quot;</span><br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hsetnx命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hsetnx key field value</p>
</blockquote>
<p>只有当field不存在时，才保存value；如果field不在，则不进行任何操作。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmset key1 a aa b bb c cc<br>OK<br>127.0.0.1:6379&gt; hkeys key1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; hvals key1<br>1) <span class="hljs-string">&quot;aa&quot;</span><br>2) <span class="hljs-string">&quot;bb&quot;</span><br>3) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; hsetnx key1 a aanew<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; hget key1 a<br><span class="hljs-string">&quot;aa&quot;</span><br>127.0.0.1:6379&gt; hsetnx key1 d aanew<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget key1 d<br><span class="hljs-string">&quot;aanew&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hstrlen命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hstrlen key field</p>
</blockquote>
<p>该命令用用户返回field存储的value字符串长度。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hsetnx key1 d aanew<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; hget key1 d<br><span class="hljs-string">&quot;aanew&quot;</span><br>127.0.0.1:6379&gt; hstrlen key1 d<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>hscan命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>hscan key cursor [MATCH pattern] [COUNT count]</p>
</blockquote>
<p>该命令用于以多次迭代的方式将Hash（散列）中的数据取出。</p>
<p>hscan命令是一个基于游标的迭代器，代表在每次调用次命令时服务器都会返回一个更新的游标值，用户需要使用该游标值作为游标参数才可以执行下一次迭代。当游标值设置为0时开始迭代，当服务器返回的游标值为0时停止迭代。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hscan key1 0<br>1) <span class="hljs-string">&quot;0&quot;</span><br>2) 1) <span class="hljs-string">&quot;a&quot;</span><br>   2) <span class="hljs-string">&quot;aa&quot;</span><br>   3) <span class="hljs-string">&quot;b&quot;</span><br>   4) <span class="hljs-string">&quot;bb&quot;</span><br>   5) <span class="hljs-string">&quot;c&quot;</span><br>   6) <span class="hljs-string">&quot;cc&quot;</span><br>   7) <span class="hljs-string">&quot;d&quot;</span><br>   8) <span class="hljs-string">&quot;aanew&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>使用sort命令对散列进行排序</p>
<p>对散列指定的field进行排序。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; rpush uerId 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; hmset hashkey1 name A age 100<br>OK<br>127.0.0.1:6379&gt; hmset hashkey2 name B age 50<br>OK<br>127.0.0.1:6379&gt; hmset hashkey3 name C age 1<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> userId by hashkey*-&gt;age<br>(empty array)<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> uerId by hashkey*-&gt;age<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> uerId by hashkey*-&gt;age get hashkey*-&gt;name<br>1) <span class="hljs-string">&quot;C&quot;</span><br>2) <span class="hljs-string">&quot;B&quot;</span><br>3) <span class="hljs-string">&quot;A&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> uerId by hashkey*-&gt;age get <span class="hljs-comment"># get hashkey*-&gt;name DESC</span><br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;A&quot;</span><br>3) <span class="hljs-string">&quot;2&quot;</span><br>4) <span class="hljs-string">&quot;B&quot;</span><br>5) <span class="hljs-string">&quot;3&quot;</span><br>6) <span class="hljs-string">&quot;C&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="List类型命令"><a href="#List类型命令" class="headerlink" title="List类型命令"></a>List类型命令</h2><p>List类型命令主要用于处理列表，相当于java中的LinkedList，其插入和删除速度非常快，但根据索引的定位速度就很慢。</p>
<p>以List数据类型存储的元素具有有序性，元素可以重复，可以对列表的头部和尾部进行元素的添加和弹出，可以向前或向后进行双向遍历。</p>
<p>List数据类型可以用作对列：先进先出，具有FIFO特性。</p>
<p>List数据类型可以用作栈，先进后出，具有FILO特性。</p>
<p>List数据类型可以用作任务对列，将需要延后处理的任务放入队列中，使用新的线程按顺序读取列表中任务并进行处理。任务队列可以使用具有阻塞特性的blpop或prpop命令实现。</p>
<p>一个List数据类型最多可以存储2^32-1个元素。</p>
<p>List数据类型的存储形式如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706531.png" srcset="/img/loading.gif" lazyload alt="image-20220325140342666"></p>
<ul>
<li><p>rpush、llen和lrange命令</p>
<p>rpush命令的使用格式如下：</p>
<blockquote>
<p>rpush key value [value …]</p>
</blockquote>
<p>该命令用于向队列尾部添加一个或多个元素，类似于Java中的ArrayList.add(object)方法，但是rpush命令一次可以添加多个元素。</p>
<p>llen命令的使用格式如下：</p>
<blockquote>
<p>llen key</p>
</blockquote>
<p>该命令用于获取列表中元素的个数。</p>
<p>lrange命令使用格式如下：</p>
<blockquote>
<p>lrange key start stop</p>
</blockquote>
<p>该命令用于使用偏移量返回列表的全部或部分元素，偏移量的值从0开始作为索引值，其中0代表列表的第一个元素，1代表下一个元素，依此类推。</p>
<p>偏移量也可以是负数，代表从列表尾部开始的偏移量，如-1代表列表最后一个元素，-2代表倒数第二个元素，依此类推。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; rpush key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; llen key1<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush key1 d<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; llen key1<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lrange key1 0 3<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;d&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>rpushx命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>rpushx key value</p>
</blockquote>
<p>该命令用于仅在key已经存在并被包括在列表中的情况下，才在列表尾部插入元素。与rpush命令相反，当key不存在时，rpushx命令不执行任何操作。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange key1 0 3<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;d&quot;</span><br>127.0.0.1:6379&gt; rpushx key1 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; rpushx key2 a<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>lpush命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>lpush key value [value ….]</p>
</blockquote>
<p>该命令用于向队列头部添加一个或多个元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; rpush key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; lpush key1 3 2 1<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>4) <span class="hljs-string">&quot;a&quot;</span><br>5) <span class="hljs-string">&quot;b&quot;</span><br>6) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>lpushx命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>lpush key value</p>
</blockquote>
<p>该命令用于仅在key已经存在并且包括在列表中的情况下，才在列表头部插入元素。与lpush命令相反，当key不存在时，lpushx命令将不执行任何操作。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpushx key1 3 2 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; lpush key1 3 2 1<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; lpushx key1 c b a<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>5) <span class="hljs-string">&quot;2&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>rpop命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>rpop key</p>
</blockquote>
<p>该命令用于删除并返回存于key对应的列表的最后一个元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>5) <span class="hljs-string">&quot;2&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; rpop key1<br><span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>5) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>lpop命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>lpop key</p>
</blockquote>
<p>该命令用于删除并且返回存于key对应列表的第一个元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>5) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; rpop key1<br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;1&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>rpoplpush命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>rpoplpush source destination</p>
</blockquote>
<p>该命令用于原子性的返回并删除存储在源列表的最后一个元素，并且返回的元素存储在目标列表的第一个位置。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; del key2<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; rpush key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpush key2 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; rpoplpush key1 key2<br><span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>127.0.0.1:6379&gt; lrange key2 0 -1<br>1) <span class="hljs-string">&quot;c&quot;</span><br>2) <span class="hljs-string">&quot;1&quot;</span><br>3) <span class="hljs-string">&quot;2&quot;</span><br>4) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>lrem命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>lrem key count value</p>
</blockquote>
<p>该命令用于从key对应的列表里删除前count次出现的值为value的元素。</p>
<p>参数count可以有如下几种用法：</p>
<ul>
<li>count&gt;0：从头到尾删除值为value的count个元素。</li>
<li>count&lt;0：从尾到头删除值为value的count个元素。</li>
<li>count&#x3D;0：删除所有值为value的元素</li>
</ul>
<p>使用如下命令会从列表中删除最后出现的两个hello元素：</p>
<p>lrem list -2 “hello”</p>
<p>lrem 命令删除时采用绝对等于方式</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; rpush mykey a hello b hello c hello d hello e hello f hello g hello<br>(<span class="hljs-built_in">integer</span>) 14<br>127.0.0.1:6379&gt; llen mykey<br>(<span class="hljs-built_in">integer</span>) 14<br>127.0.0.1:6379&gt; lrem mykey 3 hello<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange mykey 0 -1<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;b&quot;</span><br> 3) <span class="hljs-string">&quot;c&quot;</span><br> 4) <span class="hljs-string">&quot;d&quot;</span><br> 5) <span class="hljs-string">&quot;hello&quot;</span><br> 6) <span class="hljs-string">&quot;e&quot;</span><br> 7) <span class="hljs-string">&quot;hello&quot;</span><br> 8) <span class="hljs-string">&quot;f&quot;</span><br> 9) <span class="hljs-string">&quot;hello&quot;</span><br>10) <span class="hljs-string">&quot;g&quot;</span><br>11) <span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; lrem mykey -2 hello<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange mykey 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;d&quot;</span><br>5) <span class="hljs-string">&quot;hello&quot;</span><br>6) <span class="hljs-string">&quot;e&quot;</span><br>7) <span class="hljs-string">&quot;hello&quot;</span><br>8) <span class="hljs-string">&quot;f&quot;</span><br>9) <span class="hljs-string">&quot;g&quot;</span><br>127.0.0.1:6379&gt; lrem mykey 0 hello<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange mykey 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;d&quot;</span><br>5) <span class="hljs-string">&quot;e&quot;</span><br>6) <span class="hljs-string">&quot;f&quot;</span><br>7) <span class="hljs-string">&quot;g&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>lset命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>lset key index value</p>
</blockquote>
<p>该命令用于在指定index处放置的元素，相当于新元素更新旧元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush key1 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; lset key1 0 a<br>OK<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>ltrim命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>ltrim key start stop</p>
</blockquote>
<p>该命令类似于String.substring()方法。</p>
<p>参数start和stop也可以是负数，代表列表末尾的偏移量，其中-1代表列表的最后一个元素。</p>
<p>ltrim 命令一个常见的用法是和rpush&#x2F;lush命令使用，使用格式如下：</p>
<p>lpush mylist someelement</p>
<p>ltrim mylist 0 99</p>
<p>这对命令对将一个新的元素添加到列表头部，并保证该列表不会增长到超过100个元素，如果创建一个有界队列时会用到它们。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; rpush key1 a b c d<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; ltrim key1 0 2<br>OK<br>127.0.0.1:6379&gt; lrange key1 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>linsert命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>linsert key BEFORE|AFTER pivot value</p>
</blockquote>
<p>该命令用于在列表中的pivot元素之前（BEFORE)或之后（AFTER）插入元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; rpush mylist a b c c c d<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; linsert mylist before c x<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;x&quot;</span><br>4) <span class="hljs-string">&quot;c&quot;</span><br>5) <span class="hljs-string">&quot;c&quot;</span><br>6) <span class="hljs-string">&quot;c&quot;</span><br>7) <span class="hljs-string">&quot;d&quot;</span><br>127.0.0.1:6379&gt; linsert mylist after a AA<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; lrange mylist 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;AA&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>4) <span class="hljs-string">&quot;x&quot;</span><br>5) <span class="hljs-string">&quot;c&quot;</span><br>6) <span class="hljs-string">&quot;c&quot;</span><br>7) <span class="hljs-string">&quot;c&quot;</span><br>8) <span class="hljs-string">&quot;d&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>lindex命令</p>
<p>使用格式如下:</p>
<blockquote>
<p>lindex key index</p>
</blockquote>
<p>该命令用于返回列表中指定index的元素</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; rpush key1 a b c d<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; lindex key1 2<br><span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; lindex key1 -1<br><span class="hljs-string">&quot;d&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>blpop命令</p>
<p>如果使用列表来实现任务队列，那么当队列中没有任务时，客户端需要程序员使用轮询的方式来判断列表中有没有新元素，如果没有则继续轮询。这会造成空运行并且占用CPU资源，这种情况下可以使用阻塞BLOCK版本的pop命令解决。</p>
<p>使用格式如下：</p>
<blockquote>
<p>blpop key [key …] timeout</p>
</blockquote>
<p>它是lpop命令的阻塞版本。</p>
<p>使用阻塞版本的相关操作时，如果阻塞的时间过长，Linux会强制断开闲置的网络连接，释放网络资源。当被强制断开连接时会出现异常，所以要将catch和重试机制结合使用。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush key2 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; blpop key2 5<br>1) <span class="hljs-string">&quot;key2&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; blpop key2 5<br>(nil)<br>(5.05s)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>brpop命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>brpop key [key …] timeout</p>
</blockquote>
<p>brpop命令是rpop命令的阻塞版本，删除并返回存于列表的最后一个元素。从功能上分析，brpop命令和blpop命令基本是一样的，只不过一个是从尾部弹出元素，而另外一个是从头部弹出元素。</p>
</li>
<li><p>brpoplpush命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>brpoplpush source destination timeout</p>
</blockquote>
<p>brpoplpush命令是rpoplpush命令的阻塞版本，把最后一个元素转移到其他列表的第一个位置。</p>
<p>如果源列表和目标列表是同一个，则该命令可以实现循环链表。</p>
</li>
<li><p>使用sort命令对列表进行排序</p>
<p>使用格式如下：</p>
<blockquote>
<p>sort key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC|DESC] [ALPHA] [STORE destination]</p>
</blockquote>
<p>默认是按照数值类型排序的，并且按照两个元素的双精度浮点数进行比较。</p>
<p><strong>测试案例</strong></p>
<p>按数字大小进行正&#x2F;倒排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; rpush key1 13 234 345 324 23 345 4 67 345 8765 6<br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> key1<br> 1) <span class="hljs-string">&quot;4&quot;</span><br> 2) <span class="hljs-string">&quot;6&quot;</span><br> 3) <span class="hljs-string">&quot;13&quot;</span><br> 4) <span class="hljs-string">&quot;23&quot;</span><br> 5) <span class="hljs-string">&quot;67&quot;</span><br> 6) <span class="hljs-string">&quot;234&quot;</span><br> 7) <span class="hljs-string">&quot;324&quot;</span><br> 8) <span class="hljs-string">&quot;345&quot;</span><br> 9) <span class="hljs-string">&quot;345&quot;</span><br>10) <span class="hljs-string">&quot;345&quot;</span><br>11) <span class="hljs-string">&quot;8765&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> key1 desc<br> 1) <span class="hljs-string">&quot;8765&quot;</span><br> 2) <span class="hljs-string">&quot;345&quot;</span><br> 3) <span class="hljs-string">&quot;345&quot;</span><br> 4) <span class="hljs-string">&quot;345&quot;</span><br> 5) <span class="hljs-string">&quot;324&quot;</span><br> 6) <span class="hljs-string">&quot;234&quot;</span><br> 7) <span class="hljs-string">&quot;67&quot;</span><br> 8) <span class="hljs-string">&quot;23&quot;</span><br> 9) <span class="hljs-string">&quot;13&quot;</span><br>10) <span class="hljs-string">&quot;6&quot;</span><br>11) <span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>按ASCII值进行正&#x2F;到排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; rpush key1 a a few r erth afd ad dfasd ga dgd egd<br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> key1 alpha<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;a&quot;</span><br> 3) <span class="hljs-string">&quot;ad&quot;</span><br> 4) <span class="hljs-string">&quot;afd&quot;</span><br> 5) <span class="hljs-string">&quot;dfasd&quot;</span><br> 6) <span class="hljs-string">&quot;dgd&quot;</span><br> 7) <span class="hljs-string">&quot;egd&quot;</span><br> 8) <span class="hljs-string">&quot;erth&quot;</span><br> 9) <span class="hljs-string">&quot;few&quot;</span><br>10) <span class="hljs-string">&quot;ga&quot;</span><br>11) <span class="hljs-string">&quot;r&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> key1 alpha desc<br> 1) <span class="hljs-string">&quot;r&quot;</span><br> 2) <span class="hljs-string">&quot;ga&quot;</span><br> 3) <span class="hljs-string">&quot;few&quot;</span><br> 4) <span class="hljs-string">&quot;erth&quot;</span><br> 5) <span class="hljs-string">&quot;egd&quot;</span><br> 6) <span class="hljs-string">&quot;dgd&quot;</span><br> 7) <span class="hljs-string">&quot;dfasd&quot;</span><br> 8) <span class="hljs-string">&quot;afd&quot;</span><br> 9) <span class="hljs-string">&quot;ad&quot;</span><br>10) <span class="hljs-string">&quot;a&quot;</span><br>11) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>List类型命令的常见使用模式</p>
<p>List类型命令的常见使用模式如下：</p>
<ul>
<li>使用lpush+brpop实现阻塞队列。</li>
<li>使用lpush+rpop实现非阻塞队列。</li>
<li>使用lpush+lpop实现栈。</li>
<li>使用lpush+ltrem实现有界队列。</li>
</ul>
</li>
</ul>
<h2 id="Set类型命令"><a href="#Set类型命令" class="headerlink" title="Set类型命令"></a>Set类型命令</h2><p>Set类型命令主要用于处理Set数据类型，Set数据类型的存储形式如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706532.png" srcset="/img/loading.gif" lazyload alt="image-20220325152656228"></p>
<p>和Java中的Set接口一样，Redis中的Set数据类型不允许存储重复的元素，存储元素具有无序性。Set数据类型的元素个数最多为$2^{32}$-1个。</p>
<ul>
<li><p>sadd、smembers和scard命令</p>
<p>sadd命令使用格式如下：</p>
<blockquote>
<p>sadd key member [member …]</p>
</blockquote>
<p>该命令的作用和Java中的HashSet.add(value)方法一致。</p>
<p>smembers命令使用格式如下:</p>
<blockquote>
<p>smembers key</p>
</blockquote>
<p>该命令用于返回所有的value。</p>
<p>scard命令使用格式如下：</p>
<blockquote>
<p>scard key</p>
</blockquote>
<p>该命令用于返回元素个数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd ke1 a a b d x b d e f<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; smembers ke1<br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;d&quot;</span><br>3) <span class="hljs-string">&quot;x&quot;</span><br>4) <span class="hljs-string">&quot;a&quot;</span><br>5) <span class="hljs-string">&quot;e&quot;</span><br>6) <span class="hljs-string">&quot;f&quot;</span><br>127.0.0.1:6379&gt; scard ke1<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>sdiff和sdiffstore命令</p>
<p>sdiff命令的使用格式如下：</p>
<blockquote>
<p>sdiff key [key …]</p>
</blockquote>
<p>该命令用于返回只有第一个key具有，而其他key不具有的元素。</p>
<p>sdiffstore命令的使用格式如下：</p>
<blockquote>
<p>sdiffstore destination key [key …]</p>
</blockquote>
<p>该命令作用和sdiff命令基本一样，不同之处是将第一个key的独有元素放入目标key中。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd key1 a b c x y z<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; sadd key2 o p q<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; sadd key3 a b c x<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sdiff key1 key2 key3<br>1) <span class="hljs-string">&quot;z&quot;</span><br>2) <span class="hljs-string">&quot;y&quot;</span><br>127.0.0.1:6379&gt; sdiffstore showkey1 key1 key2 key3<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; smembers showkey1<br>1) <span class="hljs-string">&quot;z&quot;</span><br>2) <span class="hljs-string">&quot;y&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>sinter和sinterstore命令</p>
<p>sinter命令的使用格式如下：</p>
<blockquote>
<p>sinter key [key …]</p>
</blockquote>
<p>该命令用于取得指定key共同交集的value</p>
<p>sinterstore命令使用格式如下：</p>
<blockquote>
<p>sinterstore destination key [key …]</p>
</blockquote>
<p>该命令作用和sinter命令不同之处是将交集的value放入目标key中。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd key1 a b c x<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sadd key2 o p q x<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sadd key3 a u v x<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; sinter key1 key2 key3<br>1) <span class="hljs-string">&quot;x&quot;</span><br>127.0.0.1:6379&gt; sinterstore key4 key1 key2 key3<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers key4<br>1) <span class="hljs-string">&quot;x&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>sismember</p>
<p>使用格式如下：</p>
<blockquote>
<p>sismember key member</p>
</blockquote>
<p>该命令用于判断元素是否在集合中。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; sadd key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; sismember key1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember key1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember key1 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sismember key1 d<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>smove命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>smove source destinarion member</p>
</blockquote>
<p>该命令用于将元素从source(源集合)移动到destination（目标集合）。</p>
<p>如果source不存在或不包括指定的元素，则不执行任何操作，并返回0；否则，元素将从source中被删除并添加到destination中。</p>
<p>当指定的元素已存在于destination中时，将从source中删除。如果source或destination不是集合类型，则返回错误。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; sadd key2 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; smove key1 key2 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; smembers key1<br>1) <span class="hljs-string">&quot;c&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; smembers key2<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;b&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>srandmember命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>srandmember key [count]</p>
</blockquote>
<p>只提供key参数时会随机获取key集合中的某一个元素，和spop命令作用类似。不同的是，spop命令会将获取的随机元素从集合中移除，而srandmember命令仅仅获取该随机元素，不做任何的操作，包括删除。</p>
<p>count参数的作用如下：</p>
<ul>
<li>如果count是整数且小于元素的个数，则获取含有count个不同的元素的数组。</li>
<li>如果count是整数且大于元素的个数，则获取整个集合的所有元素。</li>
<li>如果count是负数，则获取包括count绝对值个数的元素的数组；如果count的绝对值大于元素的个数，则获取的数组里会出现元素重复的情况。</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd key1 1 2 3 4 5 6 7 8 9 10<br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; srandmember key1 <br><span class="hljs-string">&quot;8&quot;</span><br>127.0.0.1:6379&gt; srandmember key1 <br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; srandmember key1 <br><span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; srandmember key1 5<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;4&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;6&quot;</span><br>5) <span class="hljs-string">&quot;8&quot;</span><br>127.0.0.1:6379&gt; srandmember key1 -4<br>1) <span class="hljs-string">&quot;3&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br>3) <span class="hljs-string">&quot;1&quot;</span><br>4) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>spop命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>spop key [count]</p>
</blockquote>
<p>该命令与srandmember命令功能相似，只不过spop命令要将随机获取的元素删除掉。</p>
<p>参数count不允许为负数，不然会出现如下异常：</p>
<p>ERR index out of range</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd key1 a b c x s g w<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; spop key1<br><span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; smembers key1<br>1) <span class="hljs-string">&quot;c&quot;</span><br>2) <span class="hljs-string">&quot;x&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>4) <span class="hljs-string">&quot;w&quot;</span><br>5) <span class="hljs-string">&quot;g&quot;</span><br>6) <span class="hljs-string">&quot;s&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>srem命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>srem key member [member …]</p>
</blockquote>
<p>该命令用于从集合中删除指定的元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd mySet 1 2 3 5 6 f  f sd<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; srem mySet f 5<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; smembers mySet<br>1) <span class="hljs-string">&quot;2&quot;</span><br>2) <span class="hljs-string">&quot;1&quot;</span><br>3) <span class="hljs-string">&quot;sd&quot;</span><br>4) <span class="hljs-string">&quot;3&quot;</span><br>5) <span class="hljs-string">&quot;6&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>sunion和sunionstore命令</p>
<p>sunion命令使用格式如下：</p>
<blockquote>
<p>sunion key [key …]</p>
</blockquote>
<p>该命令用于合并所有key中的元素，并去掉重复的元素。</p>
<p>sunionstore命令的使用格式如下：</p>
<blockquote>
<p>sunionstrore destination key [key …]</p>
</blockquote>
<p>该命令用于合并所有key中的元素，去掉重复的元素，并将结合后的元素存入目标key中。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd key1 a b c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; sadd key2 1 2 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; sunion key1 key2<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;2&quot;</span><br>4) <span class="hljs-string">&quot;c&quot;</span><br>5) <span class="hljs-string">&quot;1&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; smembers key1<br>1) <span class="hljs-string">&quot;c&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>127.0.0.1:6379&gt; smembers key2<br>1) <span class="hljs-string">&quot;1&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; sunionstore key3 key1 key2<br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; smembers key3<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;2&quot;</span><br>4) <span class="hljs-string">&quot;c&quot;</span><br>5) <span class="hljs-string">&quot;1&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>sscan命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>sscan key cursor [MATCH pattern] [COUNT count]</p>
</blockquote>
<p>该命令用于增量迭代。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd setkey a b c d e g f h i j k l m n<br>(<span class="hljs-built_in">integer</span>) 14<br>127.0.0.1:6379&gt; sscan setkey 0<br>1) <span class="hljs-string">&quot;5&quot;</span><br>2)  1) <span class="hljs-string">&quot;n&quot;</span><br>    2) <span class="hljs-string">&quot;d&quot;</span><br>    3) <span class="hljs-string">&quot;e&quot;</span><br>    4) <span class="hljs-string">&quot;k&quot;</span><br>    5) <span class="hljs-string">&quot;a&quot;</span><br>    6) <span class="hljs-string">&quot;f&quot;</span><br>    7) <span class="hljs-string">&quot;m&quot;</span><br>    8) <span class="hljs-string">&quot;l&quot;</span><br>    9) <span class="hljs-string">&quot;c&quot;</span><br>   10) <span class="hljs-string">&quot;h&quot;</span><br>127.0.0.1:6379&gt; sscan setkey 3<br>1) <span class="hljs-string">&quot;0&quot;</span><br>2) 1) <span class="hljs-string">&quot;b&quot;</span><br>   2) <span class="hljs-string">&quot;i&quot;</span><br>   3) <span class="hljs-string">&quot;g&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Sorted-Set数据类型"><a href="#Sorted-Set数据类型" class="headerlink" title="Sorted Set数据类型"></a>Sorted Set数据类型</h2><p>Sorted Set数据类型和Java中的LinkedHashSet类特性一致。</p>
<p>Sorted Set数据类型的存储形式如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706533.png" srcset="/img/loading.gif" lazyload></p>
<p>Sorted Set数据类型中的元素根据分数（score）进行排序，并不像LinkedHashSet以添加的顺序作为排序依据，因此适合排行耪的场景。</p>
<p>Sorted Set数据类型中的元素以score的大小默认按升序的方式进行排序。因为存放在集合中，所以同一元素只存一次，不允许重复的元素存在。</p>
<p>可以用整数来表示score，因为Redis中的Sorted Set数据类型使用双精度64bit浮点数来表示score ，所以它能够精确地表示$-2^{53}$~$2^{53}$的整数。sorted set数据类型的元素最多为$2^{32}$-1个。</p>
<ul>
<li><p>zadd、zrange和zrevrange命令</p>
<p>zadd命令的使用格式如下：</p>
<blockquote>
<p>zadd key [NX|XX] [ch] [incr] score member [score member …]</p>
</blockquote>
<p>该命令用于将所有指定的元素添加到与key关联的有序集合里。添加时可以指定多个分数-元素（score-member）对。如果添加的元素已经是有序集合里面的元素，则会更新元素的score，并更到正确的排序位置。</p>
<p>如果key不存在，那么将创建一个新的有序集合并将score-member对添加到有序集合中。如果key存在，但是存储的类型不是有序集合将会返回一个错误信息。</p>
<p>score是一个双精度的浮点数字符串，正数最大值可以使用+inf作为代替，负数最小值可以使用-inf作为代替。</p>
<p>zadd命令用于在key和score-member对之间加入NX、XX、ch、incr参数，参数解释如下：</p>
<ul>
<li>NX：不存在时才更新。</li>
<li>XX：存在时才更新。</li>
<li>ch：ch是Changed的缩写。ch参数作用是返回新添加的新元素个数和已更新Score的已存在元素个数之和。命令行中指定的score和有序结合中拥有相同score的元素则不会计算在内。注意：zadd命令只返回新添加的新元素的个数。</li>
<li>incr：当zadd命令指定这个参数时，等同于zincrby命令，可以对元素的score进行递增操作。但同时只能对一个score-member进行自增操作。使用incr参数将返回元素的新score，用字符串来表示一个双精度浮点数。</li>
</ul>
<p>参数NX｜XX、ch、incr之间可以联合使用。</p>
<p>zrange命令的使用格式如下：</p>
<blockquote>
<p>zrange key start stop [withscores]</p>
</blockquote>
<p>该命令用于返回与key关联的有序集合中指定索引范围的元素，不是score范围。元素时按从低到高的score顺序进行排序的。</p>
<p>当需要从高到低进行排序时，请参考zrevrange命令。</p>
<p>start和stop都是从0开始的索引，其中0代表第一个元素，1代表下一个元素，依此类推。它们也可以是负数，如-1代表有序集合中的最后一个元素，-2代表倒数第二个元素，依此类推。</p>
<p>可以使用withscores参数，以便将元素的score与元素值一起返回。</p>
<p>zrevrange命令的使用格式如下:</p>
<blockquote>
<p>zrevrange key start stop [withscores]</p>
</blockquote>
<p>zrevrange命令是zrange命令的倒叙版本。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; zadd zset 1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd zset 2 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd zset 100 z<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd zset 3 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrange zset 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;z&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zcard命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zcard key</p>
</blockquote>
<p>该命令用于返回有序集合中元素的个数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 4 d 5 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zcard key1<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zrange key1<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>zcount命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zcount key min max</p>
</blockquote>
<p>该命令用于返回score在min和max之间的元素个数。常量值-inf代表最小值，+inf代表最大值。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd key1 2 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd key1 3 c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zcount key1 1 3<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zcount key1 1 2<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zunionstore命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max]</p>
</blockquote>
<p>该命令用于对多个key进行合并。</p>
<p>参数weights和aggregate可以同时使用。</p>
<p>numkeys指合并的key的数量。</p>
<p>weights操作时对应key*weight。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; del key1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; del key2<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; del key3<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zadd key2 1 a 2 b 4 d<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zunionstore key3 2 key1 key2<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; zrange key3 0 -1 withscores<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;3&quot;</span><br>5) <span class="hljs-string">&quot;b&quot;</span><br>6) <span class="hljs-string">&quot;4&quot;</span><br>7) <span class="hljs-string">&quot;d&quot;</span><br>8) <span class="hljs-string">&quot;4&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zinterstore命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zinterstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max]</p>
</blockquote>
<p>该命令用于对多个key进行计算而获得交集。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 4 d<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; zadd key2 1 a 2 b 3 c 5 e<br>(<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; zinterstore key3 2 key1 key2<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zrange key3 0 -1<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; zrange key3 0 -1 withscores<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;2&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>4) <span class="hljs-string">&quot;4&quot;</span><br>5) <span class="hljs-string">&quot;c&quot;</span><br>6) <span class="hljs-string">&quot;6&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zrangebylex、zrevrangebylex和zremrangebylex命令</p>
<p>zrange命令按索引的范围查询出元素和score，命令实例如下。</p>
<p>zrange key1 0 -1 withscores</p>
<p>如果想按元素的字典顺序进行查询，则需要使用zrangebylex命令，命令示例如下。</p>
<p>zrangebylex key1 a x</p>
<p>上面命令的作用是查询出a~x的数据（包括a和x)</p>
<p>zrangebylex命令的使用格式如下：</p>
<blockquote>
<p>zrangebylex key min max [limit offset count]</p>
</blockquote>
<p>当插入有序集合中的所有元素具有相同的score时，该命令按字典顺序从有序集合中返回最小值和最大值之间的元素。注意：此命令在使用时一定要确保score相同，否则达不到预期效果。</p>
<p>如果在字符串开头有部分字符串相同，则较长的字符串被认为大于较短的字符串。</p>
<p>有效的start和stop必须以符号“（”或“[”开始。符号“（”代表排除，符号“[”代表包括。而特殊参数“+”和“-”代表正无限和负无限，命令实例如下：</p>
<blockquote>
<p>zrangebylex myzset - +</p>
</blockquote>
<p>如果所有元素都具有相同的score，则返回有序集合中的所有元素。</p>
<p>zrevrangebylex命令的使用格式如下：</p>
<blockquote>
<p>zrevrangebylex key max min [limit offset count]</p>
</blockquote>
<p>zrevrangebylex命令是zrangebylex命令的倒序版本。</p>
<p>zremrangebylex命令的使用格式如下：</p>
<blockquote>
<p>zremrangebylex key min max</p>
</blockquote>
<p>zremrangebylex命令是zrangebylex命令的删除版本。</p>
</li>
<li><p>zlexcount命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zlexcount key min max</p>
</blockquote>
<p>该命令与zrangebylex命令类似，只不过zrangebylex命令查询的是元素，而zlexcount命令查询的是元素的个数。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zrangebylex key3 [a [c<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zrangebyscore、zrevrangebyscore和zremrangebyscore命令</p>
<p>zrangebyscore命令的使用格式如下：</p>
<blockquote>
<p>zrangebyscore key min max [withscores] [limit offset count]</p>
</blockquote>
<p>按score范围从有序集合中取得元素，范围包括min和max的值。如果不想具有包括功能，则要使用“（”。参数min和max可以使用-inf和+inf代替，代表最小值和最大值。</p>
<p>zrevrangebyscore命令的使用格式如下：</p>
<blockquote>
<p>zrevrangebyscore key max min [withscores] [limit offset count]</p>
</blockquote>
<p>zrevrangebyscore命令是zrangebyscore命令的倒序版本。</p>
<p>zremrangebyscore命令的使用格式如下：</p>
<blockquote>
<p>zremrangebyscore key min max</p>
</blockquote>
<p>zremrangebyscore命令是zrangebyscore命令的删除版本。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 11 b 111 c 111 d 2 e 3 f 33 g<br>(<span class="hljs-built_in">integer</span>) 7<br>127.0.0.1:6379&gt; zrange key1 0 -1 withscores<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;1&quot;</span><br> 3) <span class="hljs-string">&quot;e&quot;</span><br> 4) <span class="hljs-string">&quot;2&quot;</span><br> 5) <span class="hljs-string">&quot;f&quot;</span><br> 6) <span class="hljs-string">&quot;3&quot;</span><br> 7) <span class="hljs-string">&quot;b&quot;</span><br> 8) <span class="hljs-string">&quot;11&quot;</span><br> 9) <span class="hljs-string">&quot;g&quot;</span><br>10) <span class="hljs-string">&quot;33&quot;</span><br>11) <span class="hljs-string">&quot;c&quot;</span><br>12) <span class="hljs-string">&quot;111&quot;</span><br>13) <span class="hljs-string">&quot;d&quot;</span><br>14) <span class="hljs-string">&quot;111&quot;</span><br>127.0.0.1:6379&gt; zrangebyscore key1 1 5 withscores<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;1&quot;</span><br>3) <span class="hljs-string">&quot;e&quot;</span><br>4) <span class="hljs-string">&quot;2&quot;</span><br>5) <span class="hljs-string">&quot;f&quot;</span><br>6) <span class="hljs-string">&quot;3&quot;</span><br>127.0.0.1:6379&gt; zrangebyscore key1 -inf +inf withscores<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;1&quot;</span><br> 3) <span class="hljs-string">&quot;e&quot;</span><br> 4) <span class="hljs-string">&quot;2&quot;</span><br> 5) <span class="hljs-string">&quot;f&quot;</span><br> 6) <span class="hljs-string">&quot;3&quot;</span><br> 7) <span class="hljs-string">&quot;b&quot;</span><br> 8) <span class="hljs-string">&quot;11&quot;</span><br> 9) <span class="hljs-string">&quot;g&quot;</span><br>10) <span class="hljs-string">&quot;33&quot;</span><br>11) <span class="hljs-string">&quot;c&quot;</span><br>12) <span class="hljs-string">&quot;111&quot;</span><br>13) <span class="hljs-string">&quot;d&quot;</span><br>14) <span class="hljs-string">&quot;111&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>zpopmax和zpopmin命令</p>
<p>zpopmax命令的使用格式如下：</p>
<blockquote>
<p>zpopmax key [count]</p>
</blockquote>
<p>该命令用于删除并且返回最多count个score值最大的元素。</p>
<blockquote>
<p>zpopmin key [count]</p>
</blockquote>
<p>该命令用于删除并且返回最多count个score值最小的元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 h 9 i<br>(<span class="hljs-built_in">integer</span>) 9<br>127.0.0.1:6379&gt; zrange key1 0 -1 withscores<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;1&quot;</span><br> 3) <span class="hljs-string">&quot;b&quot;</span><br> 4) <span class="hljs-string">&quot;2&quot;</span><br> 5) <span class="hljs-string">&quot;c&quot;</span><br> 6) <span class="hljs-string">&quot;3&quot;</span><br> 7) <span class="hljs-string">&quot;d&quot;</span><br> 8) <span class="hljs-string">&quot;4&quot;</span><br> 9) <span class="hljs-string">&quot;e&quot;</span><br>10) <span class="hljs-string">&quot;5&quot;</span><br>11) <span class="hljs-string">&quot;f&quot;</span><br>12) <span class="hljs-string">&quot;6&quot;</span><br>13) <span class="hljs-string">&quot;g&quot;</span><br>14) <span class="hljs-string">&quot;7&quot;</span><br>15) <span class="hljs-string">&quot;h&quot;</span><br>16) <span class="hljs-string">&quot;8&quot;</span><br>17) <span class="hljs-string">&quot;i&quot;</span><br>18) <span class="hljs-string">&quot;9&quot;</span><br>127.0.0.1:6379&gt; zpopmax key1<br>1) <span class="hljs-string">&quot;i&quot;</span><br>2) <span class="hljs-string">&quot;9&quot;</span><br>127.0.0.1:6379&gt; zrange key1 0 -1 withscores<br> 1) <span class="hljs-string">&quot;a&quot;</span><br> 2) <span class="hljs-string">&quot;1&quot;</span><br> 3) <span class="hljs-string">&quot;b&quot;</span><br> 4) <span class="hljs-string">&quot;2&quot;</span><br> 5) <span class="hljs-string">&quot;c&quot;</span><br> 6) <span class="hljs-string">&quot;3&quot;</span><br> 7) <span class="hljs-string">&quot;d&quot;</span><br> 8) <span class="hljs-string">&quot;4&quot;</span><br> 9) <span class="hljs-string">&quot;e&quot;</span><br>10) <span class="hljs-string">&quot;5&quot;</span><br>11) <span class="hljs-string">&quot;f&quot;</span><br>12) <span class="hljs-string">&quot;6&quot;</span><br>13) <span class="hljs-string">&quot;g&quot;</span><br>14) <span class="hljs-string">&quot;7&quot;</span><br>15) <span class="hljs-string">&quot;h&quot;</span><br>16) <span class="hljs-string">&quot;8&quot;</span><br>127.0.0.1:6379&gt; zpopmax key1 2<br>1) <span class="hljs-string">&quot;h&quot;</span><br>2) <span class="hljs-string">&quot;8&quot;</span><br>3) <span class="hljs-string">&quot;g&quot;</span><br>4) <span class="hljs-string">&quot;7&quot;</span><br>127.0.0.1:6379&gt; zpopmin key1 2<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;1&quot;</span><br>3) <span class="hljs-string">&quot;b&quot;</span><br>4) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; zrange key1 0 -1 withscores<br>1) <span class="hljs-string">&quot;c&quot;</span><br>2) <span class="hljs-string">&quot;3&quot;</span><br>3) <span class="hljs-string">&quot;d&quot;</span><br>4) <span class="hljs-string">&quot;4&quot;</span><br>5) <span class="hljs-string">&quot;e&quot;</span><br>6) <span class="hljs-string">&quot;5&quot;</span><br>7) <span class="hljs-string">&quot;f&quot;</span><br>8) <span class="hljs-string">&quot;6&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bzpopmax和bzpopmin命令</p>
<p>bzpopmax命令的使用格式如下：</p>
<blockquote>
<p>bzpopmax key [key …] timeout</p>
</blockquote>
<p>该命令是zpopmax命令的阻塞版本。</p>
<p>bzpopmin命令的使用格式如下：</p>
<blockquote>
<p>bzpopmin key [key …] timeout</p>
</blockquote>
<p>该命令是zpopmin命令的阻塞版本。</p>
<p>timeout参数为0，表示永远等待。</p>
</li>
<li><p>zrank、zrevrank和zremrangebyrank命令</p>
<p>zrak命令的使用格式如下：</p>
<blockquote>
<p>zrank key member</p>
</blockquote>
<p>该命令用于取得元素在有序集合中的排名。排名以0为开始，相当于索引。</p>
<p>zrevrank命令的使用格式如下：</p>
<blockquote>
<p>zrevrank key member</p>
</blockquote>
<p>该命令是zrank命令的倒序版本。</p>
<p>zremrangebyrank命令的使用格式如下：</p>
<blockquote>
<p>zremrangebyrank key start stop</p>
</blockquote>
<p>该命令用于删除指定范围中的元素。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 11 a 22 b 33 c 44 d 55 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zrank key1 b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrank key1 c<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; zrevrank key1 b<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zremrangebyrank key1 0 2<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zrem命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zrem key member [member …]</p>
</blockquote>
<p>该命令用于删除指定的元素。</p>
</li>
<li><p>zscore命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>zscore key member</p>
</blockquote>
<p>该命令用于返回元素的score。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb <br>OK<br>127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 40 d 50 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zscore key1 b<br><span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; zscore key1 e<br><span class="hljs-string">&quot;50&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>zscan命令</p>
<p>使用格式如下:</p>
<blockquote>
<p>zscan key cursor [MATCH pattern] [COUNT count]</p>
</blockquote>
<p>该命令用于增量迭代。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 40 d 50 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zscan key1 0<br>1) <span class="hljs-string">&quot;0&quot;</span><br>2)  1) <span class="hljs-string">&quot;a&quot;</span><br>    2) <span class="hljs-string">&quot;1&quot;</span><br>    3) <span class="hljs-string">&quot;b&quot;</span><br>    4) <span class="hljs-string">&quot;2&quot;</span><br>    5) <span class="hljs-string">&quot;c&quot;</span><br>    6) <span class="hljs-string">&quot;3&quot;</span><br>    7) <span class="hljs-string">&quot;d&quot;</span><br>    8) <span class="hljs-string">&quot;40&quot;</span><br>    9) <span class="hljs-string">&quot;e&quot;</span><br>   10) <span class="hljs-string">&quot;50&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>sort命令</p>
<p>使用sort命令对有序集合排序时，只针对value进行排序，而不针对score。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd key1 1 a 2 b 3 c 40 d 50 e<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; <span class="hljs-built_in">sort</span> key1 alpha<br>1) <span class="hljs-string">&quot;a&quot;</span><br>2) <span class="hljs-string">&quot;b&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>4) <span class="hljs-string">&quot;d&quot;</span><br>5) <span class="hljs-string">&quot;e&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Key类型命令"><a href="#Key类型命令" class="headerlink" title="Key类型命令"></a>Key类型命令</h2><p>Key类型命令主要用于处理key。</p>
<ul>
<li><p>del和exists命令</p>
<p>del命令的使用格式如下：</p>
<blockquote>
<p>del key [key …]</p>
</blockquote>
<p>该命令用用户删除给定的一个或多个key。不存在的key会被忽略。</p>
<p>返回值是被删除key的数量。</p>
<p>exists命令的使用格式如下：</p>
<blockquote>
<p>exists key</p>
</blockquote>
<p>该命令用于判断给定的key是否存在。</p>
<p>如果key存在，则返回1；否则返回0。</p>
</li>
<li><p>unlink命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>unlink key [key …]</p>
</blockquote>
<p>此命令与del命令非常相似，功能也是删除指定的key。</p>
<p>如果key不存在，就会忽略。但是，该命令在不同的线程中执行并实现内存回收，因此 它不会阻塞，而del命令会阻塞。</p>
<p>unlink命令只断开key与value的关联，实际的删除操作是以异步的方式进行执行的。</p>
<p>执行成功后返回为断开关联的key的数量。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; clear<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 keyvalue<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 key2value<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">unlink</span> key1 key2<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; get key1<br>(nil)<br>127.0.0.1:6379&gt; exists key1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>rename指令</p>
<p>使用格式如下：</p>
<blockquote>
<p>rename key newkey</p>
</blockquote>
<p>该命令用于对key进行重命名，当key不存在时返回错误。如果newkey已经存在，则最终使用key对应的值。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 key1value<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 key2value<br>OK<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;key1value&quot;</span><br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;key2value&quot;</span><br>127.0.0.1:6379&gt; rename key1 key2<br>OK<br>127.0.0.1:6379&gt; get key1<br>(nil)<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;key1value&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>renamenx命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>renamenx key newkey</p>
</blockquote>
<p>如果newkey不存在，则将key重命名为newkey；如果newkey存在，则取消操作，当key不存在时它返回错误。</p>
<p>返回1代表成功对key进行重命名。如果newkey已存在，则返回0。</p>
</li>
<li><p>keys命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>keys pattern</p>
</blockquote>
<p>该命令用于返回匹配的所有key列表。</p>
<ul>
<li><p>测试搜索模式：？</p>
<p>h?llo可以匹配hello、hallo或hxllo，“？”代表一个字符</p>
</li>
<li><p>测试搜索模式：*</p>
<p>h*llo匹配hllo和heeeello，“*”代表任意个数的字符。</p>
</li>
<li><p>测试搜索模式：[]</p>
<p>h[ae]llo匹配hallo和hello,但不匹配hillo，“[]”中的内容之间有”或“关系，只匹配其中的一个字符。</p>
</li>
<li><p>测试搜索模式：[^]</p>
<p>h[^e]llo匹配hallo和hbllo等，但不匹配hello。</p>
</li>
<li><p>测试搜索模式：[a-b]</p>
<p>h[a-b]llo匹配hallo和hbllo。</p>
</li>
</ul>
</li>
<li><p>type命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>type key</p>
</blockquote>
<p>该命令用于获取key的value的数据类型，常见的数据类型有String、List、Set、Sonted、Set和Hash。</p>
</li>
<li><p>randomkey命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>randomkey</p>
</blockquote>
<p>该命令用于随机返回key。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 value1<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 value2<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key3 value3<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key4 value4<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key5 value5<br>OK<br>127.0.0.1:6379&gt; randomkey<br><span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; randomkey<br><span class="hljs-string">&quot;key5&quot;</span><br>127.0.0.1:6379&gt; randomkey<br><span class="hljs-string">&quot;key3&quot;</span><br>127.0.0.1:6379&gt; randomkey<br><span class="hljs-string">&quot;key5&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>dump和restore命令</p>
<p>dump命令使用格式如下:</p>
<blockquote>
<p>dump key</p>
</blockquote>
<p>该命令用于序列化指定key对应的值，通常将序列化值作为备份数据。</p>
<p>序列化值有以下几个特点。</p>
<ul>
<li>它带有64位校验和，用于检测错误和验证数据有效性，在进行反序列化之前会先检查校验和的有效性。</li>
<li>序列化值得编码格式和RDB文件保持一致。</li>
<li>RDB版本号会被编码在序列化值当中，如果由于Redis得版本不同造成RDB编码格式不兼容，那么Redis会拒绝对序列化值进行反序列化操作。</li>
<li>序列化值不包括TTL信息。</li>
</ul>
<p>如果key不存在，则返回nil；否则，返回序列化值。</p>
<p>restore命令的使用格式如下：</p>
<blockquote>
<p>restore key ttl serialized-value [replace]</p>
</blockquote>
<p>使用restore命令可以对序列化值进行反序列化，并将结果保存到当前Redis或其他Redis实例中，相当于还原数据。参数ttl以ms位单位，代表key的TTL，如果ttl为0，那么不设置TTL。</p>
<p>restore命令在执行反序列化之前会先对序列化值得RDB版本号和校验和进行检查，如果RDB版本号不相同或者数据不完整得话，那么restore命令会拒绝进行反序列化，并返回一个错误。</p>
<p>如果反序列化成功，则返回OK；否则，返回一个错误。</p>
<p>dump和restore命令为非原子性命令。</p>
<p>为什么不使用get和set命令实现数据得备份和还原呢？</p>
<p>因为使用get命令获取的数据可能被恶意或非恶意地改动，造成欲还原地数据被破坏。可以使用dump和restore命令解决这个问题，因为restore命令在还原数据时要对校验和进行检查，不通过检查不执行还原操作。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a aa<br>OK<br>127.0.0.1:6379&gt; get a<br><span class="hljs-string">&quot;aa&quot;</span><br>127.0.0.1:6379&gt; dump a<br><span class="hljs-string">&quot;\x00\x02aa\t\x00\x04\x92\xc5P\x1e\x7f\xeb\x93&quot;</span><br>127.0.0.1:6379&gt; del a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; restore a 0 <span class="hljs-string">&quot;\x00\x02aa\t\x00\x04\x92\xc5P\x1e\x7f\xeb\x93&quot;</span><br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; get a<br><span class="hljs-string">&quot;aa&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<ul>
<li>如果key已经存在，并且设置了replace参数，那么使用反序列化值来代替key原有地值。如果key已经存在，但是没有设置replace参数，那么该命令将返回一个错误。</li>
</ul>
</li>
<li><p>expire和ttl命令</p>
<p>expire命令的使用格式如下：</p>
<blockquote>
<p>expire key seconds</p>
</blockquote>
<p>注意：seconds参数是当前时间之后的秒数。</p>
<p>expire命令用于在key上设置TTL，超时后key将自动删除。</p>
<p>超时效果可以被删除，也可以被保持，具体如下。</p>
<ul>
<li>删除超时的效果可以使用del、set、getset和所有*store命令。使用RERSIST命令将key重新转换为永久key也可以删除超时效果。</li>
<li>保持超时的效果可以使用”能改变“key中value的相关命令。如使用incr命令对旧value进行增加，使用lpush命令对旧value添加新的元素，或者使用hset命令改变一个散列的字段的旧value都会使超时效果保持不变。如果使用rename命令对key进行重命名，则原有的TTL将转移到新的key中。</li>
</ul>
<p>对一个已经拥有TTL的key再次执行expire命令时，会对该key重新设置新的TTL。</p>
<p>ttl命令的使用格式如下：</p>
<blockquote>
<p>ttl key</p>
</blockquote>
<p>ttl命令的作用时返回具有ttl的key的剩余生存时间。</p>
<p>如果key不存在，该命令将返回-2；如果key存在，但是没有设置TTL，则该命令返回-1.</p>
<p>删除TTL请使用persist命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> b bb ex 20<br>OK<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 17<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 15<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 12<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 9<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; ttl b<br>(<span class="hljs-built_in">integer</span>) -2<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>pexpire和pttl命令</p>
<p>pexpire命令使用格式如下：</p>
<blockquote>
<p>pexpire key miliseconds</p>
</blockquote>
<p>此命令的工作原理与expire命令完全相同，但key的TTL是以ms为单位的，而不是s。</p>
<p>如果设置成功了TTL,则返回1；如果key不存在，则返回为0。</p>
<p>pttl命令的使用格式如下：</p>
<blockquote>
<p>pttl key</p>
</blockquote>
<p>与ttl命令一样，pttl命令返回具有TTL的key的剩余生存时间，唯一的区别是ttl命令返回的剩余生存时间以s为单位，而pttl命令以ms为单位。</p>
<p>如果key不存在，则命令将返回-2；如果key存在，但是没有关联的TTL,则该命令返回-1.</p>
</li>
<li><p>expireat命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>expireat key timestamp</p>
</blockquote>
<p>注意：timestamp参数是UNIX时间戳，时间单位是s。</p>
<p>expireat命令具有与expire命令相同的效果和语义，但expireat命令不指定TTL的秒数，而是指定绝对的UNIX时间戳（自1970年1月1日起的秒数）。当前时间超过UNIX时间戳时，立即删除key。</p>
<p>如果设置了TTL，则返回为1；如果key不存在，则返回为0。</p>
</li>
<li><p>pexpireat命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>pexpireat key milliseconds-timestamp</p>
</blockquote>
<p>pexpireat命令具有与expireat命令相同的效果和语义，但key超时的UNIX时间戳以ms而不是s为单位。</p>
<p>如果成功设置了TTL，则返回1；如果key不存在，则返回0。</p>
</li>
<li><p>persist命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>persist key</p>
</blockquote>
<p>该命令用于删除key上的TTL，将key转换成没有TTL的key,永久保存key,不会过期时删除。</p>
<p>如果TTL已删除，则返回1；如果key不存在或没有关联的TTL,则返回为0。</p>
</li>
<li><p>move命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>move key db</p>
</blockquote>
<p>该命令用于将key从当前选定的源数据库转移到指定的目标数据库，源数据库中的key会被删除。当key已存在于目标数据库中，或者当前选定的源数据库中不存在key时，不执行任何操作。</p>
<p>如果成功移动了key，则返回1；如果未移动Key，则返回0。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a aa<br>OK<br>127.0.0.1:6379&gt; move a 1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; select 1<br>OK<br>127.0.0.1:6379[1]&gt; keys *<br>1) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379[1]&gt; get a<br><span class="hljs-string">&quot;aa&quot;</span><br>127.0.0.1:6379[1]&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>object命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>object subcommand [arguments [arguments ….]]</p>
</blockquote>
<p>object命令可以获取key的元数据，检查与key关联的Redis Object的内部信息，内部信息可以理解成元数据，它对调试key使用指定编码以节省存储空间非常有用。另外，当使用Redis作为缓存时，应用程序还可以使用object命令得出的报告信息来实现应用程序级别的key删除策略，以释放缓存空间。</p>
<p>object命令支持多个子命令，具体如下。</p>
<ul>
<li><p>object refcount key：返回指定key关联的value的引用数。此命令主要用于调试。Redis新版本的refcount返回值并不是精确的数字。</p>
</li>
<li><p>object encoding key：返回key关联的value的内部表示形式。type命令取得key对应的存储数据类型，而object encoding 命令取得数据类型内部存储的具体形式。</p>
</li>
<li><p>object idletime key：返回未通过read或write操作的key的空闲时间。当内存淘汰策略设置为最少使用（Least Recently Used ,LRU)策略或不淘汰时，此子命令可用。</p>
</li>
<li><p>object freq key：返回指定key访问频率的对数。当内存淘汰策略设置为最近最不常用（Least Frequently Used ,LFU）策略时，此子命令可用。此命令的返回值是给Redis内部参考使用的，作用是在内存不够时决定将哪些数据清除。</p>
</li>
<li><p>object help：返回辅助的帮助文本。</p>
<p>使用object encoding key命令可以获得编码格式，也就是使用哪种数据类型存储数据。</p>
</li>
<li><p>String 可以被编码为RAW字符串或Int（为了节约内存，Redis会将字符串表示的64bit有符号整数编码为整数来进行存储）。</p>
</li>
<li><p>List可以被编码为ziplist或linkedlist。</p>
</li>
<li><p>Set可以被编码为intset或者hashtable。</p>
</li>
<li><p>Hash可以编码为ziplist或者hashtable。</p>
</li>
<li><p>Sorted Set可以被编码为ziplist或者skiplist。</p>
<p>数据最终使用哪种编码格式来存储取决于value的大小。</p>
<p>Redis会随着value的大小来决定最终使用什么类型的内部编码，应用层程序员无法决定。</p>
<p>将String编码成int数据类型可以节省内存。</p>
</li>
<li><p>Redis中的String内部编码有如下3种：</p>
<ul>
<li>8B的长整数。</li>
<li>embstr：小于等于39B的字符串。</li>
<li>大于39B的字符串。</li>
</ul>
</li>
<li><p>Redis内存淘汰策略主要有两种</p>
<ul>
<li>LFU：删除访问频率最低的数据。</li>
<li>LRU：删除很久没有被范文的数据。</li>
</ul>
</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; clear<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a 0<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> b 9999<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> c 10000<br>OK<br>127.0.0.1:6379&gt; get a<br><span class="hljs-string">&quot;0&quot;</span><br>127.0.0.1:6379&gt; get b<br><span class="hljs-string">&quot;9999&quot;</span><br>127.0.0.1:6379&gt; get c<br><span class="hljs-string">&quot;10000&quot;</span><br>127.0.0.1:6379&gt; object refcount a<br>(<span class="hljs-built_in">integer</span>) 2147483647<br>127.0.0.1:6379&gt; object encoding key1<br>(nil)<br>127.0.0.1:6379&gt; object encoding a<br><span class="hljs-string">&quot;int&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 <span class="hljs-string">&quot;123&quot;</span><br>OK<br>127.0.0.1:6379&gt; object encoding key1<br><span class="hljs-string">&quot;int&quot;</span><br>127.0.0.1:6379&gt; object idletime a<br>(<span class="hljs-built_in">integer</span>) 251<br></code></pre></td></tr></table></figure>
</li>
<li><p>migrate命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>migrate host port key|”” desination-db timeout [COPY] [REPLACE] [KEYS key [key …]]</p>
</blockquote>
<p>该命令用于原子性的将key从源Redis实例传输到目标Redis实例中。成功时，key将从源Redis实例中删除，并保证存于目标Redis实例中。</p>
<p>move命令在当前Redis实例中对数据进行移动，而migrate命令可以跨越不同Redis实例。</p>
<p>该命令的内部实现是这样的：它的源Redis实例中给定key执行dump命令，将它进行序列化，然后传送到目标Redis实例中；目标实例Redis实例再执行restore命令对key进行反序列化，并将反序列化所得的key添加到数据库中。源Redis实例就像目标Redis实例的客户端，只要看到restore命令就返回OK，源Redis实例就会调用del命令删除其中的key。</p>
<p>参数timeout以ms为单位，指定源Redis实例和目标Redis实例进行数据转移时的最大时间。操作耗时如果大于timeout就会出现异常。</p>
<p>migrate命令需要再给定的timeout内完成数据转移操作，如果在转移数据时发生IO错误，或者到达了timeout，那么命令会停止执行，并返回一个-IOERR错误。当还错误出现时，有以下两种可能。</p>
<ul>
<li>key可能存在于两个Redis实例中，源Redis实例中的key并没有被删除。如目的Redis实例成功添加了数据，返回给源Redis实例OK，但由于网络出现异常，源Redis实例并没有接收到OK，因此不会删除源Redis实例中的数据。</li>
<li>key可能只存在于源Redis实例中，目标Redis实例并没有key，也就是并没有转移成功。如在转移时网络出现异常。</li>
</ul>
<p>当返回任何以ERR开头的其他错误时，migrate命令保证key仍然存在于源Redis实例中，除非目标Redis实例中已存在同名的key。</p>
<p>如果源Reids实例中没有要转移的key，则返回NOKEY。因为缺少key在正常情况下是可能的，如key超时了，所以NOKEY不是一个错误。</p>
<p>可以在执行一次migrate命令时实现批量转移key。从Redis 3.0.6开始，migrate 命令支持一种新的大容量转移模式，该模式使用流水线，以便在Redis实例之间一起迁移key，减少了网络开销。想使用此模式，就要使用keys参数，并将正常key参数设置为空字符串””，实际的key名称将在keys参数之后提供，命令示例如下。</p>
<blockquote>
<p>migrate 192.168.31.45 8888 “” 0 5000 REPLACE auth accp KEYS a b c</p>
</blockquote>
<p>如果目标Redis实例有密码，则需要添加auth参数和密码值accp。</p>
<p>参数的解释如下。</p>
<ul>
<li>REPLACE：替换目标Redis实例中的现有key。</li>
<li>KEYS：如果key参数是空字符串，该命令将改为转移KEYS参数后面的所有key.</li>
</ul>
<p>Redis中的数据转移可以使用move、dump+restore和migrate命令，其中migrate命令功能最为完整和强大。</p>
</li>
<li><p>scan命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>scan cursor [MATCH pattern] [COUNT count]</p>
</blockquote>
<p>scan、sscan、hscan及zscan命令密切相关，它们都以增量的方式迭代元素集合。</p>
<p>这四个命令的解释如下：</p>
<ul>
<li>scan：迭代当前选定数据库中的key。</li>
<li>sscan：迭代Set中的元素。</li>
<li>hscan：迭代Hash中的field和value。</li>
<li>zscan：迭代Sorted Set中的元素和score</li>
</ul>
<p>这4个命令最明显的区别是sscan、hscan和zscan命令的第一个参数分别是Set、Hash和Sorted Set中key的名称。而scan命令不需要任何key名参数，因为它迭代当前数据库中所有key，因此迭代对象是数据库本身。</p>
</li>
<li><p>touch命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>touch key [key …]</p>
</blockquote>
<p>该命令用于修改指定key的最后访问时间。若key不存在，则不执行任何操作。此命令的作用是增加key的活跃度，避免其被内存淘汰策略所删除。</p>
</li>
</ul>
<h2 id="HyperLogLog、Bloom-Filter类型命令及Redis-Cell模块"><a href="#HyperLogLog、Bloom-Filter类型命令及Redis-Cell模块" class="headerlink" title="HyperLogLog、Bloom Filter类型命令及Redis-Cell模块"></a>HyperLogLog、Bloom Filter类型命令及Redis-Cell模块</h2><h3 id="HyperLogLog类型命令"><a href="#HyperLogLog类型命令" class="headerlink" title="HyperLogLog类型命令"></a>HyperLogLog类型命令</h3><p>  如果想统计一个页面被访问的次数可以使用incr命令，但如果想统计有多少个IP地址访问了它呢？借用Set数据类型的唯一特性，可以使用Set存储IP地址，再使用scard命令就能统计有多少个IP地址访问这个页面了，但这样做会占用大量内存空间。Set数据类型中已字符串存储IPv4格式的地址255.255.255.255，字符串长度为15B。如果有200000个IP地址访问，那么存储容量的大小为200000*15&#x3D;3000000B，3000000B&#x2F;1024&#x3D;2929.6875MB，相当于要占用3G的内存空间，如果网站有1000个页面呢？并且还想统计每天每个页面被多少个IP地址访问了呢？这样数据存储容量的规模不可想象，购买内存的成本会非常高，这时可以考虑使用HyperLogLog数据类型。</p>
<p>  HyperLogLog数据类型是一种概率数据类型，用于计算唯一事物的“近似数量”。由于是近似数量，因此其值并不精确，存在最大0.81%的误差，但HyperLogLog数据类型的优点是最多只占用12KB内存空间，以更低的精度换取更小的空间。</p>
<p>  Redis再操作HyperLogLog数据类型时提供了如下3个命令。</p>
<ul>
<li><p>pfadd：向key添加元素。</p>
</li>
<li><p>pfcount：返回key中存储元素的个数。</p>
</li>
<li><p>pfmerge：合并两个HyperLogLog数据类型中的元素。</p>
</li>
<li><p>pfadd和pfcount命令</p>
<p>pfadd命令的使用格式如下：</p>
<blockquote>
<p>pfadd key element [element …]</p>
</blockquote>
<p>该命令用于向key中添加元素。</p>
<p>如果HyperLogLog数据类型的近似数量（元素个数）在执行该命令时发生变化，则返回1，否则返回0。</p>
<p>pfcount命令的使用格式如下：</p>
<blockquote>
<p>pfcount key [key …]</p>
</blockquote>
<p>当参数为一个key时，该命令返回存储在HyperLogLog数据类型的元素个数近似值。</p>
<p>当参数为多个key时，该命令返回这些key并集的近似数量，近似数量是将指定多个key的HyperLogLog数据 类型合并到一个临时的HyperLogLog数据类型中计算而得到的。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; pfadd key1 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfcount key1<br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; pfadd key2 a b c d e<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfcount key2<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; pfcount key1 key2<br>(<span class="hljs-built_in">integer</span>) 15<br>127.0.0.1:6379&gt; pfadd key3 a b c d e x y z<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfcount key3<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; pfcount key1 key3<br>(<span class="hljs-built_in">integer</span>) 18<br>127.0.0.1:6379&gt; pfcount key2 key3<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; <br><span class="hljs-comment">#在使用pfcount命令指定多个key时，统计出来的近似数量是去重之后的。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>pfmerge命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>pfmerge destkey sourcekey [sourcekey …]</p>
</blockquote>
<p>该命令用于合并HyperLogLog。</p>
<p>该命令将多个sourcekey合并为一个destkey，合并后的destkey接近所有合并sourcekey的可见集合的并集。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; pfadd key1 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfadd key2 a b c d e<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfadd key3 a b c d e x y z<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; pfmerge key4 key1 key2<br>OK<br>127.0.0.1:6379&gt; pfcount key4<br>(<span class="hljs-built_in">integer</span>) 15<br>127.0.0.1:6379&gt; pfmerge key5 key2 key3<br>OK<br>127.0.0.1:6379&gt; pfcount key5<br>(<span class="hljs-built_in">integer</span>) 8<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Bloom-Filter类型命令"><a href="#Bloom-Filter类型命令" class="headerlink" title="Bloom Filter类型命令"></a>Bloom Filter类型命令</h3><p>HyperLogLog数据类型以近似数量的形式统计出海量元素的个数，但却不能确定某一个元素是否被添加过，因此HyperLogLog数据类型并没有提供PFCONTAINS方法，这时可以使用Bloom Filter数据类型来实现这样的需求。</p>
<p>举一个例子，某些App要求用户每次给客户端推荐的内容都是不重复的，如果用传统的RDBMS存储统计信息，那么无论如何优化也达不到理想的效果。RDBMS不管在硬盘还是内存占用等方面，都是极其浪费资源的，这种场景正是使用Bloom Filter数据类型的好时机。</p>
<p>Bloom Filter数据类型就像一个“不太精确的Set数据类型”，它使用contains()方法判断是否误判一个元素存在。Bloom Filter数据类型判断某个元素存在时，这个元素可能不存在，而判断某个元素不存在时，此元素肯定不存在 。根据这个特性，使用Bloom Filter数据类型实现推送系统时，可以绝对精确地向用户推荐没有看过地内容。</p>
<ul>
<li><p>在Redis中安装RedisBloom模块</p>
<p>在Redis中需要以模块地方式安装RedisBloom。下载Redis的RedisBloom的压缩包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --recursive https://github.com/RedisBloom/RedisBloom.git<br><span class="hljs-built_in">cd</span> redisbloom<br>make<br><span class="hljs-comment"># Assuming you have a redis build from the unstable branch:</span><br>/path/to/redis-server --loadmodule ./redisbloom.so<br></code></pre></td></tr></table></figure>


</li>
<li><p>bf.reserve、bf.add和bf.info命令</p>
<p>bf.reserve命令的使用格式如下：</p>
<blockquote>
<p>bf.reserve(key) {error_rate} {capacity} [EXPANSION expansion] [NONSCALING]</p>
</blockquote>
<p>根据指定的误判率和初始容量创建一个空的布隆过滤器。命令执行成功返回OK，否则返回异常。</p>
<p>可以通过创建子判过滤器的方式来扩展布隆过滤器容量（扩容），但与创建布隆过滤器时指定合适的容量比，子布隆过滤器将消耗更多的内存和CPU资源。</p>
<p>参数解释如下：</p>
<ul>
<li>key：key的名称。</li>
<li>error_rate：期望的误判率，取0~1的十进制数。如期望的误判率为0.1%（1000个中有1个),error_rate应该设置为0.001.其值越接近于0，则内存消耗越大，CPU使用率越高。</li>
<li>capacity：计划添加到布隆过滤器中的元素个数，添加超过此数量的元素后，布隆过滤器的性能开始下降。</li>
<li>EXPANSION expansion：如果创建了一个新的子布隆过滤器，则其内容将是当前布隆过滤器的容量*expansion，expansion默认为2。这意味着新的子布隆过滤器的布隆过滤器将是前一个布隆过滤器容量的两倍。</li>
<li>NONSCALING：如果达到初始的容量，则阻止布隆过滤器创建其他子布隆过滤器。不可扩容的布隆过滤器所需要的内存容量比可扩容的布隆过滤器要少。</li>
</ul>
<p>在使用布隆过滤器时，需要着重考虑两点。</p>
<ul>
<li>预估数据量n，也就是capacity。</li>
<li>期望的误判率p，也就是error_rate。</li>
</ul>
<p>这两点关乎布隆过滤器的内存占用量，内存占用量的计算比较复杂，使用如下公式。</p>
<p>​	m&#x3D;$-(n*lnp)&#x2F;(lnk)^2$</p>
<p>bf.add命令的使用格式如下：</p>
<blockquote>
<p>bf.add {key} {item}</p>
</blockquote>
<p>该命令用于将元素添加到布隆过滤器中，如果该布隆过滤器不存在，则创建布隆过滤器。如果添加了新的元素，则返回1；返回0代表添加的元素可能已经存在。</p>
<p>bf.info命令的使用格式如下：</p>
<blockquote>
<p>bf.info {key}</p>
</blockquote>
<p>该命令用于返回key的相关信息。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; bf.reserve mykey 0.001 1000000<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> mykey<br>MBbloom--<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;mykey&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>继续测试自动扩容的效果，测试案例如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; bf.reserve mykey 0.001 3<br>OK<br>127.0.0.1:6379&gt; bf.add mykey a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.add mykey b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.add mykey c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 3<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 160<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 3<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; bf.add mykey d<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 9<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 296<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 2<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 4<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>如果使用NONSCALING参数，则容量不够时出现异常，不再扩容，测试案例如下。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.reserve mykey <span class="hljs-number">0</span>.<span class="hljs-number">001</span> <span class="hljs-number">3</span> NONSCALING<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.add mykey a<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.add mykey b<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.add mykey c<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.info mykey<br> <span class="hljs-number">1</span>) Capacity<br> <span class="hljs-number">2</span>) (integer) <span class="hljs-number">3</span><br> <span class="hljs-number">3</span>) Size<br> <span class="hljs-number">4</span>) (integer) <span class="hljs-number">160</span><br> <span class="hljs-number">5</span>) Number of filters<br> <span class="hljs-number">6</span>) (integer) <span class="hljs-number">1</span><br> <span class="hljs-number">7</span>) Number of items inserted<br> <span class="hljs-number">8</span>) (integer) <span class="hljs-number">3</span><br> <span class="hljs-number">9</span>) Expansion rate<br><span class="hljs-number">10</span>) (nil)<br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.add mykey c<br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; bf.info mykey<br> <span class="hljs-number">1</span>) Capacity<br> <span class="hljs-number">2</span>) (integer) <span class="hljs-number">3</span><br> <span class="hljs-number">3</span>) Size<br> <span class="hljs-number">4</span>) (integer) <span class="hljs-number">160</span><br> <span class="hljs-number">5</span>) Number of filters<br> <span class="hljs-number">6</span>) (integer) <span class="hljs-number">1</span><br> <span class="hljs-number">7</span>) Number of items inserted<br> <span class="hljs-number">8</span>) (integer) <span class="hljs-number">3</span><br> <span class="hljs-number">9</span>) Expansion rate<br><span class="hljs-number">10</span>) (nil)<br><span class="hljs-number">127.0.0.1:6379</span>&gt; <br></code></pre></td></tr></table></figure>

<p>使用EXPANSION参数可以定义扩展的容量的大小，默认值是2，测试案例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 3<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 160<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 0<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; bf.add mykey a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.add mykey b<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.add mykey c<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.add mykey d<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 15<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 312<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 2<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 4<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 4<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bf.madd命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bf.madd {key} {item} [item …]</p>
</blockquote>
<p>该命令用于向布隆过滤器中添加多个元素，返回值是boolean[]类型即布尔数组。如果成功添加新的元素，则返回true；如果元素已经存在，则返回false。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; bf.madd mykey a b c d<br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 1<br>3) (<span class="hljs-built_in">integer</span>) 1<br>4) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 100<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 296<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 4<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; bf.madd mykey a b c d e<br>1) (<span class="hljs-built_in">integer</span>) 0<br>2) (<span class="hljs-built_in">integer</span>) 0<br>3) (<span class="hljs-built_in">integer</span>) 0<br>4) (<span class="hljs-built_in">integer</span>) 0<br>5) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 100<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 296<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 5<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bf.insert命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bf.insert {key} [CAPACITY {cap}] [ERROR {error}] [EXPANSION expansion] [NOCREATE] [NONSCALING] ITMES {items ….}</p>
</blockquote>
<p>该命令用于创建布隆过滤器的同时向布隆过滤器中添加一个或多个元素。返回值是boolean[]类型，如果成功添加新的元素，返回true；如果元素已经存在，返回false。</p>
<p>参数解释如下：</p>
<ul>
<li>key：key的名称。</li>
<li>CAPACITY：如果指定此参数，则对创建的布隆过滤器设置cap。如果布隆过滤器已存在，则忽略此参数。如果创建布隆过滤器时并未指定此参数，则使用默认cap。</li>
<li>ERROR：如果指定此参数，则对创建的布隆过滤器设置error。如果布隆过滤器已经存在，则忽略此参数。如果创建布隆过滤器时并没有指定此参数，则使用默认error。</li>
<li>EXPANSION：如果创建了一个新的子布隆过滤器，则其容量将是当前布隆过滤器的容量*expansion，expansion默认值是2，这意味着新的子布隆过滤器的容量将是当前布隆过滤器容量的两倍。</li>
<li>NOCREATE：指定此参数，代表如果布隆过滤器不存在，则不创建布隆过滤器，并且会返回错误信息。参数NOCRETE与CAPCITY或ERROR一起使用会发生错误。</li>
<li>NONSCALING：如果达到初始的容量，则阻止布隆过滤器创建子布隆过滤器。不可扩容的过滤器所需要的内存容量比可扩容的过滤器少。</li>
<li>ITEMS：添加一个或多个元素。</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; bf.insert mykey items a b c<br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 1<br>3) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 100<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 296<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 3<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bf.exists命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bf.exists {key} {item}</p>
</blockquote>
<p>该命令用于判断元素是否在集合中。</p>
<p>如果元素肯定不存在，返回0；如果元素可能存在，返回1.</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; bf.insert mykey items a b c<br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 1<br>3) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.info mykey<br> 1) Capacity<br> 2) (<span class="hljs-built_in">integer</span>) 100<br> 3) Size<br> 4) (<span class="hljs-built_in">integer</span>) 296<br> 5) Number of filters<br> 6) (<span class="hljs-built_in">integer</span>) 1<br> 7) Number of items inserted<br> 8) (<span class="hljs-built_in">integer</span>) 3<br> 9) Expansion rate<br>10) (<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; bf.exists mykey a<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; bf.exists mykey g<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>bf.mexists命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>bf.mexists {key} {item} [item …]</p>
</blockquote>
<p>该命令用于判断多个元素是否在集合中。</p>
</li>
</ul>
<h3 id="使用Redis-Cell模块实现限流"><a href="#使用Redis-Cell模块实现限流" class="headerlink" title="使用Redis-Cell模块实现限流"></a>使用Redis-Cell模块实现限流</h3><p>限流是互联网行业中应用得比较多的功能之一，指在有限的时间内允许多少次操作，如60s之内允许最多5次回帖，使用Redis-Cell模块能非常容易实现这类功能。</p>
<ul>
<li><p>在Redis中安装Redis-Cell模块</p>
<p>进入Redis-Cell模块网站，下载二进制文件。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/brandur/redis-cell">Redis-Cell</a></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">CL.THROTTLE user123 15 30 60 1<br>        ▲     ▲  ▲  ▲ ▲<br>        |<span class="hljs-string">      </span>|<span class="hljs-string">   </span>|<span class="hljs-string">  </span>|<span class="hljs-string"> └───── 每操作1次作为1个令牌，默认值是0</span><br><span class="hljs-string">        </span>|<span class="hljs-string">      </span>|<span class="hljs-string">   └──┴─────── 60秒内最多允许获取30个令牌</span><br><span class="hljs-string">        </span>|<span class="hljs-string">      └─────────────令牌桶中令牌的总数16个，因为从0开始</span><br><span class="hljs-string">        └─────────────────── key 的名称</span><br></code></pre></td></tr></table></figure>



<p>详细教程见官网。</p>
</li>
</ul>
<h2 id="GEO类型命令"><a href="#GEO类型命令" class="headerlink" title="GEO类型命令"></a>GEO类型命令</h2><p>Redis提供了地理位置数据类型的支持。使用GEO类型命令可以实现“附近的人”“附近约车”“就近干活”等与地理位置和距离有关的业务功能。</p>
<ul>
<li><p>geoadd和agepos命令</p>
<p>geoadd命令的使用格式如下：</p>
<blockquote>
<p>geoadd key longitude latitude member [longitude latitude member …]</p>
</blockquote>
<p>该命令用于将指定的地理空间项（包括经度、纬度、名称）添加到指定key中。数据以有序集合的方式存储在key中。</p>
<p>geoadd 命令对可使用的坐标值有限制：非常靠近两级区域的坐标不可使用。经、维度的有效值在EPSG:900913、EPSG:3785的范围内。OSGEO:41001标准中有如下两个限制。</p>
<ul>
<li>有效经度为-180°~180°。</li>
<li>有效纬度为-85.05112878~85.05112878</li>
</ul>
<p>如果使用非指定范围内的坐标值，就会出现异常。</p>
<p>geopos命令的使用格式如下：</p>
<blockquote>
<p>geopos key member [member …]</p>
</blockquote>
<p>该命令用于获取指定key中member的地理位置，值是近似值。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd mykey 50 50 china<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd mykey 51 51 america 52 52 shanghai<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;mykey&quot;</span><br>127.0.0.1:6379&gt; geopos mykey china<br>1) 1) <span class="hljs-string">&quot;49.99999970197677612&quot;</span><br>   2) <span class="hljs-string">&quot;49.99999957172130394&quot;</span><br>127.0.0.1:6379&gt; geopos mykey america<br>1) 1) <span class="hljs-string">&quot;51.00000232458114624&quot;</span><br>   2) <span class="hljs-string">&quot;51.00000029822487591&quot;</span><br>127.0.0.1:6379&gt; geopos mykey shanghai china<br>1) 1) <span class="hljs-string">&quot;51.99999958276748657&quot;</span><br>   2) <span class="hljs-string">&quot;52.00000102472843366&quot;</span><br>2) 1) <span class="hljs-string">&quot;49.99999970197677612&quot;</span><br>   2) <span class="hljs-string">&quot;49.99999957172130394&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>geodist命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>geodist key member1 member2 [unit]</p>
</blockquote>
<p>该命令用于返回两个元素之间的距离。</p>
<p>距离单位可以选择如下单位，默认是m。</p>
<ul>
<li>m：米。</li>
<li>km：公里。</li>
<li>mi：英里。</li>
<li>ft：英尺。</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd mykey 50 50 china<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd mykey 51 51 america 52 52 shanghai<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;mykey&quot;</span><br>127.0.0.1:6379&gt; geodist mykey china shanghai m<br><span class="hljs-string">&quot;262814.0788&quot;</span><br>127.0.0.1:6379&gt; geodist mykey china shanghai km<br><span class="hljs-string">&quot;262.8141&quot;</span><br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>
</li>
<li><p>geohash命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>geohash key member [member …]</p>
</blockquote>
<p>该命令用于返回地理位置的散列字符串，字符串长度为11个字符。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd key 30 30 A <br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd key 45 65 B<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geohash key A<br>1) <span class="hljs-string">&quot;stm6dtm6dt0&quot;</span><br>127.0.0.1:6379&gt; geohash key B<br>1) <span class="hljs-string">&quot;v581b0bh2n0&quot;</span><br>127.0.0.1:6379&gt; geohash key B A<br>1) <span class="hljs-string">&quot;v581b0bh2n0&quot;</span><br>2) <span class="hljs-string">&quot;stm6dtm6dt0&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>georadius命令</p>
<p>使用格式如下:</p>
<blockquote>
<p>georadius key longitude laritude radius m|km|ft|mi [withdist] [withhash] [count count] [asc|desc] [store key] [storedist key1]</p>
</blockquote>
<p>该命令用于根据指定坐标（中心点），返回围绕坐标在指定半径之内的地理位置。</p>
<p>结合如下3个参数可以返回其他附加的结果。</p>
<ul>
<li><p>withdist：返回查找的结果与中心点的距离。</p>
</li>
<li><p>withcoord：返回经纬度坐标。</p>
</li>
<li><p>withhash：返回散列字符串。</p>
<p>默认情况下，georadius命令将返回的结果是未排序的，可以使用如下两个参数进行排序。</p>
<ul>
<li>asc：相对中心点，将返回的结果从近到远进行排序。</li>
<li>desc：相对中心点，将返回值的结果从远到近进行排序。</li>
</ul>
</li>
</ul>
<p>结合参数count可以对返回结果的数量进行限制。</p>
<p>参数store和storedist可以实现将返回的结果或距离另存到其他的key中。</p>
<p><strong>测试案例</strong></p>
<p>执行如下命令初始化测试环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; flushdb<br>OK<br>127.0.0.1:6379&gt; geoadd key 30 31 A 30 32 B 30 33 C 30 34 D 30 35 E<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; geodist key A B m<br><span class="hljs-string">&quot;111226.0989&quot;</span><br>127.0.0.1:6379&gt; geodist key A C m<br><span class="hljs-string">&quot;222452.4797&quot;</span><br>127.0.0.1:6379&gt; geodist key A D m<br><span class="hljs-string">&quot;333678.8605&quot;</span><br>127.0.0.1:6379&gt; geodist key A E m<br><span class="hljs-string">&quot;444904.9594&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<p>测试距离单位m、km、ft、mi</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; georadius key 30 31 30000 m<br>1) <span class="hljs-string">&quot;A&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>gepradiusbymember命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>georadiusbymember key member radius m|km|ft|mi [withdist] [withhash] [count count] [asc|desc] [store key] [storedist key1]</p>
</blockquote>
<p>该命令用于根据元素返回附近的地理位置。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; georadiusbymember key  B 300000 m<br>1) <span class="hljs-string">&quot;B&quot;</span><br>2) <span class="hljs-string">&quot;C&quot;</span><br>3) <span class="hljs-string">&quot;D&quot;</span><br>4) <span class="hljs-string">&quot;A&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>删除GEO数据类型中的元素</p>
<p>GEO数据类型内部使用Sorted Set数据类型，删除元素可以使用zrem命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geoadd key 30 31 A 30 32 B 30 33 C 30 34 D 30 35 E<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> key<br>zset<br>127.0.0.1:6379&gt; zcard key<br>(<span class="hljs-built_in">integer</span>) 5<br>127.0.0.1:6379&gt; zrem key A B<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; zcard key<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; zrange key 0 -1<br>1) <span class="hljs-string">&quot;C&quot;</span><br>2) <span class="hljs-string">&quot;D&quot;</span><br>3) <span class="hljs-string">&quot;E&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Pub-x2F-Sub类型命令"><a href="#Pub-x2F-Sub类型命令" class="headerlink" title="Pub&#x2F;Sub类型命令"></a>Pub&#x2F;Sub类型命令</h2><p>Pub&#x2F;Sub（发布&#x2F;订阅）模式在生活中随处可见。如某些网站上的“话题广场”就是典型的Pub&#x2F;Sub模式。</p>
<p>在话题广场中，用户选择自己感兴趣的话题进行订阅，当发布了与订阅话题有关的帖子时，网站会自动把帖子传送给订阅的用户。</p>
<p>Pub&#x2F;Sub模式有3个角色。</p>
<ul>
<li>主题（Topic）：发布者与订阅者沟通的桥梁。</li>
<li>订阅者（Subscriber）：订阅主题，并从主题获取消息。</li>
<li>发布者（Publisher）：向主题发布消息。</li>
</ul>
<p>3个角色的结构关系如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706534.png" srcset="/img/loading.gif" lazyload alt="image-20220326163807846"></p>
<p>订阅者首先订阅指定的主题，发布者把消息传送给主题，主题会把消息传送给订阅主题的订阅者。</p>
<p>在Redis中，主题换了一个新的名称，即“频道”，频道其实和原来主题的功能作用是一样的。Redis中的Pub&#x2F;Sub模式的结构如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706535.png" srcset="/img/loading.gif" lazyload alt="image-20220326164101014"></p>
<p>订阅者首先订阅指定的频道，发布者把消息传送给频道，频道会把消息传送给订阅频道的订阅者。</p>
<p>Redis中的Pub&#x2F;Sub模式可以总结出如下3个特性。</p>
<ul>
<li>以频道未中介，实现了发布者与订阅者之间的解耦，发布者不知道订阅者在哪里，而订阅者也不知道发布者在哪里。</li>
<li>订阅者要先订阅频道，然后频道会将发布者发布的消息传送给订阅者。如果发布者在订阅频道前发布消息，则订阅者接收不到消息。</li>
<li>Pub&#x2F;Sub模式就是Java中的观察者模式。</li>
</ul>
<p><strong>具体命令</strong></p>
<ul>
<li><p>publish和subscribe命令</p>
<p>publish和subscribe命令的作用是发布与订阅。</p>
<p>publish使用格式如下：</p>
<blockquote>
<p>publish channel message</p>
</blockquote>
<p>该命令用于向指定的频道发布消息。</p>
<p>subscribe使用格式如下：</p>
<blockquote>
<p>subscribe channel [channel …]</p>
</blockquote>
<p>该命令用于订阅指定的频道。</p>
<p>一旦客户端（订阅者）进入订阅状态，就不能执行除subscribe、psubcribe、unsubscribe和punsubscribe以外的命令。</p>
<p><strong>测试案例</strong></p>
<p>订阅者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; subscribe chnnelA channelB<br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;chnnelA&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;channelB&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 2<br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;channelB&quot;</span><br>3) <span class="hljs-string">&quot;bmessage&quot;</span><br></code></pre></td></tr></table></figure>

<p>发布者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; publish channelB  bmessage<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>
</li>
<li><p>unsubscribe命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>unsubscribe [channel [channel …]]</p>
</blockquote>
<p>该命令用于取消订阅指定频道，如果频道未指定，则取消订阅所有频道。</p>
<p>redis-cli中一旦进入订阅状态，就无法执行unsubscribe命令实现取消订阅的效果，因此需要在Redis环境中进行。</p>
</li>
<li><p>psubscribe命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>psubscribe pattern [pattern]</p>
</blockquote>
<p>该命令用于订阅与指定模式pattern匹配的频道，支持glob风格的匹配模式。</p>
</li>
<li><p>punsubscribe命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>punsubscribe [pattern [pattern ,,,]]</p>
</blockquote>
<p>该命令用于按模式pattern批量取消订阅，如果pattern未指定，则取消订阅所有频道。</p>
</li>
<li><p>pubsub命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>pubsub subcommand [argument [argument …]]</p>
</blockquote>
<p>该命令用于获取订阅发布的状态，使用形式如下。</p>
<blockquote>
<p>pubsub <subcommand> … args ….</p>
</blockquote>
</li>
</ul>
<h2 id="Stream类型命令"><a href="#Stream类型命令" class="headerlink" title="Stream类型命令"></a>Stream类型命令</h2><p>Stream数据类型是Redis5.0新添加的数据类型，是Redis数据类型中最复杂的，尽管其数据结构本身非常简单。其最大的特点就是有序存储field-value。</p>
<p>先来看一看其他数据类型的缺点。</p>
<ul>
<li>String：想要存储field-value对，必须存储JSON格式，JSON格式里包括field-value对。另外需要在JSON格式的内容中自行处理元素的有序性，如使用数组；缺点是不支持直接存储field-value对。</li>
<li>Hash：无序，支持存储field-value对；缺点是无序。</li>
<li>List：有序，想要存储field-value对必须存储JSON格式；缺点是无序和不支持直接存储field-value对。</li>
<li>Sorted Set：有序，想要存储field-value对必须存储JSON格式；缺点是不支持直接存储field-value对。</li>
</ul>
<p>以上5大数据类型都或多或少有缺点，但Stream数据类型的出现却改正了这些缺点。Stream数据类型不仅支持有序性。还支持直接存储field-value对。另外，Stream数据类型也允许消费者以阻塞的方式等待生产者向Stream数据类型中发送新消息，此外还有“消费者组”的实现。作用是允许多个消费者相互配合来消费同一个Stream数据类型中不同部分的消息。上面介绍的这些知识点都在本章以案例的形式实现。</p>
<p>Stream数据类型的存储形式如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706536.png" srcset="/img/loading.gif" lazyload alt="image-20220326190031097"></p>
<p>Stream数据类型中的key对应的value由一个ID和若干field-value对组成，和Hash数据类型非常相似。但Hash数据类型存储的元素是无序的，而Stream数据类型借助于ID的大小可以使存储的元素是有序的，和Sorted Set数据类型借助于score存储的元素是有序的效果一样。和Sorted Set 数据类型相比，Stream数据类型的优势是可以直接存储field-value对。</p>
<ul>
<li><p>xadd命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>xadd key ID field string [field string …]</p>
</blockquote>
<p>该命令用于添加元素。</p>
<p>参数field string整体代表流条目（Streams Entry），一个流条目由多个field-string对组成。流条目整体可以理解成一个普通的元素，为了便于理解，我们将“流条目”和“元素”作为同一事物。</p>
<p>ID由time和sequence两部分组成，使用格式为”time-sequence”。</p>
<p>生成元素ID可以有两种方式。</p>
<ul>
<li>自动生成：在自动生成ID的情况下，time单位是ms，是当前Redis实例的服务器时间。当time一样时，为了标识元素的唯一性，需要使用sequence进行自增。用time作为ID的优势是可以根据时间范围查询元素。使用“*”自动生成ID，有Redis根据当前时间自动生成一个唯一的ID，每次自动生成的ID都会比上一个ID更大，因为时间一直在前进，就像数据库的主键自增一样。</li>
<li>自定义：在手动生成ID的情况下，time和sequence的值是可以自定义的。一般使用自定义ID的情况少。</li>
</ul>
<p><strong>测试案例</strong></p>
<p>1 使用“*”自动生成ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; xadd key1 * a aa b bb c cc<br><span class="hljs-string">&quot;1648293296729-0&quot;</span><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;key1&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>使用maxlen限制流的绝对长度，这样会保留最新的元素，也就是ID值小的元素会被删除。</p>
<p>使用maxlen~限制流的近似长度，会保留最新的元素。</p>
</li>
<li><p>xlen命令</p>
<p>使用格式 如下：</p>
<blockquote>
<p>xlen key</p>
</blockquote>
<p>该命令用于获取key中存储的元素个数。</p>
</li>
<li><p>xdel命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>xdel key ID [ID …]</p>
</blockquote>
<p>该命令用于 根据ID删除对应的元素。</p>
</li>
<li><p>xrange命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>xrange key start end [COUNT count]</p>
</blockquote>
<p>该命令用于按ID范围正序返回元素（包括start和end值，属于start&lt;&#x3D;ID&lt;&#x3D;end的关系）。</p>
<p>xrange命令可以在如下场景中使用。</p>
<ul>
<li>按时间范围返回元素，因为ID可以以时间为值进行排序。</li>
<li>如果流中存储的元素数量比较多，可以采用COUNT参数实现增量迭代，类似scan命令。</li>
<li>返回单个元素。</li>
</ul>
<p>与xrange命令对应有一个倒序命令xrevrange，以相反的顺序返回元素，除了返回顺序相反以外，它们在功能上是完全相同的。</p>
</li>
<li><p>xrevrange命令</p>
<p>使用格式 如下：</p>
<blockquote>
<p>xrevrange key end start [COUNT count]</p>
</blockquote>
<p>该命令用于按ID范围倒序返回元素（包括end和start值，属于end&lt;&#x3D;ID&lt;&#x3D;start的关系）。</p>
</li>
<li><p>xread命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>xread [COUNT count] [BLOCK milleseconds] STREAMS key [key …] id [id …]</p>
</blockquote>
<p>该命令用于读取流中比指定ID值大的元素（属于大于关系）。</p>
<p>xrange命令和xrevrange只能从一个流中读取元素，而xread命令支持从多个流中读取元素，还支持阻塞与非阻塞的操作。</p>
<p>xread命令还具有阻塞功能，和Pub&#x2F;Sub模式或者阻塞队列动能非常相似，但却有本质上的不同。</p>
<ul>
<li>xread可以有多个消费者以阻塞的方式一同监听新的元素。如果有新的元素到达，xread则把新的元素分发到不同的消费者，每个消费者接收的元素是相同的，和Pub&#x2F;Sub模式的效果是一样的；但和阻塞队列不同，使用阻塞队列的消费者接收的元素是不相同的。</li>
<li>Pub&#x2F;Sub模式和阻塞队列中的元素是瞬时的，元素被消费完毕后立即删除，并不保存，而流中的元素会一直保存，除非手动删除。不同的消费者通过接收的最后一个ID与服务器进行对比，从而知道哪些元素是最新的。</li>
<li>Stream数据类型提供消费者组的概念，更细化地控制流中元素地处理。</li>
</ul>
<p>符号“$”表示使用流已经存储地最大值ID作为最后一个ID值，让消费者仅接收从开始监听地那个时间以后地消息。示例如下：</p>
<blockquote>
<p>xread block 0 stream key1 $</p>
</blockquote>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; xread streams key1 0-0<br>1) 1) <span class="hljs-string">&quot;key1&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1648293296729-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;a&quot;</span><br>            2) <span class="hljs-string">&quot;aa&quot;</span><br>            3) <span class="hljs-string">&quot;b&quot;</span><br>            4) <span class="hljs-string">&quot;bb&quot;</span><br>            5) <span class="hljs-string">&quot;c&quot;</span><br>            6) <span class="hljs-string">&quot;cc&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>


</li>
<li><p>xtrim命令</p>
<p>使用格式如下：</p>
<blockquote>
<p>xtrim key maxlen [~] count</p>
</blockquote>
<p>该命令限制地长度为count。</p>
<p>参数maxlen [~] count 支持绝对count长度和近似count长度，与xadd命令地maxlen参数一模一样，会保留最新地元素。</p>
</li>
<li><p>消费者组的使用</p>
<p>前文使用xread命令实现了对流中消息的阻塞监听功能。如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706537.png" srcset="/img/loading.gif" lazyload alt="image-20220326204331197"></p>
</li>
</ul>
<p>消费者1<del>3同时在监听流中是否有最新的消息，当生产者1</del>5对流中的消息执行添加操作时，消费者1<del>3就会收到生产者1</del>5添加的消息。</p>
<p>除了流中的消息可以持久保存外，使用xread命令结合阻塞功能所实现的效果和Pub&#x2F;Sub模式别无两样，基本相同。</p>
<p>xread命令和Pub&#x2F;Sub模式都有消息的生产者&#x2F;发布者（简称生产者）和消费者&#x2F;订阅者（简称消费者），同组消费者处理的是一样的。但是在某些情况下，想要实现的不是向多个消费者提供相同的消息，而是向不同的消费者传递不同的消息，通过将不同的消息传递到不同的消费者来模拟负载均衡的效果，将计算机资源更高效地利用。如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706538.png" srcset="/img/loading.gif" lazyload alt="image-20220326205016144"></p>
<p>消费者组就像一个”伪消费者“，从流中为多个消费者获取消息，消费者组提供如下5点保证。</p>
<ul>
<li>将一条消息提供给唯一的消费者，消费者和消息之间是一对一的关系，不同的消费者接收的消息不同，不会将同一份消息传递给多个消费者。</li>
<li>消费者在消费者组中通过唯一名称来识别。</li>
<li>当消费者请求新消息时，消费者组提供消费者以前从未收到的消息。</li>
<li>消费消息后需要使用xack命令进行显示确认，表示这条消息已经被正确处理了，可以从消费者组中删除，之所以要有ACK确认机制，是因为万一在消费消息时出现宕机、掉电等情况造成消息丢失，只有消息消费完毕才会对其进行确认，将其从消费者组中删除。</li>
<li>消费者组监控当前所有”待确认“的消息，也就是消息已经被传递到消费者，但消费者还没有对消息进行消费确认，消费者组中这样的消息就是待确认消息。每个消费者只能看到传递给它的消息。</li>
</ul>
<p>使用消费者组实现消息消费需要3个命令。</p>
<ul>
<li>xgroup：用于创建、删除或者管理消费者组。</li>
<li>xreadgroup：用于通过消费者组从一个流中读取消息。</li>
<li>xack：允许消费者将待确认消息标记为已确认。</li>
</ul>
<p>于消费者组有关的命令</p>
<ul>
<li><p>xgroup命令的使用格式如下：</p>
<blockquote>
<p>xgroup [create key groupname id-or-$] [setid key groupname id-or-$] [destroy key groupname] [delconsumer key groupname consumername]</p>
</blockquote>
<p>xgroup命令主要有如下4个参数。</p>
<ul>
<li>参数setid key groupname id-or-$：将消费者组中最后的ID值设置为其他值。</li>
<li>参数create key groupname id-or-$：创建消费者组。</li>
<li>参数destroy key groupname：删除消费者组。</li>
<li>参数delconsumer key groupname consumername：从消费者组中删除指定的消费者。</li>
</ul>
<p>xreadgroup命令的使用格式如下：</p>
<blockquote>
<p>xreadgroup group group consumer [count count] [block milliseconds] [noack] streams key [key …] ID [ID …]</p>
</blockquote>
<p>xreadgroup命令的作用是从消费者组中读取消息，将消息存储在”待处理条目列表（Pending Entry List,PEL）“中，并且支持阻塞模式。</p>
<ul>
<li>参数group：监听消费者组的名称。</li>
<li>参数consumer：设置消费者的唯一名称。</li>
<li>参数noack：不需要ACK机制。</li>
</ul>
<p>xinfo命令的使用格式如下：</p>
<blockquote>
<p>xinfo [consumers key groupname] [groups key] [stream key] [help]</p>
</blockquote>
<p>xinfo命令主要有4个参数。</p>
<ul>
<li>参数consumers key groupname：查看消费者相关的信息。</li>
<li>参数groups key：查看key对应消费者组相关的信息。</li>
<li>参数stream key：查看流相关的信息。</li>
<li>参数help：查看命令文档说明。</li>
</ul>
<p>xack命令的使用格式如下：</p>
<blockquote>
<p>xack key group ID [ID …]</p>
</blockquote>
<p>xack命令的作用是对消费者组中的待确认的消息进行确认。待确认的消息存储在待处理条目列表中。</p>
<p>xpending命令的使用分时如下：</p>
<blockquote>
<p>xpending key group [start end count] [consumer]</p>
</blockquote>
<p>xpending命令的作用是查看待处理条目列表的中的消息。</p>
<p>xclaim命令的使用格式如下：</p>
<blockquote>
<p>xclaim key group consumer min-idle-time ID [ID …] [idle ms] [time ms-unix-time] [retrycount count] [force] [justid]</p>
</blockquote>
<p>xlaim命令的作用是改变处理消息的消费者。</p>
<p>当使用xgroup create 命令创建一个消费者之后，消费者组会维护至少3个主要的数据。</p>
<ul>
<li><p>该消费者组下有哪些消费者。</p>
</li>
<li><p>创建一个队列，用于存储处于待确认状态的消息。</p>
</li>
<li><p>当前消费者组最后发送消息的ID。</p>
<p>当使用xreadgroup命令成功读取消息时，会把当前消费者关联到消费者组中；把读取到的消息存储在待确认队列中；将最后发送的消息ID设置为消费者组最后发送消息的ID。</p>
</li>
</ul>
</li>
<li><p>在xreadgroup命令中使用&gt;或指定ID值。</p>
<ul>
<li>&gt;:代表从消费者组中读取从未被其他消费者消费的消息，会更新消费者组最后发送消息的ID值。</li>
<li>指定ID值：从待处理消息队列中读取消息。</li>
</ul>
</li>
<li><p>xgroup create mykey1 mygroup1 ID mkstream 命令中的”ID“代表消费者组从Stream中读取消息的起始ID。</p>
</li>
<li><p>xreadgroup group mygroup1 myconsumer1 block 0 streams mykey1 &gt;命令中的”&gt;“代表从消费者组中读取从未被其他消费者消息的消息，会更新消费者组最后发送消息的ID。</p>
</li>
<li><p>xreadgroup group mygroup1 myconsumer block 0 streams mykey1 ID 命令中的”ID“代表从待处理消息队列中读取消息。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; xgroup create mykey1 mygroup1 $ mkstream<br>OK<br>127.0.0.1:6379&gt; xreadgroup group mygroup1 myconsumer1 block 0 streams mykey1 &gt;<br>1) 1) <span class="hljs-string">&quot;mykey1&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;a&quot;</span><br>            2) <span class="hljs-string">&quot;aa&quot;</span><br>            3) <span class="hljs-string">&quot;b&quot;</span><br>            4) <span class="hljs-string">&quot;bb&quot;</span><br>            5) <span class="hljs-string">&quot;c&quot;</span><br>            6) <span class="hljs-string">&quot;cc&quot;</span><br>(22.49s)<br>127.0.0.1:6379&gt; xreadgroup group mygroup1 myconsumer1 block 0 streams mykey1 &gt;<br>1) 1) <span class="hljs-string">&quot;mykey1&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;2-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;a&quot;</span><br>            2) <span class="hljs-string">&quot;aa&quot;</span><br>            3) <span class="hljs-string">&quot;b&quot;</span><br>            4) <span class="hljs-string">&quot;bb&quot;</span><br>            5) <span class="hljs-string">&quot;c&quot;</span><br>            6) <span class="hljs-string">&quot;cc&quot;</span><br>(17.67s)<br>127.0.0.1:6379&gt; xinfo <span class="hljs-built_in">groups</span> mykey1<br>1) 1) <span class="hljs-string">&quot;name&quot;</span><br>   2) <span class="hljs-string">&quot;mygroup1&quot;</span><br>   3) <span class="hljs-string">&quot;consumers&quot;</span><br>   4) (<span class="hljs-built_in">integer</span>) 1<br>   5) <span class="hljs-string">&quot;pending&quot;</span><br>   6) (<span class="hljs-built_in">integer</span>) 2<br>   7) <span class="hljs-string">&quot;last-delivered-id&quot;</span><br>   8) <span class="hljs-string">&quot;2-0&quot;</span><br>127.0.0.1:6379&gt; xpending mykey1 mygroup1<br>1) (<span class="hljs-built_in">integer</span>) 2<br>2) <span class="hljs-string">&quot;1-0&quot;</span><br>3) <span class="hljs-string">&quot;2-0&quot;</span><br>4) 1) 1) <span class="hljs-string">&quot;myconsumer1&quot;</span><br>      2) <span class="hljs-string">&quot;2&quot;</span><br>127.0.0.1:6379&gt; xpending mykey1 mygroup1 - + 100<br>1) 1) <span class="hljs-string">&quot;1-0&quot;</span><br>   2) <span class="hljs-string">&quot;myconsumer1&quot;</span><br>   3) (<span class="hljs-built_in">integer</span>) 170386<br>   4) (<span class="hljs-built_in">integer</span>) 1<br>2) 1) <span class="hljs-string">&quot;2-0&quot;</span><br>   2) <span class="hljs-string">&quot;myconsumer1&quot;</span><br>   3) (<span class="hljs-built_in">integer</span>) 106914<br>   4) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; xack mykey1 mygroup1 1<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; xpending mykey1 mygroup1 - + 100 myconsumer1<br>1) 1) <span class="hljs-string">&quot;2-0&quot;</span><br>   2) <span class="hljs-string">&quot;myconsumer1&quot;</span><br>   3) (<span class="hljs-built_in">integer</span>) 149483<br>   4) (<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; xack mykey1 mygroup1 2<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; xpending mykey1 mygroup1 - + 100 myconsumer1<br>(empty array)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>



<ul>
<li><p>xclaim命令</p>
<p>该命令用于实现消息认领。</p>
<p>消息为什么要被认领呢？假设有一个消费者组，其中有两个消费者A和B，当消费者A从消费者组中获取消息后进行处理时，由于意外断电，导致消费者A处理消息的过程被中断。并且消费者A的服务器不能恢复，因此在待确认队列中会保存消费者A未被确认的消息，这些消息将占用服务器内存资源。可以将待确认队列中的消息有消费者B进行处理，xlcaim命令就是实现这个功能，也就是消息认领。</p>
</li>
<li><p>Stream数据类型与其他Redis数据类型有一个不同的地方在于：当其他数据类型中没有元素的时候，在内部会自动调用删除命令把key删除。如当调用ZREM命令时，会将Sorted Set数据类型中的最后一个元素删除，这个Sorted Set 数据类型也就彻底删除。但是Stream数据类型允许在内部没有元素的情况下key仍然存在，这样设计的原因是Stream数据类型可能和消费者进行关联，在实际场景中不希望由于Stream数据类型中没有元素而自动删除，导致消费者组的信息丢失。</p>
</li>
</ul>
<h2 id="Pipelining和Transaction类型命令"><a href="#Pipelining和Transaction类型命令" class="headerlink" title="Pipelining和Transaction类型命令"></a>Pipelining和Transaction类型命令</h2><p>流水线（Pipelining)可以实现批量发送多个命令到服务器，提高程序运行效率。</p>
<p>事务（Transaction）可以保证服务器批量执行多个命令，这些命令是一体的，具有原子性，但Redis并没有完整的ACID特性。</p>
<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>流水线可以实现批量发送多个命令到服务器，提高程序运行效率。流水线是在客户端实现的，和服务器无关。</p>
<p>Redis中提供的流水线类似JDBC中的Bath技术。如果不用流水线或Batch技术，向服务器发送10条命令，会有10次请求和响应的过程，每一次的请求和响应的用时被称为往返时间（Round Trip Time，RTT）。由于Redis是单线程的，因此每一次的请求和响应都是按顺序执行的，会产生10次RTT，执行速度慢。当使用Pipelining或Batch技术时，一次打包发送10个命令到服务器，只需要一次请求和响应过程，提高了程序的运行效率。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>RDBMS中的事务是指一系列操作步骤完全地执行或完全不执行，具有回滚地特性。</p>
<p>但Redis中地事务是指一组Command命令（至少是两个或两个以上的命令）。Redis事务保证这些命令被执行时不会被任何其他操作打断，这和RDBMS中的事务完全不同。</p>
<p>Redis没有回滚。</p>
<p>Redis中的事务既然不能回滚，那么它的主要作用是什么呢？它的主要作用是保证 multi 命令和 exec命令之间的命令是原子性的、不可拆分的。其他命令必须在事务执行完毕之后才可以执行，所以其他命令看到的是事务提交之后最终的运行结果，而不是一个“半成品”。因为事务中存在n条命令，所以只有这n条命令执行完毕之后才可以执行其他命令。</p>
<p>事务开启的时候创建命令队列，把执行的命令放入队列中，事务接收到exec命令后就将命令队列中的命令一次性执行，中途不能被打断，具有原子性。</p>
<p>Redis通过multi、exec、watch等命令来实现事务功能。事务提供了一种将多条命令进行打包，然后一次性、按顺序执行多条命令的机制，并且在事务执行期间，服务器不会中断事务而去执行其他客户端的命令，会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令。一个事务从开始到结束通常会经历如下3个阶段。</p>
<ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h5 id="multi和exec命令"><a href="#multi和exec命令" class="headerlink" title="multi和exec命令"></a>multi和exec命令</h5><p>multi命令的使用格式如下：</p>
<blockquote>
<p>multi</p>
</blockquote>
<p>该命令用于标记一个事务块的开始，事务内的多条命令会按照先后顺序放入一个事务命令队列当中，未来在执行exec命令时作为一个原子性命令被整体执行。</p>
<p>exec命令的使用格式如下：</p>
<blockquote>
<p>exec</p>
</blockquote>
<p>该命令用于执行事务中所有在事务命令队列中等待的命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> a aa<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> b bb<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> c cc<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) OK<br>2) OK<br>3) OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>3) <span class="hljs-string">&quot;c&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<h5 id="discard命令"><a href="#discard命令" class="headerlink" title="discard命令"></a>discard命令</h5><p>discard命令的使用格式如下：</p>
<blockquote>
<p>discard</p>
</blockquote>
<p>该命令用于取消一个事务中所有在事务命令队列中等待的命令，也就是取消事务，放弃执行事务块内的所有命令。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> a aa<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> b bb<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> c cc<br>QUEUED<br>127.0.0.1:6379(TX)&gt; discard<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>(error) ERR EXEC without MULTI<br>127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>执行了discard命令取消事务之后再执行exec命令出现了异常，因为没有事务环境了。</p>
<h5 id="watch命令"><a href="#watch命令" class="headerlink" title="watch命令"></a>watch命令</h5><p>使用格式如下：</p>
<blockquote>
<p>watch key [key ..]</p>
</blockquote>
<p>该命令用于监视指定的key来实现乐观锁。</p>
<p>什么是乐观锁？乐观锁是一种并发控制的方法，在提交数据更新之前，事务会先检查在该事务读取数据后，是否有其他事务修改了该数据，如果其他事务修改了数据的话，正在提交的事务会被取消。如果两个人同时要对第3个人实现转账操作，为了实现金额的累加，可以使用乐观锁。</p>
<p>Redis中watch的机制原理：使用watch命令监视一个或多个key，跟踪key的value修改情况，如果某个key的value在事务执行之前被修改了，那么整个事务被取消，返回提示信息，内容是事务已经失败。watch机制使事务执行变得有条件，事务只有在key没有被修改的前提下才能成功执行提交操作，如果不满足条件，事务被取消。乐观锁能够很好地解决数据冲突地问题。一句话总结：只要value被修改了，就取消事务的执行。</p>
<p>使用watch命令监视一个带TTL的key，那么即使这个key超时了，事务仍然可以正常执行。</p>
<p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; keys *<br>(empty array)<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a aa<br>OK<br>127.0.0.1:6379&gt; watch a<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> b bb<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">set</span> a AA<br>QUEUED<br>127.0.0.1:6379(TX)&gt; <span class="hljs-built_in">exec</span><br>1) OK<br>2) OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;b&quot;</span><br>2) <span class="hljs-string">&quot;a&quot;</span><br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>这里value如果被修改了，更新事务就取消了。</p>
<p>何时取消key的监视？</p>
<ul>
<li>watch命令可以被调用多次，对key的监视从watch命令执行之后开始生效，直到调用exec命令为止。不管事务是否执行成功，对所有key的监视都会被取消。</li>
<li>当客户端断开连接时，该客户端对key的监视也会被取消。</li>
<li>unwatch命令可以手动取消对所有key的监视。</li>
<li>调用discard命令时，如果已使用watch命令，则discard命令将释放所有被监视的key。</li>
</ul>
<h5 id="unwatch命令"><a href="#unwatch命令" class="headerlink" title="unwatch命令"></a>unwatch命令</h5><p>使用格式如下：</p>
<blockquote>
<p>unwatch</p>
</blockquote>
<p>该命令用于取消watch命令所有key的监视。在执行watch命令之后，如果exec命令或discard命令先被执行了的话，就不需要手动执行unwatch命令了。</p>
<p>事务之内执行unwatch命令是无效的。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis中的数据默认存储在内存中的，因此断电或死机等不可抗的原因造成数据丢失是非常严重的后果。Redis支持将内存中的数据持久化到硬盘中，实现数据的持久化（Persistence)。</p>
<p>Redis实现数据持久化有3种方式，便于发生故障后能迅速恢复数据。</p>
<ul>
<li><p>Redis数据库（Redis DataBase,RDB）:RDB持久化数据其实就是持久化内存的快照，将内存种的数据整体持久化到硬盘上的二进制RDB文件中，相当于全量持久化。RDB方式持久化数据非常的占用内存，如果内存中待持久化的数据大小为4GB，则至少要有4GB的空闲内存作为数据持久化的交换空间，所以需要的总内存大小就是8GB。Redis默认启用RDB。</p>
</li>
<li><p>扩展文件（Append-Only File，AOF）：相当于增量持久化，把对Redis操作的命令保存进AOF文件中，重启Reids服务器时再从AOF文件中执行相应命令，实现还原数据的效果。当RDB文件和AOF文件同时存在时，优先加载AOF文件。</p>
<p>RDB和AOF区别如下：</p>
<p>AOF会把每一次写数据库的命令都同步到AOF文件中，AOF文件中的命令与内存中的数据一 一对应。</p>
<p>RDB只把当前内存中的数据存放到RDB文件中，当对Redis文件中的数据再次修改时，只将内存中的数据进行修改，变成新数据，而RDB文件中的数据依然是旧的。</p>
</li>
<li><p>RDB和AOF混合：Redis4.0之后支持此种方式，也就是现在Redis版本默认启用的。</p>
</li>
</ul>
<h5 id="使用RDB实现数据持久化"><a href="#使用RDB实现数据持久化" class="headerlink" title="使用RDB实现数据持久化"></a>使用RDB实现数据持久化</h5><p>使用RDB实现数据持久化可以有3种方式。</p>
<ul>
<li>save配置选项：达到某一条件时执行数据持久化，自动方式。</li>
<li>SAVE命令：同步执行数据持久化，手动方式。</li>
<li>BGSAVE命令：异步执行数据持久化，手动方式。</li>
</ul>
<h5 id="自动方式：save配置选项"><a href="#自动方式：save配置选项" class="headerlink" title="自动方式：save配置选项"></a>自动方式：save配置选项</h5><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706539.png" srcset="/img/loading.gif" lazyload alt="image-20220327134831375"></p>
<p>上面配置save&lt;seconds&gt;&lt;changes&gt;的作用是指在指定的seconds时间内，如果对各个数据库总共发生了changes次更改，就调用bgsave命令把当前内存中的数据以rdbcompression yes压缩的方式存储到路径 dir .&#x2F;、文件名为dbfilename dump.rdb的文件中进行持久化。</p>
<ul>
<li>.&#x2F;：代表当前路径。</li>
<li>save 3600 1 代表3600s时间内有一次更改就开始RDB持久化。</li>
<li>save 300 100 代表300s时间内有100次更改就开始RDB持久化。</li>
<li>save 60 10000 代表60s时间内有1000次更改就开始RDB持久化。</li>
</ul>
<p>设置save配置选项时，seconds、changes这两个参数需要根据业务需求来确定，设置时间太短虽然可以减少数据丢失的量，但浪费CPU资源，而设置时间太长虽然节省了CPU资源。但会出现数据大量丢失的情况。</p>
<h5 id="手动方式：使用save命令"><a href="#手动方式：使用save命令" class="headerlink" title="手动方式：使用save命令"></a>手动方式：使用save命令</h5><p>save命令具有同步性，当命令执行后Redis呈阻塞状态，会把内存中全部数据库的全部数据保存到新的RDB文件中。</p>
<p>持久化数据期间Redis呈现阻塞状态，不在执行客户端命令，知道生成RDB文件为止。持久化结束后删除旧的RDB文件，使用新的RDB文件。</p>
<h5 id="使用save命令"><a href="#使用save命令" class="headerlink" title="使用save命令"></a>使用save命令</h5><p><strong>测试案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> 1 11<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> 2 22 <br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> 3 33<br>OK<br>127.0.0.1:6379&gt; save<br>OK<br>127.0.0.1:6379&gt; <br><span class="hljs-comment">#在执行save命令之前没有dump.rdb文件，执行之后就创建它。</span><br></code></pre></td></tr></table></figure>

<h5 id="手动方式：使用bgsave命令"><a href="#手动方式：使用bgsave命令" class="headerlink" title="手动方式：使用bgsave命令"></a>手动方式：使用bgsave命令</h5><p>save命令具有同步性，在数据持久化期间，Redis不能执行其他客户端的命令，这降低了系统吞吐量，而bgsave命令是save命令的异步版本。</p>
<p>当bgsave命令执行后会创建子进程，子进程执行save命令把内存中全部数据库的全部数据保存到新的RDB文件中。持久化数据期间，Redis不呈现阻塞状态，可以接收新的命令。持久化结束后删除旧的RDB文件，使用新的RDB文件。</p>
<p>bgsave命令和save命令一样，也存在丢失数据的可能性，也就是在最后一次成功完成RDB持久化后的数据将会丢失。</p>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>RDB的优点：使用RDB文件直接存储二进制数据，所以恢复数据比AOF速度快。</p>
<p>RDB的缺点如下：</p>
<ul>
<li>可能会丢失数据。丢失最后一次持久化以后更改的数据。如果应用能容忍一定程序的数据丢失，那么使用RDB是不错的选择；如果不能容忍一定程序的数据丢失，那么使用RDB就不是一个很好的选择。</li>
<li>使用bgsave命令持久化数据时会创建一个新的子进程，如果Redis的数据量很大，那么子进程会占用比较多的CPU资源，并且在获取内存快照时会将Redis服务器停一段时间（毫秒级别）。如果数据量非常大而且硬件配置较差，可能出现暂停数秒的情况。</li>
</ul>
<h5 id="使用AOF实现数据持久化"><a href="#使用AOF实现数据持久化" class="headerlink" title="使用AOF实现数据持久化"></a>使用AOF实现数据持久化</h5><p>使用AOF持久化数据时，Redis每次接收一条更改数据的命令时，都将把该命令写到一个AOF文件中（只记录写操作，读操作不记录）。当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。AOF的有点是比RDB丢失的数据少一些。另外，由于AOF文件存储Redis的命令，而不像RDB文件存储数据二进制，因此使用AOF还原数据时比RDB要慢很多。</p>
<p><strong>测试案例</strong></p>
<p>更改redis.conf配置文件，禁止RDB，只用AOF实现数据持久化。</p>
<p>在redis.cong配置文件中的“APPEND　ONLY　MODE”节点下有AOF的相关配置</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706540.png" srcset="/img/loading.gif" lazyload alt="image-20220327141815684"></p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706541.png" srcset="/img/loading.gif" lazyload alt="image-20220327141847208"></p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706542.png" srcset="/img/loading.gif" lazyload alt="image-20220327141922120"></p>
<p>将配置appendonly no 改为appendonly yes，因为默认情况下AOF方式是不启用的。</p>
<p>配置appendfilename “apendonly.aof”指定使用哪个 AOF文件来存储命令。将配置aof-use-rdb-preamble yes改成 aof-use-rdb-preamble no,因为默认情况下采用RDB和AOF混合方式，使用no值后只使用AOF方式。</p>
<p>如果存在dump,rdb文件或aooendonly,aof文件则删除。重启Redis服务器。</p>
<h6 id="存在数据丢失的可能性"><a href="#存在数据丢失的可能性" class="headerlink" title="存在数据丢失的可能性"></a>存在数据丢失的可能性</h6><p>向AOF文件同步命令是对AOF文件的写操作，现代操作系统为了提高写操作的效率，会将多次写操作最终转化成一次写操作。原理就是将多次写入的数据放入缓存区中，达到某个写入的条件时一次性将数据写入硬盘中，提高程序运行的效率，而选项appendfsync的作用就是配置向AOF文件执行写入命令的方式，Redis提供3中方式。</p>
<ul>
<li>no：不主动进行同步操作，而是完全交由操作系用来做。比较快但不是很安全，会丢失最后一次写操作之后所有的写入命令。</li>
<li>always：每次执行写入命令都会同步到AOF文件中。此种方式比较慢，但是比较安全，在生产环境下不建议使用。</li>
<li>everysec：每秒执行一次同步操作。此种方式比较平衡，由于兼顾性能和安全，因此是默认选项，也是推荐使用的选项。它会丢失最后一秒未持久化的数据。</li>
</ul>
<h5 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h5><p>前面的AOF文件中保存着大量操作Redis的命令，其中就包括del命令。其实在还原数据时只需要set a aa和set b bb命令，从原始数据效率上的考虑出发，set c cc和del c命令可以从AOF文件中删除，那么就有必要让Redis服务器重启时读取最精简版的AOF文件，没有其他多余的命令，也就是要把多余的命令过滤删除。这时就要创建最精简版的AOF文件，此过程在Redis中被称为“AOF”文件重写机制。</p>
<p>重写机制可以将多个命令缩写成一个，还可以对超时的数据不再恢复。重写机制的原理是开启新的进程，新的进程不读取旧版的AOF文件，而是直接把内存中的数据转化成最新版的AOF文件，完成后再对旧版AOF文件按进行覆盖，达到了AOF文件内容的精简。</p>
<p><strong>手动方式实现重写机制案例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; bgrewriteAOF<br>Background append only file rewriting started<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p><strong>自动方式实现重写机制</strong></p>
<p>redis.conf配置文件中的选项auto-AOF-rewrite-min-size的作用是设置重写的最小AOF文件的大小，默认是64MB。当AOF文件大小大于64MB时，开始重写AOF。目标是缩小AOF文件的大小。</p>
<p>redis.conf配置文件中的选项auto-AOF-rewrite-oercentage 100的作用是设置文件大小增大多少比例触发重写。该选项表示当前AOF文件的大小比最后一次执行AOF重写后增加了一倍（100%），则触发重写。</p>
<h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>AOF和RDB同时开启，并且存在AOF文件时，优先加载AOF文件。</p>
<p>AOF关闭或者没有AOF文件时，加载RDB文件。</p>
<p>AOF是另一个数据持久化的方案。AOF文件会在操作过程中变得越来越大，因为有很多命令是无用的，如查询命令，但Redis支持在不影响服务的前提下在后台重写AOF文件，让AOF文件得以变小。</p>
<p>AOF的优点是丢失的数据在理论上比RDB少，允许丢失最后1s内的数据。</p>
<p>AOF的缺点如下：</p>
<ul>
<li>由于AOF文件存储的是写命令，因此文件大小较大。</li>
<li>由于RDB文件存储的是二进制的数据，因此恢复数据比AOF要快。AOF恢复数据慢。</li>
</ul>
<p>RDB会在满足某个save配置条件时自动持久化，而AOF是根据appendfsync配置自动持久化。</p>
<p>RDB和AOF都有优缺点，可以两者结合使用，互相弥补。</p>
<h5 id="使用RDB和AOF混合实现数据持久化"><a href="#使用RDB和AOF混合实现数据持久化" class="headerlink" title="使用RDB和AOF混合实现数据持久化"></a>使用RDB和AOF混合实现数据持久化</h5><p>使用RDB和AOF混合实现数据持久化时，会在AOF文件的开头保存RDB格式的数据，然后保存AOF格式的命令。</p>
<h5 id="使用shutdown命令正确停止Redis服务"><a href="#使用shutdown命令正确停止Redis服务" class="headerlink" title="使用shutdown命令正确停止Redis服务"></a>使用shutdown命令正确停止Redis服务</h5><p>正确停止Redis服务要使用shutdown命令，该命令执行后将执行接收新的请求，并且开始执行持久化操作，完成后销毁Redis进程。</p>
<p>不要暴力地销毁Redis进程，这样做会丢失数据。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>新版本地Redis已经将复制(Replication) 架构地名称由原来的主-从(Master-Slave)，改未主-副本(Master-Replica)，所以Slave和Replica在Redis中是一样的。</p>
<p>Redis可以对相同的数据创建多个副本，这些副本数据存放在其他服务器中，这样在数据恢复、负载均衡、读写分离等场景中非常有利。</p>
<p>一个Master服务器作为主节点可以有多个Replica服务器作为副本节点，但每个副本节点只能有一个主节点，Master架构类似于树形结构。如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706543.png" srcset="/img/loading.gif" lazyload alt="image-20220327151024210"></p>
<p>在一主多副本的架构中，默认情况下可以对Master服务器执行读写操作，而对Replica服务器执行查询、读取的操作，这就是经典的“读写分离”方案。Replica服务器越多，读的性能就越好，因为相同的数据分散在不同Replica服务器上，减轻了每台Peplica服务器的读的压力。</p>
<p>Master服务器对Replica服务器进行数据传输时是非阻塞的，代表Master服务器可以一边传输数据给Replica服务器，一边执行客户端发送过来的读写命令。Replica服务器在接收数据期间也是非阻塞的，可以一边接收数据一边执行其他客户端发送过来的读的请求。</p>
<p>默认情况下，Replica服务器只可以执行读操作，但可以对Replica服务器开放写权限。但建议不要这样做，如果Master服务器和Replica服务器恰好有相同的Key,则Master服务器的数据会把Replica服务器中的数据覆盖。如果对key的命名有好的规划，那么可以这样做。</p>
<p>有些情况下必须对Replica服务器开放写权限，如Replica服务器中执行类似ZINTERSTORE统计命令时，建议对key设置TTL，超时后自动删除。对Replica服务器开放写权限需要在redis.conf配置文件中使用配置replica-read-only&#x3D;no。</p>
<p>当对主节点和副本节点进行关联时，Redis会将副本节点全部的数据进行清空，再对主节点执行写操作，主节点会将数据的变化同步到副本节点上。由于网络慢等原因，主节点和副本节点在某一时间会出现数据不一样的情况，如果要求数据强制一致性，客户端可以直接读取主节点，但在最后主节点和副本节点的数据会完全相同，实现最终一致性。</p>
<p>一主多副本架构的弊端比较明显，就是主节点需要承担更多的任务，如一个主节点在处理业务的同时还需要将数据发送给多个副本节点实现数据的复制，如果传输的数据量较大，很容易造成主节点发给副本节点数据时CPU占用率过高，还会产生网络拥堵，造成主节点性能下降，所以可以对主节点采用“多级级联”架构来疏散网络拥堵。所谓的多级级联就是副本节点再关联一个Replica副本节点，如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706544.png" srcset="/img/loading.gif" lazyload alt="image-20220327153221319"></p>
<p>副本节点Slave1关联了连个副本节点Slave2和Slave3，副本节点Slave1相当于副本节点Slave2和Slave3的主节点，副本节点Slave2和Slave3的数据由Slave1进行传输，Slavel的数据由主节点进行传输，主节点只负责一个节点的数据传输，而不是3个，所以多级级联架构减小了主节点的任务量。根据业务需求，多级级联架构可以继续级联。</p>
<p>复制数据时是由主节点向副本节点进行复制，反之则不支持。针对主节点的任何操作都会同步到副本节点。</p>
<h5 id="实现复制"><a href="#实现复制" class="headerlink" title="实现复制"></a>实现复制</h5><p>有3中方式可以实现Master-Replica的数据复制。</p>
<ul>
<li>在redis.conf配置文件中加入replicaof {masterHost} {masterPort}配置。</li>
<li>对redis-server命令传入–replicaof {masterHost} {masterPort}参数。</li>
<li>在副本节点中使用replicaof {masterHost} {masterPort} ,此种方式的优势是可以动态地创建复制连接。</li>
</ul>
<p>参数masterHost是主节点地IP地址，参数masterPort是主节点地端口号。</p>
<p>当主节点和副本节点连接上时，主节点会把全部地数据传输到副本节点中。</p>
<h5 id="取消复制"><a href="#取消复制" class="headerlink" title="取消复制"></a>取消复制</h5><p>取消复制就是将Replica服务器和Master服务器断开Master-Replica关联。</p>
<p>取消复制地方式就是在Replica服务器使用如下命令：</p>
<blockquote>
<p>replicaof no one</p>
</blockquote>
<h5 id="手动操作实现故障转移"><a href="#手动操作实现故障转移" class="headerlink" title="手动操作实现故障转移"></a>手动操作实现故障转移</h5><p>当Master服务器发生故障时，需要手动对其中一台Replica服务器使用命令replicaof no one将这个Replicca服务器与Master服务器断开关联，目的是将此Replica服务器提升为Master服务器，其他的Replica服务器需要手动执行命令replicaof ip port指向这个新的Master服务器，建立新的关联后开始同步数据。</p>
<p>Master-Replica复制架构的特点如下：</p>
<ul>
<li>一个Master服务器可以有多个Replica服务器。</li>
<li>Replica服务器下线，读请求的处理性能下降，因为Master服务器要同时处理读和写请求。</li>
<li>Master服务器下线，写请求无法执行。</li>
<li>在Master-Replica复制架构下，Master服务器A宕机，Replica服务器B还是Replica服务器，Master服务器A恢复运行时，Master-Replica复制架构恢复，又开始工作了。</li>
<li>当Replica服务器B宕机后，重启Replica服务器B时不使用任何的replicaof配置会将Replica服务器B变成另外一个独立的Master服务器C，这时可以在Master服务器C中使用replicaof命令设置Master服务器，将Master服务器C重新变成Replica服务器。</li>
<li>Master-Replica复制架构出现故障时需要手动操作，比较繁琐，也不利于运行稳定性，不保证能高可用，但可以使用Redis提供的哨兵功能在出现故障时自动化处理。</li>
</ul>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>如果有3台计算机A、B和C，在Master-Replica架构下，A是Master节点，B和C分别是Slave1和Slave2节点，Master-Replica架构如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706545.png" srcset="/img/loading.gif" lazyload alt="image-20220327163241822"></p>
<p>如果Master节点A由于故障不能提供服务，则需要下面4个步骤进行处理。</p>
<ul>
<li>在Slave1节点B处手动输入replicaof no one命令将Slave1节点B与Master节点A断开，目的是把Slave1节点B作为新的主节点。</li>
<li>更改Java代码，使用新的主节点B的IP地址。</li>
<li>在Slave2节点C处手动输入命令replicaof no one将Slave2节点C与Master节点A断开，并且执行命令replicaof ip port将C的主节点改成B。</li>
<li>重启A计算机后还需要使用replicaof ip port将A的主节点改成B。</li>
</ul>
<p>这一系列的手动操作大大减弱了软件的高可用性，极大地增加了运维成本，这种情况下可以使用Redis提供的哨兵（Sentinel）以自动化的方式来解决，哨兵是Redis实现高可用性的方案之一。</p>
<p>将不可用的服务器替换成可用的服务器，这种机制被称为故障转移。Redis中的哨兵可以实现自动故障转移。</p>
<p>哨兵是Redis官方提供的保障高可用性的方案，它使用心跳检测的方法来监控多个Redis实例的运行情况。当主节点出现故障时，哨兵能自动完成故障发现和故障转移，这些步骤都是自动化的，不需要手动处理，真正实现了高可用性。哨兵的系统架构如图</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706546.png" srcset="/img/loading.gif" lazyload alt="image-20220327165118684"></p>
<p>每个哨兵服务器（以下简称哨兵）一同监视Master节点、Slave1和Slave2节点，哨兵之间也是互相监视。</p>
<p>如上图中，若干个哨兵一直在监控一个主节点和两个副本节点，哨兵在一起“协商投票”后，确认主节点因为网络等原因出现了故障，并选举一个副本节点作为新的主节点，这个过程都是哨兵自动处理的，不需要人为的干预。</p>
<p>选举算法分为如下3步：</p>
<ul>
<li>优先级最高的Replica服务器获胜。优先级使用replica-priority 选项进行配置，默认是100，值越小优先级越高。</li>
<li>如果有两个Replica服务器的replica-priority 值一样，则复制数据的偏移量最大的的Replica服务器获胜。</li>
<li>如果复制数据的偏移量一致，则Redis服务器启动时被分配了一个小运行ID的Replica服务器获胜。</li>
</ul>
<p>建议将哨兵安装到不同的物理计算机上，这样如果有一个哨兵出现了故障，至少还有其他的哨兵在工作，另外使用多个哨兵可以防止误判。</p>
<p>哨兵具有如下的几个功能。</p>
<ul>
<li>监视：哨兵会监视Master服务器和Replica服务器以及其他的哨兵是否可达。</li>
<li>通知：哨兵会将故障转移的结果通知未Java客户端。</li>
<li>故障转移：实现Replica服务器升级为Master服务器，并且维护后续的Master-Replica关联。</li>
<li>入口提供者：Java客户端连接的是哨兵，通过哨兵来访问Master服务器。</li>
<li>不提供数据保存：哨兵只负责监视，不提供数据保存的服务。</li>
</ul>
<p>想要实现故障转移，至少需要有3个哨兵。</p>
<h5 id="搭建哨兵环境"><a href="#搭建哨兵环境" class="headerlink" title="搭建哨兵环境"></a>搭建哨兵环境</h5><p>可以使用两种方式启动哨兵。</p>
<ul>
<li>redis-sentinel sentinel.conf。</li>
<li>redis-server sentinel.conf –sentinel ,参数–sentinel代表启动的Redis服务器是具有监视功能的哨兵，不是普通的Redis服务。</li>
</ul>
<p>系统中只有一个哨兵可能会出现单点故障，唯一的哨兵出现故障后不能进行故障发现和故障转移，造成整体的Master-Replica环境失效。</p>
<h5 id="监视多个Master服务器"><a href="#监视多个Master服务器" class="headerlink" title="监视多个Master服务器"></a>监视多个Master服务器</h5><p>前面的哨兵只监视一个Master服务器，哨兵还可以监视多个Master服务器，监视多个Master服务器的架构如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706547.png" srcset="/img/loading.gif" lazyload alt="image-20220327171023428"></p>
<h5 id="哨兵常用命令"><a href="#哨兵常用命令" class="headerlink" title="哨兵常用命令"></a>哨兵常用命令</h5><p>测试哨兵常用命令：</p>
<blockquote>
<p>sentinel masters</p>
</blockquote>
<p>该命令的作用是显示所有主节点的信息。</p>
<blockquote>
<p>sentinel master &lt;master name&gt;</p>
</blockquote>
<p>该命令的作用是显示指定别名的主节点信息。</p>
<blockquote>
<p>sentinel slaves &lt;master name&gt;</p>
</blockquote>
<p>该命令的作用是显示指定别名节点下的所有副本节点相关信息。</p>
<blockquote>
<p>sentinel sentinels &lt;master name&gt;</p>
</blockquote>
<p>该命令的作用是显示指定别名主节点的哨兵节点集合，不包括当前的哨兵节点。</p>
<blockquote>
<p>sentinel get-master-addr-by-name &lt;master name&gt;</p>
</blockquote>
<p>该命令的作用是显示指定别名主节点的IP地址和端口号。</p>
<blockquote>
<p>sentinel reset &lt;pattern&gt;</p>
</blockquote>
<p>该命令的作用是对关联当前哨兵的主节点的配置和环境进行重置，包括清除主节点的相关信息，重新发现副本节点和哨兵节点。</p>
<blockquote>
<p>sentinel ckquorum &lt;master name&gt;</p>
</blockquote>
<p>该命令的作用是检查当前可达的哨兵节点总数是否到达quorum。如果quorom值是3，而当前可达的哨兵节点个数是为2，那么将无法进行故障转移。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群（Cluster)分为以下两种。</p>
<ul>
<li><p>高可用集群：使用Redis的哨兵和Master-Replica架构实现，一个Master节点可以有个Replica节点，每个Redis实例中的数据保持一致。如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706548.png" srcset="/img/loading.gif" lazyload alt="image-20220327173102407"></p>
</li>
<li><p>分布式集群：使用Redis Cluster实现，同时有多个Master节点，数据被分片存储在各个Master节点中 &#x3D;，平衡各个Master节点的压力，另外每个Master节点可以拥有多个Replica。如果使用Redis Cluster存储1~13个数字，则存储结构如下图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706549.png" srcset="/img/loading.gif" lazyload alt="image-20220327191110229"></p>
</li>
</ul>
<p>Redis集群是Redis分布式存储的解决方案，在3.0版本被推出，解决了前面版本只能以单机模式运行的缺点。Redis集群可以有效解决单机内存不够、并发量大、流量大等系统运行的瓶颈。</p>
<p>集群是为了将大量数据分散在不同的计算机中进行存储、每台计算机分别存储一部分数据，每台计算机参与处理请求，将高并发、大流量的场景进行分散，多台计算机的内存支持量会比单机的更大。</p>
<h5 id="使用虚拟槽实现数据分片"><a href="#使用虚拟槽实现数据分片" class="headerlink" title="使用虚拟槽实现数据分片"></a>使用虚拟槽实现数据分片</h5><p>Redis集群中的数据采用虚拟槽（Sloat）技术来对数据进行分片，实现分布存储，Redis中一共有16384个槽（0~16383，以下简称槽）。每个虚拟槽（简称槽）代表集群内数据管理和迁移的基本单位。</p>
<p>如存在5台运行Redis实例的服务器，每台服务器都拥有一个槽集合，则存在5个集合。而Redis一共有16384个槽，所以按业务的需要将这16384个槽按需分配给5台服务器，这样每台服务器就可以存储指定槽范围的数据了，槽集合与服务器对应关系如图：</p>
<p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202203310706550.png" srcset="/img/loading.gif" lazyload alt="image-20220328191038880"></p>
<h5 id="自动搭建本地Redis集群环境"><a href="#自动搭建本地Redis集群环境" class="headerlink" title="自动搭建本地Redis集群环境"></a>自动搭建本地Redis集群环境</h5><p>搭建Redis集群环境和搭建Master-Replica或哨兵环境一样，需要准备大量配置文件，但有些时候我们只是想在测试环境中快速把Redis集群环境搭建起来进行使用和测试，如果需要大量配置文件则会影响测试的效率，Redis提供了create-cluster命令来实现这样的需求，该命令在redis&#x2F;utils&#x2F;create-cluster路劲中，执行如下命令：</p>
<blockquote>
<p>.&#x2F;create-cluster</p>
</blockquote>
<p>执行成功有7个参数。参数作用如下：</p>
<ul>
<li>create-cluster start：启动Redis集群实例。</li>
<li>create-cluster create：创建Redis集群。</li>
<li>create-cluster stop：停止Redis集群实例。</li>
<li>create-cluster watch：显示第一个服务器的输出（前30行）。</li>
<li>create-cluster tail 1：查看日志信息（1代表第一个服务器）。</li>
<li>create-cluster clean：删除所有实例数据，日志和配置文件。</li>
<li>create-cluster clean-logs：只删除实例日志文件。</li>
</ul>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>内存淘汰策略有两种算法。</p>
<ul>
<li>LRU过时：删除很久没有访问的数据。</li>
<li>LFU过时：删除访问频率最低的数据。</li>
</ul>
<p>Redis支持的内存淘汰策略有如下8种。</p>
<ul>
<li>noeviction：不淘汰策略，存放的数据大于最大内存限制时返回异常。</li>
<li>volatile-lru：对超时的key使用LRU算法。</li>
<li>volatile-lfu：对超时的key使用LFU算法。</li>
<li>volatile-random：对超时的key使用随机删除策略。</li>
<li>volatile-ttl：对超时的key使用TTL最小值删除策略。</li>
<li>allkeys-lru：对所有key使用LRU算法。</li>
<li>allkeys-lfu：对所有key使用LFU算法。</li>
<li>allkeys-random：对所有key使用随机删除。</li>
</ul>
<p>改变内存淘汰策略可以对redis.conf配置文件的maxmemory-policy属性进行更改。</p>
<p>本章种的案例使用最大内存为1MB，在redis.conf配置文件种使用maxmemory 1mb 进行配置。</p>
<p>当需要设置大小时，单位不区分大小写，1GB、1Gb和1gB的作用一样。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/redis/" class="category-chain-item">redis</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/NoSQL/">#NoSQL</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis</div>
      <div>http://example.com/2022/09/07/NoSQL/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>liziyuan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月7日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/07/Netty01-nio/" title="Netty-nio">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Netty-nio</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/07/OSI%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%AF%8F%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82%E5%8D%8F%E8%AE%AE/" title="OSI体系结构各层对应功能与协议">
                        <span class="hidden-mobile">OSI体系结构各层对应功能与协议</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://venom-lemon.github.io/whitehmoob/" target="_blank" rel="nofollow noopener"><span>easy-nav</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
