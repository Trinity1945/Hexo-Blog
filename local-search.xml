<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL数据库优化</title>
    <link href="/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <url>/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h1><h2 id="1-添加索引"><a href="#1-添加索引" class="headerlink" title="1.添加索引"></a>1.添加索引</h2><p>很多时候，我们的慢查询，都是因为<strong>没有加索引</strong>。如果没有加索引的话，会导致全表扫描的。因此，应考虑在<code>where</code>的条件列，<strong>建立索引</strong>，尽量避免全表扫描。</p><h2 id="2-SQL-索引不生效"><a href="#2-SQL-索引不生效" class="headerlink" title="2.SQL 索引不生效"></a>2.SQL 索引不生效</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939541.png" alt="image-20220616193455553"></p><h3 id="2-1-隐式的类型转换，索引失效"><a href="#2-1-隐式的类型转换，索引失效" class="headerlink" title="2.1 隐式的类型转换，索引失效"></a>2.1 隐式的类型转换，索引失效</h3><p>我们创建一个用户user表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  userId <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  age  <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>  KEY idx_userid (userId) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p><code>userId</code>字段为<strong>字串类型</strong>，是B+树的普通索引，如果查询条件传了一个<strong>数字</strong>过去，会导致索引失效。如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939110.png" alt="图片"></p><p>如果给数字加上<code>&#39;&#39;</code>,也就是说，传的是一个字符串呢，<strong>当然是走索引</strong>，如下图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939411.png" alt="图片"></p><blockquote><p>为什么第一条语句<strong>未加单引号就不走索引</strong>了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做<strong>隐式的类型转换</strong>，把它们转换为浮点数再做比较。隐式的类型转换，索引会失效。</p></blockquote><h3 id="2-2-查询条件包含or，可能导致索引失效"><a href="#2-2-查询条件包含or，可能导致索引失效" class="headerlink" title="2.2 查询条件包含or，可能导致索引失效"></a>2.2 查询条件包含or，可能导致索引失效</h3><p>我们还是用这个表结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  userId <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  age  <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>  KEY idx_userid (userId) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>其中<code>userId</code>加了索引，但是<code>age</code>没有加索引的。我们使用了<code>or</code>，以下SQL是不走索引的，如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939390.png" alt="图片"></p><p>对于<code>or</code>+没有索引的<code>age</code>这种情况，假设它走了<code>userId</code>的索引，但是走到<code>age</code>查询条件时，它还得全表扫描，也就是需要三步过程：<strong>全表扫描+索引扫描+合并</strong>。如果它一开始就走<strong>全表扫描</strong>，直接一遍扫描就完事。Mysql优化器出于效率与成本考虑，遇到<code>or</code>条件，让索引失效，看起来也合情合理嘛。</p><p><strong>注意</strong>：如果<code>or</code>条件的列都加了索引，<strong>索引可能会走也可能不走</strong>，大家可以自己试一试哈。但是平时大家使用的时候，还是要注意一下这个<code>or</code>，学会用<code>explain</code>分析。遇到不走索引的时候，考虑拆开两条SQL。</p><h3 id="2-3-like通配符可能导致索引失效。"><a href="#2-3-like通配符可能导致索引失效。" class="headerlink" title="2.3. like通配符可能导致索引失效。"></a>2.3. like通配符可能导致索引失效。</h3><p>并不是用了<code>like</code>通配符，索引一定会失效，而是like查询是以<code>%</code>开头，才会导致索引失效。</p><p>like查询以<code>%</code>开头，索引失效</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939350.png" alt="图片"></p><p>把<code>%</code>放后面，发现索引还是正常走的，如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;123%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939116.png" alt="图片"></p><p>既然<code>like</code>查询以<code>%</code>开头，会导致索引失效。我们如何优化呢？</p><ul><li>使用覆盖索引</li><li>把<code>%</code>放后面</li></ul><h3 id="2-4-查询条件不满足联合索引的最左匹配原则"><a href="#2-4-查询条件不满足联合索引的最左匹配原则" class="headerlink" title="2.4 查询条件不满足联合索引的最左匹配原则"></a>2.4 查询条件不满足联合索引的最左匹配原则</h3><p>MySQl建立联合索引时，会遵循最左前缀匹配的原则，即最左优先。如果你建立一个<code>（a,b,c）</code>的联合索引，相当于建立了<code>(a)、(a,b)、(a,b,c)</code>三个索引。</p><p>假设有以下表结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  user_id <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  age  <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>  KEY idx_userid_name (user_id,<span class="hljs-type">name</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>有一个联合索引<code>idx_userid_name</code>，我们执行这个SQL，查询条件是<code>name</code>，索引是无效：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> =<span class="hljs-string">&#x27;捡田螺的小男孩&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为查询条件列<code>name</code>不是联合索引<code>idx_userid_name</code>中的第一个列，索引不生效</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939661.png" alt="图片"></p><p>在联合索引中，查询条件满足<strong>最左匹配原则</strong>时，索引才正常生效。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939697.png" alt="图片"></p><h3 id="2-5-在索引列上使用mysql的内置函数"><a href="#2-5-在索引列上使用mysql的内置函数" class="headerlink" title="2.5 在索引列上使用mysql的内置函数"></a>2.5 在索引列上使用mysql的内置函数</h3><p>表结构：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`userId`</span> varchar(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`login_time`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_userId`</span> (<span class="hljs-symbol">`userId`</span>) <span class="hljs-keyword">USING</span> BTREE,<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_login_time`</span> (<span class="hljs-symbol">`login_Time`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>虽然<code>login_time</code>加了索引，但是因为使用了<code>mysql</code>的内置函数<code>Date_ADD()</code>，索引直接GG，如图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939935.png" alt="图片"></p><p>一般这种情况怎么优化呢？可以把<strong>内置函数的逻辑转移到右边</strong>，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">explain</span>  select * from user where login_time = DATE_ADD(&#x27;<span class="hljs-number">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">22</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&#x27;,INTERVAL -<span class="hljs-number">1</span> DAY);<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939940.png" alt="图片"></p><h3 id="2-6-对索引进行列运算（如，-、-、-、-x2F-）-索引不生效"><a href="#2-6-对索引进行列运算（如，-、-、-、-x2F-）-索引不生效" class="headerlink" title="2.6 对索引进行列运算（如，+、-、*、&#x2F;）,索引不生效"></a>2.6 对索引进行列运算（如，+、-、*、&#x2F;）,索引不生效</h3><p>表结构：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`userId`</span> varchar(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_age`</span> (<span class="hljs-symbol">`age`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>虽然<code>age</code>加了索引，但是因为它进行运算，索引直接迷路了。。。如图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939032.png" alt="图片"></p><p>所以<strong>不可以对索引列进行运算，可以在代码处理好，再传参进去</strong>。</p><h3 id="2-7-索引字段上使用（！-x3D-或者-lt-gt-），索引可能失效"><a href="#2-7-索引字段上使用（！-x3D-或者-lt-gt-），索引可能失效" class="headerlink" title="2.7 索引字段上使用（！&#x3D; 或者 &lt; &gt;），索引可能失效"></a>2.7 索引字段上使用（！&#x3D; 或者 &lt; &gt;），索引可能失效</h3><p>表结构：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`userId`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_age`</span> (<span class="hljs-symbol">`age`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>虽然<code>age</code>加了索引，但是使用了<code>！= </code>或者<code>&lt; &gt;，not in</code>这些时，索引如同虚设。如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939223.png" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939226.png" alt="图片"></p><p>其实这个也是跟<code>mySQL优化器</code>有关，如果优化器觉得即使走了索引，还是需要扫描很多很多行的哈，它觉得不划算，<strong>不如直接不走索引</strong>。平时我们用<code>！= </code>或者<code>&lt; &gt;，not in</code>的时候，留点心眼哈。</p><h3 id="2-8-索引字段上使用is-null，-is-not-null，索引可能失效"><a href="#2-8-索引字段上使用is-null，-is-not-null，索引可能失效" class="headerlink" title="2.8 索引字段上使用is null， is not null，索引可能失效"></a>2.8 索引字段上使用is null， is not null，索引可能失效</h3><p>表结构:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`card`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_name`</span> (<span class="hljs-symbol">`name`</span>) <span class="hljs-keyword">USING</span> BTREE,<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_card`</span> (<span class="hljs-symbol">`card`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>单个<code>name</code>字段加上索引，并查询<code>name</code>为非空的语句，其实会走索引的，如下:</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939193.png" alt="图片"></p><p>单个<code>card</code>字段加上索引，并查询name为非空的语句，其实会走索引的，如下:<img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939847.png" alt="图片"></p><p>但是它两用or连接起来，索引就失效了，如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939037.png" alt="图片"></p><p>很多时候，也是因为数据量问题，导致了MySQL优化器放弃走索引。同时，平时我们用explain分析SQL的时候，如果<code>type=range</code>,要注意一下哈，因为这个可能因为数据量问题，导致索引无效。</p><h3 id="2-9-左右连接，关联的字段编码格式不一样"><a href="#2-9-左右连接，关联的字段编码格式不一样" class="headerlink" title="2.9 左右连接，关联的字段编码格式不一样"></a>2.9 左右连接，关联的字段编码格式不一样</h3><p>新建两个表，一个<code>user</code>，一个<code>user_job</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY `idx_name` (`<span class="hljs-type">name</span>`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_job` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `userId` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `job` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY `idx_name` (`<span class="hljs-type">name</span>`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p><code>user</code>表的<code>name</code>字段编码是<code>utf8mb4</code>，而<code>user_job</code>表的<code>name</code>字段编码为<code>utf8</code>。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939333.png" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939393.png" alt="图片"></p><p>执行左外连接查询,<code>user_job</code>表还是走全表扫描，如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939934.png" alt="图片"></p><p>如果把它们的<code>name</code>字段改为编码一致，相同的SQL，还是会走索引。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939479.png" alt="图片"></p><p>所以大家在做表关联时，注意一下<strong>关联字段的编码问题</strong>哈。</p><h3 id="2-10-优化器选错了索引"><a href="#2-10-优化器选错了索引" class="headerlink" title="2.10 优化器选错了索引"></a>2.10 优化器选错了索引</h3><p>MySQL 中一张表是可以支持多个索引的。你写<code>SQL</code>语句的时候，没有主动指定使用哪个索引的话，用哪个索引是由<code>MySQL</code>来确定的。</p><p>我们日常开发中，不断地删除历史数据和新增数据的场景，有可能会导致MySQL选错索引。那么有哪些解决方案呢？</p><ul><li>使用<code>force index</code> 强行选择某个索引</li><li>修改你的SQl，引导它使用我们期望的索引</li><li>优化你的业务逻辑</li><li>优化你的索引，新建一个更合适的索引，或者删除误用的索引。</li></ul><h2 id="3-limit深分页问题"><a href="#3-limit深分页问题" class="headerlink" title="3. limit深分页问题"></a>3. limit深分页问题</h2><p>limit深分页问题，会导致慢查询，应该大家都司空见惯了吧。</p><h3 id="3-1-limit深分页为什么会变慢"><a href="#3-1-limit深分页为什么会变慢" class="headerlink" title="3.1 limit深分页为什么会变慢"></a>3.1 limit深分页为什么会变慢</h3><p>limit深分页为什么会导致<strong>SQL变慢</strong>呢？假设我们有表结构如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键Id&#x27;</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;账户名&#x27;</span>,<br>  balance <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;余额&#x27;</span>,<br>  create_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  update_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>  KEY idx_name (<span class="hljs-type">name</span>),<br>  KEY idx_create_time (create_time) //索引<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 ROW_FORMAT=REDUNDANT <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;账户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>你知道以下<code>SQL</code>，执行过程是怎样的嘛？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> create_time&gt; <span class="hljs-string">&#x27;2020-09-19&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这个SQL的执行流程：</p><ol><li>通过普通二级索引树<code>idx_create_time</code>，过滤<code>create_time</code>条件，找到满足条件的主键<code>id</code>。</li><li>通过<code>主键id</code>，回到<code>id主键索引树</code>，找到满足记录的行，然后取出需要展示的列（回表过程）</li><li>扫描满足条件的<code>100010</code>行，然后扔掉前<code>100000</code>行，返回。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzT0uCAjOiaqJtsiaX04ZsLkMzvicfiba4r9qnmvibLyyI7jGRX0CGwk816KL1EtiaqadU01ZUn9qOuWAdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><code>limit</code>深分页，导致<code>SQL</code>变慢原因有两个：</p><ul><li><code>limit</code>语句会先扫描<code>offset+n</code>行，然后再丢弃掉前<code>offset</code>行，返回后<code>n</code>行数据。也就是说<code>limit 100000,10</code>，就会扫描<code>100010</code>行，而limit <code>0,10</code>，只扫描<code>10</code>行。</li><li><code>limit 100000,10</code> 扫描更多的行数，也意味着<strong>回表更多的次数</strong>。</li></ul><h3 id="3-2-如何优化深分页问题"><a href="#3-2-如何优化深分页问题" class="headerlink" title="3.2 如何优化深分页问题"></a>3.2 如何优化深分页问题</h3><p>我们可以通过减少回表次数来优化。一般有<strong>标签记录法和延迟关联法</strong>。</p><p><strong>标签记录法</strong></p><blockquote><p>就是标记一下上次查询到哪一条了，下次再来查的时候，从该条开始往下扫描。就好像看书一样，上次看到哪里了，你就折叠一下或者夹个书签，下次来看的时候，直接就翻到啦。</p></blockquote><p>假设上一次记录到<code>100000</code>，则SQL可以修改为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">100000</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样的话，后面无论翻多少页，性能都会不错的，因为命中了<code>id索引</code>。但是这种方式有局限性：需要一种类似连续自增的字段。</p><p><strong>延迟关联法</strong></p><p>延迟关联法，就是把条件转移到<strong>主键索引树</strong>，然后减少回表。如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  acct1.id,acct1.name,acct1.balance <span class="hljs-keyword">FROM</span> account acct1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> a.id <span class="hljs-keyword">FROM</span> account a <span class="hljs-keyword">WHERE</span> a.create_time &gt; <span class="hljs-string">&#x27;2020-09-19&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">AS</span> acct2 <span class="hljs-keyword">on</span> acct1.id= acct2.id;<br></code></pre></td></tr></table></figure><p><strong>优化思路</strong>就是，先通过<code>idx_create_time</code>二级索引树查询到满足条件的<code>主键ID</code>，再与原表通过<code>主键ID</code>内连接，这样后面直接走了主键索引了，同时也减少了回表。</p><h2 id="4-单表数据量太大"><a href="#4-单表数据量太大" class="headerlink" title="4. 单表数据量太大"></a>4. 单表数据量太大</h2><h3 id="4-1-单表数据量太大为什么会变慢？"><a href="#4-1-单表数据量太大为什么会变慢？" class="headerlink" title="4.1 单表数据量太大为什么会变慢？"></a>4.1 单表数据量太大为什么会变慢？</h3><p>一个表的数据量达到好几千万或者上亿时，加索引的效果没那么明显啦。性能之所以会变差，是因为维护索引的<code>B+</code>树结构层级变得更高了，查询一条数据时，需要经历的磁盘IO变多，因此查询性能变慢。</p><h3 id="4-2-一棵B-树可以存多少数据量"><a href="#4-2-一棵B-树可以存多少数据量" class="headerlink" title="4.2 一棵B+树可以存多少数据量"></a>4.2 一棵B+树可以存多少数据量</h3><p><strong>大家是否还记得，一个B+树大概可以存放多少数据量呢？</strong></p><p>InnoDB存储引擎最小储存单元是页，一页大小就是<code>16k</code>。</p><p>B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzT0uCAjOiaqJtsiaX04ZsLkMdS8D4Nz6GUOzKoCxtFdx2SaRsXAZYxw4smrOCBeCFfVtv0aP7ef0NQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>假设B+树的高度为<code>2</code>的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为&#x3D;根结点指针数*单个叶子节点记录行数。</p><ul><li>如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 &#x3D;16k&#x2F;1k &#x3D;16.</li><li>非叶子节点内存放多少指针呢？我们假设主键ID为<strong>bigint类型，长度为8字节</strong>(<strong>面试官问你int类型，一个int就是32位，4字节</strong>)，而指针大小在InnoDB源码中设置为6字节，所以就是8+6&#x3D;14字节，16k&#x2F;14B &#x3D;16*1024B&#x2F;14B &#x3D; 1170</li></ul><p>因此，一棵高度为2的B+树，能存放<code>1170 * 16=18720</code>条这样的数据记录。同理一棵高度为3的B+树，能存放<code>1170 *1170 *16 =21902400</code>，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。</p><p>如果B+树想存储更多的数据，那树结构层级就会更高，查询一条数据时，需要经历的磁盘IO变多，因此查询性能变慢。</p><h3 id="4-3-如何解决单表数据量太大，查询变慢的问题"><a href="#4-3-如何解决单表数据量太大，查询变慢的问题" class="headerlink" title="4.3 如何解决单表数据量太大，查询变慢的问题"></a>4.3 如何解决单表数据量太大，查询变慢的问题</h3><p>一般超过千万级别，我们可以考虑<strong>分库分表</strong>了。</p><p>分库分表可能导致的问题：</p><ul><li>事务问题</li><li>跨库问题</li><li>排序问题</li><li>分页问题</li><li>分布式ID</li></ul><p>因此，大家在评估是否分库分表前，先考虑下，是否可以把部分历史数据归档先，如果可以的话，先不要急着<strong>分库分表</strong>。如果真的要分库分表，综合考虑和评估方案。比如可以考虑垂直、水平分库分表。水平分库分表策略的话，<strong>range范围、hash取模、range+hash取模混合</strong>等等。</p><h2 id="5-join-或者子查询过多"><a href="#5-join-或者子查询过多" class="headerlink" title="5. join 或者子查询过多"></a>5. join 或者子查询过多</h2><p>一般来说，不建议使用子查询，可以把子查询改成<code>join</code>来优化。而数据库有个规范约定就是：<strong>尽量不要有超过3个以上的表连接</strong>。为什么要这么建议呢? 我们来聊聊，<code>join</code>哪些方面可能导致慢查询吧。</p><p>MySQL中，join的执行算法，分别是：<code>Index Nested-Loop Join</code>和<code>Block Nested-Loop Join</code>。</p><ul><li><code>Index Nested-Loop Join</code>：这个join算法，跟我们写程序时的嵌套查询类似，并且可以用上<strong>被驱动表的索引</strong>。</li><li><code>Block Nested-Loop Join</code>：这种join算法，<strong>被驱动表上没有可用的索引</strong>,它会先把驱动表的数据读入线程内存<code>join_buffer</code>中，再扫描被驱动表，把被驱动表的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ul><p><code>join</code>过多的问题：</p><blockquote><p>一方面，过多的表连接，会大大增加SQL复杂度。另外一方面，如果可以使用被驱动表的<strong>索引</strong>那还好，并且使用<strong>小表来做驱动表</strong>，<strong>查询效率更佳</strong>。如果被驱动表<strong>没有可用的索引</strong>，join是在<code>join_buffer</code>内存做的，如果匹配的数据量比较小或者<code>join_buffer</code>设置的比较大，速度也不会太慢。但是，如果<code>join</code>的数据量比较大时，mysql会采用在硬盘上创建临时表的方式进行多张表的关联匹配，这种显然效率就极低，本来磁盘的 IO 就不快，还要关联。</p></blockquote><p>一般情况下，如果业务需要的话，关联<code>2~3</code>个表是可以接受的，但是<strong>关联的字段需要加索引</strong>哈。如果需要关联更多的表，建议从代码层面进行拆分，在业务层先查询一张表的数据，然后以关联字段作为条件查询关联表形成<code>map</code>，然后在业务层进行数据的拼装。</p><h2 id="6-in元素过多"><a href="#6-in元素过多" class="headerlink" title="6. in元素过多"></a>6. in元素过多</h2><p>如果使用了<code>in</code>，即使后面的条件加了索引，还是要注意<code>in</code>后面的元素不要过多哈。<code>in</code>元素一般建议不要超过<code>500</code>个，如果超过了，建议分组，每次<code>500</code>一组进行哈。</p><p><strong>反例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> user_id,<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> user_id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3.</span>.<span class="hljs-number">.1000000</span>); <br></code></pre></td></tr></table></figure><p>如果我们对<code>in的条件</code>不做任何限制的话，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。尤其有时候，我们是用的子查询，in后面的子查询，你都不知道数量有多少那种，更容易采坑（<strong>所以我把in元素过多抽出来作为一个小节</strong>）。如下这种子查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> user_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> author_id <span class="hljs-keyword">from</span> artilce <span class="hljs-keyword">where</span> <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>正例是，<strong>分批进行</strong>，每批500个：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> user_id,<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> user_id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3.</span>.<span class="hljs-number">.500</span>);<br></code></pre></td></tr></table></figure><p>如果传参的ids太多，还可以做个参数校验什么的</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">if</span> (userIds.<span class="hljs-keyword">size</span>() &gt; <span class="hljs-number">500</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;单次查询的用户Id不能超过200&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-数据库在刷脏页"><a href="#7-数据库在刷脏页" class="headerlink" title="7. 数据库在刷脏页"></a>7. 数据库在刷脏页</h2><h3 id="7-1-什么是脏页"><a href="#7-1-什么是脏页" class="headerlink" title="7.1 什么是脏页"></a>7.1 什么是脏页</h3><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“<strong>脏页</strong>”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。一般有更新SQL才可能会导致脏页，我们回忆一下：一条更新语句是如何执行的</p><h3 id="7-2-一条更新语句是如何执行的？"><a href="#7-2-一条更新语句是如何执行的？" class="headerlink" title="7.2 一条更新语句是如何执行的？"></a>7.2 一条更新语句是如何执行的？</h3><p>以下的这个更新SQL，如何执行的呢？</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update t <span class="hljs-built_in">set</span> <span class="hljs-attribute">c</span>=c+1 where <span class="hljs-attribute">id</span>=666;<br></code></pre></td></tr></table></figure><ol><li>对于这条更新SQL，执行器会先找引擎取<code>id=666</code>这一行。如果这行所在的数据页本来就在内存中的话，就直接返回给执行器。如果不在内存，就去磁盘读入内存，再返回。</li><li>执行器拿到引擎给的行数据后，给这一行<code>C</code>的值加一，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到<code>redo log</code>里面，但是此时<code>redo log </code>是处于<code>prepare</code>状态的哈。</li><li>执行器生成这个操作的<code>binlog</code>，并把<code>binlog</code>写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的<code>redo log</code>改成提交（commit）状态，更新完成。</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939528.png" alt="图片"></p><p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作<code>redo log</code>（重做日志）。平时更新SQL执行得很快，其实是因为它只是在写内存和<code>redo log</code>日志，等到空闲的时候，才把<code>redo log</code>日志里的数据同步到磁盘中。</p><blockquote><p>有些小伙伴可能有疑惑，<code>redo log</code>日志不是在磁盘嘛？那为什么不慢？其实是因为写<code>redo log</code>的过程是顺序写磁盘的。<strong>磁盘顺序写</strong>会减少寻道等待时间，速度比随机写要快很多的。</p></blockquote><h3 id="7-3-为什么会出现脏页呢？"><a href="#7-3-为什么会出现脏页呢？" class="headerlink" title="7.3 为什么会出现脏页呢？"></a>7.3 为什么会出现脏页呢？</h3><p>更新SQL只是在写内存和<code>redo log</code>日志，等到空闲的时候，才把<code>redo log</code>日志里的数据同步到磁盘中。这时内存数据页跟磁盘数据页内容不一致,就出现脏页。</p><h3 id="7-4-什么时候会刷脏页（flush）？"><a href="#7-4-什么时候会刷脏页（flush）？" class="headerlink" title="7.4 什么时候会刷脏页（flush）？"></a>7.4 什么时候会刷脏页（flush）？</h3><p>InnoDB存储引擎的<code>redo log</code>大小是固定，且是环型写入的，如下图（图片来源于MySQL 实战 45 讲）：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939484.png" alt="图片"></p><p>那什么时候会刷脏页？有几种场景：</p><ol><li><code>redo log</code>写满了，要刷脏页。这种情况要尽量避免的。因为出现这种情况时，整个系统就不能再接受更新啦，即所有的更新都必须堵住。</li><li>内存不够了，需要新的内存页，就要淘汰一些数据页，这时候会刷脏页</li></ol><blockquote><p>InnoDB 用缓冲池（buffer pool）管理内存,而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须<strong>将脏页先刷到磁盘</strong>，变成干净页后才能复用。</p></blockquote><ol><li>MySQL 认为<strong>系统空闲</strong>的时候，也会刷一些脏页</li><li>MySQL 正常关闭时，会把内存的脏页都 flush 到磁盘上</li></ol><h3 id="7-5-为什么刷脏页会导致SQL变慢呢？"><a href="#7-5-为什么刷脏页会导致SQL变慢呢？" class="headerlink" title="7.5 为什么刷脏页会导致SQL变慢呢？"></a>7.5 为什么刷脏页会导致SQL变慢呢？</h3><ol><li><code>redo log</code>写满了，要刷脏页，这时候会导致系统所有的更新堵住，写性能都跌为0了，肯定慢呀。一般要杜绝出现这个情况。</li><li>一个查询要淘汰的脏页个数太多，一样会导致查询的响应时间明显变长。</li></ol><h2 id="8-order-by-文件排序"><a href="#8-order-by-文件排序" class="headerlink" title="8. order by 文件排序"></a>8. order by 文件排序</h2><p><code>order by</code>就一定会导致慢查询吗？<strong>不是这样的哈</strong>，因为<code>order by</code>平时用得多，并且数据量一上来，还是走<strong>文件排序</strong>的话，很容易有慢SQL的。听我娓娓道来，<code>order by</code>哪些时候可能会导致慢SQL哈。</p><h3 id="8-1-order-by-的-Using-filesort文件排序"><a href="#8-1-order-by-的-Using-filesort文件排序" class="headerlink" title="8.1 order by 的 Using filesort文件排序"></a>8.1 order by 的 Using filesort文件排序</h3><p>我们平时经常需要用到<code>order by</code> ，主要就是用来给某些字段排序的。比如以下SQL:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span>,age,city <span class="hljs-keyword">from</span> staff <span class="hljs-keyword">where</span> city = <span class="hljs-string">&#x27;深圳&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>它表示的意思就是：<strong>查询前10个，来自深圳员工的姓名、年龄、城市，并且按照年龄小到大排序。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzT0uCAjOiaqJtsiaX04ZsLkMdzH6oxuEbKvyiaSrWA6OjkB9rO6icbX7bbNsmkoqKo99j0fncFXfBzsA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>查看<code>explain</code>执行计划的时候，可以看到<code>Extra</code>这一列，有一个<code>Using filesort</code>，它表示用到<strong>文件排序</strong>。</p><h3 id="8-2-order-by文件排序效率为什么较低"><a href="#8-2-order-by文件排序效率为什么较低" class="headerlink" title="8.2 order by文件排序效率为什么较低"></a>8.2 order by文件排序效率为什么较低</h3><p><code>order by</code>用到文件排序时，为什么查询效率会相对低呢？</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939315.png" alt="图片"></p><p><code>order by</code>排序，分为全字段排序和rowid排序。它是拿<code>max_length_for_sort_data</code>和结果行数据长度对比，如果结果行数据长度超过<code>max_length_for_sort_data</code>这个值，就会走<strong>rowid排序</strong>，相反，则走<strong>全字段排序</strong>。</p><h4 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h4><p>rowid排序，一般需要<strong>回表去找满足条件的数据，所以效率会慢一点</strong>。以下这个SQL，使用<code>rowid</code>排序，执行过程是这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span>,age,city <span class="hljs-keyword">from</span> staff <span class="hljs-keyword">where</span> city = <span class="hljs-string">&#x27;深圳&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ol><li>MySQL 为对应的线程初始化<code>sort_buffer</code>，放入需要排序的<code>age</code>字段，以及<code>主键id</code>；</li><li>从索引树<code>idx_city</code>， 找到第一个满足 <code>city=&#39;深圳’</code>条件的<code>主键id</code>，也就是图中的<code>id=9</code>；</li><li>到<code>主键id索引树</code>拿到<code>id=9</code>的这一行数据， 取<code>age和主键id</code>的值，存到<code>sort_buffer</code>；</li><li>从索引树<code>idx_city</code>拿到下一个记录的<code>主键id</code>，即图中的<code>id=13</code>；</li><li>重复步骤 3、4 直到<code>city</code>的值不等于深圳为止；</li><li>前面5步已经查找到了所有<code>city</code>为深圳的数据，在<code>sort_buffer</code>中，将所有数据根据age进行排序；</li><li>遍历排序结果，取前10行，并按照<code>id</code>的值回到原表中，取出<code>city、name 和 age</code>三个字段返回给客户端。</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939441.png" alt="图片"></p><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>同样的SQL，如果是走全字段排序是这样的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span>,age,city <span class="hljs-keyword">from</span> staff <span class="hljs-keyword">where</span> city = <span class="hljs-string">&#x27;深圳&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ol><li>MySQL 为对应的线程初始化<code>sort_buffer</code>，放入需要查询的<code>name、age、city</code>字段；</li><li>从索引树<code>idx_city</code>， 找到第一个满足 <code>city=&#39;深圳’</code>条件的主键 id，也就是图中的<code>id=9</code>；</li><li>到主键<code>id索引树</code>拿到<code>id=9</code>的这一行数据， 取<code>name、age、city</code>三个字段的值，存到<code>sort_buffer</code>；</li><li>从索引树<code>idx_city </code>拿到下一个记录的主键<code>id</code>，即图中的<code>id=13</code>；</li><li>重复步骤 3、4 直到<code>city</code>的值不等于深圳为止；</li><li>前面5步已经查找到了所有<code>city</code>为深圳的数据，在<code>sort_buffer</code>中，将所有数据根据<code>age</code>进行排序；</li><li>按照排序结果取前10行返回给客户端。</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939436.png" alt="图片"></p><p><code>sort_buffer</code>的大小是由一个参数控制的：<code>sort_buffer_size</code>。</p><ul><li>如果要排序的数据小于<code>sort_buffer_size</code>，排序在<code>sort_buffer</code>内存中完成</li><li>如果要排序的数据大于<code>sort_buffer_size</code>，则借助磁盘文件来进行排序。</li></ul><blockquote><p>借助磁盘文件排序的话，<strong>效率就更慢一点</strong>。因为先把数据放入<code>sort_buffer</code>，当快要满时。会排一下序，然后把<code>sort_buffer</code>中的数据，放到临时磁盘文件，等到所有满足条件数据都查完排完，再用归并算法把磁盘的临时排好序的小文件，合并成一个有序的大文件。</p></blockquote><h3 id="8-3-如何优化order-by的文件排序"><a href="#8-3-如何优化order-by的文件排序" class="headerlink" title="8.3 如何优化order by的文件排序"></a>8.3 如何优化order by的文件排序</h3><p><code>order by</code>使用<strong>文件排序</strong>，效率会低一点。我们怎么优化呢？</p><ul><li>因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不会再用到文件排序啦。而索引数据本身是有序的，我们通过建立索引来优化<code>order by</code>语句。</li><li>我们还可以通过调整<code>max_length_for_sort_data</code>、<code>sort_buffer_size</code>等参数优化；</li></ul><p>大家有兴趣可以看下我之前这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490571&idx=1&sn=e8638573ec8d720fd25da5b2b0d90ed2&scene=21#wechat_redirect">看一遍就理解：order by详解</a></p><h3 id="8-4使用where过滤数目而不是having"><a href="#8-4使用where过滤数目而不是having" class="headerlink" title="8.4使用where过滤数目而不是having"></a>8.4使用where过滤数目而不是having</h3><p>使用where子句替换Having子句：避免使用having子句，having只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序分组，如果能通过where子句提前过滤查询的数目，就可以减少这方面的开销。</p><ul><li>低效: <code>SELECT JOB, AVG(SAL) FROM EMP GROUP by JOB HAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’</code></li><li>高效: <code>SELECT JOB, AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ GROUP by JOB</code></li></ul><h2 id="9-拿不到锁"><a href="#9-拿不到锁" class="headerlink" title="9. 拿不到锁"></a>9. 拿不到锁</h2><p>有时候，我们查询一条很简单的SQL，但是却等待很长的时间，不见结果返回。一般这种时候就是表被锁住了，或者要查询的某一行或者几行被锁住了。我们只能慢慢等待锁被释放。</p><blockquote><p>举一个生活的例子哈，你和别人合租了一间房子，这个房子只有一个卫生间的话。假设某一时刻，你们都想去卫生间，但是对方比你早了一点点。那么此时你只能等对方出来后才能进去。</p></blockquote><p>这时候，我们可以用<code>show processlist</code>命令，看看当前语句处于什么状态哈。</p><h2 id="10-delete-in子查询不走索引！"><a href="#10-delete-in子查询不走索引！" class="headerlink" title="10. delete + in子查询不走索引！"></a>10. delete + in子查询不走索引！</h2><p>之前见到过一个生产慢SQL问题，当<code>delete</code>遇到<code>in</code>子查询时，即使有索引，也是不走索引的。而对应的<code>select + in</code>子查询，却可以走索引。</p><p>MySQL版本是5.7，假设当前有两张表account和old_account,表结构如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `old_account` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键Id&#x27;</span>,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;账户名&#x27;</span>,<br>  `balance` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;余额&#x27;</span>,<br>  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `update_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY `idx_name` (`<span class="hljs-type">name</span>`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 ROW_FORMAT=REDUNDANT <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;老的账户表&#x27;</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `account` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键Id&#x27;</span>,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;账户名&#x27;</span>,<br>  `balance` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;余额&#x27;</span>,<br>  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `update_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY `idx_name` (`<span class="hljs-type">name</span>`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 ROW_FORMAT=REDUNDANT <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;账户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>执行的SQL如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> old_account);<br></code></pre></td></tr></table></figure><p>查看执行计划，发现不走索引：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939727.png" alt="图片"></p><p>但是如果把<code>delete</code>换成<code>select</code>，就会走索引。如下：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939800.png" alt="图片"></p><p>为什么<code>select + in</code>子查询会走索引，<code>delete + in</code>子查询却不会走索引呢？</p><p>我们执行以下SQL看看：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> old_account);<br><span class="hljs-keyword">show</span> WARNINGS; //可以查看优化后,最终执行的<span class="hljs-keyword">sql</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">select `test2`.`account`.`id` AS `id`,`test2`.`account`.`name` AS `name`,`test2`.`account`.`balance` AS `balance`,`test2`.`account`.`create_time` AS `create_time`,`test2`.`account`.`update_time` AS `update_time` from `test2`.`account` <br>semi join (`test2`.`old_account`)<br>where (`test2`.`account`.`name` = `test2`.`old_account`.`name`)<br></code></pre></td></tr></table></figure><p>可以发现，实际执行的时候，MySQL对<code>select in</code>子查询做了优化，把子查询改成<code>join</code>的方式，所以可以走索引。但是很遗憾，对于<code>delete in</code>子查询，MySQL却没有对它做这个优化。</p><p>日常开发中，大家注意一下这个场景哈，大家有兴趣可以看下这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247495170&idx=1&sn=ce914de3abdb0d887e286b680b25111f&chksm=cf22312bf855b83d31a00da110626747df8e69fca1bc310642c56e39d663b006a8105f9fb1e1&token=1495321435&lang=zh_CN&scene=21#wechat_redirect">生产问题分析！delete in子查询不走索引？！</a></p><h2 id="11、group-by使用临时表"><a href="#11、group-by使用临时表" class="headerlink" title="11、group by使用临时表"></a>11、group by使用临时表</h2><p><code>group by</code>一般用于分组统计，它表达的逻辑就是根据<strong>一定的规则，进行分组</strong>。日常开发中，我们使用得比较频繁。如果不注意，很容易产生慢SQL。</p><h3 id="11-1-group-by的执行流程"><a href="#11-1-group-by的执行流程" class="headerlink" title="11.1 group by的执行流程"></a>11.1 group by的执行流程</h3><p>假设有表结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `staff` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键id&#x27;</span>,<br>  `id_card` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;身份证号码&#x27;</span>,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  `city` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;城市&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">15</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;员工表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们查看一下这个SQL的执行计划：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> city ,<span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">as</span> num <span class="hljs-keyword">from</span> staff <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> city;<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939841.png" alt="图片"></p><ul><li>Extra 这个字段的<code>Using temporary</code>表示在执行分组的时候使用了<strong>临时表</strong></li><li>Extra 这个字段的<code>Using filesort</code>表示使用了<strong>文件排序</strong></li></ul><p><code>group by</code>是怎么使用到临时表和排序了呢？我们来看下这个SQL的执行流程</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> city ,<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> num <span class="hljs-keyword">from</span> staff <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> city;<br></code></pre></td></tr></table></figure><ol><li>创建内存临时表，表里有两个字段<code>city和num</code>；</li><li>全表扫描<code>staff</code>的记录，依次取出<code>city = &#39;X&#39;</code>的记录。</li></ol><ul><li>判断临时表中是否有为 <code>city=&#39;X&#39;</code>的行，没有就插入一个记录<code> (X,1)</code>;</li><li>如果临时表中有<code>city=&#39;X&#39;</code>的行，就将X这一行的num值加 1；</li></ul><ol><li>遍历完成后，再根据字段<code>city</code>做排序，得到结果集返回给客户端。这个流程的执行图如下：</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206161939063.png" alt="图片"></p><p><strong>临时表的排序是怎样的呢？</strong></p><p>就是把需要排序的字段，放到sort buffer，排完就返回。在这里注意一点哈，排序分<strong>全字段排序和rowid排序</strong></p><ul><li>如果是全字段排序，需要查询返回的字段，都放入sort buffer，根据排序字段排完，直接返回</li><li>如果是rowid排序，只是需要排序的字段放入sort buffer，然后多一次回表操作，再返回。</li></ul><h3 id="11-2-group-by可能会慢在哪里？"><a href="#11-2-group-by可能会慢在哪里？" class="headerlink" title="11.2  group by可能会慢在哪里？"></a>11.2  group by可能会慢在哪里？</h3><p><code>group by</code>使用不当，很容易就会产生慢SQL 问题。因为它既用到临时表，又默认用到排序。有时候还可能用到磁盘临时表。</p><ul><li>如果执行过程中，会发现<code>内存临时表</code>大小到达了上限（控制这个上限的参数就是tmp_table_size），会把内存临时表转成磁盘临时表。</li><li>如果数据量很大，很可能这个查询需要的磁盘临时表，就会占用大量的磁盘空间。</li></ul><h3 id="11-3-如何优化group-by呢？"><a href="#11-3-如何优化group-by呢？" class="headerlink" title="11.3 如何优化group by呢？"></a>11.3 如何优化group by呢？</h3><p>从哪些方向去优化呢？</p><ul><li>方向1：既然它默认会排序，我们不给它排是不是就行啦。</li><li>方向2：既然临时表是影响<code>group by</code>性能的X因素，我们是不是可以不用临时表？</li></ul><p>我们一起来想下，执行<code>group by</code>语句为什么需要临时表呢？<code>group by</code>的语义逻辑，就是统计不同的值出现的个数。如果这个这些值一开始就是有序的，我们是不是直接往下扫描统计就好了，就不用临时表来记录并统计结果啦?</p><p>可以有这些优化方案：</p><ul><li>group by 后面的字段加索引</li><li>order by null 不用排序</li><li>尽量只使用内存临时表</li><li>使用SQL_BIG_RESULT</li></ul><p>大家可以看下我这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247497527&idx=1&sn=1f30251d88b0e935bfffc3e8eaf53f28&chksm=cf22281ef855a1084fe84a7b257db5734c7b982c6ddaf9ef497d4e31e60faebd5f329e3c55a6&token=352114508&lang=zh_CN&scene=21#wechat_redirect">看一遍就理解：group by详解</a></p><h2 id="12-系统硬件或网络资源"><a href="#12-系统硬件或网络资源" class="headerlink" title="12. 系统硬件或网络资源"></a>12. 系统硬件或网络资源</h2><ul><li>如果数据库服务器内存、硬件资源，或者网络资源配置不是很好，就会慢一些哈。这时候可以升级配置。这就好比你的计算机有时候很卡，你可以加个内存条什么的一个道理。</li><li>如果数据库压力本身很大，比如高并发场景下，大量请求到数据库来，数据库服务器<code>CPU</code>占用很高或者<code>IO利用率</code>很高，这种情况下所有语句的执行都有可能变慢的哈。</li></ul><h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>数据库中的 B+树索引可以分为聚集索引和非聚集索引。聚集索引和非聚集索引的不同点在于叶子节点是否是完整行数据。</p><p>Innodb 存储引擎表是索引组织表，即表中的数据按照主键顺序存放。聚集索引就是按照每张表的主键构造一棵 B+树，叶子节点存放的是表的完整行记录。非聚集索引的叶子节点不包含行记录的全部数据。Innodb 存储引擎的非聚集索引的叶子节点的内容为主键索引值。</p><p>若数据表没有主键聚集索引是怎么建立的？在没有主键时 Innodb 会给数据表的每条记录生成一个 6 个字节长度的 RowId 字段，会以此建立聚集索引。</p><h2 id="13-区分in和exists"><a href="#13-区分in和exists" class="headerlink" title="13 区分in和exists"></a>13 区分in和exists</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表A <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> (select <span class="hljs-built_in">id</span> <span class="hljs-keyword">from</span> 表B)<br></code></pre></td></tr></table></figure><p>上面的语句相当于：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表B <span class="hljs-keyword">where</span> 表B.id=表A.id)<br></code></pre></td></tr></table></figure><p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</p><p>另外，in查询在某些情况下有可能会查询返回错误的结果，因此，通常是建议在确定且有限的集合时，可以使用in。如 IN （0，1，2）。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库</title>
    <link href="/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一部分-MySQL基础篇"><a href="#第一部分-MySQL基础篇" class="headerlink" title="第一部分 MySQL基础篇"></a>第一部分 MySQL基础篇</h2><h3 id="第01章-数据库概述"><a href="#第01章-数据库概述" class="headerlink" title="第01章 数据库概述"></a>第01章 数据库概述</h3><h4 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h4><ul><li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘上加以“固化”</strong>，而持久化的实现过程大多通过各种关系数据库来完成。</li><li>持久化的主要作用是<strong>将内存中的数据存储在关系型数据库中</strong>，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h4 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h4><h5 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2.1 数据库的相关概念"></a>2.1 数据库的相关概念</h5><ul><li><p><strong>DB：数据库(Database)</strong></p><ul><li>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</li></ul></li><li><p><strong>DBMS：数据库管理系统(Database Management System)</strong></p><ul><li>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</li></ul></li><li><p><strong>SQL：结构化查询语言（Structured Query Language）</strong></p><ul><li>专门用来与数据库通信的语言。</li></ul></li></ul><h4 id="3-RDBMS与非RDBMS"><a href="#3-RDBMS与非RDBMS" class="headerlink" title="3. RDBMS与非RDBMS"></a>3. RDBMS与非RDBMS</h4><h5 id="3-1-关系型数据库-RDBMS"><a href="#3-1-关系型数据库-RDBMS" class="headerlink" title="3.1 关系型数据库(RDBMS)"></a>3.1 关系型数据库(RDBMS)</h5><h6 id="3-1-1-实质"><a href="#3-1-1-实质" class="headerlink" title="3.1.1 实质"></a>3.1.1 实质</h6><ul><li>这种类型的数据库是<strong>最古老</strong>的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的<strong>二元关系</strong> （即二维表格形式）。</li><li>关系型数据库以**行(row)<strong>和</strong>列(column)<strong>的形式存储数据，以便于用户理解。这一系列的行和列被称为</strong>表(table)<strong>，一组表组成了一个</strong>库(database)**。</li><li>SQL就是关系型数据库的查询语言。</li></ul><h6 id="3-1-2-优势"><a href="#3-1-2-优势" class="headerlink" title="3.1.2 优势"></a>3.1.2 优势</h6><ul><li><strong>复杂查询</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><h5 id="3-2-非关系型数据库-非RDBMS"><a href="#3-2-非关系型数据库-非RDBMS" class="headerlink" title="3.2 非关系型数据库(非RDBMS)"></a>3.2 非关系型数据库(非RDBMS)</h5><h6 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h6><p><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能<strong>阉割版本</strong>，基于键值对存储数据，不需要经过SQL层的解析，<strong>性能非常高</strong>。同时，通过减少不常用的功能，进一步提高性能。</p><h4 id="4-关系型数据库设计规则"><a href="#4-关系型数据库设计规则" class="headerlink" title="4. 关系型数据库设计规则"></a>4. 关系型数据库设计规则</h4><ul><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</li></ul><h5 id="4-1-表、记录、字段"><a href="#4-1-表、记录、字段" class="headerlink" title="4.1 表、记录、字段"></a>4.1 表、记录、字段</h5><ul><li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<strong>实体集</strong>、<strong>属性</strong>、<strong>联系集</strong>。</li><li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li></ul><h5 id="4-2-表的关联关系"><a href="#4-2-表的关联关系" class="headerlink" title="4.2 表的关联关系"></a>4.2 表的关联关系</h5><ul><li>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</li><li>四种：一对一关联、一对多关联、多对多关联、自我引用</li></ul><h3 id="第02章-MySQL环境搭建（略）"><a href="#第02章-MySQL环境搭建（略）" class="headerlink" title="第02章 MySQL环境搭建（略）"></a>第02章 MySQL环境搭建（略）</h3><h4 id="1-MySQL演示使用"><a href="#1-MySQL演示使用" class="headerlink" title="1. MySQL演示使用"></a>1. MySQL演示使用</h4><h5 id="1-1-MySQL的编码设置"><a href="#1-1-MySQL的编码设置" class="headerlink" title="1.1 MySQL的编码设置"></a>1.1 MySQL的编码设置</h5><p><strong>MySQL5.7中</strong></p><p><strong>问题再现：命令行操作sql乱码问题</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_stu <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br>ERROR <span class="hljs-number">1366</span> (HY000): Incorrect string <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;sname&#x27;</span> <span class="hljs-keyword">at</span> <span class="hljs-type">row</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>问题解决</strong></p><p>步骤1：查看编码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;character_%&#x27;</span>;<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;collation_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>步骤2：修改mysql的数据目录下的my.ini配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">default-character-set</span>=utf8 <span class="hljs-comment">#默认字符集 [mysqld]</span><br><br><span class="hljs-comment"># 大概在76行左右，在其下添加</span><br>...<br><span class="hljs-attr">character-set-server</span>=utf8<br><span class="hljs-attr">collation-server</span>=utf8_general_ci<br></code></pre></td></tr></table></figure><p>步骤3：重启服务</p><p>步骤4：查看编码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;character_%&#x27;</span>;<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;collation_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>MySQL8.0中</strong></p><p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为<strong>utf8mb4</strong>，从而避免了上述的乱码问题。</p><h4 id="问题1：root用户密码忘记，重置的操作"><a href="#问题1：root用户密码忘记，重置的操作" class="headerlink" title="问题1：root用户密码忘记，重置的操作"></a>问题1：root用户密码忘记，重置的操作</h4><p>1: 通过任务管理器或者服务管理，关掉mysqld(服务进程)</p><p>2: 通过命令行+特殊参数开启mysqld mysqld – defaults-file&#x3D;”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables </p><p>3: 此时，mysqld服务进程已经打开。并且不需要权限检查</p><p>4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行</p><p>5: 修改权限表 （1） use mysql; （2）update user set authentication_string&#x3D;password(‘新密码’) where user&#x3D;’root’ and Host&#x3D;’localhost’; （3）flush privileges;</p><p>6: 通过任务管理器，关掉mysqld服务进程。</p><p>7: 再次通过服务管理，打开mysql服务。</p><p>8: 即可用修改后的新密码登陆。</p><h4 id="问题2：mysql命令报“不是内部或外部命令”"><a href="#问题2：mysql命令报“不是内部或外部命令”" class="headerlink" title="问题2：mysql命令报“不是内部或外部命令”"></a>问题2：mysql命令报“不是内部或外部命令”</h4><p>如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。</p><h4 id="问题3：-No-database-selected"><a href="#问题3：-No-database-selected" class="headerlink" title="问题3： No database selected"></a>问题3： No database selected</h4><p>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</p><p>解决方案二：就是所有的表对象前面都加上“数据库.” </p><h4 id="问题4：命令行客户端的字符集问题"><a href="#问题4：命令行客户端的字符集问题" class="headerlink" title="问题4：命令行客户端的字符集问题"></a>问题4：命令行客户端的字符集问题</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_stu <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br>ERROR <span class="hljs-number">1366</span> (HY000): Incorrect string <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;sname&#x27;</span> <span class="hljs-keyword">at</span> <span class="hljs-type">row</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>查看所有字符集：<code>SHOW VARIABLES LIKE &#39;character_set_%&#39;; </code></p><p>解决方案，设置当前连接的客户端字符集 <code>SET NAMES GBK;</code></p><h4 id="问题5：修改数据库和表的字符编码"><a href="#问题5：修改数据库和表的字符编码" class="headerlink" title="问题5：修改数据库和表的字符编码"></a>问题5：修改数据库和表的字符编码</h4><p>修改编码：</p><p>（1)先停止服务，（2）修改my.ini文件（3）重新启动服务</p><p>说明：</p><p>如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database <span class="hljs-number">0728</span>db charset Latin1;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> use <span class="hljs-number">0728</span>db;<br>Database changed<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br><span class="hljs-keyword">Table</span>: student <br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` ( `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1 <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student charset utf8; #修改表字符编码为UTF8<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br>Records: <span class="hljs-number">0</span> Duplicates: <span class="hljs-number">0</span> Warnings: <span class="hljs-number">0</span><br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br><span class="hljs-keyword">Table</span>: student<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` ( `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> latin1 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, #字段仍然是latin1编码 <span class="hljs-keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student modify name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) charset utf8; #修改字段字符编码为UTF8<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.05</span> sec)<br>Records: <span class="hljs-number">0</span> Duplicates: <span class="hljs-number">0</span> Warnings: <span class="hljs-number">0</span><br>                                      <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br><span class="hljs-keyword">Table</span>: student <br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>: <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` ( `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`) ) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database <span class="hljs-number">0728</span>db;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------------------------------------------------------------+</span><br><span class="hljs-operator">|</span>Database<span class="hljs-operator">|</span> <span class="hljs-keyword">Create</span> Database <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+-------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span><span class="hljs-number">0728</span>db<span class="hljs-operator">|</span> <span class="hljs-keyword">CREATE</span> DATABASE `<span class="hljs-number">0728</span>db` <span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+-------------------------------------------------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> database <span class="hljs-number">0728</span>db charset utf8; #修改数据库的字符编码为utf8<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章 基本的SELECT语句"></a>第03章 基本的SELECT语句</h3><h4 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL概述</h4><h5 id="1-1-SQL分类"><a href="#1-1-SQL分类" class="headerlink" title="1.1 SQL分类"></a>1.1 SQL分类</h5><ul><li><p>DDL:数据定义语言。<code>CREATE</code> \ <code>ALTER</code> \ <code>DROP</code> \ <code>RENAME</code> \ <code>TRUNCATE</code></p></li><li><p>DML:数据操作语言。<code>INSERT</code> \ <code>DELETE</code> \ <code>UPDATE</code> \ <code>SELECT</code> （重中之重）</p></li><li><p>DCL:数据控制语言。<code>COMMIT</code> \ <code>ROLLBACK</code> \ <code>SAVEPOINT</code> \ <code>GRANT</code> \ <code>REVOKE</code></p></li></ul><h4 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL语言的规则与规范</h4><h5 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h5><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li><li>列的别名，尽量使用双引号（” “），而且不建议省略as</li></ul></li></ul><h5 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2.2 SQL大小写规范 （建议遵守）"></a>2.2 SQL大小写规范 （建议遵守）</h5><ul><li><strong>MySQL在Windows环境下是大小写不敏感的</strong></li><li><strong>MySQL在Linux环境下是大小写敏感的</strong><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li><strong>推荐采用统一的书写规范：</strong><ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><h5 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2.3 注 释"></a>2.3 注 释</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">单行注释：#注释文字(MySQL特有的方式)<br>单行注释：<span class="hljs-comment">-- 注释文字(--后面必须包含一个空格。)</span><br>多行注释：<span class="hljs-comment">/* 注释文字 */</span><br></code></pre></td></tr></table></figure><h5 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2.4 命名规则（暂时了解）"></a>2.4 命名规则（暂时了解）</h5><ul><li>数据库、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h5 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2.5 数据导入指令"></a>2.5 数据导入指令</h5><p>在命令行客户端登录mysql，使用source指令导入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> source d:\mysqldb.sql<br></code></pre></td></tr></table></figure><h4 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3. 基本的SELECT语句"></a>3. 基本的SELECT语句</h4><h5 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3.0 SELECT…"></a>3.0 SELECT…</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>; #没有任何子句<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">FROM</span> DUAL; #dual：伪表<br></code></pre></td></tr></table></figure><h5 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3.1 SELECT … FROM"></a><strong>3.1 SELECT … FROM</strong></h5><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 标识选择哪些列<br><span class="hljs-keyword">FROM</span> 标识从哪个表中选择<br></code></pre></td></tr></table></figure><ul><li>选择全部列：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> departments;<br></code></pre></td></tr></table></figure><ul><li>选择特定的列：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, location_id<br><span class="hljs-keyword">FROM</span> departments;<br></code></pre></td></tr></table></figure><h5 id="3-2-列的别名"><a href="#3-2-列的别名" class="headerlink" title="3.2 列的别名"></a><strong>3.2</strong> <strong>列的别名</strong></h5><ul><li>重命名一个列</li><li>便于计算</li><li>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</li><li>AS 可以省略</li><li>建议别名简短，见名知意</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">AS</span> name, commission_pct comm <br><span class="hljs-keyword">FROM</span> employees;<br><br><span class="hljs-keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span> &quot;Annual Salary&quot;<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><h5 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3.3 去除重复行"></a><strong>3.3</strong> <strong>去除重复行</strong></h5><p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id,salary <br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>这里有两点需要注意：</p><ol><li><p><code>DISTINCT</code>需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</p></li><li><p><code>DISTINCT</code>其实是对后面所有列名的组合进行去重。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</p></li></ol><h5 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a><strong>3.4</strong> <strong>空值参与运算</strong></h5><ul><li>所有运算符或列值遇到null值，运算的结果都为null</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,salary,commission_pct, <span class="hljs-number">12</span> <span class="hljs-operator">*</span> salary <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> commission_pct) &quot;annual_sal&quot; <br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p><h5 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3.5 着重号"></a><strong>3.5</strong> <strong>着重号</strong></h5><ul><li>错误的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">ORDER</span>;<br></code></pre></td></tr></table></figure><ul><li>正确的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">ORDER</span>`;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">order</span>`;<br></code></pre></td></tr></table></figure><ul><li>结论</li></ul><p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对&#96;&#96;（着重号）引起来。</p><h5 id="3-6-查询常数"><a href="#3-6-查询常数" class="headerlink" title="3.6 查询常数"></a><strong>3.6 查询常数</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;尚硅谷&#x27;</span> <span class="hljs-keyword">as</span> corporation, last_name<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><h4 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a><strong>4.</strong> <strong>显示表结构</strong></h4><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> employees;<br>或<br><span class="hljs-keyword">DESC</span> employees;<br></code></pre></td></tr></table></figure><h4 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a><strong>5.</strong> <strong>过滤数据</strong></h4><ul><li>语法<ul><li>使用WHERE 子句，将不满足条件的行过滤掉</li><li><strong>WHERE子句紧随FROM子句</strong></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span><br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">WHERE</span> 过滤条件<br></code></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, job_id, department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><h3 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章 运算符"></a>第04章 运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a><strong>1.</strong> <strong>算术运算符</strong></h4><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加法运算符</td><td>计算两个值或表达式的和</td><td>SELECT A + B</td></tr><tr><td>-</td><td>减法运算符</td><td>计算两个值或表达式的差</td><td>SELECT A - B</td></tr><tr><td>*</td><td>乘法运算符</td><td>计算两个值或表达式的乘积</td><td>SELECT A * B</td></tr><tr><td>&#x2F; 或 DIV</td><td>除法运算符</td><td>计算两个值或表达式的商</td><td>SELECT A &#x2F; B 或者 SELECT A DIV B</td></tr><tr><td>% 或 MOD</td><td>求模（求余）运算符</td><td>计算两个值或表达式的余数</td><td>SELECT A % B 或者 SELECT A MOD B</td></tr></tbody></table><p>加法与减法运算符结论:</p><blockquote><ul><li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li><li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li><li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li><li><strong>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</strong></li></ul></blockquote><p>乘法与除法运算符结论:</p><blockquote><ul><li>一个数乘以整数1和除以整数1后仍得原数；</li><li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li><li><strong>一个数除以整数后，不管是否能除尽，结果都为一个浮点数</strong>；</li><li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li><li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li><li><strong>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</strong></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 取模运算： <span class="hljs-operator">%</span> mod<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">12</span> <span class="hljs-operator">%</span> <span class="hljs-number">3</span>,<span class="hljs-number">12</span> <span class="hljs-operator">%</span> <span class="hljs-number">5</span>, <span class="hljs-number">12</span> MOD <span class="hljs-number">-5</span>,<span class="hljs-number">-12</span> <span class="hljs-operator">%</span> <span class="hljs-number">5</span>,<span class="hljs-number">-12</span> <span class="hljs-operator">%</span> <span class="hljs-number">-5</span><br><span class="hljs-keyword">FROM</span> DUAL; # 结果的符号只与被模数有关<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+-----------+---------+----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">12</span> <span class="hljs-operator">%</span> <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-number">12</span> <span class="hljs-operator">%</span> <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">12</span> MOD <span class="hljs-number">-5</span> <span class="hljs-operator">|</span> <span class="hljs-number">-12</span> <span class="hljs-operator">%</span> <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">-12</span> <span class="hljs-operator">%</span> <span class="hljs-number">-5</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+-----------+---------+----------+</span><br><span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-number">2</span> <span class="hljs-operator">|</span>         <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">-2</span> <span class="hljs-operator">|</span>       <span class="hljs-number">-2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+-----------+---------+----------+</span><br></code></pre></td></tr></table></figure><h4 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a><strong>2.</strong> <strong>比较运算符</strong></h4><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于运算符</td><td>判断两个值、字符串或表达式是否相等</td><td>SELECT C FROM TABLE WHERE A &#x3D; B</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>安全等于运算符</td><td>安全地判断两个值、字符串或表达式是否相等</td><td>SELECT C FROM TABLE WHERE A &lt;&#x3D;&gt; B</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于运算符</td><td>判断两个值、字符串或表达式是否不相等</td><td>SELECT C FROM TABLE WHERE A &lt;&gt; B</td></tr><tr><td>&lt;</td><td>小于运算符</td><td>判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &lt; B</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于运算符</td><td>判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &lt;&#x3D; B</td></tr><tr><td>&gt;</td><td>大于运算符</td><td>判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &gt; B</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于运算符</td><td>判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式</td><td>SELECT C FROM TABLE WHERE A &gt;&#x3D; B</td></tr></tbody></table><p><strong>等号运算符</strong></p><ul><li>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</li><li>在使用等号运算符时，遵循如下规则：<ul><li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li><li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li><li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li><li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li></ul></li></ul><p><strong>安全等于运算符（为NULL而生）</strong></p><p>安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的， <strong>唯一的区别</strong>是‘&lt;&#x3D;&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p><p><strong>不等于运算符</strong></p><p>不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。</p><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>IS NULL</td><td>为空运算符</td><td>判断值、字符串或表达式是否为空</td><td>SELECT B FROM TABLE WHERE A IS NULL</td></tr><tr><td>IS NOTNULL</td><td>不为空运算符</td><td>判断值、字符串或表达式是否不为空</td><td>SELECT B FROM TABLE WHERE A IS NOT NULL</td></tr><tr><td>LEAST</td><td>最小值运算符</td><td>在多个值中返回最小值</td><td>SELECT D FROM TABLE WHERE C LEAST(A, B)</td></tr><tr><td>GREATEST</td><td>最大值运算符</td><td>在多个值中返回最大值</td><td>SELECT D FROM TABLE WHERE C GREATEST(A, B)</td></tr><tr><td>BETWEEN … AND …</td><td>两值之间的运算符</td><td>判断一个值是否在两个值之间</td><td>SELECT D FROM TABLE WHERE C BETWEEN A AND B</td></tr><tr><td>ISNULL</td><td>为空运算符</td><td>判断一个值、字符串或表达式是否为空</td><td>SELECT B FROM TABLE WHERE A ISNULL</td></tr><tr><td>IN</td><td>属于运算符</td><td>判断一个值是否为列表中的任意一个值</td><td>SELECT D FROM TABLE WHERE C IN(A, B)</td></tr><tr><td>NOT IN</td><td>不属于运算符</td><td>判断一个值是否不是一个列表中的任意一个值</td><td>SELECT D FROM TABLE WHERE C NOT IN(A, B)</td></tr><tr><td>LIKE</td><td>模糊匹配运算符</td><td>判断一个值是否符合模糊匹配规则</td><td>SELECT C FROM TABLE WHERE A LIKE B</td></tr><tr><td>REGEXP</td><td>正则表达式运算符</td><td>判断一个值是否符合正则表达式的规则</td><td>SELECT C FROM TABLE WHERE A REGEXPB</td></tr><tr><td>RLIKE</td><td>正则表达式运算符</td><td>判断一个值是否符合正则表达式的规则</td><td>SELECT C FROM TABLE WHERE A RLIKEB</td></tr></tbody></table><p><strong>空运算符</strong></p><p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。</p><p><strong>非空运算符</strong></p><p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。</p><p><strong>最小值运算符</strong></p><p>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p><p>当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>最大值运算符</strong></p><p>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p><p>当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p><strong>BETWEEN AND运算符</strong> </p><p>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p><p><strong>IN运算符</strong> </p><p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p><p><strong>NOT IN运算符</strong></p><p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。列表中存在NULL，则结果为NULL。</p><p><strong>LIKE运算符</strong> </p><p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 </p><p>LIKE运算符通常使用如下通配符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">“<span class="hljs-operator">%</span>”：匹配<span class="hljs-number">0</span>个或多个字符。<br>“_”：只能匹配一个字符。<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">#练习：查询last_name中包含字符<span class="hljs-string">&#x27;a&#x27;</span>的员工信息<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;<br>#练习：查询last_name中以字符<span class="hljs-string">&#x27;a&#x27;</span>开头的员工信息<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br>#练习：查询第<span class="hljs-number">3</span>个字符是<span class="hljs-string">&#x27;a&#x27;</span>的员工信息<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;__a%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>ESCAPE</strong></p><ul><li>回避特殊符号的：<strong>使用转义符</strong>。</li><li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#练习：查询第<span class="hljs-number">2</span>个字符是_且第<span class="hljs-number">3</span>个字符是<span class="hljs-string">&#x27;a&#x27;</span>的员工信息<br>#需要使用转义字符: \ <br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_\_a%&#x27;</span>;<br>#或者  (了解)<br><span class="hljs-keyword">SELECT</span> last_name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_$_a%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;$&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>REGEXP运算符</strong></p><p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果NULL。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">（1）‘^’匹配以该字符后面的字符开头的字符串。<br>（2）‘$’匹配以该字符前面的字符结尾的字符串。<br>（3）‘.’匹配任何一个单字符。<br>（4）“<span class="hljs-comment">[...]</span>”匹配在方括号内的任何字符。例如，“<span class="hljs-comment">[abc]</span>”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“<span class="hljs-comment">[a-z]</span>”匹配任何字母，而“<span class="hljs-comment">[0-9]</span>”匹配任何数字。<br>（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“<span class="hljs-comment">[0-9]</span>*”匹配任何数量的数字， 而“*”匹配任何数量的任何字符。<br></code></pre></td></tr></table></figure><h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a><strong>3.</strong> <strong>逻辑运算符</strong></h4><table><thead><tr><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>NOT 或 !</td><td>逻辑非</td><td>SELECT NOT A</td></tr><tr><td>AND 或 &amp;&amp;</td><td>逻辑与</td><td>SELECT A AND B</td></tr><tr><td>OR 或 ||</td><td>逻辑或</td><td>SELECT A OR B</td></tr><tr><td>XOR</td><td>逻辑异或</td><td>SELECT A XOR B</td></tr></tbody></table><p><strong>逻辑非运算符</strong></p><p>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p><p><strong>逻辑与运算符</strong></p><p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。 </p><p><strong>逻辑或运算符</strong></p><p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p><blockquote><p>注意：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p></blockquote><p><strong>逻辑异或运算符</strong></p><p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p><h4 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a><strong>4.</strong> <strong>位运算符</strong></h4><table><thead><tr><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与（位AND）</td><td>SELECT A &amp; B</td></tr><tr><td>|</td><td>按位或（位OR）</td><td>SELECT A | B</td></tr><tr><td>^</td><td>按位异或（为XOR）</td><td>SELECT A ^ B</td></tr><tr><td>~</td><td>按位取反</td><td>SELECT  ~A</td></tr><tr><td>&gt;&gt;</td><td>按位右移</td><td>SELECT  A &gt;&gt; 2</td></tr><tr><td>&lt;&lt;</td><td>按位左移</td><td>SELECT  B &lt;&lt; 2</td></tr></tbody></table><p><strong>按位与运算符</strong></p><p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。</p><p><strong>按位或运算符</strong></p><p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p><p><strong>按位取反运算符</strong></p><p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。</p><p><strong>按位右移运算符</strong></p><p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p><p><strong>按位左移运算符</strong></p><p>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p><h3 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章 排序与分页"></a>第05章 排序与分页</h3><h4 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a><strong>1.</strong> <strong>排序数据</strong></h4><h5 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a><strong>1.1</strong> <strong>排序规则</strong></h5><ul><li>使用 ORDER BY 子句排序<ul><li><strong>ASC（ascend）:升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><strong>ORDER BY子句在SELECT语句的结尾。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 单列排序<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary; # 如果在<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 后没有显式指名排序的方式的话，则默认按照升序排列。<br># 我们可以使用列的别名，进行排序<br><span class="hljs-keyword">SELECT</span> employee_id,salary,salary <span class="hljs-operator">*</span> <span class="hljs-number">12</span> annual_sal<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> annual_sal;<br># 多列排序<br><span class="hljs-keyword">SELECT</span> employee_id,salary,department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">DESC</span>,salary <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><ul><li>可以使用不在SELECT列表中的列排序。</li><li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li></ul><h4 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a><strong>2.</strong> <strong>分页</strong></h4><h5 id="2-1-实现规则"><a href="#2-1-实现规则" class="headerlink" title="2.1 实现规则"></a><strong>2.1</strong> <strong>实现规则</strong></h5><ul><li><strong>MySQL中使用LIMIT实现分页</strong></li><li>格式：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">LIMIT [位置偏移量,] 行数<br></code></pre></td></tr></table></figure><ul><li>“偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 前10条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">10</span>; <br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 第11至20条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT <span class="hljs-number">10</span>,<span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 第21至30条记录： </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 LIMIT <span class="hljs-number">20</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><blockquote><p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p></blockquote><ul><li>分页显式公式：<strong>（当前页数-1）*每页条数，每页条数</strong></li><li><strong>注意：LIMIT子句必须放在整个SELECT语句的最后！</strong></li></ul><h3 id="第06章-多表查询"><a href="#第06章-多表查询" class="headerlink" title="第06章 多表查询"></a>第06章 多表查询</h3><h4 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a><strong>1.</strong> <strong>一个案例引发的多表连接</strong></h4><h5 id="1-1-笛卡尔积（或交叉连接）的理解"><a href="#1-1-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.1 笛卡尔积（或交叉连接）的理解"></a><strong>1.1</strong> <strong>笛卡尔积（或交叉连接）的理解</strong></h5><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p><p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是<code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#查询员工姓名和所在部门名称 <br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees,departments; <br><span class="hljs-keyword">SELECT</span> last_name,department_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> departments;<br></code></pre></td></tr></table></figure><ul><li><strong>笛卡尔积的错误会在下面条件下产生</strong>：<ul><li>省略多个表的连接条件（或关联条件）</li><li>连接条件（或关联条件）无效</li><li>所有表中的所有行互相连接</li></ul></li><li>为了避免笛卡尔积， 可以<strong>在WHERE加入有效的连接条件。</strong></li></ul><h4 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a><strong>2.</strong> <strong>多表查询分类讲解</strong></h4><p><strong>分类1：等值连接vs非等值连接</strong></p><p><strong>拓展1：区分重复的列名</strong></p><ul><li><strong>多个表中有相同列时，必须在列名之前加上表名前缀。</strong></li></ul><p><strong>拓展2：表的别名</strong></p><ul><li>使用别名可以简化查询。</li><li>列名前使用表名前缀可以提高查询效率。</li></ul><blockquote><p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p></blockquote><p><strong>拓展3：连接多个表</strong></p><ul><li><strong>连接n个表,至少需要n-1个连接条件。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#非等值连接的例子<br><span class="hljs-keyword">SELECT</span> e.last_name,e.salary,j.grade_level<br><span class="hljs-keyword">FROM</span> employees e,job_grades j<br>#<span class="hljs-keyword">where</span> e.`salary` <span class="hljs-keyword">between</span> j.`lowest_sal` <span class="hljs-keyword">and</span> j.`highest_sal`;<br><span class="hljs-keyword">WHERE</span> e.`salary` <span class="hljs-operator">&gt;=</span> j.`lowest_sal` <span class="hljs-keyword">AND</span> e.`salary` <span class="hljs-operator">&lt;=</span> j.`highest_sal`;<br></code></pre></td></tr></table></figure><p><strong>分类2：自连接vs非自连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#自连接的例子：<br>#练习：查询员工id,员工姓名及其管理者的id和姓名<br><span class="hljs-keyword">SELECT</span> emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name<br><span class="hljs-keyword">FROM</span> employees emp ,employees mgr<br><span class="hljs-keyword">WHERE</span> emp.`manager_id` <span class="hljs-operator">=</span> mgr.`employee_id`;<br></code></pre></td></tr></table></figure><p><strong>分类3：内连接  vs  外连接</strong></p><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p><ul><li>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</li><li>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</li></ul></li></ul><h4 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h4><h5 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a><strong>3.1</strong> <strong>基本语法</strong></h5><ul><li>使用JOIN…ON子句创建连接的语法结构：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.column, table2.column, table3.column<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1 和 table2 的连接条件<br><span class="hljs-keyword">JOIN</span> table3<br><span class="hljs-keyword">ON</span> table2 和 table3 的连接条件<br></code></pre></td></tr></table></figure><h5 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a><strong>3.2</strong> <strong>内连接(INNER JOIN)的实现</strong></h5><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></td></tr></table></figure><h5 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a><strong>3.3</strong> <strong>外连接(OUTER JOIN)的实现</strong></h5><h6 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a><strong>3.3.1</strong> <strong>左外连接(LEFT OUTER JOIN)</strong></h6><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></td></tr></table></figure><h6 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3.3.2 右外连接(RIGHT OUTER JOIN)"></a><strong>3.3.2</strong> <strong>右外连接(RIGHT OUTER JOIN)</strong></h6><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <br><span class="hljs-keyword">FROM</span> A表 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B表<br><span class="hljs-keyword">ON</span> 关联条件<br><span class="hljs-keyword">WHERE</span> 等其他子句;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br></code></pre></td></tr></table></figure><h4 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a><strong>4. UNION的使用</strong></h4><p><strong>UNION操作符</strong></p><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p><p><strong>UNION ALL操作符</strong></p><p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p><blockquote><p>如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p></blockquote><h4 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5. 7种SQL JOINS的实现"></a><strong>5. 7种SQL JOINS的实现</strong></h4><h5 id="5-1-举例"><a href="#5-1-举例" class="headerlink" title="5.1 举例"></a><strong>5.1 举例</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 中图：内连接<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br># 左上图：左外连接<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br># 右上图：右外连接<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br># 左中图：<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br># 右中图：<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br># 左下图：满外连接<br># 方式<span class="hljs-number">1</span>：左上图 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 右中图<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br># 方式<span class="hljs-number">2</span>：左中图 <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 右上图<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;<br># 右下图：左中图  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 右中图<br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> employee_id,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h5 id="5-2-语法格式小结"><a href="#5-2-语法格式小结" class="headerlink" title="5.2 语法格式小结"></a><strong>5.2 语法格式小结</strong></h5><ul><li>左中图</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#实现A <span class="hljs-operator">-</span> A∩B<br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>右中图</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#实现B <span class="hljs-operator">-</span> A∩B<br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>左下图</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#实现查询结果是A∪B<br>#用左外的A，<span class="hljs-keyword">union</span> 右外的B<br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 等其他子句<br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 等其他子句;<br></code></pre></td></tr></table></figure><ul><li>右下图</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#实现A∪B <span class="hljs-operator">-</span> A∩B 或 (A <span class="hljs-operator">-</span> A∩B) ∪ （B <span class="hljs-operator">-</span> A∩B）<br>#使用左外的 (A <span class="hljs-operator">-</span> A∩B) <span class="hljs-keyword">union</span> 右外的（B <span class="hljs-operator">-</span> A∩B）<br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句<br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> 字段列表<br><span class="hljs-keyword">from</span> A表 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B表<br><span class="hljs-keyword">on</span> 关联条件<br><span class="hljs-keyword">where</span> 从表关联字段 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">and</span> 等其他子句<br></code></pre></td></tr></table></figure><h4 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a><strong>6. SQL99语法新特性</strong></h4><h5 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a><strong>6.1</strong> <strong>自然连接</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`<br><span class="hljs-keyword">AND</span> e.`manager_id` <span class="hljs-operator">=</span> d.`manager_id`;<br># <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> : 它会帮你自动查询两张连接表中`所有相同的字段`，然后进行`等值连接`。<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> departments d;<br></code></pre></td></tr></table></figure><h5 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a><strong>6.2 USING连接</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id;<br># 指定数据表里的同名字段进行等值连接，只能配合<span class="hljs-keyword">JOIN</span>一起使用。<br><span class="hljs-keyword">SELECT</span> employee_id,last_name,department_name<br><span class="hljs-keyword">FROM</span> employees e <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">USING</span> (department_id);<br></code></pre></td></tr></table></figure><blockquote><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p></blockquote><h3 id="第07章-单行函数"><a href="#第07章-单行函数" class="headerlink" title="第07章 单行函数"></a>第07章 单行函数</h3><h4 id="1-数值函数"><a href="#1-数值函数" class="headerlink" title="1. 数值函数"></a><strong>1.</strong> <strong>数值函数</strong></h4><h5 id="1-1-基本函数"><a href="#1-1-基本函数" class="headerlink" title="1.1 基本函数"></a><strong>1.1</strong> <strong>基本函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIGN(X)</td><td>返回X的符号。正数返回1，负数返回-1，0返回0</td></tr><tr><td>PI()</td><td>返回圆周率的值</td></tr><tr><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr><td>RAND()</td><td>返回0~1的随机值</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机</td></tr><tr><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><h5 id="1-2-角度与弧度"><a href="#1-2-角度与弧度" class="headerlink" title="1.2 角度与弧度"></a><strong>1.2</strong> <strong>角度与弧度</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数x为角度值</td></tr><tr><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数x为弧度值</td></tr></tbody></table><h5 id="1-3-三角函数"><a href="#1-3-三角函数" class="headerlink" title="1.3 三角函数"></a><strong>1.3</strong> <strong>三角函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>SIN(x)</td><td>返回x的正弦值，其中，参数x为弧度值</td></tr><tr><td>ASIN(x)</td><td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr><td>COS(x)</td><td>返回x的余弦值，其中，参数x为弧度值</td></tr><tr><td>ACOS(x)</td><td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td></tr><tr><td>TAN(x)</td><td>返回x的正切值，其中，参数x为弧度值</td></tr><tr><td>ATAN(x)</td><td>返回x的反正切值，即返回正切值为x的值</td></tr><tr><td>ATAN2(m,n)</td><td>返回两个参数的反正切值</td></tr><tr><td>COT(x)</td><td>返回x的余切值，其中，X为弧度值</td></tr></tbody></table><h5 id="1-4-指数与对数"><a href="#1-4-指数与对数" class="headerlink" title="1.4 指数与对数"></a><strong>1.4</strong> <strong>指数与对数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>POW(x,y)，POWER(X,Y)</td><td>返回x的y次方</td></tr><tr><td>EXP(X)</td><td>返回e的X次方，其中e是一个常数，2.718281828459045</td></tr><tr><td>LN(X)，LOG(X)</td><td>返回以e为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td></tr><tr><td>LOG10(X)</td><td>返回以10为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td></tr><tr><td>LOG2(X)</td><td>返回以2为底的X的对数，当X &lt;&#x3D; 0 时，返回NULL</td></tr></tbody></table><h5 id="1-5-进制间的转换"><a href="#1-5-进制间的转换" class="headerlink" title="1.5 进制间的转换"></a><strong>1.5</strong> <strong>进制间的转换</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><h4 id="2-字符串函数"><a href="#2-字符串函数" class="headerlink" title="2. 字符串函数"></a><strong>2.</strong> <strong>字符串函数</strong></h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1,s2,……,sn)</td><td>连接s1,s2,……,sn为一个字符串</td></tr><tr><td>CONCAT_WS(x,s1,s2,……,sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td></tr><tr><td>INSERT(str, idx, len,replacestr)</td><td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td></tr><tr><td>REPLACE(str, a, b)</td><td>用字符串b替换字符串str中所有出现的字符串a</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s) 或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符，实现右对齐效果</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符，实现左对齐效果</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr><td>TRIM(s1 FROM s)</td><td>去掉字符串s开始与结尾的s1</td></tr><tr><td>TRIM(LEADING s1 FROM s)</td><td>去掉字符串s开始处的s1</td></tr><tr><td>TRIM(TRAILING s1 FROM s)</td><td>去掉字符串s结尾处的s1</td></tr><tr><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr><td>SPACE(n)</td><td>返回n个空格</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2的ASCII码值的大小</td></tr><tr><td>SUBSTR(s,index,len)</td><td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td></tr><tr><td>LOCATE(substr,str)</td><td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td></tr><tr><td>ELT(m,s1,s2,…,sn)</td><td>返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn</td></tr><tr><td>FIELD(s,s1,s2,…,sn)</td><td>返回字符串s在字符串列表中第一次出现的位置</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td></tr><tr><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td></tr></tbody></table><blockquote><p>注意：MySQL中，字符串的位置是从1开始的。</p></blockquote><h4 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3. 日期和时间函数"></a><strong>3.</strong> <strong>日期和时间函数</strong></h4><h5 id="3-1-获取日期、时间"><a href="#3-1-获取日期、时间" class="headerlink" title="3.1 获取日期、时间"></a><strong>3.1</strong> <strong>获取日期、时间</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td><strong>CURDATE()</strong> ，CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr><td><strong>CURTIME()</strong> ， CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td><strong>NOW()</strong> &#x2F; SYSDATE() &#x2F; CURRENT_TIMESTAMP() &#x2F; LOCALTIME() &#x2F; LOCALTIMESTAMP()</td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间</td></tr></tbody></table><h5 id="3-2-日期与时间戳的转换"><a href="#3-2-日期与时间戳的转换" class="headerlink" title="3.2 日期与时间戳的转换"></a><strong>3.2</strong> <strong>日期与时间戳的转换</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>UNIX_TIMESTAMP()</td><td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>将时间date以UNIX时间戳的形式返回。</td></tr><tr><td>FROM_UNIXTIME(timestamp)</td><td>将UNIX时间戳的时间转换为普通格式的时间</td></tr></tbody></table><h5 id="3-3-获取月份、星期、星期数、天数等函数"><a href="#3-3-获取月份、星期、星期数、天数等函数" class="headerlink" title="3.3 获取月份、星期、星期数、天数等函数"></a><strong>3.3</strong> <strong>获取月份、星期、星期数、天数等函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>YEAR(date) &#x2F; MONTH(date) &#x2F; DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time) &#x2F; MINUTE(time) &#x2F; SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，…</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，。。。周日是6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为1～4</td></tr><tr><td>WEEK(date) ， WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是1，周一是2，。。。周六是7</td></tr></tbody></table><h5 id="3-4-日期的操作函数"><a href="#3-4-日期的操作函数" class="headerlink" title="3.4 日期的操作函数"></a><strong>3.4</strong> <strong>日期的操作函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type指定返回的值</td></tr></tbody></table><p>EXTRACT(type FROM date)函数中type的取值与含义：</p><table><thead><tr><th align="left">type取值</th><th>含义</th></tr></thead><tbody><tr><td align="left">MICROSECOND</td><td>返回毫秒数</td></tr><tr><td align="left">SECOND</td><td>返回秒数</td></tr><tr><td align="left">MINUTE</td><td>返回分钟数</td></tr><tr><td align="left">HOUR</td><td>返回小时数</td></tr><tr><td align="left">DAY</td><td>返回天数</td></tr><tr><td align="left">WEEK</td><td>返回日期在一年中的第几个星期</td></tr><tr><td align="left">MONTH</td><td>返回日期在一年中的第几个月</td></tr><tr><td align="left">QUARTER</td><td>返回日期在一年中的第几个季度</td></tr><tr><td align="left">YEAR</td><td>返回日期的年份</td></tr><tr><td align="left">SECOND_MICROSECOND</td><td>返回秒和毫秒值</td></tr><tr><td align="left">MINUTE_MICROSECOND</td><td>返回分钟和毫秒值</td></tr><tr><td align="left">MINUTE_SECOND</td><td>返回分钟和秒值</td></tr><tr><td align="left">HOUR_MICROSECOND</td><td>返回小时和毫秒值</td></tr><tr><td align="left">HOUR_SECOND</td><td>返回小时和秒值</td></tr><tr><td align="left">HOUR_MINUTE</td><td>返回小时和分钟值</td></tr><tr><td align="left">DAY_MICROSECOND</td><td>返回天和毫秒值</td></tr><tr><td align="left">DAY_SECOND</td><td>返回天和秒值</td></tr><tr><td align="left">DAY_MINUTE</td><td>返回天和分钟值</td></tr><tr><td align="left">DAY_HOUR</td><td>返回天和小时</td></tr><tr><td align="left">YEAR_MONTH</td><td>返回年和月</td></tr></tbody></table><h5 id="3-5-时间和秒钟转换的函数"><a href="#3-5-时间和秒钟转换的函数" class="headerlink" title="3.5 时间和秒钟转换的函数"></a><strong>3.5</strong> <strong>时间和秒钟转换的函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>TIME_TO_SEC(time)</td><td>将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟*60+秒</td></tr><tr><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr></tbody></table><h5 id="3-6-计算日期和时间的函数"><a href="#3-6-计算日期和时间的函数" class="headerlink" title="3.6 计算日期和时间的函数"></a><strong>3.6</strong> <strong>计算日期和时间的函数</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr><td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td><td>返回与date相差INTERVAL时间间隔的日期</td></tr></tbody></table><p>上述函数中type的取值：</p><table><thead><tr><th>间隔类型</th><th>含义</th></tr></thead><tbody><tr><td>HOUR</td><td>小时</td></tr><tr><td>MINUTE</td><td>分钟</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月</td></tr><tr><td>DAY</td><td>日</td></tr><tr><td>YEAR_MONTH</td><td>年和月</td></tr><tr><td>DAY_HOUR</td><td>日和小时</td></tr><tr><td>DAY_MINUTE</td><td>日和分钟</td></tr><tr><td>DAY_SECOND</td><td>日和秒</td></tr><tr><td>HOUR_MINUTE</td><td>小时和分钟</td></tr><tr><td>HOUR_SECOND</td><td>小时和秒</td></tr><tr><td>MINUTE_SECOND</td><td>分钟和秒</td></tr></tbody></table><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ADDTIME(time1,time2)</td><td>返回time1加上time2的时间。当time2为一个数字时，代表的是秒 ，可以为负数</td></tr><tr><td>SUBTIME(time1,time2)</td><td>返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回date1 - date2的日期间隔天数</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>返回time1 - time2的时间间隔</td></tr><tr><td>FROM_DAYS(N)</td><td>返回从0000年1月1日起，N天以后的日期</td></tr><tr><td>TO_DAYS(date)</td><td>返回日期date距离0000年1月1日的天数</td></tr><tr><td>LAST_DAY(date)</td><td>返回date所在月份的最后一天的日期</td></tr><tr><td>MAKEDATE(year,n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr><td>MAKETIME(hour,minute,second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr><td>PERIOD_ADD(time,n)</td><td>返回time加上n后的时间</td></tr></tbody></table><h5 id="3-7-日期的格式化与解析"><a href="#3-7-日期的格式化与解析" class="headerlink" title="3.7 日期的格式化与解析"></a><strong>3.7</strong> <strong>日期的格式化与解析</strong></h5><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_FORMAT(date,fmt)</td><td>按照字符串fmt格式化日期date值</td></tr><tr><td>TIME_FORMAT(time,fmt)</td><td>按照字符串fmt格式化时间time值</td></tr><tr><td>GET_FORMAT(date_type,format_type)</td><td>返回日期字符串的显示格式</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p><table><thead><tr><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January,….）</td><td>%m</td><td>两位数字表示月份（01,02,03。。。）</td></tr><tr><td>%b</td><td>缩写的月名（Jan.，Feb.，….）</td><td>%c</td><td>数字表示月份（1,2,3,…）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td><td>%d</td><td>两位数字表示月中的天数(01,02…)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5…..）</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数，24小时制（01,02..）</td><td>%h和%I</td><td>两位数字表示小时，12小时制（01,02..）</td></tr><tr><td>%k</td><td>数字形式的小时，24小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时，12小时制（1,2,3,4….）</td></tr><tr><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02…)</td></tr><tr><td>%W</td><td>一周中的星期名称（Sunday…）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td></tr><tr><td>%w</td><td>以数字表示周中的天数(0&#x3D;Sunday,1&#x3D;Monday….)</td><td></td><td></td></tr><tr><td>%j</td><td>以3位数字表示年中的天数(001,002…)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24小时制</td><td>%r</td><td>12小时制</td></tr><tr><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><p>GET_FORMAT函数中date_type和format_type参数取值如下：</p><table><thead><tr><th>日期类型</th><th>格式化类型</th><th>返回的格式化字符串</th></tr></thead><tbody><tr><td>DATE</td><td>USA</td><td>%m.%d.%Y</td></tr><tr><td>DATE</td><td>JIS</td><td>%Y-%m-%d</td></tr><tr><td>DATE</td><td>ISO</td><td>%Y-%m-%d</td></tr><tr><td>DATE</td><td>EUR</td><td>%d.%m.%Y</td></tr><tr><td>DATE</td><td>INTERNAL</td><td>%Y%m%d</td></tr><tr><td>TIME</td><td>USA</td><td>%h:%i:%s %P</td></tr><tr><td>TIME</td><td>JIS</td><td>%H:%i:%s</td></tr><tr><td>TIME</td><td>ISO</td><td>%H:%i:%s</td></tr><tr><td>TIME</td><td>EUR</td><td>%H.%i.%s</td></tr><tr><td>TIME</td><td>INTERNAL</td><td>%H%i%s</td></tr><tr><td>DATETIME</td><td>USA</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr><td>DATETIME</td><td>JIS</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr><td>DATETIME</td><td>ISO</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr><td>DATETIME</td><td>EUR</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr><td>DATETIME</td><td>INTERNAL</td><td>%Y%m%d%H%i%s</td></tr></tbody></table><h4 id="4-流程控制函数"><a href="#4-流程控制函数" class="headerlink" title="4. 流程控制函数"></a><strong>4.</strong> <strong>流程控制函数</strong></h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>IF(value,value1,value2)</td><td>如果value的值为TRUE，返回value1，否则返回value2</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为NULL，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2…. [ELSE resultn] END</td><td>相当于Java的if…else if…else…</td></tr><tr><td>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td><td>相当于Java的switch…case…</td></tr></tbody></table><h4 id="5-加密与解密函数"><a href="#5-加密与解密函数" class="headerlink" title="5. 加密与解密函数"></a><strong>5.</strong> <strong>加密与解密函数</strong></h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密。<strong>在mysql8.0中已弃用。</strong></td></tr><tr><td>MD5(str)</td><td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td></tr><tr><td>SHA(str)</td><td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</td></tr><tr><td>ENCODE(value,password_seed)</td><td>返回使用password_seed作为加密密码加密value，<strong>在mysql8.0中已弃用。</strong></td></tr><tr><td>DECODE(value,password_seed)</td><td>返回使用password_seed作为加密密码解密value，<strong>在mysql8.0中已弃用。</strong></td></tr></tbody></table><h4 id="6-MySQL信息函数"><a href="#6-MySQL信息函数" class="headerlink" title="6. MySQL信息函数"></a><strong>6. MySQL信息函数</strong></h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><h4 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7. 其他函数"></a><strong>7.</strong> <strong>其他函数</strong></h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>FORMAT(value,n)</td><td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td></tr><tr><td>CONV(value,from,to)</td><td>将value的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的IP地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的IP地址转化为以点分隔的IP地址</td></tr><tr><td>BENCHMARK(n,expr)</td><td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将value所使用的字符编码修改为char_code</td></tr></tbody></table><h3 id="第08章-聚合函数"><a href="#第08章-聚合函数" class="headerlink" title="第08章 聚合函数"></a>第08章 聚合函数</h3><h4 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a><strong>1.</strong> <strong>聚合函数介绍</strong></h4><h5 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1.1 AVG和SUM函数"></a><strong>1.1 AVG和SUM函数</strong></h5><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary), <span class="hljs-built_in">MAX</span>(salary),<span class="hljs-built_in">MIN</span>(salary), <span class="hljs-built_in">SUM</span>(salary)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> job_id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%REP%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-operator">|</span> <span class="hljs-built_in">SUM</span>(salary) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">8272.727273</span> <span class="hljs-operator">|</span>    <span class="hljs-number">11500.00</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6000.00</span> <span class="hljs-operator">|</span>   <span class="hljs-number">273000.00</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------+-------------+-------------+-------------+</span><br></code></pre></td></tr></table></figure><h5 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1.2 MIN和MAX函数"></a><strong>1.2 MIN和MAX函数</strong></h5><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(hire_date), <span class="hljs-built_in">MAX</span>(hire_date)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">MIN</span>(hire_date) <span class="hljs-operator">|</span> <span class="hljs-built_in">MAX</span>(hire_date) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1987</span><span class="hljs-number">-06</span><span class="hljs-number">-17</span>     <span class="hljs-operator">|</span> <span class="hljs-number">2000</span><span class="hljs-number">-04</span><span class="hljs-number">-21</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span><br></code></pre></td></tr></table></figure><h5 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1.3 COUNT函数"></a><strong>1.3 COUNT函数</strong></h5><ul><li>COUNT(*)返回表中记录总数，适用于<strong>任意数据类型</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span>       <span class="hljs-number">45</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br></code></pre></td></tr></table></figure><ul><li>COUNT(expr) 返回<strong>expr不为NULL</strong>的记录总数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(commission_pct)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">COUNT</span>(commission_pct) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br><span class="hljs-operator">|</span>                     <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><br></code></pre></td></tr></table></figure><ul><li><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></li></ul><p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p><p>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</p><ul><li><strong>问题：能不能使用count(列名)替换count(*)?</strong></li></ul><p>不要使用 count(列名)来替代<code>count(*)</code>，<code>count(*) </code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p><h4 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a><strong>2. GROUP BY</strong></h4><h5 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a><strong>2.1</strong> <strong>基本使用</strong></h5><p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span>, group_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> group_by_expression]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">column</span>];<br></code></pre></td></tr></table></figure><blockquote><p><strong>明确：WHERE一定放在FROM后面</strong></p></blockquote><p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></td></tr></table></figure><p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br></code></pre></td></tr></table></figure><h5 id="2-2-使用多个列分组"><a href="#2-2-使用多个列分组" class="headerlink" title="2.2 使用多个列分组"></a><strong>2.2</strong> <strong>使用多个列分组</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id dept_id, job_id, <span class="hljs-built_in">SUM</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_id;<br></code></pre></td></tr></table></figure><p><strong>2.3 GROUP BY中使用WITH ROLLUP</strong></p><p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p></blockquote><h4 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a><strong>3. HAVING</strong></h4><h5 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a><strong>3.1</strong> <strong>基本使用</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">MAX</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>非法使用聚合函数 ： 不能在</strong> <strong>WHERE</strong> <strong>子句中使用聚合函数。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">AVG</span>(salary)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">8000</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;<br>ERROR <span class="hljs-number">1111</span> (HY000): Invalid use <span class="hljs-keyword">of</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><blockquote><p>结论：</p><p>当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。</p><p>当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。</p></blockquote><h5 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3.2 WHERE和HAVING的对比"></a><strong>3.2 WHERE和HAVING的对比</strong></h5><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><h4 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a><strong>4. SELECT的执行过程</strong></h4><h5 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4.1 查询的结构"></a><strong>4.1</strong> <strong>查询的结构</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>： <br><span class="hljs-keyword">SELECT</span> ...,....,...<br><span class="hljs-keyword">FROM</span> ...,...,....<br><span class="hljs-keyword">WHERE</span> 多表的连接条件<br><span class="hljs-keyword">AND</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,...<br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span><br>LIMIT ...,... <br><br>#方式<span class="hljs-number">2</span>：<br><span class="hljs-keyword">SELECT</span> ...,....,...<br><span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">JOIN</span> ...<br><span class="hljs-keyword">ON</span> 多表的连接条件<br><span class="hljs-keyword">JOIN</span> ...<br><span class="hljs-keyword">ON</span> ...<br><span class="hljs-keyword">WHERE</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">AND</span><span class="hljs-operator">/</span><span class="hljs-keyword">OR</span> 不包含组函数的过滤条件<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...,...<br><span class="hljs-keyword">HAVING</span> 包含组函数的过滤条件<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span><br>LIMIT ...,...<br><br>#其中： <br>#（<span class="hljs-number">1</span>）<span class="hljs-keyword">from</span>：从哪些表中筛选 <br>#（<span class="hljs-number">2</span>）<span class="hljs-keyword">on</span>：关联多表查询时，去除笛卡尔积 <br>#（<span class="hljs-number">3</span>）<span class="hljs-keyword">where</span>：从表中筛选的条件<br>#（<span class="hljs-number">4</span>）<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>：分组依据 <br>#（<span class="hljs-number">5</span>）<span class="hljs-keyword">having</span>：在统计结果中再次筛选 <br>#（<span class="hljs-number">6</span>）<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>：排序 <br>#（<span class="hljs-number">7</span>）limit：分页<br></code></pre></td></tr></table></figure><h5 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4.2 SELECT执行顺序"></a><strong>4.2 SELECT执行顺序</strong></h5><p>你需要记住 SELECT 查询时的两个顺序：</p><p><strong>1.</strong> <strong>关键字的顺序是不能颠倒的：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">HAVING</span> ... <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ... LIMIT...<br></code></pre></td></tr></table></figure><p><strong>2.SELECT</strong> <strong>语句的执行顺序</strong>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-keyword">FROM</span> ...,...<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">LEFT</span><span class="hljs-operator">/</span>RIGNT  <span class="hljs-keyword">JOIN</span>) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> LIMIT<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> player_id, player_name, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num # 顺序 <span class="hljs-number">5</span><br><span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">JOIN</span> team <span class="hljs-keyword">ON</span> player.team_id <span class="hljs-operator">=</span> team.team_id # 顺序 <span class="hljs-number">1</span><br><span class="hljs-keyword">WHERE</span> height <span class="hljs-operator">&gt;</span> <span class="hljs-number">1.80</span> # 顺序 <span class="hljs-number">2</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> player.team_id # 顺序 <span class="hljs-number">3</span><br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> # 顺序 <span class="hljs-number">4</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num <span class="hljs-keyword">DESC</span> # 顺序 <span class="hljs-number">6</span><br>LIMIT <span class="hljs-number">2</span> # 顺序 <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p><h5 id="4-3-SQL-的执行原理"><a href="#4-3-SQL-的执行原理" class="headerlink" title="4.3 SQL 的执行原理"></a><strong>4.3 SQL</strong> <strong>的执行原理</strong></h5><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li><p>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1； </p></li><li><p>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2； </p></li><li><p>添加外部行。如果我们使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</p></li></ol><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</p><p>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段 。</p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code>。</p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段 ，得到虚拟表<code>vt6</code>。</p><p>最后在 vt6 的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段 ，得到最终的结果，对应的是虚拟表<code>vt7</code>。</p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p><h3 id="第09章-子查询"><a href="#第09章-子查询" class="headerlink" title="第09章 子查询"></a>第09章 子查询</h3><h4 id="1-需求分析与问题解决"><a href="#1-需求分析与问题解决" class="headerlink" title="1. 需求分析与问题解决"></a><strong>1.</strong> <strong>需求分析与问题解决</strong></h4><h5 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1.1 实际问题"></a><strong>1.1</strong> <strong>实际问题</strong></h5><p><strong>题目：谁的工资比Abel高？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式一：<br><span class="hljs-keyword">SELECT</span> salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Abel&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> last_name,salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">11000</span>;<br><br>#方式二：自连接<br><span class="hljs-keyword">SELECT</span> e2.last_name,e2.salary <br><span class="hljs-keyword">FROM</span> employees e1,employees e2 <br><span class="hljs-keyword">WHERE</span> e1.last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Abel&#x27;</span> <br><span class="hljs-keyword">AND</span> e1.`salary` <span class="hljs-operator">&lt;</span> e2.`salary`<br><br>#方式三：子查询 <br><span class="hljs-keyword">SELECT</span> last_name,salary <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> ( <br>    <span class="hljs-keyword">SELECT</span> salary <br>    <span class="hljs-keyword">FROM</span> employees <br>    <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Abel&#x27;</span> <br>);<br></code></pre></td></tr></table></figure><h5 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1.2 子查询的基本使用"></a><strong>1.2</strong> <strong>子查询的基本使用</strong></h5><ul><li>子查询（内查询）在主查询之前一次执行完成。</li><li>子查询的结果被主查询（外查询）使用 。</li><li><strong>注意事项</strong><ul><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ul></li></ul><h5 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1.3 子查询的分类"></a><strong>1.3</strong> <strong>子查询的分类</strong></h5><p><strong>分类方式1：</strong></p><p>我们按内查询的结果返回一条还是多条记录，将子查询分为<code>单行子查询</code>、<code>多行子查询</code>。</p><p><strong>分类方式2：</strong></p><p>我们按内查询是否被执行多次，将子查询划分为<code>相关(或关联)子查询</code>和<code>不相关(或非关联)子查询</code>。</p><h4 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a><strong>2.</strong> <strong>单行子查询</strong></h4><h5 id="2-1-单行比较操作符"><a href="#2-1-单行比较操作符" class="headerlink" title="2.1 单行比较操作符"></a><strong>2.1</strong> <strong>单行比较操作符</strong></h5><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>equal to</td></tr><tr><td>&gt;</td><td>greater than</td></tr><tr><td>&gt;&#x3D;</td><td>greater than or equal to</td></tr><tr><td>&lt;</td><td>less than</td></tr><tr><td>&lt;&#x3D;</td><td>less than or equal to</td></tr><tr><td>&lt;&gt;</td><td>not equal to</td></tr></tbody></table><h5 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a><strong>2.2</strong> <strong>代码示例</strong></h5><p><strong>题目：返回公司工资最少的员工的last_name,job_id和salary</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, job_id, salary <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>    <span class="hljs-keyword">FROM</span> employees<br>);<br></code></pre></td></tr></table></figure><h5 id="2-3-HAVING-中的子查询"><a href="#2-3-HAVING-中的子查询" class="headerlink" title="2.3 HAVING 中的子查询"></a><strong>2.3 HAVING</strong> <strong>中的子查询</strong></h5><p><strong>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">MIN</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MIN</span>(salary) <span class="hljs-operator">&gt;</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span><br>);<br></code></pre></td></tr></table></figure><h5 id="2-4-CASE中的子查询"><a href="#2-4-CASE中的子查询" class="headerlink" title="2.4 CASE中的子查询"></a><strong>2.4 CASE中的子查询</strong></h5><p><strong>题目：显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, (<br>    <span class="hljs-keyword">CASE</span> department_id <br>    <span class="hljs-keyword">WHEN</span> (<br>        <span class="hljs-keyword">SELECT</span> department_id<br>        <span class="hljs-keyword">FROM</span> departments<br>        <span class="hljs-keyword">WHERE</span> location_id <span class="hljs-operator">=</span> <span class="hljs-number">1800</span><br>    ) <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Canada&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;USA&#x27;</span> <span class="hljs-keyword">END</span><br>) location<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><h5 id="2-5-子查询中的空值问题"><a href="#2-5-子查询中的空值问题" class="headerlink" title="2.5 子查询中的空值问题"></a><strong>2.5</strong> <strong>子查询中的空值问题</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> last_name, job_id<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">SELECT</span> job_id<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Haas&#x27;</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><blockquote><p><strong>子查询不返回任何行</strong></p></blockquote><h5 id="2-6-非法使用子查询"><a href="#2-6-非法使用子查询" class="headerlink" title="2.6 非法使用子查询"></a><strong>2.6</strong> <strong>非法使用子查询</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> employee_id, last_name<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">=</span> ( # 多行子查询使用单行比较符<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br>ERROR <span class="hljs-number">1242</span> (<span class="hljs-number">21000</span>): Subquery <span class="hljs-keyword">returns</span> more than <span class="hljs-number">1</span> <span class="hljs-type">row</span><br></code></pre></td></tr></table></figure><h4 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a><strong>3.</strong> <strong>多行子查询</strong></h4><h5 id="3-1-多行比较操作符"><a href="#3-1-多行比较操作符" class="headerlink" title="3.1 多行比较操作符"></a><strong>3.1</strong> <strong>多行比较操作符</strong></h5><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td></tr><tr><td>SOME</td><td>实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><h5 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a><strong>3.2</strong> <strong>代码示例</strong></h5><p><strong>题目：查询平均工资最低的部门id</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">#方式<span class="hljs-number">1</span>：<br><span class="hljs-keyword">SELECT</span> department_id <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(avg_sal) <br>    <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal <br>        <span class="hljs-keyword">FROM</span> employees <br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <br>    ) dept_avg_sal <br>);<br><br>#方式<span class="hljs-number">2</span>：<br><span class="hljs-keyword">SELECT</span> department_id <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">ALL</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) avg_sal<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <br>);<br></code></pre></td></tr></table></figure><blockquote><p>MySQL中聚合函数是不能嵌套使用的。</p></blockquote><h5 id="3-3-空值问题"><a href="#3-3-空值问题" class="headerlink" title="3.3 空值问题"></a><strong>3.3</strong> <strong>空值问题</strong></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> last_name<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">SELECT</span> manager_id<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> );<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><h4 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a><strong>4.</strong> <strong>相关子查询</strong></h4><h5 id="4-1-相关子查询执行流程"><a href="#4-1-相关子查询执行流程" class="headerlink" title="4.1 相关子查询执行流程"></a><strong>4.1</strong> <strong>相关子查询执行流程</strong></h5><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。</p><h5 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a><strong>4.2</strong> <strong>代码示例</strong></h5><p><strong>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</strong></p><p><strong>方式一：相关子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name, salary, department_id<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> e.department_id<br>);<br></code></pre></td></tr></table></figure><p><strong>方式二：在</strong> <strong>FROM</strong> <strong>中使用子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,salary,e1.department_id<br><span class="hljs-keyword">FROM</span> employees e1,(<br>    <span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-built_in">AVG</span>(salary) dept_avg_sal<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br>) e2 <br><span class="hljs-keyword">WHERE</span> e1.`department_id` <span class="hljs-operator">=</span> e2.department_id <br><span class="hljs-keyword">AND</span> e2.dept_avg_sal <span class="hljs-operator">&lt;</span> e1.`salary`;<br></code></pre></td></tr></table></figure><p>在ORDER BY 中使用子查询：</p><p><strong>题目：查询员工的id,salary,按照department_name排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,salary<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (<br>    <span class="hljs-keyword">SELECT</span> department_name <br>    <span class="hljs-keyword">FROM</span> departments d<br>    <span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id` <br>);<br></code></pre></td></tr></table></figure><blockquote><p>结论：在SELECT中，除了GROUP BY 和 LIMIT之外，其他位置都可以声明子查询！</p></blockquote><h5 id="4-3-EXISTS与NOT-EXISTS关键字"><a href="#4-3-EXISTS与NOT-EXISTS关键字" class="headerlink" title="4.3 EXISTS与NOT EXISTS关键字"></a><strong>4.3 EXISTS与NOT EXISTS关键字</strong></h5><ul><li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li><li><strong>如果在子查询中不存在满足条件的行：</strong><ul><li>条件返回 FALSE</li><li>继续在子查询中查找</li></ul></li><li><strong>如果在子查询中存在满足条件的行：</strong><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li><li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li></ul><p><strong>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><p>方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, last_name, job_id, department_id<br><span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> ( <br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br>    <span class="hljs-keyword">FROM</span> employees e2 <br>    <span class="hljs-keyword">WHERE</span> e2.manager_id <span class="hljs-operator">=</span> e1.employee_id<br>);<br></code></pre></td></tr></table></figure><p>方式二：自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.job_id, e1.department_id<br><span class="hljs-keyword">FROM</span> employees e1 <span class="hljs-keyword">JOIN</span> employees e2 <br><span class="hljs-keyword">WHERE</span> e1.employee_id <span class="hljs-operator">=</span> e2.manager_id;<br></code></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id,last_name,job_id,department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span> ( <br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> manager_id <br>    <span class="hljs-keyword">FROM</span> employees <br>);<br></code></pre></td></tr></table></figure><p><strong>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id,department_name<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-operator">=</span> e.`department_id`<br>);<br></code></pre></td></tr></table></figure><blockquote><p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p></blockquote><h3 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章 创建和管理表"></a>第10章 创建和管理表</h3><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a><strong>1.</strong> <strong>基础知识</strong></h4><h5 id="1-1-标识符命名规则"><a href="#1-1-标识符命名规则" class="headerlink" title="1.1 标识符命名规则"></a><strong>1.1</strong> <strong>标识符命名规则</strong></h5><ul><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h4 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a><strong>2.</strong> <strong>创建和管理数据库</strong></h4><h5 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a><strong>2.1</strong> <strong>创建数据库</strong></h5><ul><li>方式1：创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE 数据库名;<br></code></pre></td></tr></table></figure><ul><li>方式2：创建数据库并指定字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE 数据库名 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集;<br></code></pre></td></tr></table></figure><ul><li>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名;<br></code></pre></td></tr></table></figure><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的</p></blockquote><h5 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2.2 使用数据库"></a><strong>2.2</strong> <strong>使用数据库</strong></h5><ul><li>查看当前所有的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES; #有一个S，代表多个数据库<br></code></pre></td></tr></table></figure><ul><li>查看当前正在使用的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATABASE(); #使用的一个 mysql 中的全局函数<br></code></pre></td></tr></table></figure><ul><li>查看指定库下所有的表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES <span class="hljs-keyword">FROM</span> 数据库名;<br></code></pre></td></tr></table></figure><ul><li>查看数据库的创建信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> DATABASE 数据库名;<br>或者： <br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> DATABASE 数据库名\G<br></code></pre></td></tr></table></figure><ul><li>使用&#x2F;切换数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p></blockquote><h5 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2.3 修改数据库"></a><strong>2.3</strong> <strong>修改数据库</strong></h5><ul><li>更改数据库字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> DATABASE 数据库名 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> 字符集; #比如：gbk、utf8等<br></code></pre></td></tr></table></figure><h5 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2.4 删除数据库"></a><strong>2.4</strong> <strong>删除数据库</strong></h5><ul><li>方式1：删除指定的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名;<br></code></pre></td></tr></table></figure><ul><li>方式2：删除指定的数据库（<code>推荐</code>）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> 数据库名;<br></code></pre></td></tr></table></figure><h4 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a><strong>3.</strong> <strong>创建表</strong></h4><h5 id="3-1-创建方式1"><a href="#3-1-创建方式1" class="headerlink" title="3.1 创建方式1"></a><strong>3.1</strong> <strong>创建方式1</strong></h5><ul><li><strong>必须具备：</strong><ul><li>CREATE TABLE权限</li><li>存储空间</li></ul></li><li><strong>语法格式：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 表名( <br>    字段<span class="hljs-number">1</span> 数据类型 [约束条件] [默认值], <br>    字段<span class="hljs-number">2</span> 数据类型 [约束条件] [默认值], <br>    字段<span class="hljs-number">3</span> 数据类型 [约束条件] [默认值], <br>    ……<br>    [表约束条件] <br>);<br></code></pre></td></tr></table></figure><blockquote><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><h5 id="3-2-创建方式2"><a href="#3-2-创建方式2" class="headerlink" title="3.2 创建方式2"></a><strong>3.2</strong> <strong>创建方式2</strong></h5><ul><li>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">table</span> [(<span class="hljs-keyword">column</span>, column...)]<br><span class="hljs-keyword">AS</span> subquery;<br></code></pre></td></tr></table></figure><ul><li>指定的列和子查询中的列要一一对应</li><li>通过列名和默认值定义列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp1 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees; <br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp2 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>; <span class="hljs-comment">-- 创建的emp2是空表</span><br></code></pre></td></tr></table></figure><h5 id="3-3-查看数据表结构"><a href="#3-3-查看数据表结构" class="headerlink" title="3.3 查看数据表结构"></a><strong>3.3</strong> <strong>查看数据表结构</strong></h5><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC </code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p><p>语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名\G<br></code></pre></td></tr></table></figure><p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p><h4 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a><strong>4.</strong> <strong>修改表</strong></h4><h5 id="4-1-追加一个列"><a href="#4-1-追加一个列" class="headerlink" title="4.1 追加一个列"></a><strong>4.1</strong> <strong>追加一个列</strong></h5><p>语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] 字段名 字段类型 [<span class="hljs-keyword">FIRST</span><span class="hljs-operator">|</span>AFTER 字段名];<br></code></pre></td></tr></table></figure><h5 id="4-2-修改一个列"><a href="#4-2-修改一个列" class="headerlink" title="4.2 修改一个列"></a><strong>4.2</strong> <strong>修改一个列</strong></h5><ul><li>修改字段数据类型、长度、默认值、位置的语法格式如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>MODIFY [<span class="hljs-keyword">COLUMN</span>] 字段名<span class="hljs-number">1</span> 字段类型 [<span class="hljs-keyword">DEFAULT</span> 默认值][<span class="hljs-keyword">FIRST</span><span class="hljs-operator">|</span>AFTER 字段名 <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><ul><li>对默认值的修改只影响今后对表的修改</li></ul><h5 id="4-3-重命名一个列"><a href="#4-3-重命名一个列" class="headerlink" title="4.3 重命名一个列"></a><strong>4.3</strong> <strong>重命名一个列</strong></h5><ul><li>语法格式如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br>CHANGE [<span class="hljs-keyword">column</span>] 列名 新列名 新数据类型;<br></code></pre></td></tr></table></figure><h5 id="4-4-删除一个列"><a href="#4-4-删除一个列" class="headerlink" title="4.4 删除一个列"></a><strong>4.4</strong> <strong>删除一个列</strong></h5><ul><li>语法格式如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <br><span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] 字段名;<br></code></pre></td></tr></table></figure><h4 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a><strong>5.</strong> <strong>重命名表</strong></h4><ul><li>方式一：使用RENAME（<code>推荐</code>）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">RENAME <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">TO</span> myemp;<br></code></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> dept<br>RENAME [<span class="hljs-keyword">TO</span>] detail_dept; <span class="hljs-comment">-- [TO]可以省略</span><br></code></pre></td></tr></table></figure><h4 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a><strong>6.</strong> <strong>删除表</strong></h4><ul><li>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</li><li>数据和结构都被删除</li><li>所有正在运行的相关事务被提交</li><li>所有相关索引被删除</li><li>语法格式：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] 数据表<span class="hljs-number">1</span> [, 数据表<span class="hljs-number">2</span>, …, 数据表n];<br></code></pre></td></tr></table></figure><p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p><ul><li>DROP TABLE 语句不能回滚</li></ul><h4 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a><strong>7.</strong> <strong>清空表</strong></h4><ul><li>TRUNCATE TABLE语句：<ul><li>删除表中所有的数据</li><li>释放表的存储空间</li></ul></li><li>举例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> detail_dept;<br></code></pre></td></tr></table></figure><ul><li>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚</li><li>COMMIT:提交数据。一旦执行COMMIT，则数据就被永久的保存在了数据库中，意味着数据不可以回滚。</li><li>ROLLBACK:回滚数据。一旦执行ROLLBACK,则可以实现数据的回滚。回滚到最近的一次COMMIT之后。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span>;<br><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> emp2;<br>#<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> emp2; <br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp2;<br><span class="hljs-keyword">ROLLBACK</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp2;<br></code></pre></td></tr></table></figure><p><strong>DDL 和 DML 的说明</strong></p><ul><li><p>DDL的操作一旦执行，就不可回滚。指令SET autocommit &#x3D; FALSE对DDL操作失效。(因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit &#x3D; FALSE影响的。)</p></li><li><p>DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DML之前，执行了 SET autocommit &#x3D; FALSE，则执行的DML操作就可以实现回滚。</p></li></ul><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><h4 id="8-内容拓展"><a href="#8-内容拓展" class="headerlink" title="8. 内容拓展"></a><strong>8.</strong> <strong>内容拓展</strong></h4><p><strong>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</strong></p><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name</li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。</p><ul><li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。</p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p></li></ul><p><strong>拓展2：如何理解清空表、删除表等操作需谨慎？！</strong> </p><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操作时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用<code>ALTER TABLE</code>进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><p><strong>拓展3：MySQL8新特性—DDL的原子化</strong></p><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><h3 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章 数据处理之增删改"></a>第11章 数据处理之增删改</h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a><strong>1.</strong> <strong>插入数据</strong></h4><h5 id="1-1-方式1：VALUES的方式添加"><a href="#1-1-方式1：VALUES的方式添加" class="headerlink" title="1.1 方式1：VALUES的方式添加"></a><strong>1.1</strong> <strong>方式1：VALUES的方式添加</strong></h5><p>使用这种语法一次只能向表中插入<strong>一条</strong>数据。</p><p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <br><span class="hljs-keyword">VALUES</span> (value1,value2,....);<br></code></pre></td></tr></table></figure><p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p><p><strong>情况2：为表的指定字段插入数据（推荐）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(column1 [, column2, …, columnn]) <br><span class="hljs-keyword">VALUES</span> (value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p><p><strong>情况3：同时插入多条记录（推荐）</strong></p><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name <br><span class="hljs-keyword">VALUES</span> <br>(value1 [,value2, …, valuen]), <br>(value1 [,value2, …, valuen]), <br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name(column1 [, column2, …, columnn]) <br><span class="hljs-keyword">VALUES</span> <br>(value1 [,value2, …, valuen]), <br>(value1 [,value2, …, valuen]), <br>……<br>(value1 [,value2, …, valuen]);<br></code></pre></td></tr></table></figure><blockquote><p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p><p>VALUES 也可以写成 VALUE ，但是VALUES是标准写法。</p></blockquote><h5 id="1-2-方式2：将查询结果插入到表中"><a href="#1-2-方式2：将查询结果插入到表中" class="headerlink" title="1.2 方式2：将查询结果插入到表中"></a><strong>1.2</strong> <strong>方式2：将查询结果插入到表中</strong></h5><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p><p>基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 目标表名 (tar_column1 [, tar_column2, …, tar_columnn]) <br><span class="hljs-keyword">SELECT</span> (src_column1 [, src_column2, …, src_columnn]) <br><span class="hljs-keyword">FROM</span> 源表名<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><ul><li>在 INSERT 语句中加入子查询。</li><li><strong>不必书写</strong> <strong>VALUES</strong> <strong>子句。</strong></li><li>子查询中的值列表应与 INSERT 子句中的列名对应。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp2 <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sales_reps(id, name, salary, commission_pct) <br><span class="hljs-keyword">SELECT</span> employee_id, last_name, salary, commission_pct <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> job_id <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%REP%&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>说明：emp2表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。</p><p>如果emp2表中要添加数据的字段的长度低于employees表中查询的字段的长度的话，就有添加不成功的风险。</p></blockquote><h4 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a><strong>2.</strong> <strong>更新数据</strong></h4><ul><li>使用 UPDATE 语句更新数据。语法如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name <br><span class="hljs-keyword">SET</span> column1<span class="hljs-operator">=</span>value1, column2<span class="hljs-operator">=</span>value2, … , <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>valuen <br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><ul><li>可以一次更新<strong>多条</strong>数据。</li><li>如果需要回滚数据，需要保证在DML前，进行设置：<strong>SET AUTOCOMMIT &#x3D; FALSE;</strong></li><li>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</li><li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li></ul><h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a><strong>3.</strong> <strong>删除数据</strong></h4><ul><li>使用 DELETE 语句从表中删除数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name [<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">condition</span><span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><ul><li>使用 WHERE 子句删除指定的记录。</li><li>如果省略 WHERE 子句，则表中的全部数据将被删除</li></ul><h4 id="4-MySQL8新特性：计算列"><a href="#4-MySQL8新特性：计算列" class="headerlink" title="4. MySQL8新特性：计算列"></a><strong>4. MySQL8新特性：计算列</strong></h4><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p><p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb1( <br>    id <span class="hljs-type">INT</span>, <br>    a <span class="hljs-type">INT</span>, <br>    b <span class="hljs-type">INT</span>, <br>    c <span class="hljs-type">INT</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> (a <span class="hljs-operator">+</span> b) VIRTUAL <br>);<br></code></pre></td></tr></table></figure><p>插入演示数据，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb1(a,b) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>查询数据表tb1中的数据，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1;<br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> a    <span class="hljs-operator">|</span> b    <span class="hljs-operator">|</span> c    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>  <span class="hljs-number">100</span> <span class="hljs-operator">|</span>  <span class="hljs-number">200</span> <span class="hljs-operator">|</span>  <span class="hljs-number">300</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br></code></pre></td></tr></table></figure><p>更新数据中的数据，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> tb1 <span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1;<br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br><span class="hljs-operator">|</span> id   <span class="hljs-operator">|</span> a    <span class="hljs-operator">|</span> b    <span class="hljs-operator">|</span> c    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>  <span class="hljs-number">500</span> <span class="hljs-operator">|</span>  <span class="hljs-number">200</span> <span class="hljs-operator">|</span>  <span class="hljs-number">700</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------+------+------+------+</span><br></code></pre></td></tr></table></figure><h3 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章 MySQL数据类型精讲"></a>第12章 MySQL数据类型精讲</h3><h4 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a><strong>1. MySQL中的数据类型</strong></h4><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、**INT(或INTEGER)**、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td><strong>DECIMAL</strong></td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、<strong>DATETIME</strong>、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性，如下：</p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h4 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a><strong>2.</strong> <strong>整数类型</strong></h4><h5 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a><strong>2.1</strong> <strong>类型介绍</strong></h5><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h5 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a><strong>2.2</strong> <strong>可选属性</strong></h5><p><strong>整数类型的可选属性有三个：</strong></p><h6 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a><strong>2.2.1 M</strong></h6><p><code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“0”填满宽度，否则指定显示宽度无效。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p><h6 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a><strong>2.2.2 UNSIGNED</strong></h6><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><blockquote><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。因为负号占了一个数字位。</p></blockquote><h6 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a><strong>2.2.3 ZEROFILL</strong></h6><p><code>ZEROFILL</code>: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><h5 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a><strong>2.3</strong> <strong>适用场景</strong></h5><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p><p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h5 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a><strong>2.4</strong> <strong>如何选择？</strong></h5><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。</p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。</p><p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p><h4 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a><strong>3.</strong> <strong>浮点类型</strong></h4><h5 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a><strong>3.1</strong> <strong>类型介绍</strong></h5><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。</p><ul><li>FLOAT 表示单精度浮点数；</li><li>DOUBLE 表示双精度浮点数；</li></ul><table><thead><tr><th>类型</th><th>占用字节数</th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td></tr><tr><td>DOUBLE</td><td>8</td></tr></tbody></table><ul><li>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SET</span> sql_mode <span class="hljs-operator">=</span> “REAL_AS_FLOAT”;<br></code></pre></td></tr></table></figure><p><strong>问题1：</strong>FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题2</strong>：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p><p>MySQL 存储浮点数的格式为：<code>符号(S) 、 尾数(M) 和 阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p><h5 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3.2 数据精度说明"></a><strong>3.2</strong> <strong>数据精度说明</strong></h5><p>对于浮点类型，在MySQL中单精度值使用<code>4</code>个字节，双精度值使用<code>8</code>个字节。</p><ul><li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。</p><p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p></li><li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</p></li><li><p>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。</p></li><li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p><ul><li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li><li>如果存储时，小数点部分若超出范围，就分以下情况：<ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li><li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li></ul></li></ul></li><li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D)和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p></li></ul><blockquote><p>在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来判断两个数是否相等。</strong></p></blockquote><h4 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a><strong>4.</strong> <strong>定点数类型</strong></h4><h5 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a><strong>4.1</strong> <strong>类型介绍</strong></h5><ul><li>MySQL中的定点数类型只有 DECIMAL 一种类型。</li></ul><table><thead><tr><th>数据类型</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC</td><td>M+2字节</td><td>有效范围由M和D决定</td></tr></tbody></table><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;&#x3D;M&lt;&#x3D;65， 0&lt;&#x3D;D&lt;&#x3D;30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p><ul><li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。</p></li><li><p>定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。</p></li><li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</p></li><li><p><strong>浮点数</strong> <strong>vs</strong> <strong>定点数</strong></p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li></ul></li></ul><h5 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a><strong>4.2</strong> <strong>开发中经验</strong></h5><blockquote><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p></blockquote><h4 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a><strong>5.</strong> <strong>位类型：BIT</strong></h4><p>BIT类型中存储的是二进制值，类似010110。</p><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;&#x3D; M &lt;&#x3D; 64</td><td>约为(M + 7)&#x2F;8个字节</td></tr></tbody></table><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p><blockquote><p>使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p></blockquote><h4 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a><strong>6.</strong> <strong>日期与时间类型</strong></h4><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><ul><li><code>YEAR</code>类型通常用来表示年</li><li><code>DATE</code>类型通常用来表示年、月、日</li><li><code>TIME</code>类型通常用来表示时、分、秒</li><li><code>DATETIME</code>类型通常用来表示年、月、日、时、分、秒</li><li><code>TIMESTAMP</code>类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01  00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><h5 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a><strong>6.1 YEAR类型</strong></h5><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要<code>1个字节 </code>的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li><li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul><li>当取值为01到69时，表示2001到2069；</li><li>当取值为70到99时，表示1970到1999；</li><li>当取值整数的0或00添加的话，那么是0000年；</li><li>当取值是日期&#x2F;字符串的’0’添加的话，是2000年。</li></ul></li></ul><p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。</p><h5 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a><strong>6.2 DATE类型</strong></h5><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要<code>3个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li><li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li><li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li></ul><h5 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a><strong>6.3 TIME类型</strong></h5><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要<code>3个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。 （1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS</code>‘、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。 （2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。 （3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p><p><strong>6.4 DATETIME类型</strong> </p><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要<code>8</code>个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。 <ul><li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li><li>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li></ul></li><li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li></ul><h5 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a><strong>6.5 TIMESTAMP类型</strong></h5><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li><li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li><li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li><li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</li></ul><h5 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a><strong>6.6</strong> <strong>开发中经验</strong></h5><p>用得最多的日期时间类型，就是<code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算。</p><h4 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a><strong>7.</strong> <strong>文本字符串类型</strong></h4><h5 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a><strong>7.1 CHAR与VARCHAR类型</strong></h5><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;&#x3D; M &lt;&#x3D; 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;&#x3D; M &lt;&#x3D; 65535</td><td>(实际长度 + 1) 个字节</td></tr></tbody></table><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li></ul><p><strong>哪些情况使用</strong> <strong>CHAR</strong> <strong>或</strong> <strong>VARCHAR</strong> <strong>更好</strong></p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p><p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li><code>MyISAM</code>数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</li><li><code>MEMORY</code>存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li><li>InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且<strong>主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I&#x2F;O和数据存储总量比较好。</li></ul><h5 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a><strong>7.2 TEXT类型</strong></h5><table><thead><tr><th>文本字符串类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;&#x3D; L&lt;&#x3D; 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL不允许</strong> <strong>TEXT</strong> <strong>类型的字段做主键</strong>。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。</p><p><strong>开发中经验：</strong></p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><h4 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a><strong>8. ENUM类型</strong></h4><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;&#x3D; L &lt;&#x3D; 65535</td><td>1或2个字节</td></tr></tbody></table><ul><li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</li><li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</li><li>ENUM类型的成员个数的上限为65535个。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_enum( <br>    season ENUM(<span class="hljs-string">&#x27;春&#x27;</span>,<span class="hljs-string">&#x27;夏&#x27;</span>,<span class="hljs-string">&#x27;秋&#x27;</span>,<span class="hljs-string">&#x27;冬&#x27;</span>,<span class="hljs-string">&#x27;unknow&#x27;</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_enum <br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;春&#x27;</span>),(<span class="hljs-string">&#x27;秋&#x27;</span>);<br><br># 允许按照角标的方式获取指定索引位置的枚举值<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_enum <br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;1&#x27;</span>),(<span class="hljs-number">3</span>);<br><br># 当ENUM类型的字段没有声明为<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>时，插入<span class="hljs-keyword">NULL</span>也是有效的<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_enum<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>);<br></code></pre></td></tr></table></figure><h4 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a><strong>9. SET类型</strong></h4><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;&#x3D; L &lt;&#x3D; 8</td><td>1个字节</td></tr><tr><td>9 &lt;&#x3D; L &lt;&#x3D; 16</td><td>2个字节</td></tr><tr><td>17 &lt;&#x3D; L &lt;&#x3D; 24</td><td>3个字节</td></tr><tr><td>25 &lt;&#x3D; L &lt;&#x3D; 32</td><td>4个字节</td></tr><tr><td>33 &lt;&#x3D; L &lt;&#x3D; 64</td><td>8个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_set(<br>    s <span class="hljs-keyword">SET</span> (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_set (s)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-string">&#x27;A,B&#x27;</span>);<br>#插入重复的<span class="hljs-keyword">SET</span>类型成员时，MySQL会自动删除重复的成员 <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_set (s) <br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;A,B,C,A&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a><strong>10.</strong> <strong>二进制字符串类型</strong></h4><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p><strong>BINARY与VARBINARY类型</strong> </p><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;&#x3D; M &lt;&#x3D; 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;&#x3D; M &lt;&#x3D; 65535）</td><td>M+1个字节</td></tr></tbody></table><p><strong>BLOB类型</strong> </p><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;&#x3D; L &lt;&#x3D; 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>TEXT和BLOB的使用注意事项：</strong></p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。 </p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p><h4 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a><strong>11. JSON</strong> <strong>类型</strong></h4><p>JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON</strong> <strong>可以将</strong> <strong>JavaScript</strong> <strong>对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_json(<br>    js json <br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_json (js) <br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span> js <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;$.name&#x27;</span> <span class="hljs-keyword">AS</span> NAME,js <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;$.age&#x27;</span> <span class="hljs-keyword">AS</span> age ,js <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;$.address.province&#x27;</span> <span class="hljs-keyword">AS</span> province, js <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;$.address.city&#x27;</span> <span class="hljs-keyword">AS</span> city <br><span class="hljs-keyword">FROM</span> test_json;<br></code></pre></td></tr></table></figure><h4 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a><strong>12.</strong> <strong>空间类型</strong></h4><p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、 LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 。</p><h4 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a><strong>13.</strong> <strong>小结及选择建议</strong></h4><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code>INT</code>； 如果是<code>小数</code>，一定用定点数类型<code>DECIMAL(M,D)</code>； 如果是日期与时间，就用<code>DATETIME</code>。</p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li><p>任何字段如果为非负数，必须是 UNSIGNED</p></li><li><p>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。</p><ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。<strong>如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</strong></li></ul></li><li><p>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p><p>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li></ul><h3 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章 约束"></a>第13章 约束</h3><h4 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束(constraint)概述"></a><strong>1.</strong> <strong>约束(constraint)概述</strong></h4><h5 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1.1 为什么需要约束"></a><strong>1.1</strong> <strong>为什么需要约束</strong></h5><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男&#x2F;女” </li><li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li><li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><h5 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1.2 什么是约束"></a><strong>1.2</strong> <strong>什么是约束</strong></h5><p>约束是表级的强制规定。</p><p>可以在<strong>创建表时规定约束（通过</strong> <strong>CREATE TABLE</strong> <strong>语句）</strong>，或者在<strong>表创建之后通过</strong> <strong>ALTER TABLE</strong> <strong>语句规定约束</strong>。 </p><h5 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1.3 约束的分类"></a><strong>1.3</strong> <strong>约束的分类</strong></h5><ul><li><p><strong>根据约束数据列的限制，</strong>约束可分为：</p><ul><li><strong>单列约束</strong>：每个约束只约束一列</li><li><strong>多列约束</strong>：每个约束可约束多列数据</li></ul></li><li><p><strong>根据约束的作用范围</strong>，约束可分为：</p><ul><li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面</li><li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义</li></ul></li><li><p><strong>根据约束起的作用</strong>，约束可分为：</p><ul><li><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></li><li><strong>UNIQUE</strong> <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></li><li><strong>PRIMARY KEY</strong> <strong>主键(非空且唯一)约束</strong></li><li><strong>FOREIGN KEY</strong> <strong>外键约束</strong></li><li><strong>CHECK</strong> <strong>检查约束</strong></li><li><strong>DEFAULT</strong> <strong>默认值约束</strong></li></ul></li><li><p>查看某个表已有的约束</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#information_schema数据库名（系统库） <br>#table_constraints表名称（专门存储各个表的约束）<br>SELECT * FROM information_schema.table_constraints <br>WHERE table_name = &#x27;表名称&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a><strong>2.</strong> <strong>非空约束</strong></h4><h5 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a><strong>2.1</strong> <strong>作用</strong></h5><p>限定某个字段&#x2F;某列的值不允许为空</p><h5 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a><strong>2.2</strong> <strong>关键字</strong></h5><p>NOT NULL</p><h5 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a><strong>2.3</strong> <strong>特点</strong></h5><ul><li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串’’不等于NULL，0也不等于NULL</li></ul><h5 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2.4 添加非空约束"></a><strong>2.4</strong> <strong>添加非空约束</strong></h5><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名称( <br>    字段名 数据类型, <br>    字段名 数据类型 NOT NULL, <br>    字段名 数据类型 NOT NULL <br>);<br></code></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称 <br>MODIFY 字段名 数据类型 NOT NULL;<br></code></pre></td></tr></table></figure><h5 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a><strong>2.5</strong> <strong>删除非空约束</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 方式一：<br>ALTER TABLE 表名称 <br>MODIFY 字段名 数据类型 NULL; <br># 方式二：<br>ALTER TABLE 表名称 <br>MODIFY 字段名 数据类型;<br></code></pre></td></tr></table></figure><h4 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a><strong>3.</strong> <strong>唯一性约束</strong></h4><h5 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a><strong>3.1</strong> <strong>作用</strong></h5><p>用来限制某个字段&#x2F;某列的值不能重复。</p><h5 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a><strong>3.2</strong> <strong>关键字</strong></h5><p>UNIQUE</p><h5 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3.3 特点"></a><strong>3.3</strong> <strong>特点</strong></h5><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><h5 id="3-4-添加（复合）唯一约束"><a href="#3-4-添加（复合）唯一约束" class="headerlink" title="3.4 添加（复合）唯一约束"></a><strong>3.4</strong> <strong>添加（复合）唯一约束</strong></h5><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名称( <br>    字段名 数据类型, <br>    字段名 数据类型 UNIQUE [KEY], <br>    字段名 数据类型 <br>);<br>CREATE TABLE 表名称( <br>    字段名 数据类型, <br>    字段名 数据类型, <br>    字段名 数据类型, <br>    [CONSTRAINT 约束名] UNIQUE [KEY](字段列表)  #多个字段之间用逗号隔开<br>);<br></code></pre></td></tr></table></figure><p>（2）建表后指定唯一键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的<br>#方式1： <br>ALTER TABLE 表名称 <br>ADD [CONSTRAINT 约束名] UNIQUE [KEY](字段列表); #多个字段之间用逗号隔开<br>#方式2： <br>ALTER TABLE 表名称 <br>MODIFY 字段名 字段类型 UNIQUE [KEY];<br></code></pre></td></tr></table></figure><blockquote><p>可以向声明为unique的字段上添加null值。而且可以多次添加null</p></blockquote><h5 id="3-5-删除唯一约束"><a href="#3-5-删除唯一约束" class="headerlink" title="3.5 删除唯一约束"></a><strong>3.5</strong> <strong>删除唯一约束</strong></h5><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和(字段列表)中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称<br>DROP INDEX 索引名;<br></code></pre></td></tr></table></figure><blockquote><p>注意：可以通过<code>show index from 表名称;</code>查看表的索引</p></blockquote><h4 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a><strong>4. PRIMARY KEY</strong> <strong>约束</strong></h4><h5 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a><strong>4.1</strong> <strong>作用</strong></h5><p>用来唯一标识表中的一行记录</p><h5 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4.2 关键字"></a><strong>4.2</strong> <strong>关键字</strong></h5><p>primary key </p><h5 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a><strong>4.3</strong> <strong>特点</strong></h5><ul><li><p>主键约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值</p></li><li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p></li><li><p>主键约束对应着表中的一列或者多列（复合主键）</p></li><li><p>如果是多列组合的复合主键约束，那么这些列<strong>都不允许</strong>为空值，并且组合的值不允许重复。</p></li><li><p><strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用。</p></li><li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p></li><li><p>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p></li></ul><h5 id="4-4-添加（复合）主键约束"><a href="#4-4-添加（复合）主键约束" class="headerlink" title="4.4 添加（复合）主键约束"></a><strong>4.4</strong> <strong>添加（复合）主键约束</strong></h5><p>（1）建表时指定主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称( <br>    字段名 数据类型 primary key, #列级模式 <br>    字段名 数据类型, <br>    字段名 数据类型 <br>);<br>create table 表名称( <br>    字段名 数据类型, <br>    字段名 数据类型, <br>    字段名 数据类型, <br>    [constraint 约束名] primary key(字段列表) #表级模式，多个字段之间用逗号隔开<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 列级约束<br>CREATE TABLE emp4( <br>    id INT PRIMARY KEY AUTO_INCREMENT, # AUTO_INCREMENT 表示自增<br>    NAME VARCHAR(20) <br>);<br># 表级约束<br>CREATE TABLE emp5( <br>    id INT NOT NULL AUTO_INCREMENT, <br>    NAME VARCHAR(20), pwd VARCHAR(15), <br>    CONSTRAINT emp5_id_pk PRIMARY KEY(id) #没有必要起名字<br>);<br></code></pre></td></tr></table></figure><p>（2）建表后增加主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名称 <br>ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键<br></code></pre></td></tr></table></figure><h5 id="4-5-删除主键约束"><a href="#4-5-删除主键约束" class="headerlink" title="4.5 删除主键约束"></a><strong>4.5</strong> <strong>删除主键约束</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 <br>drop primary key;<br></code></pre></td></tr></table></figure><blockquote><p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p><p>在实际开发中，不会去删除表中的主键约束！</p></blockquote><h4 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a><strong>5.</strong> <strong>自增列：AUTO_INCREMENT</strong></h4><h5 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a><strong>5.1</strong> <strong>作用</strong></h5><p>某个字段的值自增</p><h5 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a><strong>5.2</strong> <strong>关键字</strong></h5><p>auto_increment </p><h5 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5.3 特点和要求"></a><strong>5.3</strong> <strong>特点和要求</strong></h5><p>（1）一个表最多只能有一个自增长列</p><p>（2）当需要产生唯一标识符或顺序值时，可设置自增长</p><p>（3）自增长列约束的列必须是键列（主键列，唯一键列）</p><p>（4）自增约束的列的数据类型必须是整数类型</p><p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p><h5 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5.4 如何指定自增约束"></a><strong>5.4</strong> <strong>如何指定自增约束</strong></h5><p><strong>（1）建表时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称( <br>    字段名 数据类型 primary key auto_increment, <br>    字段名 数据类型 unique key not null, <br>    字段名 数据类型 unique key, <br>    字段名 数据类型 not null default 默认值<br>);<br>create table 表名称( <br>    字段名 数据类型 default 默认值, <br>    字段名 数据类型 unique key auto_increment, <br>    字段名 数据类型 not null default 默认值, <br>    primary key(字段名) <br>);<br></code></pre></td></tr></table></figure><p><strong>（2）建表后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 auto_increment;<br></code></pre></td></tr></table></figure><h5 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5.5 如何删除自增约束"></a><strong>5.5</strong> <strong>如何删除自增约束</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束 <br>alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除<br></code></pre></td></tr></table></figure><h5 id="5-6-MySQL-8-0新特性—自增变量的持久化"><a href="#5-6-MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="5.6 MySQL 8.0新特性—自增变量的持久化"></a><strong>5.6 MySQL 8.0新特性—自增变量的持久化</strong></h5><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。</p><p>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>MySQL 8.0将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><h4 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a><strong>6. FOREIGN KEY</strong> <strong>约束</strong></h4><h5 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a><strong>6.1</strong> <strong>作用</strong></h5><p>限定某个表的某个字段的引用完整性。</p><h5 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a><strong>6.2</strong> <strong>关键字</strong></h5><p>FOREIGN KEY </p><h5 id="6-3-主表和从表-x2F-父表和子表"><a href="#6-3-主表和从表-x2F-父表和子表" class="headerlink" title="6.3 主表和从表&#x2F;父表和子表"></a><strong>6.3</strong> <strong>主表和从表&#x2F;父表和子表</strong></h5><p>主表（父表）：被引用的表，被参考的表</p><p>从表（子表）：引用别人的表，参考别人的表</p><h5 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6.4 特点"></a><strong>6.4</strong> <strong>特点</strong></h5><p>（1）从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列</p><p>为什么？因为被依赖&#x2F;被参考的值必须是唯一的</p><p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如student_ibfk_1;），也可以指定外键约束名。</p><p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p><p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p><p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p><p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p><p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p><p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）</p><p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p><h5 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6.5 添加外键约束"></a><strong>6.5</strong> <strong>添加外键约束</strong></h5><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 主表名称( <br>    字段1 数据类型 primary key, <br>    字段2 数据类型 <br>);<br>create table 从表名称( <br>    字段1 数据类型 primary key, <br>    字段2 数据类型, <br>    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) <br>);<br>#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样<br>#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样<br>-- FOREIGN KEY: 在表级指定子表中的列<br>-- REFERENCES: 标示在父表中的列<br></code></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 从表名 <br>ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx];<br></code></pre></td></tr></table></figure><p>总结：约束关系是针对双方的</p><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h5 id="6-6-约束等级"><a href="#6-6-约束等级" class="headerlink" title="6.6 约束等级"></a><strong>6.6</strong> <strong>约束等级</strong></h5><ul><li><code>Cascade方式</code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</li><li><code>Set null方式</code>：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null </li><li><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</li><li><code>Restrict方式</code>：同no action， 都是立即检查外键约束</li><li><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</li></ul><p>如果没有指定等级，就相当于Restrict方式。</p><p>对于外键约束，最好是采用:<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table emp( <br>    eid int primary key, #员工编号 <br>    ename varchar(5), #员工姓名 <br>    deptid int, #员工所在的部门<br>    foreign key (deptid) references dept(did) ON UPDATE CASCADE ON DELETE RESTRICT #把修改操作设置为级联修改等级，把删除操作设置为Restrict等级 <br>);<br></code></pre></td></tr></table></figure><h5 id="6-7-删除外键约束"><a href="#6-7-删除外键约束" class="headerlink" title="6.7 删除外键约束"></a><strong>6.7</strong> <strong>删除外键约束</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># (1)第一步先查看约束名和删除外键约束 <br>SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名 <br>ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; <br>#（2）第二步查看索引名和删除索引。（注意，只能手动删除） <br>SHOW INDEX FROM 表名称; #查看某个表的索引名 <br>ALTER TABLE 从表名 DROP INDEX 索引名;<br></code></pre></td></tr></table></figure><h5 id="6-8-开发场景"><a href="#6-8-开发场景" class="headerlink" title="6.8 开发场景"></a><strong>6.8</strong> <strong>开发场景</strong></h5><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p><p>答：不是的</p><p><strong>问题2：建和不建外键约束有什么区别？</strong></p><p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p><p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p><p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p><p>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><h5 id="6-9-阿里开发规范"><a href="#6-9-阿里开发规范" class="headerlink" title="6.9 阿里开发规范"></a><strong>6.9</strong> <strong>阿里开发规范</strong></h5><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p><h4 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a><strong>7. CHECK</strong> <strong>约束</strong></h4><h5 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a><strong>7.1</strong> <strong>作用</strong></h5><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p><h5 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7.2 关键字"></a><strong>7.2 关键字</strong></h5><p>CHECK</p><h5 id="7-3-说明：MySQL-5-7-不支持"><a href="#7-3-说明：MySQL-5-7-不支持" class="headerlink" title="7.3 说明：MySQL 5.7 不支持"></a><strong>7.3 说明：MySQL 5.7</strong> <strong>不支持</strong></h5><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p><p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE temp( <br>    id INT AUTO_INCREMENT, <br>    NAME VARCHAR(20), <br>    age INT CHECK(age &gt; 20), <br>    gender char CHECK (&#x27;男&#x27; OR &#x27;女&#x27;),<br>    PRIMARY KEY(id) <br>);<br></code></pre></td></tr></table></figure><h4 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a><strong>8. DEFAULT约束</strong></h4><h5 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a><strong>8.1</strong> <strong>作用</strong></h5><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h5 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a><strong>8.2</strong> <strong>关键字</strong></h5><p>DEFAULT</p><h5 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8.3 如何给字段加默认值"></a><strong>8.3</strong> <strong>如何给字段加默认值</strong></h5><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名称(<br>    字段名 数据类型 default 默认值 , <br>    字段名 数据类型 not null default 默认值, <br>    字段名 数据类型 not null default 默认值, <br>    primary key(字段名),<br>    unique key(字段名) <br>);<br># 说明：默认值约束一般不在唯一键和主键列上加<br></code></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 <br>modify 字段名 数据类型 default 默认值; <br>#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了 <br>#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了 <br>alter table 表名称 modify 字段名 数据类型 default 默认值 not null;<br></code></pre></td></tr></table></figure><h5 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8.4 如何删除默认值约束"></a><strong>8.4</strong> <strong>如何删除默认值约束</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 <br>alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束<br></code></pre></td></tr></table></figure><h4 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a><strong>9.</strong> <strong>面试</strong></h4><p><strong>面试1、为什么建表时，加 not null default ‘’ 或 default 0</strong></p><p>答：不想让表中出现null值。</p><p><strong>面试2、为什么不想要</strong> <strong>null</strong> <strong>的值</strong></p><p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。 </p><p>（2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p><p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong> </p><p>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p><p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong> </p><p>外键约束（FOREIGN KEY）不能跨引擎使用。</p><p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p><h3 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章 视图"></a>第14章 视图</h3><h4 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a><strong>1.</strong> <strong>常见的数据库对象</strong></h4><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table><h4 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a><strong>2.</strong> <strong>视图概述</strong></h4><h5 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2.1 为什么使用视图？"></a><strong>2.1</strong> <strong>为什么使用视图？</strong></h5><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p><h5 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2.2 视图的理解"></a><strong>2.2</strong> <strong>视图的理解</strong></h5><ul><li>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</li><li><strong>视图建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong>。</li><li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li><li>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong><ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li></ul></li><li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li></ul><h4 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a><strong>3.</strong> <strong>创建视图</strong></h4><ul><li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [OR REPLACE] <br>[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] <br>VIEW 视图名称 [(字段列表)] <br>AS 查询语句 <br>[WITH [CASCADED|LOCAL] CHECK OPTION]<br></code></pre></td></tr></table></figure><ul><li>精简版</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW 视图名称 <br>AS 查询语句<br></code></pre></td></tr></table></figure><h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a><strong>4.</strong> <strong>查看视图</strong></h4><p>语法1：查看数据库的表对象、视图对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure><p>语法2：查看视图的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC / DESCRIBE 视图名称;<br></code></pre></td></tr></table></figure><p>语法3：查看视图的属性信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等） <br>SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G<br></code></pre></td></tr></table></figure><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法4：查看视图的详细定义信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW 视图名称;<br></code></pre></td></tr></table></figure><h4 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a><strong>5.</strong> <strong>更新视图的数据</strong></h4><h5 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5.1 一般情况"></a><strong>5.1</strong> <strong>一般情况</strong></h5><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><h5 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5.2 不可更新的视图"></a><strong>5.2</strong> <strong>不可更新的视图</strong></h5><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE；</li><li>视图定义基于一个<code>不可更新视图</code>；</li><li>常量视图</li></ul><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p></blockquote><h4 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a><strong>6.</strong> <strong>修改、删除视图</strong></h4><h5 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6.1 修改视图"></a><strong>6.1</strong> <strong>修改视图</strong></h5><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p><p>方式2：ALTER VIEW</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER VIEW 视图名称 <br>AS<br>查询语句<br></code></pre></td></tr></table></figure><h5 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6.2 删除视图"></a><strong>6.2</strong> <strong>删除视图</strong></h5><ul><li>删除视图只是删除视图的定义，并不会删除基表的数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS 视图名称;<br></code></pre></td></tr></table></figure><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7.</strong> <strong>总结</strong></h4><h5 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7.1 视图优点"></a><strong>7.1</strong> <strong>视图优点</strong></h5><p><strong>1.</strong> <strong>操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2.</strong> <strong>减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3.</strong> <strong>数据安全</strong></p><p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p><p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4.</strong> <strong>适应灵活多变的需求</strong> 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5.</strong> <strong>能够分解复杂的查询逻辑</strong> 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><h5 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7.2 视图不足"></a><strong>7.2</strong> <strong>视图不足</strong></h5><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h3 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章 存储过程与函数"></a>第15章 存储过程与函数</h3><h4 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a><strong>1.</strong> <strong>存储过程概述</strong></h4><h5 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a><strong>1.1</strong> <strong>理解</strong></h5><p><strong>含义</strong>：存储过程的英文是<code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><h4 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a><strong>2.</strong> <strong>创建存储过程</strong></h4><h5 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2.1 语法分析"></a><strong>2.1</strong> <strong>语法分析</strong></h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) <br>[characteristics ...] <br>BEGIN<br>存储过程体 <br>END<br></code></pre></td></tr></table></figure><p>说明：</p><p>1、参数前面的符号的意思</p><ul><li><code>IN</code>：当前参数为输入参数，也就是表示入参；<ul><li>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</li></ul></li><li><code>OUT</code>：当前参数为输出参数，也就是表示出参；<ul><li>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li></ul></li><li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li></ul><p>2、形参类型可以是 MySQL数据库中的任意类型。</p><p>3、<code>characteristics</code>表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LANGUAGE SQL <br>| [NOT] DETERMINISTIC <br>| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; <br>| SQL SECURITY &#123; DEFINER | INVOKER &#125; <br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure><ul><li><p><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。 </p></li><li><p><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p></li><li><p><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。</p><ul><li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li><li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li><li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li><li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li><li>默认情况下，系统会指定为CONTAINS SQL。</li></ul></li><li><p><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p><ul><li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li><li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li></ul></li><li><p><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</p></li></ul><p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p><p>5、需要设置新的结束标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER 新的结束标记<br></code></pre></td></tr></table></figure><h5 id="2-2-代码举例"><a href="#2-2-代码举例" class="headerlink" title="2.2 代码举例"></a><strong>2.2</strong> <strong>代码举例</strong></h5><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $ <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> select_all_data() <br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emps; <br><span class="hljs-keyword">END</span> $ <br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE PROCEDURE avg_employee_salary () <br>BEGIN<br>SELECT AVG(salary) AS avg_salary FROM emps; <br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE PROCEDURE show_max_salary() <br>    LANGUAGE SQL<br>    NOT DETERMINISTIC<br>    CONTAINS SQL <br>    SQL SECURITY DEFINER <br>    COMMENT &#x27;查看最高薪资&#x27; <br>BEGIN<br>SELECT MAX(salary) FROM emps;<br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例4：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE) <br>BEGIN<br>SELECT salary INTO empsalary FROM emps WHERE ename = empname; <br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>举例5：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20)) <br>BEGIN<br>SELECT ename INTO empname FROM emps WHERE eid = (SELECT MID FROM emps WHERE ename=empname); <br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><h4 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a><strong>3.</strong> <strong>调用存储过程</strong></h4><h5 id="3-1-调用格式"><a href="#3-1-调用格式" class="headerlink" title="3.1 调用格式"></a><strong>3.1</strong> <strong>调用格式</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL 存储过程名(实参列表)<br></code></pre></td></tr></table></figure><p><strong>格式：</strong></p><p>1、调用in模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL sp1(&#x27;值&#x27;);<br></code></pre></td></tr></table></figure><p>2、调用out模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @name; <br>CALL sp1(@name); <br>SELECT @name;<br></code></pre></td></tr></table></figure><p>3、调用inout模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @name=值; <br>CALL sp1(@name); <br>SELECT @name;<br></code></pre></td></tr></table></figure><h4 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a><strong>4.</strong> <strong>存储函数的使用</strong></h4><h5 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4.1 语法分析"></a><strong>4.1</strong> <strong>语法分析</strong></h5><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION 函数名(参数名 参数类型,...) <br>RETURNS 返回值类型 <br>[characteristics ...] <br>BEGIN<br>函数体 #函数体中肯定有 RETURN 语句 <br>END<br></code></pre></td></tr></table></figure><p>说明：</p><p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p><p>2、RETURNS type 语句表示函数返回数据的类型；</p><p>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p><p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p><p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p><h5 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4.2 调用存储函数"></a><strong>4.2</strong> <strong>调用存储函数</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 函数名(实参列表)<br></code></pre></td></tr></table></figure><h5 id="4-3-代码举例"><a href="#4-3-代码举例" class="headerlink" title="4.3 代码举例"></a><strong>4.3</strong> <strong>代码举例</strong></h5><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE FUNCTION count_by_id(dept_id INT) <br>RETURNS INT <br>LANGUAGE SQL <br>NOT DETERMINISTIC <br>READS SQL DATA <br>SQL SECURITY DEFINER <br>COMMENT &#x27;查询部门平均工资&#x27; <br>BEGIN<br>RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id); <br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @dept_id = 50; <br>SELECT count_by_id(@dept_id);<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p><ul><li>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</li><li>方式2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;<br></code></pre></td></tr></table></figure><h5 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4.4 对比存储函数和存储过程"></a><strong>4.4</strong> <strong>对比存储函数和存储过程</strong></h5><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有0个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p><h4 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a><strong>5.</strong> <strong>存储过程和函数的查看、修改、删除</strong></h4><h5 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5.1 查看"></a><strong>5.1</strong> <strong>查看</strong></h5><p><strong>1.</strong> <strong>使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]<br></code></pre></td></tr></table></figure><p><strong>3.</strong> <strong>从information_schema.Routines表中查看存储过程和函数的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.Routines <br>WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];<br></code></pre></td></tr></table></figure><h5 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5.2 修改"></a><strong>5.2</strong> <strong>修改</strong></h5><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...];<br></code></pre></td></tr></table></figure><p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; <br>| SQL SECURITY &#123; DEFINER | INVOKER &#125; <br>| COMMENT &#x27;string&#x27;<br></code></pre></td></tr></table></figure><h5 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a><strong>5.3</strong> <strong>删除</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名;<br></code></pre></td></tr></table></figure><h4 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a><strong>6.</strong> <strong>关于存储过程使用的争议</strong></h4><h5 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a><strong>6.1</strong> <strong>优点</strong></h5><p><strong>1、存储过程可以一次编译多次使用。</strong>存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p><p><strong>2、可以减少开发工作量。</strong>将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</p><p><strong>3、存储过程的安全性强。</strong>我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</p><p><strong>4、可以减少网络传输量。</strong>因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p><p><strong>5、良好的封装性。</strong>在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。 </p><h5 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a><strong>6.2</strong> <strong>缺点</strong></h5><blockquote><p><strong>阿里开发规范</strong></p><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><p><strong>1、可移植性差。</strong>存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p><p><strong>2、调试困难。</strong>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p><p><strong>3、存储过程的版本管理很困难。</strong>比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p><p><strong>4、它不适合高并发的场景。</strong>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了。</p><p>小结：</p><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p><h3 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章 变量、流程控制与游标"></a>第16章 变量、流程控制与游标</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a><strong>1.</strong> <strong>变量</strong></h4><h5 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1.1 系统变量"></a><strong>1.1</strong> <strong>系统变量</strong></h5><h6 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1.1.1 系统变量分类"></a><strong>1.1.1</strong> <strong>系统变量分类</strong></h6><p>系统变量分为全局系统变量（需要添加<code>global</code>关键字）以及会话系统变量（需要添加<code>session</code>关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。<strong>如果不写，默认会话级别。</strong>静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p><ul><li><p>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></p></li><li><p>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</p></li><li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</p></li></ul><h6 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1.1.2 查看系统变量"></a><strong>1.1.2</strong> <strong>查看系统变量</strong></h6><ul><li><strong>查看所有或部分系统变量</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看所有全局变量 <br>SHOW GLOBAL VARIABLES; <br>#查看所有会话变量 <br>SHOW SESSION VARIABLES; <br>#或<br>SHOW VARIABLES;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看满足条件的部分系统变量。 <br>SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;<br>#查看满足条件的部分会话变量 <br>SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;;<br></code></pre></td></tr></table></figure><ul><li><strong>查看指定系统变量</strong></li></ul><p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看指定的系统变量的值 <br>SELECT @@global.变量名; <br>#查看指定的会话变量的值 <br>SELECT @@session.变量名; <br>#或者 <br>SELECT @@变量名;<br></code></pre></td></tr></table></figure><ul><li><strong>修改系统变量的值</strong></li></ul><p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p><p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#为某个系统变量赋值 <br>#方式1： <br>SET @@global.变量名=变量值; <br>#方式2： <br>SET GLOBAL 变量名=变量值;<br>#为某个会话变量赋值 <br>#方式1： <br>SET @@session.变量名=变量值; <br>#方式2： <br>SET SESSION 变量名=变量值;<br></code></pre></td></tr></table></figure><h5 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1.2 用户变量"></a><strong>1.2</strong> <strong>用户变量</strong></h5><h6 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1.2.1 用户变量分类"></a><strong>1.2.1</strong> <strong>用户变量分类</strong></h6><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p><ul><li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li></ul><h6 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1.2.2 会话用户变量"></a><strong>1.2.2</strong> <strong>会话用户变量</strong></h6><ul><li>变量的定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方式1：“=”或“:=” <br>SET @用户变量 = 值; <br>SET @用户变量 := 值; <br>#方式2：“:=” 或 INTO关键字 <br>SELECT @用户变量 := 表达式 [FROM 等子句]; <br>SELECT 表达式 INTO @用户变量 [FROM 等子句];<br></code></pre></td></tr></table></figure><ul><li>查看用户变量的值 （查看、比较、运算等）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @用户变量<br></code></pre></td></tr></table></figure><h6 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1.2.3 局部变量"></a><strong>1.2.3</strong> <strong>局部变量</strong></h6><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN<br>#声明局部变量 <br>DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值]; <br>DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];<br>    #为局部变量赋值 <br>    SET 变量名1 = 值; <br>    SELECT 值 INTO 变量名2 [FROM 子句]; <br>    #查看局部变量的值 <br>    SELECT 变量1,变量2,变量3; <br>END<br></code></pre></td></tr></table></figure><p><strong>1.定义变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL<br></code></pre></td></tr></table></figure><p><strong>2.变量赋值</strong></p><p>方式1：一般用于赋简单的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET 变量名=值; <br>SET 变量名:=值;<br></code></pre></td></tr></table></figure><p>方式2：一般用于赋表中的字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段名或表达式 INTO 变量名 FROM 表;<br></code></pre></td></tr></table></figure><p><strong>3.使用变量</strong>（查看、比较、运算等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 局部变量名;<br></code></pre></td></tr></table></figure><h6 id="1-2-4-对比会话用户变量与局部变量"><a href="#1-2-4-对比会话用户变量与局部变量" class="headerlink" title="1.2.4 对比会话用户变量与局部变量"></a><strong>1.2.4</strong> <strong>对比会话用户变量与局部变量</strong></h6><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>会话用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的BEGIN END中</td><td>BEGIN END的第一句话</td><td>一般不用加@,需要指定类型</td></tr></tbody></table><h4 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a><strong>2.</strong> <strong>定义条件与处理程序</strong></h4><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><p>在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p><h5 id="2-1-定义条件"><a href="#2-1-定义条件" class="headerlink" title="2.1 定义条件"></a><strong>2.1</strong> <strong>定义条件</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）<br></code></pre></td></tr></table></figure><p>错误码的说明：</p><ul><li><p><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。</p><ul><li>MySQL_error_code是数值类型错误代码。</li><li>sqlstate_value是长度为5的字符串类型错误代码。</li></ul></li><li><p>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#使用MySQL_error_code <br>DECLARE Field_Not_Be_NULL CONDITION FOR 1048; <br>#使用sqlstate_value <br>DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-2-定义处理程序"><a href="#2-2-定义处理程序" class="headerlink" title="2.2 定义处理程序"></a><strong>2.2</strong> <strong>定义处理程序</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句<br></code></pre></td></tr></table></figure><ul><li><p><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。 </p><ul><li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li><li><code>EXIT</code>：表示遇到错误马上退出。</li><li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li></ul></li><li><p><strong>错误类型</strong>（即条件）可以有如下取值：</p><ul><li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为5的sqlstate_value类型的错误代码； </li><li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li><li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li><li><code>SQLWARNING</code>：匹配所有以01开头的SQLSTATE错误代码；</li><li><code>NOT FOUND</code>：匹配所有以02开头的SQLSTATE错误代码；</li><li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li></ul></li><li><p><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</p></li></ul><p>定义处理程序的几种方式，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#方法1：捕获sqlstate_value <br>DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;; <br>#方法2：捕获mysql_error_value <br>DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;; <br>#方法3：先定义条件，再调用 <br>DECLARE no_such_table CONDITION FOR 1146;<br>DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;; <br>#方法4：使用SQLWARNING <br>DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;; <br>#方法5：使用NOT FOUND <br>DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;; <br>#方法6：使用SQLEXCEPTION <br>DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;<br></code></pre></td></tr></table></figure><h4 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a><strong>3.</strong> <strong>流程控制</strong></h4><h5 id="3-1-分支结构之-IF"><a href="#3-1-分支结构之-IF" class="headerlink" title="3.1 分支结构之 IF"></a><strong>3.1</strong> <strong>分支结构之</strong> <strong>IF</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF 表达式1 THEN 操作1 <br>[ELSEIF 表达式2 THEN 操作2]…… <br>[ELSE 操作N] <br>END IF<br></code></pre></td></tr></table></figure><h5 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a><strong>3.2</strong> <strong>分支结构之</strong> <strong>CASE</strong></h5><p>CASE 语句的语法结构1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#情况一：类似于switch <br>CASE 表达式 <br>WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) <br>WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号) <br>... <br>ELSE 结果n或语句n(如果是语句，需要加分号) <br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure><p>CASE 语句的语法结构2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#情况二：类似于多重if <br>CASE <br>WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) <br>WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号) <br>... <br>ELSE 结果n或语句n(如果是语句，需要加分号) <br>END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）<br></code></pre></td></tr></table></figure><h5 id="3-3-循环结构之LOOP"><a href="#3-3-循环结构之LOOP" class="headerlink" title="3.3 循环结构之LOOP"></a><strong>3.3</strong> <strong>循环结构之LOOP</strong></h5><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[loop_label:] LOOP <br>循环执行的语句 <br>END LOOP [loop_label]<br></code></pre></td></tr></table></figure><h5 id="3-4-循环结构之WHILE"><a href="#3-4-循环结构之WHILE" class="headerlink" title="3.4 循环结构之WHILE"></a><strong>3.4</strong> <strong>循环结构之WHILE</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[while_label:] WHILE 循环条件 DO <br>循环体 <br>END WHILE [while_label];<br></code></pre></td></tr></table></figure><h5 id="3-5-循环结构之REPEAT"><a href="#3-5-循环结构之REPEAT" class="headerlink" title="3.5 循环结构之REPEAT"></a><strong>3.5</strong> <strong>循环结构之REPEAT</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[repeat_label:] REPEAT <br>循环体的语句 <br>UNTIL 结束循环的条件表达式 <br>END REPEAT [repeat_label]<br></code></pre></td></tr></table></figure><p><strong>对比三种循环结构：</strong></p><p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。 2、 LOOP：一般用于实现简单的”死”循环；WHILE：先判断后执行；REPEAT：先执行后判断，无条件至少执行一次。</p><h5 id="3-6-跳转语句之LEAVE语句"><a href="#3-6-跳转语句之LEAVE语句" class="headerlink" title="3.6 跳转语句之LEAVE语句"></a><strong>3.6</strong> <strong>跳转语句之LEAVE语句</strong></h5><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LEAVE 标记名<br></code></pre></td></tr></table></figure><h5 id="3-7-跳转语句之ITERATE语句"><a href="#3-7-跳转语句之ITERATE语句" class="headerlink" title="3.7 跳转语句之ITERATE语句"></a><strong>3.7</strong> <strong>跳转语句之ITERATE语句</strong></h5><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ITERATE label<br></code></pre></td></tr></table></figure><h4 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a><strong>4.</strong> <strong>游标</strong></h4><h5 id="4-1-什么是游标（或光标）"><a href="#4-1-什么是游标（或光标）" class="headerlink" title="4.1 什么是游标（或光标）"></a><strong>4.1</strong> <strong>什么是游标（或光标）</strong></h5><p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让</strong> <strong>SQL</strong> <strong>这种面向集合的语言有了面向过程开发的能力。</strong></p><h5 id="4-2-使用游标步骤"><a href="#4-2-使用游标步骤" class="headerlink" title="4.2 使用游标步骤"></a><strong>4.2</strong> <strong>使用游标步骤</strong></h5><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。</p><p><strong>第一步，声明游标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DECLARE cursor_name CURSOR FOR select_statement;<br></code></pre></td></tr></table></figure><p><strong>第二步，打开游标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OPEN cursor_name<br></code></pre></td></tr></table></figure><p><strong>第三步，使用游标（从游标中取得数据）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FETCH cursor_name INTO var_name [, var_name] ...<br></code></pre></td></tr></table></figure><p>注意：<strong>游标的查询结果集中的字段数，必须跟</strong> <strong>INTO</strong> <strong>后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p><p><strong>第四步，关闭游标</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CLOSE cursor_name<br></code></pre></td></tr></table></figure><p>当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。</p><h5 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a><strong>4.3</strong> <strong>小结</strong></h5><p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p><p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行<code>加锁</code>，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p><p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h4 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a><strong>补充：MySQL 8.0的新特性—全局变量的持久化</strong></h4><p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了<code>SET PERSIST</code>命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PERSIST global max_connections = 1000;<br></code></pre></td></tr></table></figure><p>MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><h3 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章 触发器"></a>第17章 触发器</h3><h4 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a><strong>1.</strong> <strong>触发器概述</strong></h4><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h4 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a><strong>2.</strong> <strong>触发器的创建</strong></h4><h5 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2.1 创建触发器语法"></a><strong>2.1</strong> <strong>创建触发器语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER 触发器名称 <br>&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 <br>FOR EACH ROW <br>触发器执行的语句块;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>表名</code>：表示触发器监控的对象。</li><li><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li><li><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。<ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER // <br>CREATE TRIGGER before_insert <br>BEFORE INSERT ON test_trigger <br>FOR EACH ROW <br>BEGIN<br>INSERT INTO test_trigger_log (t_log) <br>VALUES(&#x27;before_insert&#x27;); <br>END // <br>DELIMITER ;<br></code></pre></td></tr></table></figure><h4 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a><strong>3.</strong> <strong>查看、删除触发器</strong></h4><h5 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3.1 查看触发器"></a><strong>3.1</strong> <strong>查看触发器</strong></h5><p>方式1：查看当前数据库的所有触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS\G<br></code></pre></td></tr></table></figure><p>方式2：查看当前数据库中某个触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TRIGGER 触发器名<br></code></pre></td></tr></table></figure><p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM information_schema.TRIGGERS;<br></code></pre></td></tr></table></figure><h5 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3.2 删除触发器"></a><strong>3.2</strong> <strong>删除触发器</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TRIGGER IF EXISTS 触发器名称;<br></code></pre></td></tr></table></figure><h4 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a><strong>4.</strong> <strong>触发器的优缺点</strong></h4><h5 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a><strong>4.1</strong> <strong>优点</strong></h5><p><strong>1、触发器可以确保数据的完整性</strong>。</p><p><strong>2、触发器可以帮助我们记录操作日志。</strong></p><p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p><h5 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a><strong>4.2</strong> <strong>缺点</strong></h5><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p><p>比如触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是表的结构出了问题。</p><p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p><p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p><h5 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a><strong>4.3</strong> <strong>注意点</strong></h5><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE&#x2F;DELETE CASCADE&#x2F;SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><h3 id="第18章-MySQL8其它新特性"><a href="#第18章-MySQL8其它新特性" class="headerlink" title="第18章 MySQL8其它新特性"></a>第18章 MySQL8其它新特性</h3><h4 id="1-新特性1：窗口函数"><a href="#1-新特性1：窗口函数" class="headerlink" title="1. 新特性1：窗口函数"></a><strong>1.</strong> <strong>新特性1：窗口函数</strong></h4><h5 id="1-1-窗口函数分类"><a href="#1-1-窗口函数分类" class="headerlink" title="1.1 窗口函数分类"></a><strong>1.1</strong> <strong>窗口函数分类</strong></h5><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p><ul><li><p>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</p></li><li><p>动态窗口函数的窗口大小会随着记录的不同而变化。</p></li></ul><table><thead><tr><th>函数分类</th><th>函数</th><th>函数说明</th></tr></thead><tbody><tr><td>序号函数</td><td>ROW_NUMBER()</td><td>顺序排序</td></tr><tr><td></td><td>RANK()</td><td>并列排序，会跳过重复的序号，比如序号为1、1、3</td></tr><tr><td></td><td>DENSE_RANK()</td><td>并列排序，不会跳过重复的序号，比如序号为1、1、2</td></tr><tr><td>分布函数</td><td>PERCENT_RANK()</td><td>等级值百分比</td></tr><tr><td></td><td>CUME_DIST()</td><td>累积分布值</td></tr><tr><td>前后函数</td><td>LAG(expr, n)</td><td>返回当前行的前n行的expr的值</td></tr><tr><td></td><td>LEAD(expr, n)</td><td>返回当前行的后n行的expr的值</td></tr><tr><td>首尾函数</td><td>FIRST_VALUE(expr)</td><td>返回第一个expr的值</td></tr><tr><td></td><td>LAST_VALUE(expr)</td><td>返回最后一个expr的值</td></tr><tr><td>其他函数</td><td>NTH_VALUE(expr, n)</td><td>返回第n个expr的值</td></tr><tr><td></td><td>NTILE(n)</td><td>将分区中的有序数据分为n个桶，记录桶编号</td></tr></tbody></table><h5 id="1-2-语法结构"><a href="#1-2-语法结构" class="headerlink" title="1.2 语法结构"></a><strong>1.2</strong> <strong>语法结构</strong></h5><p>窗口函数的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<br></code></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）<br></code></pre></td></tr></table></figure><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num, id, category_id, category, NAME, price, stock<br>FROM goods;<br></code></pre></td></tr></table></figure><h5 id="1-3-小-结"><a href="#1-3-小-结" class="headerlink" title="1.3 小 结"></a><strong>1.3</strong> <strong>小 结</strong></h5><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h4 id="2-新特性2：公用表表达式"><a href="#2-新特性2：公用表表达式" class="headerlink" title="2. 新特性2：公用表表达式"></a><strong>2.</strong> <strong>新特性2：公用表表达式</strong></h4><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code>2 种。</p><h5 id="2-1-普通公用表表达式"><a href="#2-1-普通公用表表达式" class="headerlink" title="2.1 普通公用表表达式"></a><strong>2.1</strong> <strong>普通公用表表达式</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH CTE名称 <br>AS （子查询） <br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure><p>举例：查询员工所在的部门的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH emp_dept_id<br>AS (SELECT DISTINCT department_id FROM employees)<br>SELECT *<br>FROM departments d JOIN emp_dept_id e<br>ON d.department_id = e.department_id;<br></code></pre></td></tr></table></figure><h5 id="2-2-递归公用表表达式"><a href="#2-2-递归公用表表达式" class="headerlink" title="2.2 递归公用表表达式"></a><strong>2.2</strong> <strong>递归公用表表达式</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE <br>CTE名称 AS （子查询） <br>SELECT|DELETE|UPDATE 语句;<br></code></pre></td></tr></table></figure><p><strong>案例：</strong>针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p><ul><li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p></li><li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p></li><li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p></li></ul><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE cte <br>AS(SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100<br>-- 种子查询，找到第一代领导 <br>UNION ALL <br>SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte <br>ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人 <br>)<br>SELECT employee_id,last_name FROM cte WHERE n &gt;= 3;<br></code></pre></td></tr></table></figure><h5 id="2-3-小-结"><a href="#2-3-小-结" class="headerlink" title="2.3 小 结"></a><strong>2.3</strong> <strong>小 结</strong></h5><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p><h2 id="第二部分-MySQL高级特性篇"><a href="#第二部分-MySQL高级特性篇" class="headerlink" title="第二部分 MySQL高级特性篇"></a>第二部分 MySQL高级特性篇</h2><h3 id="第01章-Linux下MySQL的安装与使用"><a href="#第01章-Linux下MySQL的安装与使用" class="headerlink" title="第01章 Linux下MySQL的安装与使用"></a>第01章 Linux下MySQL的安装与使用</h3><h4 id="1-安装前说明"><a href="#1-安装前说明" class="headerlink" title="1. 安装前说明"></a><strong>1.</strong> <strong>安装前说明</strong></h4><h5 id="1-1-查看是否安装过MySQL"><a href="#1-1-查看是否安装过MySQL" class="headerlink" title="1.1 查看是否安装过MySQL"></a><strong>1.1</strong> <strong>查看是否安装过MySQL</strong></h5><ul><li>如果你是用rpm安装, 检查一下RPM PACKAGE：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa | grep -i mysql # -i 忽略大小写<br></code></pre></td></tr></table></figure><ul><li>检查mysql service：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status mysqld.service<br></code></pre></td></tr></table></figure><h5 id="1-2-MySQL的卸载"><a href="#1-2-MySQL的卸载" class="headerlink" title="1.2 MySQL的卸载"></a><strong>1.2 MySQL的卸载</strong></h5><p><strong>1.</strong> <strong>关闭</strong> <strong>mysql</strong> <strong>服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop mysqld.service<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>查看当前</strong> <strong>mysql</strong> <strong>安装状况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa | grep -i mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>yum list installed | grep mysql<br></code></pre></td></tr></table></figure><p><strong>3.</strong> <strong>卸载上述命令查询出的已安装程序</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx<br></code></pre></td></tr></table></figure><p>务必卸载干净，反复执行<code>rpm -qa | grep -i mysql</code>确认是否有卸载残留</p><p><strong>4.</strong> <strong>删除</strong> <strong>mysql</strong> <strong>相关文件</strong></p><ul><li>查找相关文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name mysql<br></code></pre></td></tr></table></figure><ul><li>删除上述命令查找出的相关文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf xxx<br></code></pre></td></tr></table></figure><p><strong>5.删除 my.cnf</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /etc/my.cnf<br></code></pre></td></tr></table></figure><h4 id="2-MySQL的Linux版安装"><a href="#2-MySQL的Linux版安装" class="headerlink" title="2. MySQL的Linux版安装"></a><strong>2. MySQL的Linux版安装</strong></h4><h5 id="2-1-CentOS7下检查MySQL依赖"><a href="#2-1-CentOS7下检查MySQL依赖" class="headerlink" title="2.1 CentOS7下检查MySQL依赖"></a><strong>2.1 CentOS7下检查MySQL依赖</strong></h5><p><strong>1.</strong> <strong>检查&#x2F;tmp临时目录权限（必不可少）</strong></p><p>由于mysql安装过程中，会通过mysql用户在&#x2F;tmp目录下新建tmp_db文件，所以请给&#x2F;tmp较大的权限。执行 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod -R 777 /tmp<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>安装前，检查依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -qa|grep libaio<br>rpm -qa|grep net-tools<br></code></pre></td></tr></table></figure><h5 id="2-2-CentOS7下MySQL安装过程"><a href="#2-2-CentOS7下MySQL安装过程" class="headerlink" title="2.2 CentOS7下MySQL安装过程"></a><strong>2.2 CentOS7下MySQL安装过程</strong></h5><p><strong>1.</strong> <strong>将安装程序拷贝到&#x2F;opt目录下</strong></p><p>在mysql的安装文件目录下执行：（必须按照顺序执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm <br>rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm <br>rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm <br>rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm <br>rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><ul><li><code>rpm</code>是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</li><li><code>-i</code>, –install 安装软件包</li><li><code>-v</code>, –verbose 提供更多的详细信息输出</li><li><code>-h</code>, –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li></ul><blockquote><p>若存在mariadb-libs问题，则执行<strong>yum remove mysql-libs</strong>即可</p></blockquote><h5 id="2-3-查看MySQL版本"><a href="#2-3-查看MySQL版本" class="headerlink" title="2.3 查看MySQL版本"></a><strong>2.3</strong> <strong>查看MySQL版本</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql --version <br><span class="hljs-meta prompt_">#</span><span class="language-bash">或</span><br>mysqladmin --version<br></code></pre></td></tr></table></figure><h5 id="2-4-服务的初始化"><a href="#2-4-服务的初始化" class="headerlink" title="2.4 服务的初始化"></a><strong>2.4</strong> <strong>服务的初始化</strong></h5><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqld --initialize --user=mysql<br></code></pre></td></tr></table></figure><p>说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将<code>该密码标记为过期</code>，登录后你需要设置一个新的密码。生成的<code>临时密码</code>会往日志中记录一份。</p><p>查看密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /var/log/mysqld.log<br></code></pre></td></tr></table></figure><p>root@localhost: 后面就是初始化的密码</p><h5 id="2-5-启动MySQL，查看状态"><a href="#2-5-启动MySQL，查看状态" class="headerlink" title="2.5 启动MySQL，查看状态"></a><strong>2.5</strong> <strong>启动MySQL，查看状态</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">加不加.service后缀都可以</span> <br>启动：systemctl start mysqld.service <br>关闭：systemctl stop mysqld.service <br>重启：systemctl restart mysqld.service <br>查看状态：systemctl status mysqld.service<br></code></pre></td></tr></table></figure><h5 id="2-6-查看MySQL服务是否自启动"><a href="#2-6-查看MySQL服务是否自启动" class="headerlink" title="2.6 查看MySQL服务是否自启动"></a><strong>2.6</strong> <strong>查看MySQL服务是否自启动</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl list-unit-files|grep mysqld.service<br></code></pre></td></tr></table></figure><ul><li>如不是enabled可以运行如下命令设置自启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable mysqld.service<br></code></pre></td></tr></table></figure><ul><li>如果希望不进行自启动，运行如下命令设置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl disable mysqld.service<br></code></pre></td></tr></table></figure><h4 id="3-MySQL登录"><a href="#3-MySQL登录" class="headerlink" title="3. MySQL登录"></a><strong>3. MySQL登录</strong></h4><h5 id="3-1-首次登录"><a href="#3-1-首次登录" class="headerlink" title="3.1 首次登录"></a><strong>3.1</strong> <strong>首次登录</strong></h5><p>通过<code>mysql -hlocalhost -P3306 -uroot -p</code>进行登录，在Enter password：录入初始化密码</p><h5 id="3-2-修改密码"><a href="#3-2-修改密码" class="headerlink" title="3.2 修改密码"></a><strong>3.2</strong> <strong>修改密码</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password&#x27;;<br></code></pre></td></tr></table></figure><h5 id="3-3-设置远程登录"><a href="#3-3-设置远程登录" class="headerlink" title="3.3 设置远程登录"></a><strong>3.3</strong> <strong>设置远程登录</strong></h5><p><strong>1.</strong> <strong>确认网络</strong> </p><p>1.在远程机器上使用ping ip地址<code>保证网络畅通</code></p><p>2.在远程机器上使用telnet命令<code>保证端口号开放</code>访问</p><p><strong>2.</strong> <strong>关闭防火墙或开放端口</strong></p><p><strong>方式一：关闭防火墙</strong></p><ul><li>CentOS6 ：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service iptables stop<br></code></pre></td></tr></table></figure><ul><li>CentOS7：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">开启防火墙</span><br>systemctl start firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看防火墙状态</span><br>systemctl status firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭防火墙</span><br>systemctl stop firewalld.service<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置开机启用防火墙</span> <br>systemctl enable firewalld.service <br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置开机禁用防火墙</span> <br>systemctl disable firewalld.service<br></code></pre></td></tr></table></figure><p><strong>方式二：开放端口</strong></p><ul><li>查看开放的端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --list-all<br></code></pre></td></tr></table></figure><ul><li>设置开放的端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --add-service=http --permanent<br>firewall-cmd --add-port=3306/tcp --permanent<br></code></pre></td></tr></table></figure><ul><li>重启防火墙</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><h4 id="4-Linux下修改配置"><a href="#4-Linux下修改配置" class="headerlink" title="4. Linux下修改配置"></a><strong>4. Linux下修改配置</strong></h4><ul><li>修改允许远程登陆</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>select Host,User from user;<br>update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure><blockquote><p><code>%</code>是个 通配符 ，如果Host&#x3D;192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果<code>Host=%</code>，表示所有IP都有连接权限。</p><p>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</p></blockquote><p>配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。</p><p><strong>解决方法一：</strong>升级远程连接工具版本</p><p><strong>解决方法二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;;<br></code></pre></td></tr></table></figure><h4 id="5-字符集的相关操作"><a href="#5-字符集的相关操作" class="headerlink" title="5. 字符集的相关操作"></a><strong>5.</strong> <strong>字符集的相关操作</strong></h4><h5 id="5-1-各级别的字符集"><a href="#5-1-各级别的字符集" class="headerlink" title="5.1 各级别的字符集"></a><strong>5.1</strong> <strong>各级别的字符集</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;character%&#x27;;<br></code></pre></td></tr></table></figure><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection </li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><p><strong>小结</strong></p><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><h5 id="5-2-请求到响应过程中字符集的变化"><a href="#5-2-请求到响应过程中字符集的变化" class="headerlink" title="5.2 请求到响应过程中字符集的变化"></a><strong>5.2</strong> <strong>请求到响应过程中字符集的变化</strong></h5><pre><code class=" mermaid">graph TBA(客户端) --&gt; |&quot;使用操作系统的字符集编码请求字符串&quot;| B(从character_set_client转换为character_set_connection)B --&gt; C(从character_set_connection转换为具体的列使用的字符集)C --&gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results)D --&gt; |&quot;使用操作系统的字符集解码响应的字符串&quot;| A</code></pre><h3 id="第02章-MySQL的数据目录"><a href="#第02章-MySQL的数据目录" class="headerlink" title="第02章 MySQL的数据目录"></a>第02章 MySQL的数据目录</h3><h4 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a><strong>1. MySQL8的主要目录结构</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name mysql<br></code></pre></td></tr></table></figure><h5 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a><strong>1.1</strong> <strong>数据库文件的存放路径</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;datadir&#x27;; # /var/lib/mysql/<br></code></pre></td></tr></table></figure><h5 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a><strong>1.2</strong> <strong>相关命令目录</strong></h5><p><strong>相关命令目录：&#x2F;usr&#x2F;bin 和&#x2F;usr&#x2F;sbin。</strong></p><h5 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a><strong>1.3</strong> <strong>配置文件目录</strong></h5><p><strong>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</strong></p><h4 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a><strong>2.</strong> <strong>数据库和文件系统的关系</strong></h4><h5 id="2-1-表在文件系统中的表示"><a href="#2-1-表在文件系统中的表示" class="headerlink" title="2.1 表在文件系统中的表示"></a><strong>2.1</strong> <strong>表在文件系统中的表示</strong></h5><h6 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a><strong>2.3.1 InnoDB存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.frm</span><br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong> </p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.ibd</span><br></code></pre></td></tr></table></figure><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span> <br><span class="hljs-attr">innodb_file_per_table</span>=<span class="hljs-number">0</span> <span class="hljs-comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></code></pre></td></tr></table></figure><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h6 id="2-3-2-MyISAM存储引擎模式"><a href="#2-3-2-MyISAM存储引擎模式" class="headerlink" title="2.3.2 MyISAM存储引擎模式"></a><strong>2.3.2 MyISAM存储引擎模式</strong></h6><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">表名<span class="hljs-string">.frm</span><br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test<span class="hljs-selector-class">.frm</span> 存储表结构 <span class="hljs-selector-id">#MySQL8</span>.<span class="hljs-number">0</span> 改为了 <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.sdi</span><br>test<span class="hljs-selector-class">.MYD</span> 存储数据 (MYData) <br>test<span class="hljs-selector-class">.MYI</span> 存储索引 (MYIndex<br></code></pre></td></tr></table></figure><h3 id="第03章-用户与权限管理"><a href="#第03章-用户与权限管理" class="headerlink" title="第03章 用户与权限管理"></a>第03章 用户与权限管理</h3><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a><strong>1.</strong> <strong>用户管理</strong></h4><h5 id="1-1-登录MySQL服务器"><a href="#1-1-登录MySQL服务器" class="headerlink" title="1.1 登录MySQL服务器"></a><strong>1.1</strong> <strong>登录MySQL服务器</strong></h5><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;<br></code></pre></td></tr></table></figure><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。</li><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;<br></code></pre></td></tr></table></figure><h5 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a><strong>1.2</strong> <strong>创建用户</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 用户名 [IDENTIFIED BY &#x27;密码&#x27;][,用户名 [IDENTIFIED BY &#x27;密码&#x27;]];<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER zhang3 IDENTIFIED BY &#x27;123123&#x27;; # 默认host是 %<br>CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><h5 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a><strong>1.3</strong> <strong>修改用户</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;; <br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h5 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a><strong>1.4</strong> <strong>删除用户</strong></h5><p><strong>方式1：使用DROP方式删除（推荐）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER user[,user]…;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER li4 ; # 默认删除host为%的用户<br>DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure><p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h5 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a><strong>1.5</strong> <strong>设置当前用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER USER() IDENTIFIED BY &#x27;new_password&#x27;;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD=&#x27;new_password&#x27;;<br></code></pre></td></tr></table></figure><h5 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a><strong>1.6</strong> <strong>修改其它用户密码</strong></h5><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER user [IDENTIFIED BY &#x27;新密码&#x27;] <br>[,user[IDENTIFIED BY &#x27;新密码&#x27;]]…;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a><strong>2.</strong> <strong>权限管理</strong></h4><h5 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a><strong>2.1</strong> <strong>权限列表</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show privileges;<br></code></pre></td></tr></table></figure><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><h5 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a><strong>2.2</strong> <strong>授予权限的原则</strong></h5><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><h5 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a><strong>2.3</strong> <strong>授予权限</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];<br></code></pre></td></tr></table></figure><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;<br></code></pre></td></tr></table></figure><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT ALL PRIVILEGES ON *.* TO joe@&#x27;%&#x27; IDENTIFIED BY &#x27;123&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a><strong>2.4</strong> <strong>查看权限</strong></h5><ul><li>查看当前用户权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS; <br># 或 <br>SHOW GRANTS FOR CURRENT_USER; <br># 或 <br>SHOW GRANTS FOR CURRENT_USER();<br></code></pre></td></tr></table></figure><ul><li>查看某用户的全局权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a><strong>2.5</strong> <strong>收回权限</strong></h5><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;<br></code></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#收回全库全表的所有权限 <br>REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;; <br>#收回mysql库下的所有表的插删改查权限 <br>REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;<br></code></pre></td></tr></table></figure><ul><li>注意：<code>须用户重新登录后才能生效</code></li></ul><h4 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3. 角色管理"></a><strong>3.</strong> <strong>角色管理</strong></h4><h5 id="3-1-创建角色"><a href="#3-1-创建角色" class="headerlink" title="3.1 创建角色"></a><strong>3.1</strong> <strong>创建角色</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...<br></code></pre></td></tr></table></figure><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><h5 id="3-2-给角色赋予权限"><a href="#3-2-给角色赋予权限" class="headerlink" title="3.2 给角色赋予权限"></a><strong>3.2</strong> <strong>给角色赋予权限</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];<br></code></pre></td></tr></table></figure><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW PRIVILEGES\G<br></code></pre></td></tr></table></figure><h5 id="3-3-查看角色的权限"><a href="#3-3-查看角色的权限" class="headerlink" title="3.3 查看角色的权限"></a><strong>3.3</strong> <strong>查看角色的权限</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR &#x27;role_name&#x27;;<br></code></pre></td></tr></table></figure><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><h5 id="3-4-回收角色的权限"><a href="#3-4-回收角色的权限" class="headerlink" title="3.4 回收角色的权限"></a><strong>3.4</strong> <strong>回收角色的权限</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;<br></code></pre></td></tr></table></figure><h5 id="3-5-删除角色"><a href="#3-5-删除角色" class="headerlink" title="3.5 删除角色"></a><strong>3.5</strong> <strong>删除角色</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP ROLE role [,role2]...<br></code></pre></td></tr></table></figure><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><h5 id="3-6-给用户赋予角色"><a href="#3-6-给用户赋予角色" class="headerlink" title="3.6 给用户赋予角色"></a><strong>3.6</strong> <strong>给用户赋予角色</strong></h5><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT role [,role2,...] TO user [,user2,...];<br></code></pre></td></tr></table></figure><p>查询当前已激活的角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CURRENT_ROLE();<br></code></pre></td></tr></table></figure><h5 id="3-7-激活角色"><a href="#3-7-激活角色" class="headerlink" title="3.7 激活角色"></a><strong>3.7</strong> <strong>激活角色</strong></h5><p><strong>方式1：使用set default role 命令激活角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET DEFAULT ROLE ALL TO &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL activate_all_roles_on_login=ON;<br></code></pre></td></tr></table></figure><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><h5 id="3-8-撤销用户的角色"><a href="#3-8-撤销用户的角色" class="headerlink" title="3.8 撤销用户的角色"></a><strong>3.8</strong> <strong>撤销用户的角色</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE role FROM user;<br></code></pre></td></tr></table></figure><h5 id="3-9-设置强制角色-mandatory-role"><a href="#3-9-设置强制角色-mandatory-role" class="headerlink" title="3.9 设置强制角色(mandatory role)"></a><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></h5><p>方式1：服务启动前设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">mandatory_roles</span>=<span class="hljs-string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></code></pre></td></tr></table></figure><p>方式2：运行时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PERSIST mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后仍然有效<br>SET GLOBAL mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后失效<br></code></pre></td></tr></table></figure><h3 id="第04章-逻辑架构"><a href="#第04章-逻辑架构" class="headerlink" title="第04章 逻辑架构"></a>第04章 逻辑架构</h3><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a><strong>1.</strong> <strong>逻辑架构剖析</strong></h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291130782.png" alt="202203291130782"></p><h5 id="1-1-第1层：连接层"><a href="#1-1-第1层：连接层" class="headerlink" title="1.1 第1层：连接层"></a><strong>1.1</strong> <strong>第1层：连接层</strong></h5><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><h5 id="1-2-第2层：服务层"><a href="#1-2-第2层：服务层" class="headerlink" title="1.2 第2层：服务层"></a><strong>1.2</strong> <strong>第2层：服务层</strong></h5><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;<br></code></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。 </li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h5 id="1-3-第3层：引擎层"><a href="#1-3-第3层：引擎层" class="headerlink" title="1.3 第3层：引擎层"></a><strong>1.3</strong> <strong>第3层：引擎层</strong></h5><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p><h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a><strong>1.4</strong> <strong>小结</strong></h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291131321.png" alt="202203291131321"></p><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p></li></ol><h4 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a><strong>2. SQL执行流程</strong></h4><h5 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a><strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291133116.png" alt="202203291133116"></p><p><strong>MySQL的查询流程：</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，则会生成一个语法树。</p><p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p><strong>4.</strong> <strong>执行器</strong>：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291145074.png"></p><p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p><h4 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池(buffer pool)"></a><strong>3.</strong> <strong>数据库缓冲池(buffer pool)</strong></h4><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h5 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a><strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h5><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291155004.png" alt="202203291155004"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>2.</strong> <strong>查询缓存</strong></p><p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h5 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a><strong>3.2</strong> <strong>缓冲池如何读取数据</strong></h5><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203291159111.png" alt="202203291159111"></p><h5 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a><strong>3.3</strong> <strong>查看&#x2F;设置缓冲池的大小</strong></h5><p>查看缓冲池的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;innodb_buffer_pool_size&#x27;;<br></code></pre></td></tr></table></figure><p>设置缓冲池的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global innodb_buffer_pool_size = 268435456;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span> <br><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">268435456</span><br></code></pre></td></tr></table></figure><h5 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a><strong>3.4</strong> <strong>多个Buffer Pool实例</strong></h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[server]</span> <br><span class="hljs-attr">innodb_buffer_pool_instances</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>何查看缓冲池的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;innodb_buffer_pool_instances&#x27;;<br></code></pre></td></tr></table></figure><p>每个<code>Buffer Pool</code>实例实际占内存空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure><h3 id="第05章-存储引擎"><a href="#第05章-存储引擎" class="headerlink" title="第05章 存储引擎"></a>第05章 存储引擎</h3><h4 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a><strong>1.</strong> <strong>查看存储引擎</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br># 或<br>show engines\G<br></code></pre></td></tr></table></figure><h4 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a><strong>2.</strong> <strong>设置系统默认的存储引擎</strong></h4><ul><li>查看默认的存储引擎：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%storage_engine%&#x27;; <br>#或<br>SELECT @@default_storage_engine;<br></code></pre></td></tr></table></figure><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET DEFAULT_STORAGE_ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><p>或者修改<code>my.cnf</code>文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">default-storage-engine</span>=MyISAM <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span> <br>systemctl restart mysqld.service<br></code></pre></td></tr></table></figure><h4 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a><strong>3.</strong> <strong>设置表的存储引擎</strong></h4><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h5 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a><strong>3.1</strong> <strong>创建表时指定存储引擎</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>    建表语句; <br>) ENGINE = 存储引擎名称;<br></code></pre></td></tr></table></figure><h5 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a><strong>3.2</strong> <strong>修改表的存储引擎</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ENGINE = 存储引擎名称;<br></code></pre></td></tr></table></figure><h4 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a><strong>4.</strong> <strong>引擎介绍</strong></h4><h5 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a><strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h5><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。 </li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构：<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul><h5 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a><strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h5><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。 </li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h5 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a><strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></h5><h5 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a><strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h5><h5 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a><strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h5><h5 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a><strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></h5><h5 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a><strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong></h5><h5 id="4-8-Merge引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge引擎：管理多个MyISAM表构成的表集合"></a><strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong></h5><h5 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a><strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></h5><h4 id="5-MyISAM和InnoDB"><a href="#5-MyISAM和InnoDB" class="headerlink" title="5. MyISAM和InnoDB"></a><strong>5. MyISAM和InnoDB</strong></h4><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h3 id="第06章-索引的数据结构"><a href="#第06章-索引的数据结构" class="headerlink" title="第06章 索引的数据结构"></a>第06章 索引的数据结构</h3><h4 id="1-索引及其优缺点"><a href="#1-索引及其优缺点" class="headerlink" title="1. 索引及其优缺点"></a><strong>1.</strong> <strong>索引及其优缺点</strong></h4><h5 id="1-1-索引概述"><a href="#1-1-索引概述" class="headerlink" title="1.1 索引概述"></a><strong>1.1</strong> <strong>索引概述</strong></h5><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><h5 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2</strong> <strong>优点</strong></h5><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p><p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><h5 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a><strong>1.3</strong> <strong>缺点</strong></h5><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p><h4 id="2-InnoDB中索引的推演"><a href="#2-InnoDB中索引的推演" class="headerlink" title="2. InnoDB中索引的推演"></a><strong>2. InnoDB中索引的推演</strong></h4><h5 id="2-1-索引之前的查找"><a href="#2-1-索引之前的查找" class="headerlink" title="2.1 索引之前的查找"></a><strong>2.1</strong> <strong>索引之前的查找</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;<br></code></pre></td></tr></table></figure><p><strong>1.在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件<ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件<ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><p><strong>2.在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p><h5 id="2-2-设计索引"><a href="#2-2-设计索引" class="headerlink" title="2.2 设计索引"></a><strong>2.2</strong> <strong>设计索引</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE index_demo(<br>    -&gt; c1 INT,<br>    -&gt; c2 INT,<br>    -&gt; c3 CHAR(1),<br>    -&gt; PRIMARY KEY(c1)<br>    -&gt; ) ROW_FORMAT = Compact;<br></code></pre></td></tr></table></figure><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203300956080.png" alt="202203300956080"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。 </li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301000365.png" alt="202203301000365"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301001377.png" alt="202203301001377"></p><p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li><li><strong>给所有的页建立一个目录项。</strong></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301004386.png" alt="202203301004386"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。 </p></li><li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><p><strong>2. InnoDB中的索引方案</strong> </p><p><strong>① 迭代1次：目录项纪录的页</strong></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301028743.png" alt="202203301028743"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </p></li><li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301034997.png" alt="202203301034997"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><p><strong>③ 迭代3次：目录项记录页的目录页</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301038376.png" alt="202203301038376"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301040190.png" alt="202203301040190"></p><p>这个数据结构，它的名称是<code>B+树</code>。 </p><p><strong>④</strong> <strong>B+Tree</strong></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p><h5 id="2-3-常见索引概念"><a href="#2-3-常见索引概念" class="headerlink" title="2.3 常见索引概念"></a><strong>2.3</strong> <strong>常见索引概念</strong></h5><p><strong>1.</strong> <strong>聚簇索引</strong></p><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p></li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><p><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301050055.png" alt="202203301050055"></p><p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><p><strong>3.</strong> <strong>联合索引</strong></p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><h5 id="2-4-InnoDB的B-树索引的注意事项"><a href="#2-4-InnoDB的B-树索引的注意事项" class="headerlink" title="2.4 InnoDB的B+树索引的注意事项"></a><strong>2.4 InnoDB的B+树索引的注意事项</strong></h5><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p><p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301110222.png" alt="202203301110222"></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301120304.png" alt="202203301120304"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><p><strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></p><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h4 id="3-MyISAM中的索引方案"><a href="#3-MyISAM中的索引方案" class="headerlink" title="3. MyISAM中的索引方案"></a><strong>3. MyISAM中的索引方案</strong></h4><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引&#x2F;存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><h5 id="3-1-MyISAM索引的原理"><a href="#3-1-MyISAM索引的原理" class="headerlink" title="3.1 MyISAM索引的原理"></a><strong>3.1 MyISAM索引的原理</strong></h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301133907.png" alt="202203301133907"></p><h5 id="3-2-MyISAM-与-InnoDB对比"><a href="#3-2-MyISAM-与-InnoDB对比" class="headerlink" title="3.2 MyISAM 与 InnoDB对比"></a><strong>3.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></h5><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><p><strong>小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。 </p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><h4 id="4-索引的代价"><a href="#4-索引的代价" class="headerlink" title="4. 索引的代价"></a><strong>4.</strong> <strong>索引的代价</strong></h4><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><h4 id="5-MySQL数据结构选择的合理性"><a href="#5-MySQL数据结构选择的合理性" class="headerlink" title="5. MySQL数据结构选择的合理性"></a><strong>5. MySQL数据结构选择的合理性</strong></h4><h5 id="5-1-二叉搜索树"><a href="#5-1-二叉搜索树" class="headerlink" title="5.1 二叉搜索树"></a><strong>5.1</strong> <strong>二叉搜索树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301636830.png" alt="202203301636830"></p><p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><h5 id="5-2-AVL树"><a href="#5-2-AVL树" class="headerlink" title="5.2 AVL树"></a><strong>5.2 AVL树</strong></h5><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301635653.png" alt="202203301635653"></p><p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301637104.png" alt="202203301637104"></p><h5 id="5-3-B-Tree"><a href="#5-3-B-Tree" class="headerlink" title="5.3 B-Tree"></a><strong>5.3 B-Tree</strong></h5><p>B 树的结构如下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301638995.png" alt="202203301638995"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。 </p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为[ceil(M&#x2F;2), M]。 </p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 </p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p></li><li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p></li><li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p></li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p><p><strong>再举例1：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301644761.png" alt="202203301644761"></p><h5 id="5-4-B-Tree"><a href="#5-4-B-Tree" class="headerlink" title="5.4 B+Tree"></a><strong>5.4 B+Tree</strong></h5><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ol><li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1。</p></li><li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p></li><li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。 </p></li><li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p></li></ol><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p><p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 &#x3D; 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1.B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash索引与B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code></p></blockquote><h3 id="第07章-InnoDB数据存储结构"><a href="#第07章-InnoDB数据存储结构" class="headerlink" title="第07章 InnoDB数据存储结构"></a>第07章 InnoDB数据存储结构</h3><h4 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h4><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p><h5 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I&#x2F;O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作）只能处理一行数据，效率会非常低。</p></blockquote><h5 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h5><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p><h5 id="1-3-页的上层结构"><a href="#1-3-页的上层结构" class="headerlink" title="1.3 页的上层结构"></a>1.3 页的上层结构</h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301838071.png" alt="202203301838071"></p><p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。</p><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><h4 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h4><h5 id="2-1-第1部分：文件头部和文件尾部"><a href="#2-1-第1部分：文件头部和文件尾部" class="headerlink" title="2.1 第1部分：文件头部和文件尾部"></a>2.1 第1部分：文件头部和文件尾部</h5><h6 id="2-1-1-File-Header（文件头部）（38字节）"><a href="#2-1-1-File-Header（文件头部）（38字节）" class="headerlink" title="2.1.1 File Header（文件头部）（38字节）"></a>2.1.1 File Header（文件头部）（38字节）</h6><p><strong>作用</strong>：<br>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小</strong>：38字节</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li><li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没有使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><ul><li><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></li><li><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p><strong>作用：</strong></p><p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><ul><li><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</li></ul><h6 id="2-1-2-File-Trailer（文件尾部）（8字节）"><a href="#2-1-2-File-Trailer（文件尾部）（8字节）" class="headerlink" title="2.1.2 File Trailer（文件尾部）（8字节）"></a>2.1.2 File Trailer（文件尾部）（8字节）</h6><ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul><h5 id="2-2-第2部分：空闲空间、用户记录和最小最大记录"><a href="#2-2-第2部分：空闲空间、用户记录和最小最大记录" class="headerlink" title="2.2 第2部分：空闲空间、用户记录和最小最大记录"></a>2.2 第2部分：空闲空间、用户记录和最小最大记录</h5><h6 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h6><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p><h6 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h6><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><h6 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h6><p><strong>记录可以比较大小吗</strong>？<br>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301913664.png" alt="202203301913664"></p><p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301914167.png" alt="202203301914167"></p><h5 id="2-3-第3部分：页目录和页面头部"><a href="#2-3-第3部分：页目录和页面头部" class="headerlink" title="2.3 第3部分：页目录和页面头部"></a>2.3 第3部分：页目录和页面头部</h5><h6 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h6><p><strong>为什么需要页目录</strong>？<br>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p><strong>页目录，二分法查找</strong></p><ol><li>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br> 最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br> 其余的组记录数量在 4-8 条之间。<br> 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><strong>举例：</strong></p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301921631.png" alt="202203301921631"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性<ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301924874.png" alt="202203301924874"></p><p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p><p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><h6 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h6><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h4 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h4><h5 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ROW_FORMAT=行格式名称<br></code></pre></td></tr></table></figure><h5 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h5><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301939611.png" alt="202203301939611"></p><h6 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h6><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p><blockquote><p> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p></blockquote><h6 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h6><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。<br><strong>为什么定义NULL值列表？</strong><br>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol><blockquote><p>注意：同样顺序也是反过来存放的</p></blockquote><h6 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h6><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203301945235.png" alt="202203301945235"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。<ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul></li></ul><p><strong>被删除的记录为什么还在页中存储呢？</strong><br>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li><li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul></li><li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li></ul><p><strong>怎么不见heap_no值为0和1的记录呢</strong>？<br>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p><ul><li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li></ul><h6 id="3-2-4-记录的真实数据"><a href="#3-2-4-记录的真实数据" class="headerlink" title="3.2.4 记录的真实数据"></a>3.2.4 记录的真实数据</h6><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><h5 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h5><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p><p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h4 id="4-区、段和碎片区"><a href="#4-区、段和碎片区" class="headerlink" title="4. 区、段和碎片区"></a>4. 区、段和碎片区</h4><h5 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h5><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB&#x3D;<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O，<code>功大于过</code>！</p><h5 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h5><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h5 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h5><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB&#x3D;1024KB）存储空间，所以<strong>默认情况下一个只存在几条记录的小表也需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p><h5 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h5><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p><h3 id="第08章-索引的创建与设计原则"><a href="#第08章-索引的创建与设计原则" class="headerlink" title="第08章 索引的创建与设计原则"></a>第08章 索引的创建与设计原则</h3><h4 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a><strong>1.</strong> <strong>索引的声明与使用</strong></h4><h5 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a><strong>1.1</strong> <strong>索引的分类</strong></h5><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul><h5 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a><strong>1.2</strong> <strong>创建索引</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name [col_name data_type] <br>[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]<br></code></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><p><strong>1.</strong> <strong>创建普通索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE book( <br>    book_id INT , <br>    book_name VARCHAR(100), <br>    authors VARCHAR(100), <br>    info VARCHAR(100) , <br>    comment VARCHAR(100), <br>    year_publication YEAR, <br>    INDEX(year_publication) <br>);<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>创建唯一索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test1( <br>    id INT NOT NULL, <br>    name varchar(30) NOT NULL, <br>    UNIQUE INDEX uk_idx_id(id) <br>);<br></code></pre></td></tr></table></figure><p><strong>3.</strong> <strong>主键索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student ( <br>    id INT(10) UNSIGNED AUTO_INCREMENT, <br>    student_no VARCHAR(200),<br>    student_name VARCHAR(200), <br>    PRIMARY KEY(id) <br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 删除主键索引<br>ALTER TABLE student drop PRIMARY KEY ;<br></code></pre></td></tr></table></figure><p><strong>4.</strong> <strong>创建单列索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test2( <br>    id INT NOT NULL, <br>    name CHAR(50) NULL, <br>    INDEX single_idx_name(name(20)) <br>);<br></code></pre></td></tr></table></figure><p><strong>5.</strong> <strong>创建组合索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test3( <br>    id INT(11) NOT NULL, <br>    name CHAR(30) NOT NULL, <br>    age INT(11) NOT NULL, <br>    info VARCHAR(255), <br>    INDEX multi_idx(id,name,age) <br>);<br></code></pre></td></tr></table></figure><p><strong>6.</strong> <strong>创建全文索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `papers` ( <br>    id` int(10) unsigned NOT NULL AUTO_INCREMENT, <br>    `title` varchar(200) DEFAULT NULL, <br>    `content` text, PRIMARY KEY (`id`), <br>    FULLTEXT KEY `title` (`title`,`content`) <br>) ENGINE=MyISAM DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);<br></code></pre></td></tr></table></figure><p><strong>7.</strong> <strong>创建空间索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test5( <br>    geo GEOMETRY NOT NULL, <br>    SPATIAL INDEX spa_idx_geo(geo) <br>) ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在已经存在的表上创建索引</strong></p><p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name <br>ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name <br>ON table_name (col_name[length],...) [ASC | DESC]<br></code></pre></td></tr></table></figure><h5 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a><strong>1.3</strong> <strong>删除索引</strong></h5><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name DROP INDEX index_name;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX index_name ON table_name;<br></code></pre></td></tr></table></figure><h4 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a><strong>2. MySQL8.0索引新特性</strong></h4><h5 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a><strong>2.1</strong> <strong>支持降序索引</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));<br></code></pre></td></tr></table></figure><h5 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a><strong>2.2</strong> <strong>隐藏索引</strong></h5><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><strong>1.</strong> <strong>创建表时直接创建</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tablename( <br>    propname1 type1[CONSTRAINT1], <br>    propname2 type2[CONSTRAINT2], <br>    ……<br>    propnamen typen, <br>    INDEX [indexname](propname1 [(length)]) INVISIBLE <br>);<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX indexname <br>ON tablename(propname[(length)]) INVISIBLE;<br></code></pre></td></tr></table></figure><p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tablename <br>ADD INDEX indexname (propname [(length)]) INVISIBLE;<br></code></pre></td></tr></table></figure><p><strong>4.</strong> <strong>切换索引可见状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 <br>ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引<br></code></pre></td></tr></table></figure><h4 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a><strong>3.</strong> <strong>索引的设计原则</strong></h4><h5 id="3-1-哪些情况适合创建索引"><a href="#3-1-哪些情况适合创建索引" class="headerlink" title="3.1 哪些情况适合创建索引"></a><strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h5><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p><p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong> </p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p><p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p><p>区分度计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">count(distinct left(列名, 索引长度))/count(*)<br></code></pre></td></tr></table></figure><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p><p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p><p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h5 id="3-2-限制索引的数目"><a href="#3-2-限制索引的数目" class="headerlink" title="3.2 限制索引的数目"></a><strong>3.2</strong> <strong>限制索引的数目</strong></h5><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul><h5 id="3-3-哪些情况不适合创建索引"><a href="#3-3-哪些情况不适合创建索引" class="headerlink" title="3.3 哪些情况不适合创建索引"></a><strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h5><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p><p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p><p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p><p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong> </p><p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p><p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p><h3 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章 性能分析工具的使用"></a>第09章 性能分析工具的使用</h3><h4 id="1-统计SQL的查询成本：last-query-cost"><a href="#1-统计SQL的查询成本：last-query-cost" class="headerlink" title="1. 统计SQL的查询成本：last_query_cost"></a><strong>1.</strong> <strong>统计SQL的查询成本：last_query_cost</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW STATUS LIKE &#x27;last_query_cost&#x27;;<br></code></pre></td></tr></table></figure><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h4 id="2-定位执行慢的SQL：慢查询日志"><a href="#2-定位执行慢的SQL：慢查询日志" class="headerlink" title="2. 定位执行慢的SQL：慢查询日志"></a><strong>2.</strong> <strong>定位执行慢的SQL：慢查询日志</strong></h4><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><h5 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a><strong>2.1</strong> <strong>开启慢查询日志参数</strong></h5><p><strong>1.</strong> <strong>开启slow_query_log</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global slow_query_log=&#x27;ON&#x27;;<br></code></pre></td></tr></table></figure><p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like `%slow_query_log%`;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 <br>mysql &gt; set global long_query_time = 1; <br>mysql&gt; show global variables like &#x27;%long_query_time%&#x27;; <br><br>mysql&gt; set long_query_time=1; <br>mysql&gt; show variables like &#x27;%long_query_time%&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-2-查看慢查询数目"><a href="#2-2-查看慢查询数目" class="headerlink" title="2.2 查看慢查询数目"></a><strong>2.2</strong> <strong>查看慢查询数目</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-3-慢查询日志分析工具：mysqldumpslow"><a href="#2-3-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="2.3 慢查询日志分析工具：mysqldumpslow"></a><strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span> <br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log <br><span class="hljs-meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span> <br>mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log<br><span class="hljs-meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span> <br>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log <br><span class="hljs-meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span> <br>mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more<br></code></pre></td></tr></table></figure><h5 id="2-4-关闭慢查询日志"><a href="#2-4-关闭慢查询日志" class="headerlink" title="2.4 关闭慢查询日志"></a><strong>2.4</strong> <strong>关闭慢查询日志</strong></h5><p><strong>方式1：永久性方式</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-literal">OFF</span><br><span class="hljs-comment">#或</span><br><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">#slow_query_log =OFF</span><br></code></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL slow_query_log=off;<br></code></pre></td></tr></table></figure><h4 id="3-查看-SQL-执行成本：SHOW-PROFILE"><a href="#3-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="3. 查看 SQL 执行成本：SHOW PROFILE"></a><strong>3.</strong> <strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;profiling&#x27;;<br>#开启<br>set profiling = &#x27;ON&#x27;;<br>#查看<br>show profiles;<br>show profile cpu,block io for query 2;<br></code></pre></td></tr></table></figure><h4 id="4-分析查询语句：EXPLAIN"><a href="#4-分析查询语句：EXPLAIN" class="headerlink" title="4. 分析查询语句：EXPLAIN"></a><strong>4.</strong> <strong>分析查询语句：EXPLAIN</strong></h4><h5 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a><strong>4.1</strong> <strong>基本语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT select_options <br>#或者<br>DESCRIBE SELECT select_options<br></code></pre></td></tr></table></figure><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h5 id="4-2-EXPLAIN各列作用"><a href="#4-2-EXPLAIN各列作用" class="headerlink" title="4.2 EXPLAIN各列作用"></a><strong>4.2 EXPLAIN各列作用</strong></h5><p><strong>1. table</strong></p><p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p><p><strong>2. id</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><p><strong>3. select_type</strong></p><p><strong>4. partitions</strong></p><p><strong>5. type（重点）</strong></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p><p><strong>6. possible_keys和key</strong></p><p><strong>7. key_len（重点）</strong></p><p><strong>key_len的长度计算公式：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">varchar</span>(<span class="hljs-number">10</span>)变长字段且允许NULL = <span class="hljs-number">10</span> * ( character set： utf8=<span class="hljs-number">3</span>,gbk=<span class="hljs-number">2</span>,latin1=<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>(NULL)+<span class="hljs-number">2</span>(变长字段) <br><br><span class="hljs-attribute">varchar</span>(<span class="hljs-number">10</span>)变长字段且不允许NULL = <span class="hljs-number">10</span> * ( character set：utf8=<span class="hljs-number">3</span>,gbk=<span class="hljs-number">2</span>,latin1=<span class="hljs-number">1</span>)+<span class="hljs-number">2</span>(变长字段)<br><br><span class="hljs-attribute">char</span>(<span class="hljs-number">10</span>)固定字段且允许NULL = <span class="hljs-number">10</span> * ( character set：utf8=<span class="hljs-number">3</span>,gbk=<span class="hljs-number">2</span>,latin1=<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>(NULL) <br><br><span class="hljs-attribute">char</span>(<span class="hljs-number">10</span>)固定字段且不允许NULL = <span class="hljs-number">10</span> * ( character set：utf8=<span class="hljs-number">3</span>,gbk=<span class="hljs-number">2</span>,latin1=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>8. ref</strong> </p><p><strong>9. rows（重点）</strong></p><p>预估的需要读取的记录条数</p><p><strong>10. filtered</strong></p><p><strong>11. Extra</strong></p><h4 id="5-EXPLAIN的进一步使用"><a href="#5-EXPLAIN的进一步使用" class="headerlink" title="5. EXPLAIN的进一步使用"></a><strong>5. EXPLAIN的进一步使用</strong></h4><h5 id="5-1-EXPLAIN四种输出格式"><a href="#5-1-EXPLAIN四种输出格式" class="headerlink" title="5.1 EXPLAIN四种输出格式"></a><strong>5.1 EXPLAIN四种输出格式</strong></h5><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><p><strong>1.</strong> <strong>传统格式</strong></p><p><strong>2. JSON格式</strong> </p><p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p><p><strong>3. TREE格式</strong></p><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><p><strong>4.</strong> <strong>可视化输出</strong></p><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p><h5 id="5-2-SHOW-WARNINGS的使用"><a href="#5-2-SHOW-WARNINGS的使用" class="headerlink" title="5.2 SHOW WARNINGS的使用"></a><strong>5.2 SHOW WARNINGS的使用</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;<br># 查看优化后的执行语句<br>mysql&gt; SHOW WARNINGS\G<br></code></pre></td></tr></table></figure><h4 id="6-分析优化器执行计划：trace"><a href="#6-分析优化器执行计划：trace" class="headerlink" title="6. 分析优化器执行计划：trace"></a><strong>6.</strong> <strong>分析优化器执行计划：trace</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 开启<br>SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; <br># 设置大小<br>set optimizer_trace_max_mem_size=1000000;<br># 使用<br>select * from student where id &lt; 10;<br>select * from information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><h4 id="7-MySQL监控分析视图-sys-schema"><a href="#7-MySQL监控分析视图-sys-schema" class="headerlink" title="7. MySQL监控分析视图-sys schema"></a><strong>7. MySQL监控分析视图-sys schema</strong></h4><p><strong>7.1 Sys schema视图使用场景</strong></p><p><strong>索引情况</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查询冗余索引 <br>select * from sys.schema_redundant_indexes; <br>#2. 查询未使用过的索引 <br>select * from sys.schema_unused_indexes; <br>#3. 查询索引的使用情况 <br>select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;<br></code></pre></td></tr></table></figure><p><strong>表相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 1. 查询表的访问量 <br>select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; <br># 2. 查询占用bufferpool较多的表 <br>select object_schema,object_name,allocated,data<br>from sys.innodb_buffer_stats_by_table order by allocated limit 10; <br># 3. 查看表的全表扫描情况 <br>select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;<br></code></pre></td></tr></table></figure><p><strong>语句相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 监控SQL执行的频率 <br>select db,exec_count,query from sys.statement_analysis order by exec_count desc; <br>#2. 监控使用了排序的SQL <br>select db,exec_count,first_seen,last_seen,query<br>from sys.statements_with_sorting limit 1; <br>#3. 监控使用了临时表或者磁盘临时表的SQL <br>select db,exec_count,tmp_tables,tmp_disk_tables,query<br>from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;<br></code></pre></td></tr></table></figure><p><strong>IO相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 查看消耗磁盘IO的文件 <br>select file,avg_read,avg_write,avg_read+avg_write as avg_io<br>from sys.io_global_by_file_by_bytes order by avg_read limit 10;<br></code></pre></td></tr></table></figure><p><strong>Innodb</strong> <strong>相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1. 行锁阻塞情况 <br>select * from sys.innodb_lock_waits;<br></code></pre></td></tr></table></figure><h3 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章 索引优化与查询优化"></a>第10章 索引优化与查询优化</h3><h4 id="1-索引失效案例"><a href="#1-索引失效案例" class="headerlink" title="1. 索引失效案例"></a><strong>1.</strong> <strong>索引失效案例</strong></h4><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><h5 id="1-1-全值匹配我最爱"><a href="#1-1-全值匹配我最爱" class="headerlink" title="1.1 全值匹配我最爱"></a><strong>1.1</strong> <strong>全值匹配我最爱</strong></h5><h5 id="1-2-最佳左前缀法则"><a href="#1-2-最佳左前缀法则" class="headerlink" title="1.2 最佳左前缀法则"></a><strong>1.2</strong> <strong>最佳左前缀法则</strong></h5><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><h5 id="1-3-主键插入顺序"><a href="#1-3-主键插入顺序" class="headerlink" title="1.3 主键插入顺序"></a><strong>1.3</strong> <strong>主键插入顺序</strong></h5><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><h5 id="1-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#1-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="1.4 计算、函数、类型转换(自动或手动)导致索引失效"></a><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h5><h5 id="1-5-类型转换导致索引失效"><a href="#1-5-类型转换导致索引失效" class="headerlink" title="1.5 类型转换导致索引失效"></a><strong>1.5</strong> <strong>类型转换导致索引失效</strong></h5><h5 id="1-6-范围条件右边的列索引失效"><a href="#1-6-范围条件右边的列索引失效" class="headerlink" title="1.6 范围条件右边的列索引失效"></a><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></h5><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><h5 id="1-7-不等于-x3D-或者-lt-gt-索引失效"><a href="#1-7-不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="1.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a><strong>1.7</strong> <strong>不等于(!&#x3D; 或者&lt;&gt;)索引失效</strong></h5><h5 id="1-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#1-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="1.8 is null可以使用索引，is not null无法使用索引"></a><strong>1.8 is null可以使用索引，is not null无法使用索引</strong></h5><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><h5 id="1-9-like以通配符-开头索引失效"><a href="#1-9-like以通配符-开头索引失效" class="headerlink" title="1.9 like以通配符%开头索引失效"></a><strong>1.9 like以通配符%开头索引失效</strong></h5><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h5 id="1-10-OR-前后存在非索引的列，索引失效"><a href="#1-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="1.10 OR 前后存在非索引的列，索引失效"></a><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></h5><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><h5 id="1-11-数据库和表的字符集统一使用utf8mb4"><a href="#1-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="1.11 数据库和表的字符集统一使用utf8mb4"></a><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></h5><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><h4 id="2-关联查询优化"><a href="#2-关联查询优化" class="headerlink" title="2. 关联查询优化"></a><strong>2.</strong> <strong>关联查询优化</strong></h4><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><h5 id="2-1-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2-1-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2.1 Index Nested-Loop Join（索引嵌套循环连接）"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204011826671.png" alt="202204011826671"></p><h5 id="2-2-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#2-2-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="2.2 Block Nested-Loop Join（块嵌套循环连接）"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204011833000.png" alt="202204011833000"></p><h5 id="2-3-Hash-Join"><a href="#2-3-Hash-Join" class="headerlink" title="2.3 Hash Join"></a>2.3 Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><h4 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3. 子查询优化"></a><strong>3.</strong> <strong>子查询优化</strong></h4><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> <strong>语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h4 id="4-排序优化"><a href="#4-排序优化" class="headerlink" title="4. 排序优化"></a><strong>4.</strong> <strong>排序优化</strong></h4><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><h4 id="5-GROUP-BY优化"><a href="#5-GROUP-BY优化" class="headerlink" title="5. GROUP BY优化"></a><strong>5. GROUP BY优化</strong></h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id="6-优化分页查询"><a href="#6-优化分页查询" class="headerlink" title="6. 优化分页查询"></a><strong>6.</strong> <strong>优化分页查询</strong></h4><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a<br>WHERE t.id = a.id;<br></code></pre></td></tr></table></figure><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;<br></code></pre></td></tr></table></figure><h4 id="7-优先考虑覆盖索引"><a href="#7-优先考虑覆盖索引" class="headerlink" title="7. 优先考虑覆盖索引"></a><strong>7.</strong> <strong>优先考虑覆盖索引</strong></h4><h5 id="7-1-什么是覆盖索引？"><a href="#7-1-什么是覆盖索引？" class="headerlink" title="7.1 什么是覆盖索引？"></a><strong>7.1</strong> <strong>什么是覆盖索引？</strong></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h5 id="7-2-覆盖索引的利弊"><a href="#7-2-覆盖索引的利弊" class="headerlink" title="7.2 覆盖索引的利弊"></a><strong>7.2</strong> <strong>覆盖索引的利弊</strong></h5><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h4 id="8-索引条件下推"><a href="#8-索引条件下推" class="headerlink" title="8. 索引条件下推"></a><strong>8.</strong> <strong>索引条件下推</strong></h4><h5 id="8-1-使用前后的扫描过程"><a href="#8-1-使用前后的扫描过程" class="headerlink" title="8.1 使用前后的扫描过程"></a><strong>8.1</strong> <strong>使用前后的扫描过程</strong></h5><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 </p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h4 id="9-其它查询优化策略"><a href="#9-其它查询优化策略" class="headerlink" title="9. 其它查询优化策略"></a><strong>9.</strong> <strong>其它查询优化策略</strong></h4><h5 id="9-1-EXISTS-和-IN-的区分"><a href="#9-1-EXISTS-和-IN-的区分" class="headerlink" title="9.1 EXISTS 和 IN 的区分"></a><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h5><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h5 id="9-2-COUNT-与COUNT-具体字段-效率"><a href="#9-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="9.2 COUNT(*)与COUNT(具体字段)效率"></a><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h5><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p><strong>环节2：</strong>如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p><strong>环节3：</strong>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h5 id="9-3-关于SELECT"><a href="#9-3-关于SELECT" class="headerlink" title="9.3 关于SELECT(*)"></a><strong>9.3</strong> <strong>关于SELECT(*)</strong></h5><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h5 id="9-4-LIMIT-1-对优化的影响"><a href="#9-4-LIMIT-1-对优化的影响" class="headerlink" title="9.4 LIMIT 1 对优化的影响"></a><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h5><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h5 id="9-5-多使用COMMIT"><a href="#9-5-多使用COMMIT" class="headerlink" title="9.5 多使用COMMIT"></a><strong>9.5</strong> <strong>多使用COMMIT</strong></h5><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo &#x2F; undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><h3 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章 数据库的设计规范"></a>第11章 数据库的设计规范</h3><h4 id="1-范-式"><a href="#1-范-式" class="headerlink" title="1. 范 式"></a><strong>1.</strong> <strong>范 式</strong></h4><h5 id="1-1-范式简介"><a href="#1-1-范式简介" class="headerlink" title="1.1 范式简介"></a><strong>1.1</strong> <strong>范式简介</strong></h5><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h5 id="1-2-范式都包括哪些"><a href="#1-2-范式都包括哪些" class="headerlink" title="1.2 范式都包括哪些"></a><strong>1.2</strong> <strong>范式都包括哪些</strong></h5><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204030928295.png" alt="202204030928295"></p><h5 id="1-3-键和相关属性的概念"><a href="#1-3-键和相关属性的概念" class="headerlink" title="1.3 键和相关属性的概念"></a><strong>1.3</strong> <strong>键和相关属性的概念</strong></h5><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h5 id="1-4-第一范式-1st-NF"><a href="#1-4-第一范式-1st-NF" class="headerlink" title="1.4 第一范式(1st NF)"></a><strong>1.4</strong> <strong>第一范式(1st NF)</strong></h5><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><h5 id="1-5-第二范式-2nd-NF"><a href="#1-5-第二范式-2nd-NF" class="headerlink" title="1.5 第二范式(2nd NF)"></a><strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h5><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><h5 id="1-6-第三范式-3rd-NF"><a href="#1-6-第三范式-3rd-NF" class="headerlink" title="1.6 第三范式(3rd NF)"></a><strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h5><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p><h5 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h5><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h4 id="2-反范式化"><a href="#2-反范式化" class="headerlink" title="2. 反范式化"></a><strong>2.</strong> <strong>反范式化</strong></h4><h5 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h5><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><h5 id="2-2-反范式的新问题"><a href="#2-2-反范式的新问题" class="headerlink" title="2.2 反范式的新问题"></a><strong>2.2</strong> <strong>反范式的新问题</strong></h5><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h5 id="2-3-反范式的适用场景"><a href="#2-3-反范式的适用场景" class="headerlink" title="2.3 反范式的适用场景"></a><strong>2.3</strong> <strong>反范式的适用场景</strong></h5><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong> </p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><h4 id="3-BCNF-巴斯范式"><a href="#3-BCNF-巴斯范式" class="headerlink" title="3. BCNF(巴斯范式)"></a><strong>3. BCNF(巴斯范式)</strong></h4><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p><h4 id="4-ER模型"><a href="#4-ER模型" class="headerlink" title="4. ER模型"></a><strong>4. ER模型</strong></h4><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><h5 id="4-1-ER-模型包括那些要素？"><a href="#4-1-ER-模型包括那些要素？" class="headerlink" title="4.1 ER 模型包括那些要素？"></a>4.1 ER 模型包括那些要素？</h5><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。 </p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h5 id="4-2-关系的类型"><a href="#4-2-关系的类型" class="headerlink" title="4.2 关系的类型"></a><strong>4.2</strong> <strong>关系的类型</strong></h5><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><h4 id="5-数据表的设计原则"><a href="#5-数据表的设计原则" class="headerlink" title="5. 数据表的设计原则"></a><strong>5.</strong> <strong>数据表的设计原则</strong></h4><p>数据表设计的一般原则：”三少一多” </p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong> </p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h4 id="6-数据库对象编写建议"><a href="#6-数据库对象编写建议" class="headerlink" title="6. 数据库对象编写建议"></a><strong>6.</strong> <strong>数据库对象编写建议</strong></h4><h5 id="6-1-关于库"><a href="#6-1-关于库" class="headerlink" title="6.1 关于库"></a><strong>6.1</strong> <strong>关于库</strong></h5><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h5 id="6-2-关于表、列"><a href="#6-2-关于表、列" class="headerlink" title="6.2 关于表、列"></a><strong>6.2</strong> <strong>关于表、列</strong></h5><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user_info ( <br>    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;, <br>    `user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;, <br>    `username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;, <br>    `email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;, <br>    `nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;, <br>    `birthday` date NOT NULL COMMENT &#x27;生日&#x27;, <br>    `sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;, <br>    `short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;, <br>    `user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;, <br>    `user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;, <br>    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, <br>    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, <br>    `user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#x27;,<br>    PRIMARY KEY (`id`), <br>    UNIQUE KEY `uniq_user_id` (`user_id`), <br>    KEY `idx_username`(`username`), <br>    KEY `idx_create_time_status`(`create_time`,`user_review_status`) <br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;<br></code></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h5 id="6-3-关于索引"><a href="#6-3-关于索引" class="headerlink" title="6.3 关于索引"></a><strong>6.3</strong> <strong>关于索引</strong></h5><ol><li><p>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h5 id="6-4-SQL编写"><a href="#6-4-SQL编写" class="headerlink" title="6.4 SQL编写"></a><strong>6.4 SQL编写</strong></h5><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol><h3 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章 数据库其它调优策略"></a>第12章 数据库其它调优策略</h3><h4 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a><strong>1.</strong> <strong>数据库调优的措施</strong></h4><h5 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a><strong>1.1</strong> <strong>调优的目标</strong></h5><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h5 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a><strong>1.2</strong> <strong>如何定位调优问题</strong></h5><ul><li><strong>用户的反馈（主要）</strong></li><li><strong>日志分析（主要）</strong></li><li><strong>服务器资源使用监控</strong></li><li><strong>数据库内部状况监控</strong></li><li><strong>其它</strong></li></ul><h5 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a><strong>1.3</strong> <strong>调优的维度和步骤</strong></h5><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong> </p><p><strong>第2步：优化表设计</strong> </p><p><strong>第3步：优化逻辑查询</strong></p><p><strong>第4步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p><p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p><p><strong>第6步：库级优化</strong> </p><p><strong>1、读写分离</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031025279.png" alt="202204031025279"></p><p><strong>2、数据分片</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031026743.png" alt="202204031026743"></p><h4 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a><strong>2.</strong> <strong>优化MySQL服务器</strong></h4><h5 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a><strong>2.1</strong> <strong>优化服务器硬件</strong></h5><p><strong>服务器的硬件性能直接决定着MySQL数据库的性能。</strong>硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p><p>（1）<code>配置较大的内存</code></p><p>（2）<code>配置高速磁盘系统</code></p><p>（3）<code>合理分布磁盘I/O</code></p><p>（4）<code>配置多处理器</code></p><h5 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2</strong> <strong>优化MySQL的参数</strong></h5><ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。 </li><li>当query_cache_type&#x3D;2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 </li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。 </li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。 </li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><h4 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a><strong>3.</strong> <strong>优化数据库结构</strong></h4><h5 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a><strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h5><h5 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a><strong>3.2</strong> <strong>增加中间表</strong></h5><h5 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a><strong>3.3</strong> <strong>增加冗余字段</strong></h5><h5 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a><strong>3.4</strong> <strong>优化数据类型</strong></h5><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p><p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p><strong>情况4：避免使用ENUM类型</strong></p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p><h5 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a><strong>3.5</strong> <strong>优化插入记录的速度</strong></h5><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><p><strong>② 禁用唯一性检查</strong></p><p><strong>③ 使用批量插入</strong></p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p><strong>2. InnoDB引擎的表：</strong></p><p> <strong>① 禁用唯一性检查</strong></p><p><strong>② 禁用外键检查</strong></p><p><strong>③ 禁止自动提交</strong></p><h5 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a><strong>3.6</strong> <strong>使用非空约束</strong></h5><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p><h5 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a><strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h5><p><strong>1.</strong> <strong>分析表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…<br></code></pre></td></tr></table></figure><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p><p><strong>2.</strong> <strong>检查表</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;<br></code></pre></td></tr></table></figure><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p><strong>3.</strong> <strong>优化表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...<br></code></pre></td></tr></table></figure><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。 </p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p><h3 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章 事务基础知识"></a>第13章 事务基础知识</h3><h4 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a><strong>1.</strong> <strong>数据库事务概述</strong></h4><h5 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a><strong>1.1</strong> <strong>基本概念</strong></h5><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚(<code>rollback</code>)到最初状态。</p><h5 id="1-2-事务的ACID特性"><a href="#1-2-事务的ACID特性" class="headerlink" title="1.2 事务的ACID特性"></a><strong>1.2</strong> <strong>事务的ACID特性</strong></h5><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><h5 id="1-3-事务的状态"><a href="#1-3-事务的状态" class="headerlink" title="1.3 事务的状态"></a><strong>1.3</strong> <strong>事务的状态</strong></h5><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204071125063.png" alt="202204071125063"></p><h4 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a><strong>2.</strong> <strong>如何使用事务</strong></h4><h5 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a><strong>2.1</strong> <strong>显式事务</strong></h5><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN; <br>#或者 <br>mysql&gt; START TRANSACTION;<br></code></pre></td></tr></table></figure><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>： </p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 提交事务。当提交事务后，对数据库的修改是永久性的。<br>mysql&gt; COMMIT;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 回滚事务。即撤销正在进行的所有没有提交的修改 <br>mysql&gt; ROLLBACK; <br><br># 将事务回滚到某个保存点。 <br>mysql&gt; ROLLBACK TO [SAVEPOINT]<br></code></pre></td></tr></table></figure><p>其中关于SAVEPOINT相关操作有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事物中可以存在多个保存点。<br>SAVEPOINT 保存点名称;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 删除某个保存点<br>RELEASE SAVEPOINT 保存点名称;<br></code></pre></td></tr></table></figure><h5 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a><strong>2.2</strong> <strong>隐式事务</strong></h5><ul><li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></li></ul><h5 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a><strong>2.3</strong> <strong>隐式提交数据的情况</strong></h5><ul><li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p></li><li><p><strong>隐式使用或修改mysql数据库中的表</strong></p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><ul><li>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</li><li>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</li></ul></li></ul><h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a><strong>3.</strong> <strong>事务隔离级别</strong></h4><h5 id="3-1-数据并发问题"><a href="#3-1-数据并发问题" class="headerlink" title="3.1 数据并发问题"></a><strong>3.1</strong> <strong>数据并发问题</strong></h5><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031124086.png" alt="202204031124086"></p><p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段。之后若 Session B<code>回滚</code>，Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031124136.png" alt="202204031124136"></p><p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p><p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031124331.png" alt="202204031124331"></p><p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031125847.png" alt="202204031125847"></p><p><strong>注意1：</strong></p><p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2：</strong></p><p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p><h5 id="3-2-SQL中的四种隔离级别"><a href="#3-2-SQL中的四种隔离级别" class="headerlink" title="3.2 SQL中的四种隔离级别"></a><strong>3.2 SQL中的四种隔离级别</strong></h5><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031127542.png" alt="202204031127542"></p><h5 id="3-3-如何设置事务的隔离级别"><a href="#3-3-如何设置事务的隔离级别" class="headerlink" title="3.3 如何设置事务的隔离级别"></a><strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; <br>#其中，隔离级别格式： <br>&gt; READ UNCOMMITTED <br>&gt; READ COMMITTED <br>&gt; REPEATABLE READ <br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27; <br>#其中，隔离级别格式： <br>&gt; READ-UNCOMMITTED <br>&gt; READ-COMMITTED <br>&gt; REPEATABLE-READ <br>&gt; SERIALIZABLE<br></code></pre></td></tr></table></figure><h3 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章 MySQL事务日志"></a>第14章 MySQL事务日志</h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><h4 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a><strong>1. redo日志</strong></h4><h5 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a><strong>1.1</strong> <strong>为什么需要REDO日志</strong></h5><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p><h5 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a><strong>1.2 REDO日志的好处、特点</strong></h5><p><strong>1.</strong> <strong>好处</strong></p><ul><li><strong>redo日志降低了刷盘频率</strong></li><li><strong>redo日志占用的空间非常小</strong></li></ul><p><strong>2.</strong> <strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong></li><li><strong>事务执行过程中，redo log不断记录</strong></li></ul><h5 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a><strong>1.3 redo的组成</strong></h5><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。 </p><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><h5 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a><strong>1.4 redo的整体流程</strong></h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031147714.png" alt="202204031147714"></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p><p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p><p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式 </p><p>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h5 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a><strong>1.5 redo log的刷盘策略</strong></h5><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>） </li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><h5 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a><strong>1.6</strong> <strong>不同刷盘策略演示</strong></h5><p><strong>1.</strong> <strong>流程图</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031152952.png" alt="202204031152952"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031152607.png" alt="202204031152607"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204031153931.png" alt="202204031153931"></p><h5 id="1-7-写入redo-log-buffer过程"><a href="#1-7-写入redo-log-buffer过程" class="headerlink" title="1.7 写入redo log buffer过程"></a><strong>1.7</strong> <strong>写入redo log buffer过程</strong></h5><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040912119.png" alt="202204040912119"></p><p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p><p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040915708.png" alt="202204040915708"></p><h5 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a><strong>1.8 redo log file</strong></h5><p><strong>1.</strong> <strong>相关参数设置</strong> </p><ul><li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。 </p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p></li></ul><p><strong>2.</strong> <strong>日志文件组</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040920532.png" alt="202204040920532"></p><p><strong>3. checkpoint</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040921715.png" alt="202204040921715"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><h4 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a><strong>2. Undo日志</strong></h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p><h5 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a><strong>2.1</strong> <strong>如何理解Undo日志</strong></h5><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><h5 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a><strong>2.2 Undo日志的作用</strong></h5><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC（详情看第16章）</strong></li></ul><h5 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a><strong>2.3 undo的存储结构</strong></h5><p><strong>1.</strong> <strong>回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><p><strong>2.</strong> <strong>回滚段与事务</strong> </p><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p><ol><li><p>未提交的回滚数据(uncommitted undo information) </p></li><li><p>已经提交但未过期的回滚数据(committed undo information) </p></li><li><p>事务已经提交并过期的数据(expired undo information)</p></li></ol><h5 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a><strong>2.4 undo的类型</strong></h5><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log </li><li>update undo log</li></ul><h5 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a><strong>2.5 undo log的生命周期</strong></h5><p><strong>1.</strong> <strong>简要生成过程</strong></p><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040937761.png" alt="202204040937761"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040938657.png" alt="202204040938657"></p><p><strong>2.</strong> <strong>详细生成过程</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040939231.png" alt="202204040939231"></p><p><strong>当我们执行INSERT时：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin; <br>INSERT INTO user (name) VALUES (&quot;tom&quot;);<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040940543.png" alt="202204040940543"></p><p><strong>当我们执行UPDATE时：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040941624.png" alt="202204040941624"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE user SET id=2 WHERE id=1;<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040941449.png" alt="202204040941449"></p><p><strong>3. undo log是如何回滚的</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li><p>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p></li><li><p>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0 </p></li><li><p>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom </p></li><li><p>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p></li></ol><p><strong>4. undo log的删除</strong></p><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h5 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a><strong>2.6</strong> <strong>小结</strong></h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204040944948.png" alt="202204040944948"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p><h3 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章 锁"></a>第15章 锁</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a><strong>1.</strong> <strong>概述</strong></h4><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a><strong>2. MySQL并发事务访问相同记录</strong></h4><h5 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a><strong>2.1</strong> <strong>读-读情况</strong></h5><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h5 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a><strong>2.2</strong> <strong>写-写情况</strong></h5><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p><h5 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a><strong>2.3</strong> <strong>读-写或写-读情况</strong></h5><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><h5 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a><strong>2.4</strong> <strong>并发问题的解决方案</strong></h5><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p></li><li><p>小结对比发现：</p><ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，<code>性能更高</code>。</li><li>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>，影响性能。</li></ul></li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</p><h4 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a><strong>3.</strong> <strong>锁的不同角度分类</strong></h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204050933339.png" alt="202204050933339"></p><h5 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a><strong>3.1</strong> <strong>从数据操作的类型划分：读锁、写锁</strong></h5><ul><li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于</strong> <strong>InnoDB</strong> <strong>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p><strong>1. 锁定读</strong></p><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li>对读取的记录加<code>S锁</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... LOCK IN SHARE MODE;<br># 或<br>SELECT ... FOR SHARE; #(8.0新增语法)<br></code></pre></td></tr></table></figure><ul><li>对读取的记录加<code>X锁</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FOR UPDATE;<br></code></pre></td></tr></table></figure><p><strong>MySQL8.0新特性：</strong></p><p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT … FOR UPDATE, SELECT … FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>NOWAIT：如果查询的行已经加锁，会立即报错返回</li><li>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</li></ul><p><strong>2. 写操作</strong></p><ul><li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</li><li><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：<ul><li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。</li><li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3：修改该记录的键值，则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</li></ul></li><li><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li></ul><h5 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a><strong>3.2</strong> <strong>从数据操作的粒度划分：表级锁、页级锁、行锁</strong></h5><p><strong>1.</strong> <strong>表锁（Table Lock）</strong> </p><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><p><strong>① 表级别的S锁、X锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。 </p></li><li><p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p></li></ul><p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p><p><strong>② 意向锁 （intention lock）</strong></p><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p><p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 <br>SELECT column FROM table ... LOCK IN SHARE MODE;<br></code></pre></td></tr></table></figure><ul><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 <br>SELECT column FROM table ... FOR UPDATE;<br></code></pre></td></tr></table></figure><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><p><strong>1. 意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p><ul><li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code></li><li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code></li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p><strong>③ 自增锁（AUTO-INC锁）</strong></p><p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong></p><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p><p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong></p><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。 </p><p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。 </p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时，<strong>从二进制日志重播SQL语句时，这是不安全的。</strong></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p><strong>④ 元数据锁（MDL锁）</strong></p><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p><p><strong>2. InnoDB中的行锁</strong></p><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p><p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">begin; <br>select * from student where id &lt;=8 and id &gt; 3 for update;<br></code></pre></td></tr></table></figure><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p><p><strong>3.</strong> <strong>页锁</strong></p><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h5 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a><strong>3.3</strong> <strong>从对待锁的态度划分:乐观锁、悲观锁</strong></h5><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><p><strong>1.</strong> <strong>悲观锁（Pessimistic Locking）</strong></p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>注意：<strong>select … for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p><p><strong>2.</strong> <strong>乐观锁（Optimistic Locking）</strong></p><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1.</strong> <strong>乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2.</strong> <strong>乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p><strong>3.</strong> <strong>两种锁的适用场景</strong></p><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p></li></ol><h5 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a><strong>3.4</strong> <strong>按加锁的方式划分：显式锁、隐式锁</strong></h5><p><strong>1.</strong> <strong>隐式锁</strong></p><ul><li><p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p><strong>2.</strong> <strong>显式锁</strong></p><p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p><h5 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a><strong>3.5</strong> <strong>其它锁之：全局锁</strong></h5><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Flush tables with read lock<br></code></pre></td></tr></table></figure><h5 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a><strong>3.6</strong> <strong>其它锁之：死锁</strong></h5><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p><p><strong>1. 如何处理死锁</strong></p><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s）</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p><p><strong>方式2：</strong>使用死锁检测进行死锁处理</p><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p><h4 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a><strong>4.</strong> <strong>锁的内存结构</strong></h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051514736.png" alt="202204051514736"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code>：</p><p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code>： </p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息：<ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p></blockquote><p><code>4. type_mode</code>：</p><p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051518659.png" alt="202204051518659"></p><ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。 </li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。 </li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。 </li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。 </li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。 </li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。 </li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：<ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code>：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code>：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p><h4 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a><strong>5.</strong> <strong>锁监控</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;<br></code></pre></td></tr></table></figure><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。 </p><p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p><h3 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章 多版本并发控制"></a>第16章 多版本并发控制</h3><h4 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a><strong>1.</strong> <strong>什么是MVCC</strong></h4><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><h4 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a><strong>2.</strong> <strong>快照读与当前读</strong></h4><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h5 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a><strong>2.1</strong> <strong>快照读</strong></h5><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的</strong> <strong>SELECT</strong> <strong>都属于快照读</strong>，即不加锁的非阻塞读。</p><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h5 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a><strong>2.2</strong> <strong>当前读</strong></h5><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><h4 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a><strong>3.</strong> <strong>复习</strong></h4><h5 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a><strong>3.1</strong> <strong>再谈隔离级别</strong></h5><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051536648.png" alt="202204051536648"></p><p>另图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051536125.png" alt="202204051536125"></p><h5 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a><strong>3.2</strong> <strong>隐藏字段、Undo Log版本链</strong></h5><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h4 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a><strong>4. MVCC实现原理之ReadView</strong></h4><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p><h5 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a><strong>4.1</strong> <strong>什么是ReadView</strong></h5><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p><h5 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a><strong>4.2</strong> <strong>设计思路</strong></h5><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li></ol><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 </p></blockquote><ol start="2"><li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。 </p></li><li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。 </p></li><li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><h5 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a><strong>4.3 ReadView的规则</strong></h5><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h5 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a><strong>4.4 MVCC整体操作流程</strong></h5><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li><p>首先获取事务自己的版本号，也就是事务 ID； </p></li><li><p>获取 ReadView； </p></li><li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p></li><li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p></li><li><p>最后返回符合规则的数据。</p></li></ol><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051549618.png" alt="202204051549618"></p><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051550072.png" alt="202204051550072"></p><h4 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a><strong>5.</strong> <strong>举例说明</strong></h4><h5 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a><strong>5.1 READ COMMITTED隔离级别下</strong></h5><p><strong>READ COMMITTED</strong> <strong>：每次读取数据前都生成一个ReadView</strong>。</p><h5 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a><strong>5.2 REPEATABLE READ隔离级别下</strong></h5><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</p><h5 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a><strong>5.3</strong> <strong>如何解决幻读</strong></h5><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051556631.png" alt="202204051556631"></p><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where id &gt;= 1;<br></code></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p><p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into student(id,name) values(2,&#x27;李四&#x27;); <br>insert into student(id,name) values(3,&#x27;王五&#x27;);<br></code></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051559345.png" alt="202204051559345"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051559867.png" alt="202204051559867"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6.</strong> <strong>总结</strong></h4><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView </li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul><h3 id="第17章-其它数据库日志"><a href="#第17章-其它数据库日志" class="headerlink" title="第17章 其它数据库日志"></a>第17章 其它数据库日志</h3><h4 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a><strong>1. MySQL支持的日志</strong></h4><h5 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a><strong>1.1</strong> <strong>日志类型</strong></h5><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><ul><li><p><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p></li><li><p><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p></li><li><p><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p></li><li><p><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p></li><li><p><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p></li><li><p><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</p></li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h5 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a><strong>1.2</strong> <strong>日志的弊端</strong></h5><ul><li><p>日志功能会<code>降低MySQL数据库的性能</code>。</p></li><li><p>日志会<code>占用大量的磁盘空间</code>。</p></li></ul><h4 id="2-通用查询日志-general-query-log"><a href="#2-通用查询日志-general-query-log" class="headerlink" title="2. 通用查询日志(general query log)"></a><strong>2.</strong> <strong>通用查询日志(general query log)</strong></h4><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h5 id="2-1-查看当前状态"><a href="#2-1-查看当前状态" class="headerlink" title="2.1 查看当前状态"></a><strong>2.1</strong> <strong>查看当前状态</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#x27;%general%&#x27;;<br></code></pre></td></tr></table></figure><h5 id="2-2-启动日志"><a href="#2-2-启动日志" class="headerlink" title="2.2 启动日志"></a><strong>2.2</strong> <strong>启动日志</strong></h5><p><strong>方式1：永久性方式</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">general_log</span>=<span class="hljs-literal">ON</span> <br><span class="hljs-attr">general_log_file</span>=[path[filename]] <span class="hljs-comment">#日志文件所在目录路径，filename为日志文件名</span><br></code></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL general_log=on; # 开启通用查询日志<br>SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置<br>SET GLOBAL general_log=off; # 关闭通用查询日志<br>SHOW VARIABLES LIKE &#x27;general_log%&#x27;; # 查看设置后情况<br></code></pre></td></tr></table></figure><h5 id="2-3-停止日志"><a href="#2-3-停止日志" class="headerlink" title="2.3 停止日志"></a><strong>2.3</strong> <strong>停止日志</strong></h5><p><strong>方式1：永久性方式</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">general_log</span>=<span class="hljs-literal">OFF</span><br></code></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL general_log=off;<br>SHOW VARIABLES LIKE &#x27;general_log%&#x27;;<br></code></pre></td></tr></table></figure><h4 id="3-错误日志-error-log"><a href="#3-错误日志-error-log" class="headerlink" title="3.错误日志(error log)"></a><strong>3.错误日志(error log)</strong></h4><h5 id="3-1-启动日志"><a href="#3-1-启动日志" class="headerlink" title="3.1 启动日志"></a><strong>3.1</strong> <strong>启动日志</strong></h5><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">log-error</span>=[path/[filename]] <span class="hljs-comment">#path为日志文件所在的目录路径，filename为日志文件名</span><br></code></pre></td></tr></table></figure><h5 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a><strong>3.2</strong> <strong>查看日志</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#x27;log_err%&#x27;;<br></code></pre></td></tr></table></figure><h5 id="3-3-删除-刷新日志"><a href="#3-3-删除-刷新日志" class="headerlink" title="3.3 删除\刷新日志"></a><strong>3.3</strong> <strong>删除\刷新日志</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log<br>mysqladmin -uroot -p flush-logs<br></code></pre></td></tr></table></figure><h4 id="4-二进制日志-bin-log"><a href="#4-二进制日志-bin-log" class="headerlink" title="4. 二进制日志(bin log)"></a><strong>4.</strong> <strong>二进制日志(bin log)</strong></h4><h5 id="4-1-查看默认情况"><a href="#4-1-查看默认情况" class="headerlink" title="4.1 查看默认情况"></a><strong>4.1</strong> <strong>查看默认情况</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;%log_bin%&#x27;;<br></code></pre></td></tr></table></figure><h5 id="4-2-日志参数设置"><a href="#4-2-日志参数设置" class="headerlink" title="4.2 日志参数设置"></a><strong>4.2</strong> <strong>日志参数设置</strong></h5><p><strong>方式1：永久性方式</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">#启用二进制日志 </span><br><span class="hljs-attr">log-bin</span>=atguigu-bin <br><span class="hljs-attr">binlog_expire_logs_seconds</span>=<span class="hljs-number">600</span> max_binlog_size=<span class="hljs-number">100</span>M<br></code></pre></td></tr></table></figure><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-attr">log-bin</span>=<span class="hljs-string">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></code></pre></td></tr></table></figure><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R -v mysql:mysql binlog<br></code></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># global 级别 <br>mysql&gt; set global sql_log_bin=0; <br>ERROR 1228 (HY000): Variable &#x27;sql_log_bin&#x27; is a SESSION variable and can`t be used with SET GLOBAL <br><br># session级别 <br>mysql&gt; SET sql_log_bin=0; <br>Query OK, 0 rows affected (0.01 秒)<br></code></pre></td></tr></table></figure><h5 id="4-3-查看日志"><a href="#4-3-查看日志" class="headerlink" title="4.3 查看日志"></a><strong>4.3</strong> <strong>查看日志</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;<br># 不显示binlog格式的语句<br>mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 可查看参数帮助 <br>mysqlbinlog --no-defaults --help <br><br># 查看最后100行 <br>mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 <br><br># 根据position查找 <br>mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A20 &#x27;4939002&#x27;<br></code></pre></td></tr></table></figure><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];<br></code></pre></td></tr></table></figure><ul><li><code>IN &#39;log_name&#39;</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li><li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0) </li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#x27;atguigu-bin.000002&#x27;;<br></code></pre></td></tr></table></figure><h5 id="4-4-使用日志恢复数据"><a href="#4-4-使用日志恢复数据" class="headerlink" title="4.4 使用日志恢复数据"></a><strong>4.4</strong> <strong>使用日志恢复数据</strong></h5><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [option] filename|mysql –uuser -ppass;<br></code></pre></td></tr></table></figure><ul><li><code>filename</code>：是日志文件名。</li><li><code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。 <ul><li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><h5 id="4-5-删除二进制日志"><a href="#4-5-删除二进制日志" class="headerlink" title="4.5 删除二进制日志"></a><strong>4.5</strong> <strong>删除二进制日志</strong></h5><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’ <br>PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’<br></code></pre></td></tr></table></figure><h4 id="5-再谈二进制日志-binlog"><a href="#5-再谈二进制日志-binlog" class="headerlink" title="5. 再谈二进制日志(binlog)"></a><strong>5.</strong> <strong>再谈二进制日志(binlog)</strong></h4><h5 id="5-1-写入机制"><a href="#5-1-写入机制" class="headerlink" title="5.1 写入机制"></a><strong>5.1</strong> <strong>写入机制</strong></h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051630535.png" alt="202204051630535"></p><p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051631346.png" alt="202204051631346"></p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log</strong> <strong>刷盘流程</strong>一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051632526.png" alt="202204051632526"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h5 id="5-2-binlog与redolog对比"><a href="#5-2-binlog与redolog对比" class="headerlink" title="5.2 binlog与redolog对比"></a><strong>5.2 binlog与redolog对比</strong></h5><ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性</li></ul></li></ul><h5 id="5-3-两阶段提交"><a href="#5-3-两阶段提交" class="headerlink" title="5.3 两阶段提交"></a><strong>5.3</strong> <strong>两阶段提交</strong></h5><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051637390.png" alt="202204051637390"></p><p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051639192.png" alt="202204051639192"></p><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051639403.png" alt="202204051639403"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h4 id="6-中继日志-relay-log"><a href="#6-中继日志-relay-log" class="headerlink" title="6. 中继日志(relay log)"></a><strong>6.</strong> <strong>中继日志(relay log)</strong></h4><h5 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a><strong>6.1</strong> <strong>介绍</strong></h5><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><h5 id="6-2-恢复的典型错误"><a href="#6-2-恢复的典型错误" class="headerlink" title="6.2 恢复的典型错误"></a><strong>6.2</strong> <strong>恢复的典型错误</strong></h5><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p><h3 id="第18章-主从复制"><a href="#第18章-主从复制" class="headerlink" title="第18章 主从复制"></a>第18章 主从复制</h3><h4 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a><strong>1.</strong> <strong>主从复制概述</strong></h4><h5 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a><strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h5><p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h5 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a><strong>1.2</strong> <strong>主从复制的作用</strong></h5><p><strong>第1个作用：读写分离。</strong></p><p><strong>第2个作用就是数据备份。</strong></p><p><strong>第3个作用是具有高可用性。</strong></p><h4 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a><strong>2.</strong> <strong>主从复制的原理</strong></h4><h5 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a><strong>2.1</strong> <strong>原理剖析</strong></h5><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051646097.png" alt="202204051646097"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051647759.png" alt="202204051647759"></p><p><strong>复制三步骤</strong></p><p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h5 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a><strong>2.2</strong> <strong>复制的基本原则</strong></h5><ul><li><p>每个<code>Slave</code>只有一个<code>Master</code></p></li><li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p></li><li><p>每个<code>Master</code>可以有多个<code>Slave</code></p></li></ul><h4 id="3-同步数据一致性问题"><a href="#3-同步数据一致性问题" class="headerlink" title="3. 同步数据一致性问题"></a><strong>3.</strong> <strong>同步数据一致性问题</strong></h4><p><strong>主从同步的要求：</strong></p><ul><li><p>读库和写库的数据一致(最终一致)；</p></li><li><p>写数据必须写到写库；</p></li><li><p>读数据必须到读库(不一定)；</p></li></ul><h5 id="3-1-理解主从延迟问题"><a href="#3-1-理解主从延迟问题" class="headerlink" title="3.1 理解主从延迟问题"></a><strong>3.1</strong> <strong>理解主从延迟问题</strong></h5><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><h5 id="3-2-主从延迟问题原因"><a href="#3-2-主从延迟问题原因" class="headerlink" title="3.2 主从延迟问题原因"></a><strong>3.2</strong> <strong>主从延迟问题原因</strong></h5><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong>造成原因：</p><p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><h5 id="3-3-如何减少主从延迟"><a href="#3-3-如何减少主从延迟" class="headerlink" title="3.3 如何减少主从延迟"></a><strong>3.3</strong> <strong>如何减少主从延迟</strong></h5><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ol><h5 id="3-4-如何解决一致性问题"><a href="#3-4-如何解决一致性问题" class="headerlink" title="3.4 如何解决一致性问题"></a><strong>3.4</strong> <strong>如何解决一致性问题</strong></h5><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p><p><strong>方法</strong> <strong>1：异步复制</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051654133.png" alt="202204051654133"></p><p><strong>方法</strong> <strong>2：半同步复制</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051655175.png" alt="202204051655175"></p><p><strong>方法</strong> <strong>3：组复制</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202204051656560.png" alt="202204051656560"></p><h3 id="第19章-数据库备份与恢复"><a href="#第19章-数据库备份与恢复" class="headerlink" title="第19章 数据库备份与恢复"></a>第19章 数据库备份与恢复</h3><h4 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a><strong>1.</strong> <strong>物理备份与逻辑备份</strong></h4><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h4 id="2-mysqldump实现逻辑备份"><a href="#2-mysqldump实现逻辑备份" class="headerlink" title="2. mysqldump实现逻辑备份"></a><strong>2. mysqldump实现逻辑备份</strong></h4><h5 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a><strong>2.1</strong> <strong>备份一个数据库</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名 称.sql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu&gt;atguigu.sql #备份文件存储在当前目录下<br>mysqldump -uroot -p atguigudb1 &gt; /var/lib/mysql/atguigu.sql<br></code></pre></td></tr></table></figure><h5 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a><strong>2.2</strong> <strong>备份全部数据库</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql <br>mysqldump -uroot -pxxxxxx -A &gt; all_database.sql<br></code></pre></td></tr></table></figure><h5 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a><strong>2.3</strong> <strong>备份部分数据库</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名 称.sql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p --databases atguigu atguigu12 &gt;two_database.sql<br>mysqldump -uroot -p -B atguigu atguigu12 &gt; two_database.sql<br></code></pre></td></tr></table></figure><h5 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a><strong>2.4</strong> <strong>备份部分表</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu book&gt; book.sql<br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份多张表</span> <br>mysqldump -uroot -p atguigu book account &gt; 2_tables_bak.sql<br></code></pre></td></tr></table></figure><h5 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a><strong>2.5</strong> <strong>备份单表的部分数据</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu student --where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql<br></code></pre></td></tr></table></figure><h5 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a><strong>2.6</strong> <strong>排除某些表的备份</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql<br></code></pre></td></tr></table></figure><h5 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a><strong>2.7</strong> <strong>只备份结构或只备份数据</strong></h5><ul><li>只备份结构</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu --no-data &gt; atguigu_no_data_bak.sql<br></code></pre></td></tr></table></figure><ul><li>只备份数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p atguigu --no-create-info &gt; atguigu_no_create_info_bak.sql<br></code></pre></td></tr></table></figure><h5 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a><strong>2.8</strong> <strong>备份中包含存储过程、函数、事件</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p -R -E --databases atguigu &gt; fun_atguigu_bak.sql<br></code></pre></td></tr></table></figure><h4 id="3-mysql命令恢复数据"><a href="#3-mysql命令恢复数据" class="headerlink" title="3. mysql命令恢复数据"></a><strong>3. mysql命令恢复数据</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql –u root –p [dbname] &lt; backup.sql<br></code></pre></td></tr></table></figure><h5 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a><strong>3.1</strong> <strong>单库备份中恢复单库</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">备份文件中包含了创建数据库的语句</span><br>mysql -uroot -p &lt; atguigu.sql<br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份文件中不包含了创建数据库的语句</span><br>mysql -uroot -p atguigu4&lt; atguigu.sql<br></code></pre></td></tr></table></figure><h5 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a><strong>3.2</strong> <strong>全量备份恢复</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql –u root –p &lt; all.sql<br></code></pre></td></tr></table></figure><h5 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a><strong>3.3</strong> <strong>从全量备份中恢复单库</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -n &#x27;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#x27; all_database.sql &gt; atguigu.sql <br><span class="hljs-meta prompt_">#</span><span class="language-bash">分离完成后我们再导入atguigu.sql即可恢复单个库</span><br></code></pre></td></tr></table></figure><h5 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a><strong>3.4</strong> <strong>从单库备份中恢复单表</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat atguigu.sql | sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/CREATE TABLE `class`/!d;q&#x27; &gt; class_structure.sql <br>cat atguigu.sql | grep --ignore-case &#x27;insert into `class`&#x27; &gt; class_data.sql <br><span class="hljs-meta prompt_">#</span><span class="language-bash">用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span> <br><br>use atguigu; <br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">source</span> class_structure.sql;</span> <br>Query OK, 0 rows affected, 1 warning (0.00 sec) <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">source</span> class_data.sql;</span> <br>Query OK, 1 row affected (0.01 sec)<br></code></pre></td></tr></table></figure><h4 id="4-表的导出与导入"><a href="#4-表的导出与导入" class="headerlink" title="4. 表的导出与导入"></a><strong>4.</strong> <strong>表的导出与导入</strong></h4><h5 id="4-1-表的导出"><a href="#4-1-表的导出" class="headerlink" title="4.1 表的导出"></a><strong>4.1</strong> <strong>表的导出</strong></h5><p><strong>1.</strong> <strong>使用SELECT…INTO OUTFILE导出文本文件</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GLOBAL VARIABLES LIKE &#x27;%secure%&#x27;;<br>SELECT * FROM account INTO OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用mysqldump命令导出文本文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;<br></code></pre></td></tr></table></figure><p><strong>3.</strong> <strong>使用mysql命令导出文本文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;<br></code></pre></td></tr></table></figure><h5 id="4-2-表的导入"><a href="#4-2-表的导入" class="headerlink" title="4.2 表的导入"></a><strong>4.2</strong> <strong>表的导入</strong></h5><p><strong>1.</strong> <strong>使用LOAD DATA INFILE方式导入文本文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOAD DATA INFILE &#x27;/var/lib/mysql-files/account_0.txt&#x27; INTO TABLE atguigu.account;<br># 或<br>LOAD DATA INFILE &#x27;/var/lib/mysql-files/account_1.txt&#x27; INTO TABLE atguigu.account FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;\&quot;&#x27;;<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用mysqlimport方式导入文本文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlimport -uroot -p atguigu &#x27;/var/lib/mysql-files/account.txt&#x27; --fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/2022/09/05/MySQL%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/09/05/MySQL%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png" alt="img"></a></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td></tr></tbody></table><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h1 id="二、性能与JOIN"><a href="#二、性能与JOIN" class="headerlink" title="二、性能与JOIN"></a>二、性能与JOIN</h1><h2 id="1、性能下降原因"><a href="#1、性能下降原因" class="headerlink" title="1、性能下降原因"></a>1、性能下降原因</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p><strong>单值索引</strong></p><p>创建语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_表名_字段名 ON 表名(字段名);Copy<br></code></pre></td></tr></table></figure><p><strong>复合索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_表名_字段名1字段名2... ON 表名(字段名1, 字段名2 ...);Copy<br></code></pre></td></tr></table></figure><h3 id="关联太多JOIN"><a href="#关联太多JOIN" class="headerlink" title="关联太多JOIN"></a>关联太多JOIN</h3><p>内连接、外连接的表不要过多</p><h3 id="服务器调优及参数设置"><a href="#服务器调优及参数设置" class="headerlink" title="服务器调优及参数设置"></a>服务器调优及参数设置</h3><h2 id="2、SQL执行加载顺序"><a href="#2、SQL执行加载顺序" class="headerlink" title="2、SQL执行加载顺序"></a>2、SQL执行加载顺序</h2><h3 id="手写顺序"><a href="#手写顺序" class="headerlink" title="手写顺序"></a>手写顺序</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112248.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938114.png" alt="img"></a></p><p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p><p>下面是经常出现的查询顺序：</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112330.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938074.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112343.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938224.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814191644.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938193.png" alt="img"></a></p><h2 id="3、7种JOIN"><a href="#3、7种JOIN" class="headerlink" title="3、7种JOIN"></a>3、7种JOIN</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938270.png" alt="img"></a></p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>CREATE TABLE `t_emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, empno INT NOT NULL, PRIMARY KEY (`id`), KEY `idx_dept_id` (`deptId`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;);<br>INSERT INTO t_dept(deptName,address) VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;风清扬&#x27;,90,1,100001);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;岳不群&#x27;,50,1,100002);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;令狐冲&#x27;,24,1,100003);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;洪七公&#x27;,70,2,100004);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;乔峰&#x27;,35,2,100005);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;灭绝师太&#x27;,70,3,100006);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;周芷若&#x27;,20,3,100007);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张三丰&#x27;,100,4,100008);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张无忌&#x27;,25,5,100009);<br>INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;韦小宝&#x27;,18,NULL,100010);Copy<br></code></pre></td></tr></table></figure><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><ul><li>笛卡尔积</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_dept, t_emp;Copy<br></code></pre></td></tr></table></figure><p>t_dept共20条记录，t_emp共6条记录。两表共同查询后共120条记录</p><ul><li>内连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a INNER JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153140.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938633.png" alt="img"></a></p><ul><li>左外连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153254.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938412.png" alt="img"></a></p><ul><li>右外连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON  a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png" alt="img"></a></p><ul><li>左外连接<strong>取左表的独有部分</strong></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153909.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938516.png" alt="img"></a></p><ul><li>右外连接<strong>取右表的独有部分</strong></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId = b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png" alt="img"></a></p><p><strong>注意</strong>：判断字段是否为NULL时，<strong>不能使用’&#x3D;’</strong></p><p>因为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">= NULLCopy<br></code></pre></td></tr></table></figure><p>的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IS NULLCopy<br></code></pre></td></tr></table></figure><p>来进行判空</p><ul><li>全外连接</li></ul><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.deptId = b.id<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.deptId = b.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png" alt="img"></a></p><ul><li>查询两表独有内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.deptId = b.id WHERE b.id IS NULL<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.deptId = b.id WHERE a.deptId IS NULL;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png" alt="img"></a></p><h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p><p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938615.png" alt="img"></a></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [UNIQUE] INDEX [indexName] ON table_name(column);Copy<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX [indexName] ON table_name;Copy<br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW INDEX FROM table_name;Copy<br></code></pre></td></tr></table></figure></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单值索引</p><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name) --单值索引<br>);<br><br>--单独创建单值索引<br>CREATE INDEX idx_customer_name ON customer(customer_name);Copy<br></code></pre></td></tr></table></figure></li></ul></li><li><p>唯一索引</p><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no) --唯一索引<br>);<br><br>--单独创建唯一索引<br>CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);Copy<br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键索引</p><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id) --主键索引<br>);<br><br>--单独创建主键索引<br>ALTER TABLE customer ADD PRIMARY KEY customer(customer_no);<br><br>--删除主键索引<br>ALTER TABLE customer DROP PRIMARY KEY;<br><br>--修改建主键索引<br>必须先删除掉(drop)原索引，再新建(add)索引Copy<br></code></pre></td></tr></table></figure></li></ul></li><li><p>复合索引</p><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--和表一起创建<br>CREATE TABLE customer (<br>id INT(10) UNSIGNED AUTO_INCREMENT,<br>customer_no VARCHAR(200),<br>customer_name VARCHAR(200), <br>PRIMARY KEY(id), <br>KEY (customer_name), --单值索引<br>UNIQUE (customer_no), --唯一索引<br>KEY (customer_no,customer_name) --复合索引<br>);<br><br>--单独创建复合索引<br>CREATE INDEX idx_no_name ON customer(customer_no,customer_name);Copy<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>树的内容参照<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#B%E6%A0%91%E3%80%81B-%E5%92%8CB-%E6%A0%91">JAVA数据结构 B树、B+树和B*树</a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153029.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938560.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153043.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938623.png" alt="img"></a></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li><li>在 B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822173605.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938608.png" alt="img"></a></p><p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822185520.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938584.png" alt="img"></a></p><p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p><table><thead><tr><th>a（主键）</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>1</td><td>1</td><td>a</td></tr></tbody></table><p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p><p>根据这个特点，可以看出复合索引具有以下使用方法</p><ul><li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p></li><li><p>覆盖索引的同时，可以带上主键字段，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT a, b, c, d FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p></li><li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p><ul><li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age &gt; 1;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938598.png" alt="img"></a></p></li><li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后映射到全表中的对应记录上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age &gt; 80;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938821.png" alt="img"></a></p></li><li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT age, name FROM t_emp WHERE age &gt; 1;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938841.png" alt="img"></a></p></li></ul></li><li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT id, age, name, deptId FROM t_emp ;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938863.png" alt="img"></a></p></li></ul><h2 id="5、索引的使用场景"><a href="#5、索引的使用场景" class="headerlink" title="5、索引的使用场景"></a>5、索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引</li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引</li><li>单键&#x2F;组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--EXPLAIN + SQL语句，如：<br>EXPLAIN SELECT * FROM person;Copy<br></code></pre></td></tr></table></figure><p><strong>Explain 执行后返回的信息：</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815171636.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938872.png" alt="img"></a></p><h2 id="3、表头字段介绍"><a href="#3、表头字段介绍" class="headerlink" title="3、表头字段介绍"></a>3、表头字段介绍</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));<br>INSERT INTO t1(content) VALUES(CONCAT(&#x27;t1_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t2(content) VALUES(CONCAT(&#x27;t2_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t3(content) VALUES(CONCAT(&#x27;t3_&#x27;,FLOOR(1+RAND()*1000)));<br>INSERT INTO t4(content) VALUES(CONCAT(&#x27;t4_&#x27;,FLOOR(1+RAND()*1000)));Copy<br></code></pre></td></tr></table></figure><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.id = t3.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938880.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></li><li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT t2.id FROM t2 WHERE t2.id = <br>(SELECT t1.id FROM t1 WHERE t1.id = <br>(SELECT t3.id FROM t3)<br>);Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938889.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p></li><li><p><strong>id相同又不同</strong>： 执行顺序为</p><ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM (SELECT t3.id FROM t3) s1, t2 WHERE s1.id = t2.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938548.png" alt="img"></a></p><p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p><ul><li>其中dervied<strong>2</strong> 的 2，为 id &#x3D; 2</li></ul></li></ul><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p><ul><li>都是 WHERE 后面的条件，SUBQUERY 是单个值（&#x3D;），DEPEDENT SUBQUERY 是一组值（IN）</li></ul></li><li><p>UNCACHEABLE SUBQUERY</p><ul><li>当使用了**@@来引用系统变量**的时候，不会使用缓存</li></ul></li><li><p>UNION 和 UNION RESULT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp a LEFT JOIN  t_dept b ON a.deptId = b.id WHERE b.id IS NULL<br>UNION<br>SELECT * FROM t_emp a RIGHT JOIN  t_dept b ON a.deptId = b.id WHERE a.deptId IS NULL;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938582.png" alt="img"></a></p></li></ul><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all<br><br>--常见的顺序为<br>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; allCopy<br></code></pre></td></tr></table></figure><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><p>REF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，且用到了&#x27; = &#x27;<br>EXPLAIN SELECT * FROM t_emp WHERE deptId = 3;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938590.png" alt="img"></a></p></li><li><p>RANGE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询<br>EXPLAIN SELECT * FROM t_emp WHERE deptId &gt; 3;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938633.png" alt="img"></a></p></li><li><p>INDEX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中deptId为索引，查找了整张表时，用到了索引<br>EXPLAIN SELECT deptId FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938678.png" alt="img"></a></p></li><li><p>ALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中name为非索引<br>EXPLAIN SELECT name FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938683.png" alt="img"></a></p></li></ul><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE id = 1 AND deptId = 1;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938315.png" alt="img"></a></p><p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--其中id和deptId都为索引<br>EXPLAIN SELECT id, deptId FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938353.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938345.png" alt="img"></a></p><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><p><strong>ken_len 越长，说明索引使用的越充分</strong></p><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938332.png" alt="img"></a></p><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><p><strong>验证</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--先删除索引<br>DROP INDEX idx_dept_id ON t_emp;<br><br>--查找<br>EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;<br><br>--再创建索引<br>CREATE INDEX idx_dept_id ON t_emp(deptId);<br><br>--查找<br>EXPLAIN SELECT * FROM t_dept, t_emp WHERE t_emp.deptId = t_dept.id;Copy<br></code></pre></td></tr></table></figure><p><strong>结果如下</strong></p><ul><li><p>未使用索引时，一共需要查询26行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938356.png" alt="img"></a></p></li><li><p>使用索引后，一共需要查询6行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938337.png" alt="img"></a></p></li></ul><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p><ul><li><p><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）</p><ul><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul><p><strong>演示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--创建符合索引<br>CREATE INDEX idx_emp_empno_age ON t_emp(empno, age);<br><br>--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY age;<br><br>--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY empno;<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 ORDER BY empno, age;Copy<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938860.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938839.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938905.png" alt="img"></a></p></li><li><p><strong>Using temporary</strong></p><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul><p><strong>演示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）<br>CREATE INDEX idx_emp_empno_age ON t_emp(empno, age);<br><br>----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 GROUP BY empno;<br>EXPLAIN SELECT empno FROM t_emp WHERE empno &gt;100002 GROUP BY empno, age;Copy<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938892.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938898.png" alt="img"></a></p></li></ul><p><strong>重要结论</strong></p><p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降</p><ul><li><p><strong>Using index</strong></p><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见<a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">key：实际用到的索引——覆盖索引</a>，避免访问了表的数据行，<strong>效率不错</strong>！</li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul><p><strong>演示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询 age 字段，使用了WHERE<br>EXPLAIN SELECT age FROM t_emp WHERE age &gt;100000;<br><br>--查询 empno 和 age 字段，未使用WHERE<br>EXPLAIN SELECT empno, age FROM t_emp;<br><br>--查询 empno 和 name 字段 （name字段不是索引）<br>EXPLAIN SELECT empno, name FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938889.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938242.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938255.png" alt="img"></a></p></li><li><p>Using where</p><ul><li>表明使用了 where 过滤</li></ul></li><li><p>Using join buffer</p><ul><li>使用了连接缓存</li></ul></li><li><p>impossible where</p><ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul></li><li><p>select tables optimized away</p><ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul></li></ul><h1 id="五、单表查询优化"><a href="#五、单表查询优化" class="headerlink" title="五、单表查询优化"></a>五、单表查询优化</h1><h2 id="1、全值匹配很快捷"><a href="#1、全值匹配很快捷" class="headerlink" title="1、全值匹配很快捷"></a>1、全值匹配很快捷</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--建立符合索引（age, deptId, name）<br>CREATE INDEX idx_emp_ade ON t_emp(age, deptId, NAME);<br><br>--查找<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br><br>--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = &#x27;风清扬&#x27; AND age = 90;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938279.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938299.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938328.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938306.png" alt="img"></a></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--先删除之前创建的单值索引<br>DROP INDEX idx_dept_id ON t_emp; <br><br>--查询，未按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = &#x27;风清扬&#x27;;<br><br>--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）<br>EXPLAIN SELECT empno FROM t_emp WHERE  age = 90 AND name = &#x27;风清扬&#x27;;<br><br>--查询，完全按照最佳左前缀法则<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938683.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938654.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938681.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938299.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938306.png" alt="img"></a></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="3、索引列上不计算"><a href="#3、索引列上不计算" class="headerlink" title="3、索引列上不计算"></a>3、索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--直接查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND NAME = &#x27;风清扬&#x27;;<br><br>--使用MySQL函数查询<br>EXPLAIN SELECT empno FROM t_emp WHERE LEFT(age,2) = 90 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938706.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938691.png" alt="img"></a></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="4、范围之后全失效"><a href="#4、范围之后全失效" class="headerlink" title="4、范围之后全失效"></a>4、范围之后全失效</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age &gt; 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId &gt; 1 AND NAME = &#x27;风清扬&#x27;;<br><br>--未使用范围查询<br>EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId = 1 AND name = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938727.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938093.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938122.png" alt="img"></a></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="5、覆盖索引多使用"><a href="#5、覆盖索引多使用" class="headerlink" title="5、覆盖索引多使用"></a>5、覆盖索引多使用</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询所有字段<br>EXPLAIN SELECT * FROM t_dept WHERE id = 1;<br><br>--查询索引字段<br>EXPLAIN SELECT id FROM t_dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938153.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938097.png" alt="img"></a></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="6、使用不等会失效"><a href="#6、使用不等会失效" class="headerlink" title="6、使用不等会失效"></a>6、使用不等会失效</h2><p>在使用<strong>不等于(!&#x3D; 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--SQL语句中有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age != 90;<br>EXPLAIN SELECT * FROM t_emp WHERE age &lt;&gt; 90;<br><br>--SQL语句中没有不等于<br>EXPLAIN SELECT * FROM t_emp WHERE age = 90;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938138.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938109.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938519.png" alt="img"></a></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="7、使用NULL值要小心"><a href="#7、使用NULL值要小心" class="headerlink" title="7、使用NULL值要小心"></a>7、使用NULL值要小心</h2><p>在使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IS NULL<br>或者<br>IS NOT NULLCopy<br></code></pre></td></tr></table></figure><p>时，可能会导致索引失效</p><p>但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938561.png" alt="img"></a></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM t_emp WHERE age IS NULL;<br><br>EXPLAIN SELECT * FROM t_emp WHERE age IS NOT NULL;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938495.png" alt="img"></a></p><h2 id="8、模糊查询加右边"><a href="#8、模糊查询加右边" class="headerlink" title="8、模糊查询加右边"></a>8、模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--创建单值索引<br>CREATE INDEX idx_emp_name ON t_emp(NAME);<br><br>--进行模糊查询<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;风%&#x27;;<br>EXPLAIN SELECT * FROM t_emp WHERE name LIKE &#x27;%风%&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938493.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938511.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938493.png" alt="img"></a></p><p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p><p>其他情况均失效了</p><p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT name FROM t_emp WHERE name LIKE &#x27;%风&#x27;;<br>EXPLAIN SELECT name FROM t_emp WHERE name LIKE &#x27;风%&#x27;;<br><br>EXPLAIN SELECT NAME FROM t_emp WHERE name LIKE &#x27;%风%&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938970.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938973.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938970.png" alt="img"></a></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><h2 id="9、字符串加单引号"><a href="#9、字符串加单引号" class="headerlink" title="9、字符串加单引号"></a>9、字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><p><strong>用于查询的表</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938997.png" alt="img"></a></p><p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--使用了单引号<br>EXPLAIN SELECT card_id FROM person WHERE card_id = &#x27;1&#x27;;<br><br>--未使用单引号，发生自动类型转换<br>EXPLAIN SELECT card_id FROM person WHERE card_id = 1;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938977.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938982.png" alt="img"></a></p><h2 id="10、尽量不用or查询"><a href="#10、尽量不用or查询" class="headerlink" title="10、尽量不用or查询"></a>10、尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--使用or进行查询<br>EXPLAIN SELECT * FROM t_emp WHERE age = 90 OR NAME = &#x27;风清扬&#x27;;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938142.png" alt="img"></a></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全职匹配我最爱，最左前缀要遵守</p><p>带头大哥不能死，中间兄弟不能断</p><p>索引列上少计算，范围之后全失效</p><p>LIKE 百分写最右，覆盖索引不写*</p><p>不等空值还有 OR，索引影响要注意</p><p>VARCHAR 引号不可丢，SQL 优化有诀窍</p><h1 id="六、关联查询优化"><a href="#六、关联查询优化" class="headerlink" title="六、关联查询优化"></a>六、关联查询优化</h1><p><strong>建表语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `class` (<br>`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`id`)<br>);<br>CREATE TABLE IF NOT EXISTS `book` (<br>`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `card` INT(10) UNSIGNED NOT NULL, PRIMARY KEY (`bookid`)<br>);<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));Copy<br></code></pre></td></tr></table></figure><h2 id="1、LEFT-JOIN优化"><a href="#1、LEFT-JOIN优化" class="headerlink" title="1、LEFT JOIN优化"></a>1、LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--未建立索引时的左外连接查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>--左表（class）建立索引<br>CREATE INDEX idx_class_card ON class(card);<br><br>--再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>--去掉左表索引<br>DROP INDEX idx_class_card ON class;<br><br>--右表建立索引<br>CREATE INDEX idx_book_card ON book(card);<br><br>--再次执行查询<br>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938628.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938642.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938566.png" alt="img"></a></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="2、INNER-JOIN优化"><a href="#2、INNER-JOIN优化" class="headerlink" title="2、INNER JOIN优化"></a>2、INNER JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br>EXPLAIN SELECT * FROM book INNER JOIN class ON book.card = class.card;<br><br>--删除book表中的几条记录<br>DELETE FROM book WHERE bookid&lt;10;<br><br>--再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br><br>--删除book表card字段索引，给class表的card字段添加索引<br>DROP INDEX idx_book_card ON book;<br>CREATE INDEX idx_class_card ON class(card);<br><br>--再次查询<br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938441.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938747.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938492.png" alt="img"></a></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="3、RIGHT-JOIN优化"><a href="#3、RIGHT-JOIN优化" class="headerlink" title="3、RIGHT JOIN优化"></a>3、RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h1 id="七、排序分组优化"><a href="#七、排序分组优化" class="headerlink" title="七、排序分组优化"></a>七、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938834.png" alt="img"></a></p><h2 id="1、ORDER-BY-优化"><a href="#1、ORDER-BY-优化" class="headerlink" title="1、ORDER BY 优化"></a>1、ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--不满足索引覆盖时进行排序查询<br>EXPLAIN SELECT empno FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br><br>--按照复合索引顺序进行排序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age, deptId, name;<br><br>--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name;<br><br>--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY deptId, name, age;<br><br>--排序时部分(age)升序，部分(deptId)降序，发生Using filesort<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age ASC, deptId DESC;<br><br>--排序时都为降序<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age &gt; 50 ORDER BY age DESC, deptId DESC;<br><br>--排序时，在前面的字段为常量时（非范围）<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age = 50 ORDER BY deptId, name;<br>EXPLAIN SELECT age, deptId FROM t_emp  WHERE age = 50 AND deptId&gt;10000 ORDER BY deptId, name;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938871.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938983.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938108.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938113.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938262.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938280.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938421.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938553.png" alt="img"></a></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li><li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li><li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li><li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li></ul><h3 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h3><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li>双路排序<ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。也就是<strong>本来想省一次 I&#x2F;O 操作，反而导致了大量的 I&#x2F;O 操作，反而得不偿失</strong></li></ul></li><li>优化Using filesort<ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938659.png" alt="img"></a></p><h2 id="2、GROUP-BY-优化"><a href="#2、GROUP-BY-优化" class="headerlink" title="2、GROUP BY 优化"></a>2、GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h1 id="八、截取查询分析"><a href="#八、截取查询分析" class="headerlink" title="八、截取查询分析"></a>八、截取查询分析</h1><h2 id="1、慢日志查询"><a href="#1、慢日志查询" class="headerlink" title="1、慢日志查询"></a>1、慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log&#x3D;1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time&#x3D;1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><h2 id="2、批量数据脚本"><a href="#2、批量数据脚本" class="headerlink" title="2、批量数据脚本"></a>2、批量数据脚本</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--dept 部门表<br>CREATE TABLE `dept` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, ceo INT NULL , PRIMARY KEY (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br><br>-- emp 员工表<br>CREATE TABLE `emp` (<br>`id` INT(11) NOT NULL AUTO_INCREMENT, `empno` INT NOT NULL , `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, PRIMARY KEY (`id`)<br>#CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)<br>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;Copy<br></code></pre></td></tr></table></figure><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询<br>SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;<br><br>--设置<br>SET GLOBAL log_bin_trust_function_creators=1;Copy<br></code></pre></td></tr></table></figure><h3 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h3><h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a><strong>随机产生字符串</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾<br>DELIMITER $$<br>CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)<br>BEGIN<br>DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;<br>DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;<br>DECLARE i INT DEFAULT 0;<br>WHILE i &lt; n DO<br>SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));<br>SET i = i + 1;<br>END WHILE;<br>RETURN return_str;<br>END $$Copy<br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FUNCTION rand_string;Copy<br></code></pre></td></tr></table></figure><h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>SET i = FLOOR(from_num +RAND()*(to_num -from_num+1)) ;<br>RETURN i;<br>END$$Copy<br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop function rand_num;Copy<br></code></pre></td></tr></table></figure><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE insert_emp( START INT , max_num INT )<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>#set autocommit =0 把 autocommit 设置成 0<br>SET autocommit = 0;<br>REPEAT<br>SET i = i + 1;<br>INSERT INTO emp (empno, NAME ,age ,deptid ) VALUES ((START+i) ,rand_string(6) , rand_num(30,50),rand_num(1,10000));<br>UNTIL i = max_num<br>END REPEAT;<br>COMMIT;<br>END$$<br><br>--删除<br>-- DELIMITER ;<br>-- drop PROCEDURE insert_emp;Copy<br></code></pre></td></tr></table></figure><h4 id="创建往-dept-表中插入数据的存储过程"><a href="#创建往-dept-表中插入数据的存储过程" class="headerlink" title="创建往 dept 表中插入数据的存储过程"></a>创建往 dept 表中插入数据的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 dept 表添加随机数据<br>DELIMITER $$<br>CREATE PROCEDURE `insert_dept`( max_num INT )<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>SET autocommit = 0;<br>REPEAT<br>SET i = i + 1;<br>INSERT INTO dept ( deptname,address,ceo ) VALUES (rand_string(8),rand_string(10),rand_num(1,500000));<br>UNTIL i = max_num<br>END REPEAT;<br>COMMIT;<br>END$$<br><br>--删除<br>-- DELIMITER ;<br>-- drop PROCEDURE insert_dept;Copy<br></code></pre></td></tr></table></figure><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><h4 id="添加数据到部门表"><a href="#添加数据到部门表" class="headerlink" title="添加数据到部门表"></a>添加数据到部门表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 dept 表添加 1 万条数据<br>DELIMITER ;<br>CALL insert_dept(10000);Copy<br></code></pre></td></tr></table></figure><h4 id="添加数据到员工表"><a href="#添加数据到员工表" class="headerlink" title="添加数据到员工表"></a>添加数据到员工表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--执行存储过程，往 emp 表添加 50 万条数据<br>DELIMITER ;<br>CALL insert_emp(100000,500000);Copy<br></code></pre></td></tr></table></figure><h3 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h3><h4 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))<br>BEGIN<br>DECLARE done INT DEFAULT 0;<br>DECLARE ct INT DEFAULT 0;<br>DECLARE _index VARCHAR(200) DEFAULT &#x27;&#x27;;<br>DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE<br>table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name &lt;&gt;&#x27;PRIMARY&#x27; ;<br>DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;<br>OPEN _cur;<br>FETCH _cur INTO _index;<br>WHILE _index&lt;&gt;&#x27;&#x27; DO<br>SET @str = CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename );<br>PREPARE sql_str FROM @str ;<br>EXECUTE sql_str;<br>DEALLOCATE PREPARE sql_str;<br>SET _index=&#x27;&#x27;;<br>FETCH _cur INTO _index;<br>END WHILE;<br>CLOSE _cur;<br>END$$Copy<br></code></pre></td></tr></table></figure><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);Copy<br></code></pre></td></tr></table></figure><h1 id="九、MySQL锁机制"><a href="#九、MySQL锁机制" class="headerlink" title="九、MySQL锁机制"></a>九、MySQL锁机制</h1><h2 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--展示表是否加锁<br>SHOW OPEN TABLES;<br><br>--加锁 read (读锁) write (写锁)<br>LOCK TABLE table1 read(write), table2 read(write)...<br><br>--全部解锁<br>UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul><li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加锁并查询状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE dept READ;<br><br>SHOW OPEN TABLES;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151441.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938648.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>两个客户端分别读取dept表的信息，都能读出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure></li><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152614.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938180.png" alt="img"></a></p></li><li><p>其他客户端读取度其他表信息，读取成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152714.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938420.png" alt="img"></a></p></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151654.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938322.png" alt="img"></a></p></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM dept WHERE id = 1;Copy<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151737.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938378.png" alt="img"></a></p><ul><li><p>从客户端A解锁后，客户端B修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151818.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938314.png" alt="img"></a></p></li></ul><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，知道读锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加上写锁并查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">LOCK TABLE dept WRITE;<br><br>SHOW OPEN TABLES;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153259.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938569.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM dept;<br><br>SELECT * FROM t_emp;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153403.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938735.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153437.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938732.png" alt="img"></a></p><ul><li><p>其他表读取该表信息，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM dept;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153517.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938756.png" alt="img"></a></p></li><li><p>释放后，读取成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNLOCK TABLES;Copy<br></code></pre></td></tr></table></figure></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE dept WHERE id = 2;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153637.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938259.png" alt="img"></a></p></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp WHERE id = 2;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153710.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938371.png" alt="img"></a></p></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t_emp WHERE id = 2;Copy<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="2、行锁"><a href="#2、行锁" class="headerlink" title="2、行锁"></a>2、行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a href="https://nyimac.gitee.io/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础</strong></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><p><strong>修改同一条记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--关闭自动提交<br>SET autocommit = 0;<br><br>--客户端A、B查询id=2的记录<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端A进行修改操作（将年龄改为了80），但未提交<br>UPDATE t_emp SET age = 80 WHERE id = 2;<br><br>--客户端A进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端B进行查询<br>SELECT * FROM t_emp WHERE id = 2;<br><br>--客户端B进行修改（客户端A未提交）<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>--客户端A提交<br>COMMIT;<br><br>--客户端B提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p>客户端A查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" alt="img"></a></p><p>客户端B查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" alt="img"></a></p><p>客户端A修改后A查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938408.png" alt="img"></a></p><p>客户端A修改后B查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938327.png" alt="img"></a></p><p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938426.png" alt="img"></a></p><p>客户端A提交后，B修改成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938662.png" alt="img"></a></p><p><strong>修改不同记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--客户端A对id=2的年龄进行修改<br>UPDATE t_emp SET age = 90 WHERE id = 2;<br><br>--客户端B对id=3的年龄进行修改<br>UPDATE t_emp SET age = 30 WHERE id = 3;<br><br>--客户端A，B分别提交<br>COMMIT;<br>COMMIT;Copy<br></code></pre></td></tr></table></figure><p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p><h3 id="索引失效-1"><a href="#索引失效-1" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h3 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--查询表记录，此处没有id=2的记录<br>SELECT * FROM t_emp;<br><br>--客户端A进行范围查询，但是范围内没有id=2的记录<br>UPDATE t_emp SET deptId = 1 WHERE id&gt;1 AND id &lt; 6;<br><br>--客户端B进行插入数据，插入一条id=2的记录<br>INSERT t_emp VALUES(2, &#x27;岳不群&#x27;, 11, 2, 100002); <br><br>--客户端A提交<br>COMMIT;<br><br>--客户端B提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938709.png" alt="img"></a></p><p><strong>客户端B进入阻塞状态</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938768.png" alt="img"></a></p><p>提交后，插入成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938793.png" alt="img"></a></p><p><strong>结论</strong>：可以看到表中本来<strong>没有id&#x3D;2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br><br>--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推<br>SELECT * FROM t_emp WHERE id = 1 FOR UPDATE;<br><br>--进行修改操作<br>UPDATE t_emp SET NAME = &#x27;风车车&#x27; WHERE id = 1;<br><br>--提交<br>COMMIT;Copy<br></code></pre></td></tr></table></figure><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h1 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li><li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938811.png" alt="img"></a></p><h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 <a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050938832.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到浏览器显示页面的流程</title>
    <link href="/2022/09/05/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/09/05/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到浏览器显示页面的流程"><a href="#从输入URL到浏览器显示页面的流程" class="headerlink" title="从输入URL到浏览器显示页面的流程"></a>从输入URL到浏览器显示页面的流程</h1><p>当在浏览器中输入域名，敲下回车后，不一会儿浏览器就会显示我们想要的界面。本文将简单介绍这其中经历了什么过程。</p><p>注意：以下分析基于<strong>HTTP</strong>请求，并且Web容器使用<strong>Tomcat</strong>，后端框架使用<strong>SSM</strong></p><h2 id="一、URL解析"><a href="#一、URL解析" class="headerlink" title="一、URL解析"></a>一、URL解析</h2><h3 id="1、地址解析"><a href="#1、地址解析" class="headerlink" title="1、地址解析"></a><strong>1、地址解析</strong></h3><p>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作。</p><h3 id="2、其他操作"><a href="#2、其他操作" class="headerlink" title="2、其他操作"></a>2、其他操作</h3><p>目前大部分浏览器都会<strong>强制客户端使用HTTPS协议</strong>以保证信息传输的安全性。同时还会进行一些额外的操作，比如安全检查、访问限制等。</p><h3 id="3、缓存检查"><a href="#3、缓存检查" class="headerlink" title="3、缓存检查"></a>3、缓存检查</h3><p>有时候博客在gitee上进行了更新，但是通过谷歌浏览器查看博客时，仍是更新前的博客，这是因为浏览器中缓存了之前的博客界面。</p><p>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208150315.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933888.png" alt="img"></a></p><h2 id="二、DNS解析"><a href="#二、DNS解析" class="headerlink" title="二、DNS解析"></a>二、DNS解析</h2><p><strong>DNS解析是寻找所需要的资源的IP地址的过程</strong>。因为互联网中每一台连网的机器都有<strong>唯一IP作为标识</strong>，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。其具体步骤如下。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141644.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933944.png" alt="img"></a></p><h3 id="1、查询缓存"><a href="#1、查询缓存" class="headerlink" title="1、查询缓存"></a>1、查询缓存</h3><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<strong>DNS高速缓存</strong>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。</p><h3 id="2、递归解析"><a href="#2、递归解析" class="headerlink" title="2、递归解析"></a>2、递归解析</h3><p>输入<code>www.baidu.com</code>网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。</p><p>大致过程就是<code>.</code>-&gt; <code>.com</code> -&gt;<code>baidu.com.</code> -&gt; <code>www.baidu.com.</code></p><p>其中<code>.</code>代表根域名服务器。</p><h3 id="3、DNS负载均衡"><a href="#3、DNS负载均衡" class="headerlink" title="3、DNS负载均衡"></a>3、DNS负载均衡</h3><p>访问<code>baidu.com</code>的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以<strong>根据每台机器的负载量，该机器离用户地理位置的距离</strong>等等，这种过程就是DNS负载均衡。</p><h2 id="三、建立TCP连接"><a href="#三、建立TCP连接" class="headerlink" title="三、建立TCP连接"></a>三、建立TCP连接</h2><p>TCP&#x2F;IP 分为四层，在发送数据时，<strong>每层都要对数据进行封装</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141851.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933972.png" alt="img"></a></p><p>TCP提供一种<strong>面向连接的，可靠的字节流</strong>服务，是一种可靠传输。接下来将会讲解TCP的<strong>首部、三次握手与四次挥手</strong>。</p><h3 id="1、TCP的首部"><a href="#1、TCP的首部" class="headerlink" title="1、TCP的首部"></a>1、TCP的首部</h3><p>TCP首部的格式如下</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208164319.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933969.png" alt="img"></a></p><ul><li><p><strong>源端口</strong>：源端口和IP地址的作用是标识<strong>报文的发送地址和返回地址</strong></p></li><li><p><strong>目的端口</strong>：端口指明<strong>接收方</strong>计算机上的应用程序接口</p><ul><li>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP<strong>唯一确定</strong>一条TCP连接</li></ul></li><li><p><strong>序号</strong>：是TCP可靠传输的<strong>关键部分</strong></p><ul><li><p>序号是该报文段发送的数据组的</p><p>第一个字节的序号</p><p>。在TCP传送的流中，每</p><p>一个字节都有一个序号</p><ul><li>比如一个报文段的序号为300，报文段数据部分共有100字节，则<strong>下一个报文段</strong>的序号为400。所以序号确保了TCP传输的有序性</li></ul></li></ul></li><li><p><strong>确认号：ack，用于指明下一个期待收到的字节序号</strong>，表明该序号之前的所有数据已经正确无误的收到</p><ul><li><strong>确认号只有当ACK标志为1时才有效</strong>。比如建立连接时，SYN报文的ACK标志位为0</li></ul></li><li><p><strong>首部长度&#x2F;数据偏移</strong>：占4位，它指出<strong>TCP报文的数据距离TCP报文段的起始处有多远</strong></p></li><li><p><strong>保留</strong>：占6位，保留今后使用，但<strong>目前应都位0</strong></p></li><li><p><strong>控制位：URG ACK PSH RST SYN FIN</strong>，共6个，每一个标志位表示一个控制功能</p><ul><li>URG：紧急。当URG&#x3D;1时，表明紧急指针字段有效。告诉系统<strong>此报文段中有紧急数据</strong></li><li>ACK：确认。<strong>当ACK&#x3D;1时，确认号字段才有效</strong>。TCP规定，在连接建立后所有报文的传输都必须把ACK置1</li><li>PSH：推送。当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH&#x3D;1</li><li>RST：复位。当RST&#x3D;1，表明TCP连接中出现严重差错，<strong>必须释放连接，然后再重新建立连接</strong></li><li>SYN：同步，在连接建立时用来同步序号。当SYN&#x3D;1，ACK&#x3D;0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN&#x3D;1，ACK&#x3D;1</li><li>FIN：终止，用来释放连接。当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，并且要求释放</li></ul></li><li><p><strong>窗口</strong>：<strong>滑动窗口</strong>大小，用来告知发送端<strong>接受端的缓存大小</strong>，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bits字段，因而窗口大小最大为65535</p></li><li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证</p></li><li><p><strong>紧急指针</strong>：只有当 <strong>URG 标志置 1 时紧急指针才有效</strong>。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</p></li><li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍</p></li><li><p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。<strong>在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部</strong>。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ul><h3 id="2、三次握手"><a href="#2、三次握手" class="headerlink" title="2、三次握手"></a>2、三次握手</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210127161838.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933930.png" alt="img"></a></p><p><strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>为什么是三次握手？两次不行吗？四次不行吗？</strong></p><h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手"></a>为什么不是两次握手</h4><p>这是为了<strong>避免服务器建立无用连接</strong>（客户端服务器建立连接后，却不传输数据）</p><p>如果只进行两次握手，如果客户端向服务器第一次发送的建立连接的请求因为某原因，<strong>兜兜转转绕了一大圈才到达服务器</strong>。这期间客户端因为未收到服务器的响应，就会再次发送连接请求，这时服务器收到了，向客户端发送连接请求后，连接便建立了。然后数据传输完毕后，释放连接。<strong>这时刚刚兜兜转转一大圈的建立连接的请求到了服务器</strong>，服务器收到后再次向客户端发送请求，发送后又建立了连接，但是建立连接后客户端没有再理会服务器，客户端与服务器之间没有传输数据，此时服务器的资源就会被浪费</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208172930.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933917.png" alt="img"></a></p><h4 id="为什么不是四次握手"><a href="#为什么不是四次握手" class="headerlink" title="为什么不是四次握手"></a>为什么不是四次握手</h4><p><strong>因为通信不可能100%可靠</strong>（红军蓝军约定）， 而上面的三次握手已经做好了通信的准备工作， <strong>再增加握手， 并不能显著提高可靠性</strong>，所以只需要三次握手就足够了</p><p>这里简单介绍一下<strong>红军蓝军约定</strong></p><blockquote><p>红军和蓝军都想消灭一波敌人，但是单凭他们一个军队的力量都不足以消灭这波敌人，因此他们想到了一起合作，于是红军向蓝军发了一封电报，内容是约定好早上8点一起向敌军进攻，由于他们不确定蓝军是否一定能收到电报, 所以只有收到蓝军的回复之后才会进行进攻，而蓝军也是同样的想法，因为他们不确定红军一定能收到自己的回复而在约定好的时间发动进攻，所以他们只有收到红军的回复后才发动进攻….</p><p>问怎样才能保证这次战役一定胜利呢？答案是不可能的，因为<strong>双方都对于自己发出的消息对方是否一定接收得到存在质疑</strong>，所以，这样的通信将一直进行下去，结果将是使胜利的几率一直接近100%，但是却永远达不到100%。</p></blockquote><h3 id="3、四次挥手"><a href="#3、四次挥手" class="headerlink" title="3、四次挥手"></a>3、四次挥手</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209144349.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933935.png" alt="img"></a></p><ul><li>第一次挥手<ul><li>客户端发送一个<strong>FIN&#x3D;1</strong>，用来关闭客户端到服务器的数据传送，此后客户端不会再向服务器发送数据(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。 FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<strong>客户端进入FIN-WAIT-1</strong>（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</li></ul></li><li>第二次挥手<ul><li>服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，<strong>服务端就进入了CLOSE-WAIT</strong>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，<strong>但是服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</li><li>此时，<strong>客户端就进入FIN-WAIT-2</strong>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</li></ul></li><li>第三次挥手<ul><li>服务器发送一个FIN&#x3D;1，用来关闭服务器到客户端的数据传送，也就是通知客户端，可以真正地释放连接了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，<strong>服务器就进入了LAST-ACK</strong>（最后确认）状态，等待客户端的确认</li></ul></li><li>第四次挥手<ul><li>客户端收到FIN后，发送一个ACK&#x3D;1给服务器，确认序号为收到序号+1，此时，<strong>客户端就进入了TIME-WAIT</strong>（时间等待）状态。注意此时TCP连接还没有释放，<strong>必须经过2MSL（最长报文段寿命）的时间后</strong>，当客户端撤销相应的TCB后，才进入CLOSED状态</li><li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些</li></ul></li></ul><h4 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h4><p><strong>确保第四次挥手服务器能够收到，同时使失效的连接请求从网络中消失</strong></p><p><strong>MSL</strong>是Maximum Segment Lifetime英文的缩写，中文可以译为<strong>报文最大生存时间</strong>，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><ul><li><strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，<strong>于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会<strong>重启2MSL计时器</strong></li><li>防止类似与三次握手中提到了的<strong>已经失效的连接请求报文段</strong>出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以<strong>使本连接持续的时间内所产生的所有报文段都从网络中消失</strong>（最长生存MSL）。<strong>这样新的连接中不会出现旧连接的请求报文</strong></li></ul><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手"></a>为什么建立连接是三次握手，关闭连接确是四次挥手</h4><ul><li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，<strong>把ACK和SYN放在一个报文里发送给客户端</strong></li><li>关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，<strong>己方ACK和FIN一般都会分开发送，从而导致多了一次</strong></li></ul><h2 id="四、发送HTTPS请求"><a href="#四、发送HTTPS请求" class="headerlink" title="四、发送HTTPS请求"></a>四、发送HTTPS请求</h2><h3 id="1、HTTP简介"><a href="#1、HTTP简介" class="headerlink" title="1、HTTP简介"></a>1、HTTP简介</h3><p>参考<a href="https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw"><strong>你每天都在使用的HTTP协议，到底是什么鬼？</strong></a></p><h3 id="2、HTTPS简介"><a href="#2、HTTPS简介" class="headerlink" title="2、HTTPS简介"></a>2、HTTPS简介</h3><p>在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。</p><p>HTTPS详细介绍可以参考<a href="https://zhuanlan.zhihu.com/p/158593966"><strong>一文带你了解HTTPS</strong></a></p><h4 id="HTTPS如何保证可靠性"><a href="#HTTPS如何保证可靠性" class="headerlink" title="HTTPS如何保证可靠性"></a>HTTPS如何保证可靠性</h4><ul><li>对称加密以及非对称加密<ul><li>通过非对称加密生成密钥，后面通过这个密钥进行对称加密进行传输</li></ul></li><li>数字签名<ul><li>保证非对称加密时发送的公钥是被认证过的，是安全可靠的</li></ul></li><li>单向Hash算法</li></ul><p><strong>大致过程如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209163352.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933955.png" alt="img"></a></p><h3 id="3、HTTPS传输过程"><a href="#3、HTTPS传输过程" class="headerlink" title="3、HTTPS传输过程"></a>3、HTTPS传输过程</h3><ul><li><strong>建立TCP连接</strong>（HTTP）</li><li><strong>将HTTP请求转换为HTTPS请求，转到HTTPS网站</strong><ul><li>因为一般人输入网址时，都是输入如<code>www.baidu.com</code>，而不会输入<code>https://www.baidu.com</code>。这时默认使用的是HTTP协议，<strong>浏览器会帮我们自动转换为HTTPS协议</strong></li></ul></li><li><strong>建立新的TCP连接</strong>(HTTPS)<ul><li>因为HTTP与HTTPS的端口不同。HTTP使用80端口，HTTPS使用443端口</li></ul></li><li><strong>完成一系列的协商工作</strong><ul><li>完成加密套件的协商和证书的身份确认，这次交互客户端和服务端会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等等。浏览器获取到证书之后，也要验证证书的有效性，是否过期是否撤销</li></ul></li><li><strong>浏览器获取CA域名</strong><ul><li>如果没有CA域名的缓存，还需要进行<strong>DNS解析</strong></li></ul></li><li><strong>再次建立新的TCP连接</strong>（CA域名）</li><li><strong>发送OCSP请求</strong><ul><li>OCSP全称是Online Certificate Status Protocol，在线证书状态协议，顾名思义用来获取证书状态的请求，这里的状态包括有效、过期、未知。并且可以宽限一段客户端访问证书的时间</li></ul></li><li><strong>进行密钥协商</strong></li></ul><p>经过以上过程后，便可以进行数据的对称加密传输了。</p><h2 id="五、查询MAC地址"><a href="#五、查询MAC地址" class="headerlink" title="五、查询MAC地址"></a>五、查询MAC地址</h2><p>这一步主要负责为打包好的<code>数据+TCP首部+IP首部</code>寻找传输路线，<strong>找到IP对应的物理机</strong>，这里会用到ARP协议。</p><h3 id="1、ARP协议"><a href="#1、ARP协议" class="headerlink" title="1、ARP协议"></a>1、ARP协议</h3><p>ARP（Address Resolution Protocol）即地址解析协议， 用于<strong>实现从 IP 地址到 MAC 地址的映射</strong>，即询问目标IP对应的MAC地址。</p><h3 id="2、ARP如何交互"><a href="#2、ARP如何交互" class="headerlink" title="2、ARP如何交互"></a>2、ARP如何交互</h3><p>ARP协议通过<strong>一问一答</strong>实现交互，但是问和答都有讲究，<strong>问是通过广播形式实现，答是通过单播形式。</strong></p><hr><p><strong>以上都是计算机网络的部分，接下来将介绍服务器如何接收与处理请求</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209203752.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933001.png" alt="img"></a></p><h2 id="六、请求在Tomcat中的处理流程"><a href="#六、请求在Tomcat中的处理流程" class="headerlink" title="六、请求在Tomcat中的处理流程"></a>六、请求在Tomcat中的处理流程</h2><p>Web 容器以<strong>进程</strong>的方式在计算机上运行，<strong>它主要负责接收请求，并将其投送至特定的应用</strong>，但Web容器并不属于计算机网络的组成部分。接下来将以Tomcat为例介绍Web容器的核心组件。</p><h3 id="1、Tomcat的核心组件"><a href="#1、Tomcat的核心组件" class="headerlink" title="1、Tomcat的核心组件"></a>1、Tomcat的核心组件</h3><p>Tomcat的核心组件主要有：<strong>Server、Service、Connector、Engine、Host和Context</strong>。</p><p><strong>一个Server可以包含多个Service，一个Service可以包含多个Connector，但只能包含一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context</strong>。</p><p><strong>它们之间的关系如下图所示</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209200950.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933995.png" alt="img"></a></p><p><strong>配置文件的结构如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Server&gt;</span>                              <br>    <span class="hljs-section">&lt;Service&gt;</span><br>        <span class="hljs-section">&lt;Engine&gt;</span><br>            <span class="hljs-section">&lt;Host&gt;</span><br>                <span class="hljs-section">&lt;Context /&gt;</span><br>            <span class="hljs-section">&lt;/Host&gt;</span><br>            <span class="hljs-section">&lt;Host&gt;</span><br>                <span class="hljs-section">&lt;Context /&gt;</span><br>            <span class="hljs-section">&lt;/Host&gt;</span><br>        <span class="hljs-section">&lt;/Engine&gt;</span>  <br>        <span class="hljs-section">&lt;Connector /&gt;</span><br>        <span class="hljs-section">&lt;Connector /&gt;</span><br>    <span class="hljs-section">&lt;/Service&gt;</span><br><span class="hljs-section">&lt;/Server&gt;</span><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>Server 是整个配置文件的<strong>唯一根元素</strong>，代表整个 Tomcat 容器。Server 内部可以包含多个 Service，其主要职责就是管理多个 Service，对外提供给客户端访问，同时维护所有 Service 的生命周期，包括初始化服务、结束服务、定位客户端要访问的 Service 等等。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 的主要职责就是将 Engine 与 Connector 装配在一起对外提供服务。一个 Service 可以包含多个 Connector，但只能包含一个 Engine，<strong>其中 Connector 负责从客户端接收请求，Engine 负责处理 Connector 接收进来的请求。</strong></p><h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p><strong>Connector是主要负责接收请求的组件</strong>。</p><p><strong>Tomcat有以下两种工作模式</strong></p><ul><li>作为Web服务器，直接接收客户端的请求</li><li>作为Java Web服务器，接收前置Web服务器的请求</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213925.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933015.png" alt="img"></a></p><p>每个 Service 可以有一个或多个 Connector，不同工作模式下，Tomcat 需要为各种类型的请求分别定义相应的 Connector，这样才能正确接收客户端对应协议的请求。定义 Connector 可以使用多种属性，某些属性只适用于某种特定的 Connector 类型。</p><p>一般说来，常见的 Connector 有 4 种类型</p><ul><li><strong>HTTP</strong></li><li><strong>HTTPS</strong></li><li><strong>AJP</strong></li><li><strong>Proxy</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210125922.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933000.png" alt="img"></a></p><p>Connector作为通信接口，<strong>它为其所属特定的 Service 接收外部客户端请求，以及回送应答至外部客户端</strong>。具体职责包括创建 Request、Response 对象用于跟外部客户端交换数据，并<strong>将 Request 交给配套的 Engine 来处理</strong>。</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Engine 是 Service 组件中<strong>负责请求处理的组件</strong>，其内部可以包含多个 Host。Engine 从一个或多个 Connector 中接收请求并处理，并将处理结果封装成应答交给 Connector，最终回传给外部客户端。</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p><strong>Host 代表一个虚拟主机，它对应计算机网络上的一个实体</strong>。即某个在 DNS 服务器上注册过的域名或者 IP 地址，例如：<code>www.baidu.com</code>或 201.187.10.21。Host 内部可以包含多个 Context，<strong>每个 Context 表示一个 Web 应用</strong>。Host 负责安装、展开、启动和结束每个 Web 应用。</p><p>客户端在填写目标地址时会通过主机名来标识它希望访问的服务器，Tomcat 将从 HTTP 请求头的 Host 字段提取主机名，然后再匹配对应的虚拟主机。如果没有找到匹配的，HTTP 请求将被发送至默认主机 defaultHost。</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context 代表在特定虚拟主机上运行的一个 Web 应用，<strong>负责处理某个特定 Web 应用的所有请求</strong>。</p><h3 id="2、Tomcat处理HTTP请求"><a href="#2、Tomcat处理HTTP请求" class="headerlink" title="2、Tomcat处理HTTP请求"></a>2、Tomcat处理HTTP请求</h3><p>当以 HTTP 请求到达Tomcat服务器（Server）以后，Tomcat会进行以下几个步骤，将请求交给对应的Web应用进行处理</p><ul><li>根据协议类型和端口号选定 Service 和 Engine<ul><li>Connector 主要负责接收请求。当 Connector 接收到特定协议和特定端口的请求后，<strong>其所属的 Service 和 Service 下的 Engine 也就确定了</strong></li></ul></li><li>根据域名或 IP 地址选定 Host<ul><li>Engine一旦确定了，就会根据 IP 来选择对应的虚拟主机Host来处理请求。如果匹配失败了，则会使用默认虚拟主机来处理请求</li></ul></li><li>根据 URI 选定 Context<ul><li>URI 中的 context-path 指定了 HTTPS 请求将要访问的 Web 应用</li><li>当请求抵达时，Tomcat 将根据 Context 的属性 path 取值与 URI 中的 context-path 的匹配程度来选择 Web 应用处理相应请求</li></ul></li></ul><h2 id="七、请求在Web应用中的处理流程"><a href="#七、请求在Web应用中的处理流程" class="headerlink" title="七、请求在Web应用中的处理流程"></a>七、请求在Web应用中的处理流程</h2><p>请求被 Web 容器中的 Connector 捕获，选取对应的 Server 中的 Engine ，Engine 再根据IP选择对应的虚拟主机，虚拟主机根据URI将请求交给对应的Web应用进行处理。接下来将介绍请求在Web请求中的处理过程。</p><p>介绍处理过程前，先对Web应用的基本组件进行简单介绍。</p><h3 id="1、Web应用核心组件"><a href="#1、Web应用核心组件" class="headerlink" title="1、Web应用核心组件"></a>1、Web应用核心组件</h3><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>监听器 Listener 主要用于监听 Application、Session、Request 等对象的变化，每当这些对象发生变化就会回调用对应的监听方法。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>过滤器 Filter 负责对请求做<strong>预处理</strong>，接着将请求交给 Servlet 进行处理并生成响应，最后 Filter 再对响应进行后处理。</p><p>从请求的处理过程来看，Filter 主要参与以下几个环节</p><ul><li>在 HttpServletRequest <strong>到达 Servlet 之前，拦截客户的 HttpServletRequest</strong></li><li>根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 报文头和数据</li><li>在 Servlet 生成的 HttpServletResponse <strong>抵达客户端之前，拦截 HttpServletResponse</strong></li><li>根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 报文头和数据</li></ul><p><strong>简单来说就是在真正处理请求以及返回响应之前，通过过滤器对内容再进行一些修改</strong></p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p><strong>Servlet 负责处理客户端访问动态资源的 HTTP 请求</strong>，接口 javax.servlet.Servlet 定义了所有 Servlet 必须要实现的方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Servlet</span> &#123;<br>    <span class="hljs-comment">// 由 Servlet 容器调用，完成 Servlet 初始化，启动对外服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(<span class="hljs-params">ServletConfig var1</span>) throws ServletException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 初始化和启动时参数的配置信息对象 ServletConfig</span><br>    <span class="hljs-function">ServletConfig <span class="hljs-title">getServletConfig</span>()</span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，让 Servlet 处理某个 HTTP 请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span>(<span class="hljs-params">ServletRequest var1, ServletResponse var2</span>) throws ServletException, IOException</span>;<br><br>    <span class="hljs-comment">// 获取 Servlet 的说明信息，包括：作者、版本和版权等等</span><br>    <span class="hljs-function">String <span class="hljs-title">getServletInfo</span>()</span>;<br><br>    <span class="hljs-comment">// 由 Servlet 容器调用，用于关闭停止 Servlet 提供的服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>()</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>从 HTTP 请求的处理过程来看，Servlet 主要参与以下几个环节</p><ul><li>接收请求<ul><li>客户端请求会被封装成 HttpServletRequest 对象，包含报文头参数和报文体等信息</li></ul></li><li>处理请求<ul><li>通常调用 Servlet 的方法 service、doPost 或 doGet 等方法处理请求，并<strong>进一步调用业务层相应逻辑对其进行处理等</strong></li></ul></li><li>反回响应<ul><li>处理完请求后，可以转发（forward）、重定向（redirect）到某个视图页面或者直接返回结果数据</li></ul></li></ul><h3 id="2、Web应用处理HTTP请求流程"><a href="#2、Web应用处理HTTP请求流程" class="headerlink" title="2、Web应用处理HTTP请求流程"></a>2、Web应用处理HTTP请求流程</h3><p>Web 应用处理 HTTP 请求的流程主要是<strong>穿越 Listener 和多个 Filters，最终抵达 Servlet 的过程</strong>，Servlet再进行下一步的处理。</p><p><strong>具体流程如下图</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213603.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933668.png" alt="img"></a></p><h2 id="八、请求在Spring-Web应用中的处理流程"><a href="#八、请求在Spring-Web应用中的处理流程" class="headerlink" title="八、请求在Spring Web应用中的处理流程"></a>八、请求在Spring Web应用中的处理流程</h2><p>因为使用 SSM 框架，所以 Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器。</p><h3 id="1、Spring-MVC的核心组件"><a href="#1、Spring-MVC的核心组件" class="headerlink" title="1、Spring MVC的核心组件"></a>1、Spring MVC的核心组件</h3><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>DispatcherServlet 是整个流程<strong>控制的中心</strong>，由它来<strong>接收请求并调用其它组件处理用户的请求</strong>，同时还负责响应结果。DispatcherServlet的存在降低了组件之间的耦合性。</p><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>HandlerMapping 负责<strong>根据用户请求映射获得对应的 Handler和 HandlerInterceptor</strong>。处理方法为从 URL 获得 URI，在通过 URI 从 HandlerMapping 中找到对应的 Handler 和 HandlerInterceptor，即处理器和拦截器。</p><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerAdapter 负责按照特定规则去执行 Handler。</p><p>如果 Handler 有对应的 HandlerAdapater，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong>。</p><h4 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h4><p>HandlerInterceptor 主要负责在执行 Handler 前对其进行拦截。HandlerInterceptor 中的 preHandler() 方法将会提取 HTTP 请求中的数据填充到处理器 Handler 的中。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Handler <strong>即Controller ，是处理业务代码的核心器件</strong>。这部分由程序员自行编写，一般的SSM框架中，其下层还有Service和Dao。</p><h3 id="2、Spring-MVC处理请求流程"><a href="#2、Spring-MVC处理请求流程" class="headerlink" title="2、Spring MVC处理请求流程"></a>2、Spring MVC处理请求流程</h3><p>当 Web 容器中的 Host 会选择对应的 Web应用来处理请求，这里将请求交给了 Spring MVC 中的 DispatcherServlet 来进一步处理请求。</p><ul><li>DispatcherServlet 通过解析 HTTP 请求的 URL 获得 URI，再根据该 URI <strong>从 HandlerMapping 当中获得该请求对应的 Handler 和 HandlerInterceptor</strong></li><li>DispatcherServlet 根据获得的 Handler 选择合适的 HandlerAdapter。如果成功获得 HandlerAdapter，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong></li><li>Handler 即 Controller 会进行请求的处理，并向下调用 Service 和 Dao 来处理请求</li><li>Hander 处理完成请求后会返回模型数据，模型数据由 DispatcherServlet 封装后返回给Web 容器</li></ul><p><strong>处理的流程图如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210105723.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933679.png" alt="img"></a></p><h2 id="九、返回过程"><a href="#九、返回过程" class="headerlink" title="九、返回过程"></a>九、返回过程</h2><p>Web 应用处理完请求并将结果返回给 Web 容器后，容器会将响应结果返回给客户端，这是上面流程的逆过程。浏览器收到响应结果后，会对结果进行解析和渲染。这样我们就能看到浏览器给我们显示的网页了。</p><h2 id="十、整体流程图"><a href="#十、整体流程图" class="headerlink" title="十、整体流程图"></a>十、整体流程图</h2><p>下面给出了输入URL到浏览器显示界面的流程图</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210113745.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209050933750.png" alt="img"></a></p><p><strong>以上便是从输入URL到浏览器显示页面的整个流程</strong></p>]]></content>
    
    
    <categories>
      
      <category>Http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2&amp;Vue3</title>
    <link href="/2022/09/05/Vue/"/>
    <url>/2022/09/05/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="一、vue基础"><a href="#一、vue基础" class="headerlink" title="一、vue基础"></a>一、vue基础</h1><h2 id="第一部分、Vue核心"><a href="#第一部分、Vue核心" class="headerlink" title="第一部分、Vue核心"></a>第一部分、Vue核心</h2><h4 id="安装（略）"><a href="#安装（略）" class="headerlink" title="安装（略）"></a>安装（略）</h4><h3 id="0、学前基础"><a href="#0、学前基础" class="headerlink" title="0、学前基础"></a>0、学前基础</h3><p>vue是什么，是一套用于构建用户界面的渐进式js框架</p><p>渐进式：vue可以自底向上逐层的应用</p><ul><li>简单应用：只需一个轻量小巧的核心库</li><li>复杂应用：可以引入各式各样的vue插件</li></ul><p>特点：<strong>组件化</strong>模式、<strong>声明式</strong>编码、<strong>虚拟DOM+Diff算法</strong></p><p>学习vue前要掌握的js基础知识：</p><ul><li><p>es6语法规范</p></li><li><p>es6模块化</p></li><li><p>包管理器</p></li><li><p>原型、原型链</p></li><li><p>数组常用方法</p></li><li><p>axios</p></li><li><p>promise</p></li></ul><h3 id="1、初识vue"><a href="#1、初识vue" class="headerlink" title="1、初识vue"></a>1、初识vue</h3><p>浏览器配置f12生产提示阻止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vue.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span>=<span class="hljs-literal">false</span>;<span class="hljs-comment">//阻止vue在启动时生成生产提示。</span><br></code></pre></td></tr></table></figure><p>favicon.ico页签图标</p><h5 id="1-1、插值语法"><a href="#1-1、插值语法" class="headerlink" title="1-1、插值语法"></a>1-1、插值语法</h5><p>用于解析标签体内容。</p><p>格式：<code>&#123;&#123;msg&#125;&#125;</code></p><p>插值里面放js表达式</p><p>区分js表达式和js代码(语句)</p><ul><li><p>表达式：一个表达式会生成一个值，可以放在任何一个需要值的地方；</p><ul><li><p>a</p></li><li><p>a+b</p></li><li><p>demo(1)</p></li><li><p>x&#x3D;&#x3D;&#x3D;y  ? ‘a’:’b’</p></li></ul></li><li><p>js代码(语句)</p><ul><li><code>if()&#123;&#125;</code></li><li><code>for()&#123;&#125;</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dome.<span class="hljs-title function_">toUpperCase</span>()<span class="hljs-comment">//js中让小写字母转为大写字母</span><br></code></pre></td></tr></table></figure><h5 id="1-2、指令语法"><a href="#1-2、指令语法" class="headerlink" title="1-2、指令语法"></a>1-2、指令语法</h5><p>用于解析标签、(包括:标签属性、标签体内容、绑定事件…)。</p><p>写链接时要v-bind（或者：）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">//将url通过绑定的形式绑定给href这个属性<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、数据绑定"><a href="#2、数据绑定" class="headerlink" title="2、数据绑定"></a>2、数据绑定</h3><h5 id="2-1、单向绑定-v-bind"><a href="#2-1、单向绑定-v-bind" class="headerlink" title="2-1、单向绑定 v-bind"></a>2-1、单向绑定 v-bind</h5><p>数据只能从data流向页面</p><h5 id="2-2、双向绑定-v-model"><a href="#2-2、双向绑定-v-model" class="headerlink" title="2-2、双向绑定 v-model"></a>2-2、双向绑定 v-model</h5><p>数据不仅能从data流向页面，还可以从页面流向data</p><p>备注：</p><ol><li>v-model:value 可以简写为v-model，因为v-model默认收集的就是value值</li><li>双向绑定一般都应用在表单类元素(输入类元素)上(如：input、select等)</li></ol><h5 id="2-3、简写"><a href="#2-3、简写" class="headerlink" title="2-3、简写"></a>2-3、简写</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>//单向绑定<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>//双向绑定<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>//v-bind简写<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>//v-model简写<br></code></pre></td></tr></table></figure><h3 id="3、el与data的两种写法"><a href="#3、el与data的两种写法" class="headerlink" title="3、el与data的两种写法"></a>3、el与data的两种写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;utf-8&quot;&gt;<br>&lt;title&gt;el与data两种写法&lt;/title&gt;<br>&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=&quot;app&quot;&gt;<br>&lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script type=&quot;text/javascript&quot;&gt;<br>// el的两种写法<br>var vm new Vue(&#123;<br>el:&quot;#app&quot;,//挂载点的第一种写法<br>// vm.$mount(&#x27;#app&#x27;),//挂载点的第二种写法<br>//data的第一种写法:对象式<br>data:&#123;<br>name:&#x27;timi&#x27;<br>&#125;,<br><br>// data的第二种写法:函数式<br>/* data:function()&#123;<br>console.log(this)//此处的this是Vue的实例对象,如果是箭头函数的话这个this就是全局window<br>return&#123;<br>name:&#x27;timi2&#x27;<br>&#125;<br>&#125; */<br>&#125;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure><h5 id="3-1、el有两种写法："><a href="#3-1、el有两种写法：" class="headerlink" title="3-1、el有两种写法："></a>3-1、el有两种写法：</h5><p>​(1)、new Vue时候配置el属性</p><p>​(2)、先创建Vue实例，随后再通过vm.$mount(‘#app’)指定el的值</p><h5 id="3-2、data有两种写法："><a href="#3-2、data有两种写法：" class="headerlink" title="3-2、data有两种写法："></a>3-2、data有两种写法：</h5><p>​(1)、对象式</p><p>​(2)、函数式</p><p>​如何选择：目前哪种写法都可以,以后学习到组件时,data必须使用函数式,否则会报错</p><h5 id="3-3、一个重要的原则："><a href="#3-3、一个重要的原则：" class="headerlink" title="3-3、一个重要的原则："></a>3-3、一个重要的原则：</h5><p>​由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了</p><h3 id="4、理解MVVM模型"><a href="#4、理解MVVM模型" class="headerlink" title="4、理解MVVM模型"></a>4、理解MVVM模型</h3><p>M：模型，对应data中的数据</p><ul><li>Plain JavaScript Objective：一般js对象</li></ul><p>V：视图，模板</p><ul><li>DOM：页面文件</li></ul><p>VM：视图模型，Vue实例对象</p><ul><li>DOM Listeners：DOM监听</li><li>Data Bindings：数据绑定</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071104079.png" alt="202203071104079"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071104122.png" alt="202203071104122"></p><h5 id="4-1、发现"><a href="#4-1、发现" class="headerlink" title="4-1、发现"></a>4-1、发现</h5><ol><li>data中所有属性，最后都出现在了vm身上(即vm里面有什么插值语法就能写什么)</li><li>vm身上所有属性及Vue原型(-proto-)上所有属性，在Vue模板中都可以直接使用</li></ol><h3 id="5、数据代理"><a href="#5、数据代理" class="headerlink" title="5、数据代理"></a>5、数据代理</h3><h4 id="5-1、回顾Objective-defineProperty方法"><a href="#5-1、回顾Objective-defineProperty方法" class="headerlink" title="5-1、回顾Objective.defineProperty方法"></a>5-1、回顾Objective.defineProperty方法</h4><p>Objective.defineProperty：给对象添加属性，给对象定义属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>回顾Objective.defineProperty方法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> 总结:通过改变number变量改变对象属性值靠getter,直接改变对象属性靠setter--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> number =<span class="hljs-number">18</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> person = &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">//其中age是不能枚举的 </span></span><br><span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// value:18,</span></span><br><span class="language-javascript"><span class="hljs-comment">// enumerable:true,//控制属性是否可用枚举，默认值false</span></span><br><span class="language-javascript"><span class="hljs-comment">// writable:true,//控制属性是否能被修改，默认值为false</span></span><br><span class="language-javascript"><span class="hljs-comment">// configurable:true,//属性能否被删除，默认为false</span></span><br><span class="language-javascript"><span class="hljs-comment">//当有人读取person的age属性时,get函数(getter)就会被调用,且返回值就是age的值</span></span><br><span class="language-javascript"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有人读取了age属性了&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> number</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">//当有人修改person的age属性时,set函数(setter)就会被调用,且会收到修改的具体值</span></span><br><span class="language-javascript"><span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;有人修改了age属性,且值是&#x27;</span>,value)</span><br><span class="language-javascript">number=value</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">//方法一:验证是否能枚举</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(Object.keys(person))</span></span><br><span class="language-javascript"><span class="hljs-comment">//方法二:通过for循坏验证是否能枚举</span></span><br><span class="language-javascript"><span class="hljs-comment">/* for(let key in person)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;for循坏对象:&#x27;,key,person[key])</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(person) */</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="5-2、何为数据代理"><a href="#5-2、何为数据代理" class="headerlink" title="5-2、何为数据代理"></a>5-2、何为数据代理</h4><p>数据代理：通过一个对象代理对另一个对象中属性的操作  读&#x2F;写</p><p>下面演示一个对象obj2代理obj的操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>何为数据代理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> obj =&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> obj2=&#123;<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2,<span class="hljs-string">&#x27;x&#x27;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span><br><span class="language-javascript">obj.<span class="hljs-property">x</span>=value</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="5-3、Vue中的数据代理"><a href="#5-3、Vue中的数据代理" class="headerlink" title="5-3、Vue中的数据代理"></a>5-3、Vue中的数据代理</h4><p>vm._data&#x3D;options.data&#x3D;data&#x2F;&#x2F;第三个data是外面的data</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue中的数据代理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称:&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址:&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> data=&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;222&#x27;</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">data<span class="hljs-comment">//这里是调用前面的data</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071104460.png" alt="202203071104460"></p><p>一旦data中的数据发生改变，那么页面找那个用到该数据的地方也会自动更新。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071104570.png" alt="202203071104570"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071104870.jpg" alt="202203071104870"></p><p>总结</p><p>1、Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读&#x2F;写）</p><p>2、Vue中数据代理的好处：更加方便的操作data中的数据</p><p>3、基本原理：①通过Objective.defineProperty()把data对象中所有属性添加到vm上。②为每一个添加到vm上的属性，都指定一个getter和setter。③在getter和setter内部去操作（读&#x2F;写）data中对应的属性。</p><h3 id="6、this关键字"><a href="#6、this关键字" class="headerlink" title="6、this关键字"></a>6、this关键字</h3><h4 id="6-1、this-属性名称"><a href="#6-1、this-属性名称" class="headerlink" title="6-1、this.属性名称"></a>6-1、this.属性名称</h4><p>​指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）</p><h4 id="6-2、this-方法名称"><a href="#6-2、this-方法名称" class="headerlink" title="6-2、this.方法名称"></a>6-2、this.方法名称</h4><p>​用来访问本类的成员方法</p><h4 id="6-3、this"><a href="#6-3、this" class="headerlink" title="6-3、this()"></a>6-3、this()</h4><p>​访问本类的构造方法</p><p>​()中可以有参数的 如果有参数 就是调用指定的有参构造</p><h3 id="7、事件处理"><a href="#7、事件处理" class="headerlink" title="7、事件处理"></a>7、事件处理</h3><h4 id="7-1、事件的基本操作"><a href="#7-1、事件的基本操作" class="headerlink" title="7-1、事件的基本操作"></a>7-1、事件的基本操作</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>事件的基本使用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showInfo1&quot;</span>&gt;</span>点我提示信息1(不传参)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showInfo2(66,$event)&quot;</span>&gt;</span>点我提示信息2(传参)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showInfo1</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-number">1111</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// console.log(event.target.innerText)</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(this)//此处的this是vm，如果是箭头函数的话，此处的this是window</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">showInfo2</span>(<span class="hljs-params">number,a</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// alert(2222)</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(event.target.innerText)</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number,a)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>事件的基本使用总结：</p><p>1、使用v-on:xxx或@xxx绑定事件，其中xx是事件名；</p><p>2、事件的回调需要配置在methods对象中，最终会在vm上；</p><p>3、methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p><p>4、methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；</p><p>5、@click&#x3D;”demo”和@click&#x3D;”demo($event)”效果一致，但后者可以传参；</p><h4 id="7-1-1、事件绑定"><a href="#7-1-1、事件绑定" class="headerlink" title="7-1.1、事件绑定"></a>7-1.1、事件绑定</h4><p>如果事件绑定里面的事件不写小括号表示传的参数为$event，如果小括号里面有值则表示该值的调用事件</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@click</span>=<span class="hljs-string">&quot;demo&quot;</span>和<span class="hljs-variable">@click</span>=&quot;<span class="hljs-built_in">demo</span>(event)一样<br><span class="hljs-variable">@click</span>=&quot;<span class="hljs-built_in">demo</span>(n)  调用n值产生的事件<br></code></pre></td></tr></table></figure><h4 id="7-2、事件修饰符"><a href="#7-2、事件修饰符" class="headerlink" title="7-2、事件修饰符"></a>7-2、事件修饰符</h4><p>Vue中的事件修饰符:<br>         1.prevent:阻止默认事件(常用);<br>         2.stop:阻止事件冒泡(常用);<br>         3、once:事件只触发一次(常用);<br>         4、capture:使用事件的捕获模式;<br>         5、self:只有event.target是当前操作的元素时才触发事件;<br>         6、passive:事件的默认行为立即执行,无需等待事件回调执行完毕;</p><p>事件修饰符小技巧：修饰符能连续写的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>  @<span class="hljs-attr">click.prevent.stop</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span>点我提示信息<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  //两个修饰符连着写，先调用前面的修饰符，然后再调用后面的<br><br></code></pre></td></tr></table></figure><p>案例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>事件修饰符<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">*&#123;</span><br><span class="language-css"><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.demo1</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.box1</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.box2</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.list</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css"><span class="hljs-attribute">overflow</span>: auto;</span><br><span class="language-css"><span class="hljs-comment">/* overflow 是自动滚动条 */</span></span><br><span class="language-css"></span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-tag">li</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css"></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 阻止默认事件(常用) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span>点我提示信息<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 阻止事件冒泡(常用) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span>点我提示信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 事件只触发一次(常用) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>@<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span>点我提示信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用事件的捕获模式 --&gt;</span><br><span class="hljs-comment">&lt;!-- 事件的捕获阶段为由外向内,冒泡阶段为由内向外 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">&quot;showMsg(1)&quot;</span>&gt;</span><br>div1<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showMsg(2)&quot;</span>&gt;</span><br>div2<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只有event.target是当前操作的元素时才触发事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo1&quot;</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showInfo&quot;</span>&gt;</span>点我提示信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 事件的默认行为立即执行,无需等待事件回调执行完毕 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span> @<span class="hljs-attr">scroll.passive</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;ul class=&quot;list&quot; @whell=&quot;demo&quot;&gt; --&gt;</span><span class="hljs-comment">&lt;!-- 这个是鼠标滚动轮的滚动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showInfo</span>(<span class="hljs-params">event</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// console.log(event.target)//这里是self修饰符的使用案例</span></span><br><span class="language-javascript"><span class="hljs-comment">// event.stopPropagation()//阻止stop修饰符的使用案例</span></span><br><span class="language-javascript"><span class="hljs-comment">// event.preventDefault()//阻止Vue在启动时生成生产提示。</span></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;欢迎进入百度搜索&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">showMsg</span>(<span class="hljs-params">msg</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;#&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;累坏了&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="7-3、键盘事件"><a href="#7-3、键盘事件" class="headerlink" title="7-3、键盘事件"></a>7-3、键盘事件</h4><pre><code class="hljs">键盘事件按键：         @keydown是你按下按键不用你手抬起来就触发事件         @keyup是你按下按键松手了才触发的事件         @keyup.enter 点号后面的叫别名1、Vue中常用的按键别名:        回车 =&gt;enter        删除 =&gt;delete (捕获“删除”和“退格”按键)        退出 =&gt;esc        空格 =&gt;space        换行 =&gt;tab tab会移动焦点(必须配合keydown使用)         上  =&gt;up         下  =&gt;down         左  =&gt;left         右  =&gt;right2、Vue未提供别名的按键,可以使用按键原始的key值去绑定,但注意要装维kebab-case(短横线命名)        3、系统修饰键(用法特殊):ctrl、alt、shift、meta(windows电脑的win键)        (1).配合keyup使用:按下修饰键的同时,再按下其他键,随后释放其他键,事件才会被触发。        (2).配合keydown使用:正常触发事件。                4、也可以使用keyCode去指定具体的按键(不推荐,已被web标准库删除)        5、Vue.config.keyCodes.自定义键名 =键码, 可以去定制按键别名</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>键盘事件<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下回车提示输入&quot;</span> @<span class="hljs-attr">keyup</span>=<span class="hljs-string">&quot;showInfo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showInfo</span>(<span class="hljs-params">e</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// if(e.keyCode !=13)return //keyCode获取键盘事件的代表符号 13然后判断是否按了回车按钮</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(e.target.value)</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">key</span>,e.<span class="hljs-property">keyCode</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>键盘事件小技巧：</p><p>系统修饰也能连续写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;按下回车提示输入&quot;</span> @<span class="hljs-attr">keyup.ctrl.y</span>=<span class="hljs-string">&quot;showInfo&quot;</span>/&gt;</span>//此时按下ctrl+y才能提示输入<br></code></pre></td></tr></table></figure><h3 id="8、计算属性"><a href="#8、计算属性" class="headerlink" title="8、计算属性"></a>8、计算属性</h3><h4 id="8-1、插值语法实现"><a href="#8-1、插值语法实现" class="headerlink" title="8-1、插值语法实现"></a>8-1、插值语法实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>姓名案例_插值语法实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- slice(0,3)这个函数用来截取长度 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 全名:&lt;span&gt;&#123;&#123;firstName.slice(0,3)&#125;&#125;-&#123;&#123;lastName&#125;&#125;&lt;/span&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-2、methods实现"><a href="#8-2、methods实现" class="headerlink" title="8-2、methods实现"></a>8-2、methods实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>姓名案例_methods实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>全名:<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;fullName()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>+<span class="hljs-string">&#x27;-&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-3、computed计算属性"><a href="#8-3、computed计算属性" class="headerlink" title="8-3、computed计算属性"></a>8-3、computed计算属性</h4><p>计算属性：<br>    1.定义：要用的属性不存在，要通过已有属性计算得来。<br>    2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。<br>    3.get函数什么时候执行？<br>                (1).初次读取时会执行一次。<br>                (2).当依赖的数据发生改变时会被再次调用。<br>    4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。<br>    5.备注：<br>            (1).计算属性最终会出现在vm上，直接读取使用即可。<br>            (2).如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起<strong>计算</strong>时依赖的数据发生改变。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>姓名案例_计算属性基本实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>姓:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>全名:<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">fullName</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-comment">//get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值</span></span><br><span class="language-javascript"><span class="hljs-comment">//get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。</span></span><br><span class="language-javascript"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get被调用了&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// console.log(this) //此处的this是vm</span></span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//set什么时候调用? 当fullName被修改时。</span></span><br><span class="language-javascript"><span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>,value)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> arr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = arr[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = arr[<span class="hljs-number">1</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-4、计算属性简写"><a href="#8-4、计算属性简写" class="headerlink" title="8-4、计算属性简写"></a>8-4、计算属性简写</h4><p>把computed里面的东西进行简写，确定只读取不修改(只有get没有set)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//完整写法</span><br><span class="hljs-comment">/* fullName:&#123;</span><br><span class="hljs-comment">get()&#123;</span><br><span class="hljs-comment">console.log(&#x27;get被调用了&#x27;)</span><br><span class="hljs-comment">return this.firstName + &#x27;-&#x27; + this.lastName</span><br><span class="hljs-comment">&#125;,</span><br><span class="hljs-comment">set(value)&#123;</span><br><span class="hljs-comment">console.log(&#x27;set&#x27;,value)</span><br><span class="hljs-comment">const arr = value.split(&#x27;-&#x27;)</span><br><span class="hljs-comment">this.firstName = arr[0]</span><br><span class="hljs-comment">this.lastName = arr[1]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125; */</span><br><br><br><span class="hljs-comment">//简写   确定只读取不修改(只有get没有set)</span><br><span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get被调用了&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、监视属性"><a href="#9、监视属性" class="headerlink" title="9、监视属性"></a>9、监视属性</h3><h4 id="9-1、watch监视属性"><a href="#9-1、watch监视属性" class="headerlink" title="9-1、watch监视属性"></a>9-1、watch监视属性</h4><p>监视属性watch：<br>    1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作<br>    2.监视的属性必须存在，才能进行监视！！<br>    3.监视的两种写法：<br>            (1).new Vue时传入watch配置<br>            (2).通过vm.$watch监视</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>天气案例_监视属性<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入Vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">isHot</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">info</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> ? <span class="hljs-string">&#x27;炎热&#x27;</span> : <span class="hljs-string">&#x27;凉爽&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">changeWeather</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">/* watch:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">isHot:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">immediate:true, //初始化时让handler调用一下,默认为false</span></span><br><span class="hljs-comment"><span class="language-javascript">//handler什么时候调用？当isHot发生改变时。</span></span><br><span class="hljs-comment"><span class="language-javascript">handler(newValue,oldValue)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125; */</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">vm.$watch(<span class="hljs-string">&#x27;isHot&#x27;</span>,&#123;</span><br><span class="language-javascript"><span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化时让handler调用一下</span></span><br><span class="language-javascript"><span class="hljs-comment">//handler什么时候调用？当isHot发生改变时。</span></span><br><span class="language-javascript"><span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-2、深度监视属性"><a href="#9-2、深度监视属性" class="headerlink" title="9-2、深度监视属性"></a>9-2、深度监视属性</h4><p>一、深度监视：<br>        (1).Vue中的watch默认不监测对象内部值的改变（一层）。<br>        (2).配置deep:true可以监测对象内部值改变（多层）。<br>二、备注：<br>        (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！<br>        (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>天气案例_深度监视<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>a的值是:&#123;&#123;numbers.a&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;numbers.a++&quot;</span>&gt;</span>点我让a+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>b的值是:&#123;&#123;numbers.b&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;numbers.b++&quot;</span>&gt;</span>点我让b+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;numbers = &#123;a:666,b:888&#125;&quot;</span>&gt;</span>彻底替换掉numbers<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>&#123;&#123;numbers.c.d.e&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">isHot</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript"><span class="hljs-attr">numbers</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,</span><br><span class="language-javascript"><span class="hljs-attr">b</span>:<span class="hljs-number">1</span>,</span><br><span class="language-javascript"><span class="hljs-attr">c</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">d</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">e</span>:<span class="hljs-number">100</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">info</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> ? <span class="hljs-string">&#x27;炎热&#x27;</span> : <span class="hljs-string">&#x27;凉爽&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">changeWeather</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">watch</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">isHot</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//监视多级结构中某个属性的变化</span></span><br><span class="language-javascript"><span class="hljs-comment">/* &#x27;numbers.a&#x27;:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">handler()&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;a被改变了&#x27;)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125; */</span></span><br><span class="language-javascript"><span class="hljs-comment">//监视多级结构中所有属性的变化</span></span><br><span class="language-javascript"><span class="hljs-attr">numbers</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;numbers改变了&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3、监视属性简写"><a href="#9-3、监视属性简写" class="headerlink" title="9-3、监视属性简写"></a>9-3、监视属性简写</h4><p>当配置项里面不需要immediate和deep时可以简写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>天气案例_监视属性_简写<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">isHot</span>:<span class="hljs-literal">true</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">info</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> ? <span class="hljs-string">&#x27;炎热&#x27;</span> : <span class="hljs-string">&#x27;凉爽&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">changeWeather</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">watch</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-comment">//完整写法</span></span><br><span class="language-javascript"><span class="hljs-comment">/* isHot:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">// immediate:true, //初始化时让handler调用一下</span></span><br><span class="hljs-comment"><span class="language-javascript">// deep:true,//深度监视</span></span><br><span class="hljs-comment"><span class="language-javascript">handler(newValue,oldValue)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;, */</span></span><br><span class="language-javascript"><span class="hljs-comment">//简写</span></span><br><span class="language-javascript"><span class="hljs-title function_">isHot</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue,<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//完整写法</span></span><br><span class="language-javascript"><span class="hljs-comment">/* vm.$watch(&#x27;isHot&#x27;,&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">deep:true,//深度监视</span></span><br><span class="hljs-comment"><span class="language-javascript">handler(newValue,oldValue)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//简写，这里的this指的是window</span></span><br><span class="language-javascript"><span class="hljs-comment">/* vm.$watch(&#x27;isHot&#x27;,(newValue,oldValue)=&gt;&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue,this)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-4、computed与watch比较"><a href="#9-4、computed与watch比较" class="headerlink" title="9-4、computed与watch比较"></a>9-4、computed与watch比较</h4><p>一、computed和watch之间的区别：<br>        1.computed能完成的功能，watch都可以完成。<br>        2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p><p>二、两个重要的小原则：<br>        1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。<br>        2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>姓名案例_watch实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>姓：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>全名：<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">firstName</span>:<span class="hljs-string">&#x27;张&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">lastName</span>:<span class="hljs-string">&#x27;三&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">fullName</span>:<span class="hljs-string">&#x27;张-三&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">watch</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-comment">/* firstName(val)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">this.fullName = val + &#x27;-&#x27; + this.lastName</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;, */</span></span><br><span class="language-javascript"><span class="hljs-title function_">firstName</span>(<span class="hljs-params">val</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = val + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span><br><span class="language-javascript">&#125;,<span class="hljs-number">1000</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">lastName</span>(<span class="hljs-params">val</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + val</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="10、绑定样式"><a href="#10、绑定样式" class="headerlink" title="10、绑定样式"></a>10、绑定样式</h3><h4 id="10-1、style与class样式"><a href="#10-1、style与class样式" class="headerlink" title="10-1、style与class样式"></a>10-1、style与class样式</h4><pre><code class="hljs">1. class样式            写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。                    字符串写法适用于：类名不确定，要动态获取。                    对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。                    数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 2. style样式            :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。            :style=&quot;[a,b]&quot;其中a、b是样式对象(key)，且样式对象必须是存在的。</code></pre><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>绑定样式<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.basic</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.happy</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid red;;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.644</span>);</span><br><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">30deg</span>,yellow,pink,orange,yellow);</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.sad</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">2</span>, <span class="hljs-number">197</span>, <span class="hljs-number">2</span>);</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: gray;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.normal</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.a1</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: yellowgreen;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.a2</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css"><span class="hljs-attribute">text-shadow</span>:<span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">10px</span> red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.a3</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;mood&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMood&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 绑定style样式--对象写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 绑定style样式--数组写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;basic&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">mood</span>:<span class="hljs-string">&#x27;normal&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">classArr</span>:[<span class="hljs-string">&#x27;a1&#x27;</span>,<span class="hljs-string">&#x27;a2&#x27;</span>,<span class="hljs-string">&#x27;a3&#x27;</span>],</span><br><span class="language-javascript"><span class="hljs-attr">classObj</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">a1</span>:<span class="hljs-literal">false</span>,</span><br><span class="language-javascript"><span class="hljs-attr">a2</span>:<span class="hljs-literal">false</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">styleObj</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">styleObj2</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;orange&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">styleArr</span>:[</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript"><span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;blue&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript"><span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;gray&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">changeMood</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;happy&#x27;</span>,<span class="hljs-string">&#x27;sad&#x27;</span>,<span class="hljs-string">&#x27;normal&#x27;</span>]</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">3</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">mood</span> = arr[index]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="11、条件渲染"><a href="#11、条件渲染" class="headerlink" title="11、条件渲染"></a>11、条件渲染</h3><h4 id="11-1、隐藏div的方法："><a href="#11-1、隐藏div的方法：" class="headerlink" title="11-1、隐藏div的方法："></a>11-1、隐藏div的方法：</h4><p>1、div的<strong>visibility</strong>控制div的隐藏和显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">style=&quot;<span class="hljs-attribute">visibility</span>: none;&quot;<br></code></pre></td></tr></table></figure><p>2、设置display属性  可以是div隐藏后释放占用的页面空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">style=&quot;<span class="hljs-attribute">display</span>: none;&quot;<br></code></pre></td></tr></table></figure><p>3、opacity设置元素透明度为0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">style=&quot;<span class="hljs-attribute">opacity</span>:<span class="hljs-number">0</span>;&quot;<br></code></pre></td></tr></table></figure><h4 id="11-2、v-if-和v-show"><a href="#11-2、v-if-和v-show" class="headerlink" title="11-2、v-if 和v-show"></a>11-2、v-if 和v-show</h4><p>条件渲染：<br>1.v-if<br>        写法：<br>            (1).v-if&#x3D;”表达式”<br>            (2).v-else-if&#x3D;”表达式”<br>            (3).v-else&#x3D;”表达式”<br>        适用于：切换频率较低的场景。<br>        特点：不展示的DOM元素直接被移除。v-if是通过控制dom节点的存在与否来控制元素的显隐。<br>        注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><p>2.v-show<br>        写法：v-show&#x3D;”表达式”<br>        适用于：切换频率较高的场景。<br>        特点：不展示的DOM元素未被移除，仅仅是通过设置DOM元素的display样式设置显隐。（display中block为显示，none为隐藏）<br>3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>条件渲染<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是:&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用v-show做条件渲染 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用v-if做条件渲染 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span><br><br><span class="hljs-comment">&lt;!-- v-else和v-else-if --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt;</span><br><span class="hljs-comment">&lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt;</span><br><span class="hljs-comment">&lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt;</span><br><span class="hljs-comment">&lt;div v-else&gt;哈哈&lt;/div&gt; --&gt;</span><br><br><span class="hljs-comment">&lt;!-- template只能与v-if配合使用，不能和v-show配合 ,template不影响结构，把template改为div影响结构--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;n === 1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">n</span>:<span class="hljs-number">0</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="12、列表渲染"><a href="#12、列表渲染" class="headerlink" title="12、列表渲染"></a>12、列表渲染</h3><h4 id="12-1、基本列表"><a href="#12-1、基本列表" class="headerlink" title="12-1、基本列表"></a>12-1、基本列表</h4><p>v-for指令:<br>        1.用于展示列表数据<br>        2.语法：<code>v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</code><br>        3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>基本列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 遍历数组 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表（遍历数组）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;li v-for=&quot;p in persons&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;&lt;/li&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of persons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 遍历对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>汽车信息（遍历对象）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,k) of car&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;k&#x27;</span>&gt;</span><br>&#123;&#123;k&#125;&#125;-&#123;&#123;value&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 遍历字符串 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>测试遍历字符串（用得少）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(char,index) of str&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 遍历指定次数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>测试遍历指定次数（用得少）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(number,index) of 5&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="language-javascript">],</span><br><span class="language-javascript"><span class="hljs-attr">car</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奥迪A8&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;70万&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;黑色&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">str</span>:<span class="hljs-string">&#x27;hello&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-2、key的原理"><a href="#12-2、key的原理" class="headerlink" title="12-2、key的原理"></a>12-2、key的原理</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071105550.jpg" alt="202203071105550"></p><h6 id="面试题：react、vue中的key有什么作用？（key的内部原理）"><a href="#面试题：react、vue中的key有什么作用？（key的内部原理）" class="headerlink" title="面试题：react、vue中的key有什么作用？（key的内部原理）"></a>面试题：react、vue中的key有什么作用？（key的内部原理）</h6><p>1、虚拟DOM中key的作用：<br>        key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><p>​<strong>对比规则</strong>：<br>​(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>​①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>​②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p><p>​  (2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>​创建新的真实DOM，随后渲染到到页面。<br>​</p><p>2、用index作为key或者不声明key的时候（此时默认key的value值为index时）可能会引发的问题：</p><p>​    (1).若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>​    会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p><p>​    (2).如果结构中还包含输入类的DOM：<br>​    会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p><p>3、开发中如何选择key?:<br>                (1).最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>                (2).如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>key的原理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 遍历数组 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表（遍历数组）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>添加一个老刘<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of persons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="language-javascript">],</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> p=&#123;</span><br><span class="language-javascript"><span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;004&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;老刘&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:<span class="hljs-number">40</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">unshift</span>(p)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-3、列表过滤"><a href="#12-3、列表过滤" class="headerlink" title="12-3、列表过滤"></a>12-3、列表过滤</h4><p>filter()：<strong>用于把Array中的某些元素过滤掉，然后返回剩下的元素</strong></p><p>‘abc’.indexOf(a)   <strong>判断字符出现的索引位置，没有就返回-1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>列表过滤<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入名字&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyWord&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of filPerons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//用watch实现</span></span><br><span class="language-javascript"><span class="hljs-comment">//#region </span></span><br><span class="language-javascript"><span class="hljs-comment">/* new Vue(&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">el:&#x27;#app&#x27;,</span></span><br><span class="hljs-comment"><span class="language-javascript">data:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">keyWord:&#x27;&#x27;,</span></span><br><span class="hljs-comment"><span class="language-javascript">persons:[</span></span><br><span class="hljs-comment"><span class="language-javascript">&#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:19,sex:&#x27;女&#x27;&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">&#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:20,sex:&#x27;女&#x27;&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">&#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:21,sex:&#x27;男&#x27;&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">&#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:22,sex:&#x27;男&#x27;&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">],</span></span><br><span class="hljs-comment"><span class="language-javascript">filPerons:[]</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">watch:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">keyWord:&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">immediate:true,</span></span><br><span class="hljs-comment"><span class="language-javascript">handler(val)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">this.filPerons = this.persons.filter((p)=&gt;&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">return p.name.indexOf(val) !== -1</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"><span class="hljs-comment">//#endregion</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//用computed实现</span></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">keyWord</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;马冬梅&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周冬雨&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;温兆伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">filPerons</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyWord</span>) !== -<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;) </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-4、列表排序"><a href="#12-4、列表排序" class="headerlink" title="12-4、列表排序"></a>12-4、列表排序</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>列表排序<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入名字&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyWord&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 2&quot;</span>&gt;</span>年龄升序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 1&quot;</span>&gt;</span>年龄降序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 0&quot;</span>&gt;</span>原顺序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of filPerons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span><br>&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">keyWord</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sortType</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">//0原顺序 1降序 2升序</span></span><br><span class="language-javascript"><span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;马冬梅&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">30</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周冬雨&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">31</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;温兆伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">filPerons</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyWord</span>) !== -<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">//判断一下是否需要排序</span></span><br><span class="language-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortType</span>)&#123;</span><br><span class="language-javascript">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">p1,p2</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortType</span> === <span class="hljs-number">1</span> ? p2.<span class="hljs-property">age</span>-p1.<span class="hljs-property">age</span> : p1.<span class="hljs-property">age</span>-p2.<span class="hljs-property">age</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> arr</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;) </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-5、更新时的一个问题"><a href="#12-5、更新时的一个问题" class="headerlink" title="12-5、更新时的一个问题"></a>12-5、更新时的一个问题</h4><p>Vue里面原本就有一个watch，而侦听属性的watch是给程序员用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>更新时的一个问题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>人员列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateMei&quot;</span>&gt;</span>更新马冬梅的信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(p,index) of persons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span><br>&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;马冬梅&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">30</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周冬雨&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">31</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;周杰伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;温兆伦&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">updateMei</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// this.persons[0].name = &#x27;马老师&#x27; //奏效</span></span><br><span class="language-javascript"><span class="hljs-comment">// this.persons[0].age = 50 //奏效</span></span><br><span class="language-javascript"><span class="hljs-comment">// this.persons[0].sex = &#x27;男&#x27; //奏效</span></span><br><span class="language-javascript"><span class="hljs-comment">// this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效</span></span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;马老师&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">50</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;)<span class="hljs-comment">//这是最后得出的结论</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;) </span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-6、模拟一个Vue数据监测"><a href="#12-6、模拟一个Vue数据监测" class="headerlink" title="12-6、模拟一个Vue数据监测"></a>12-6、模拟一个Vue数据监测</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> data = &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;222&#x27;</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//创建一个监视的实例对象，用于监视data中属性的变化</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> obs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(data)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obs)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//准备一个vm实例对象</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> vm = &#123;&#125;</span><br><span class="language-javascript">vm.<span class="hljs-property">_data</span> = data = obs</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Observer</span>(<span class="hljs-params">obj</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">//汇总对象中所有的属性形成一个数组</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)</span><br><span class="language-javascript"><span class="hljs-comment">//遍历</span></span><br><span class="language-javascript">keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">k</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>,k,&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> obj[k]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`</span>)</span><br><span class="language-javascript">obj[k] = val</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-7、Vue监测数据改变的原理-对象"><a href="#12-7、Vue监测数据改变的原理-对象" class="headerlink" title="12-7、Vue监测数据改变的原理__对象"></a>12-7、Vue监测数据改变的原理__对象</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue监测数据改变的原理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;222&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">student</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">rAge</span>:<span class="hljs-number">40</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sAge</span>:<span class="hljs-number">29</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">friends</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">35</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-8、Vue-set-方法"><a href="#12-8、Vue-set-方法" class="headerlink" title="12-8、Vue.set()方法"></a>12-8、Vue.set()方法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.set()使用方法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>学校信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：&#123;&#123;school.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：&#123;&#123;school.address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>校长是：&#123;&#123;school.leader&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>学生信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addSex&quot;</span>&gt;</span>添加一个性别属性，默认值是男<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>姓名：&#123;&#123;student.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;student.sex&quot;</span>&gt;</span>性别：&#123;&#123;student.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>年龄：真实&#123;&#123;student.age.rAge&#125;&#125;，对外&#123;&#123;student.age.sAge&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>朋友们<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(f,index) in student.friends&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">school</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;222&#x27;</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">student</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">rAge</span>:<span class="hljs-number">40</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sAge</span>:<span class="hljs-number">29</span>,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">friends</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">35</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tony&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">36</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">addSex</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)</span></span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-9、Vue监测数据改变的原理-数组"><a href="#12-9、Vue监测数据改变的原理-数组" class="headerlink" title="12-9、Vue监测数据改变的原理__数组"></a>12-9、Vue监测数据改变的原理__数组</h4><p>在Vue修改数组中的某个元素一定要用如下方法：<br>                            1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>                            2.Vue.set() 或 vm.$set()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue监测数据改变的原理_数组<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>学生信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>爱好<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(h,index) in student.hobby&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;h&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">student</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">hobby</span>:[<span class="hljs-string">&#x27;抽烟&#x27;</span>,<span class="hljs-string">&#x27;喝酒&#x27;</span>,<span class="hljs-string">&#x27;烫头&#x27;</span>],</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-10、总结Vue数据监测"><a href="#12-10、总结Vue数据监测" class="headerlink" title="12-10、总结Vue数据监测"></a>12-10、总结Vue数据监测</h4><p>Vue监视数据的原理：</p><p>1.vue会监视data中所有层次的数据。</p><p>2.如何监测对象中的数据？<br>    通过setter实现监视，且要在new Vue时就传入要监测的数据。<br>        (1).对象中后追加的属性，Vue默认不做响应式处理<br>        (2).如需给后添加的属性做响应式，请使用如下API：<br>            Vue.set(target，propertyName&#x2F;index，value) </p><p>​或</p><p>​vm.$set(target，propertyName&#x2F;index，value)</p><p>3.如何监测数组中的数据？<br>        通过包裹数组更新元素的方法实现，本质就是做了两件事：<br>                (1).调用原生对应的方法对数组进行更新。<br>                (2).重新解析模板，进而更新页面。</p><p>4.在Vue修改数组中的某个元素一定要用如下方法：<br>                1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>                2.Vue.set() 或 <code>vm.$set()</code><br>    特别注意：<code>Vue.set() </code>和<code> vm.$set()</code> 不能给vm 或 vm的根数据对象 添加属性！！！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>总结数据监视<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">button</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>学生信息<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;student.age++&quot;</span>&gt;</span>年龄+1岁<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addSex&quot;</span>&gt;</span>添加性别属性，默认值：男<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;student.sex = &#x27;未知&#x27; &quot;</span>&gt;</span>修改性别<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addFriend&quot;</span>&gt;</span>在列表首位添加一个朋友<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateFirstFriendName&quot;</span>&gt;</span>修改第一个朋友的名字为：张三<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addHobby&quot;</span>&gt;</span>添加一个爱好<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateHobby&quot;</span>&gt;</span>修改第一个爱好为：开车<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeSmoke&quot;</span>&gt;</span>过滤掉爱好中的抽烟<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>姓名：&#123;&#123;student.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>年龄：&#123;&#123;student.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;student.sex&quot;</span>&gt;</span>性别：&#123;&#123;student.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>爱好：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(h,index) in student.hobby&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;h&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>朋友们：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(f,index) in student.friends&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>&#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">student</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,</span><br><span class="language-javascript"><span class="hljs-attr">hobby</span>:[<span class="hljs-string">&#x27;抽烟&#x27;</span>,<span class="hljs-string">&#x27;喝酒&#x27;</span>,<span class="hljs-string">&#x27;烫头&#x27;</span>],</span><br><span class="language-javascript"><span class="hljs-attr">friends</span>:[</span><br><span class="language-javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">35</span>&#125;,</span><br><span class="language-javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tony&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">36</span>&#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">addSex</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)</span></span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>,<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">addFriend</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">friends</span>.<span class="hljs-title function_">unshift</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">70</span>&#125;)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">updateFirstFriendName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">friends</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">addHobby</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;学习&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">updateHobby</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// this.student.hobby.splice(0,1,&#x27;开车&#x27;)</span></span><br><span class="language-javascript"><span class="hljs-comment">// Vue.set(this.student.hobby,0,&#x27;开车&#x27;)</span></span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;开车&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">removeSmoke</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">student</span>.<span class="hljs-property">hobby</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> h !== <span class="hljs-string">&#x27;抽烟&#x27;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="12-11、数据劫持"><a href="#12-11、数据劫持" class="headerlink" title="12-11、数据劫持"></a>12-11、数据劫持</h4><p>数据劫持：<br>指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。比较典型的是Object.defineProperty()和 ES2016 中新增的Proxy对象。数据劫持最著名的应用当属双向绑定，这也是一个已经被讨论烂了的面试必考题。例如 <strong>Vue 2.x 使用的是Object.defineProperty()</strong>(Vue 在 3.x 版本之后改用 Proxy 进行实现)。</p><p><strong>Vue的双向绑定</strong>就是利用 Object.defineProperty()，并且把内部解耦为 <code>Observer</code>, <code>Dep</code>, 并使用 <code>Watcher</code> 相连。</p><p>数组的以下几个方法不会触发 set：（push、pop、shift、unshift、splice、sort、reverse   ）  </p><p>Vue 把这些方法定义为变异方法 ，指的是会修改原来数组的方法。与之对应则是非变异方法 ，例如 filter, concat, slice 等，它们都不会修改原始数组，而会返回一个新的数组。</p><p><img src="/img/202203071105018.png" alt="202203071105018"></p><h3 id="13、收集表单数据"><a href="#13、收集表单数据" class="headerlink" title="13、收集表单数据"></a>13、收集表单数据</h3><p>收集表单数据：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">若：&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;，则v-model收集的是value值，用户输入的就是value值。<br><br>若：&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span>/&gt;，则v-model收集的是value值，且要给标签配置value值。<br>若：&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>/&gt;<br><span class="hljs-number">1.</span>没有配置<span class="hljs-built_in">input</span>的value属性，那么收集的就是checked（勾选 <span class="hljs-keyword">or</span> 未勾选，是布尔值）<br><span class="hljs-number">2.</span>配置<span class="hljs-built_in">input</span>的value属性:<br>(<span class="hljs-number">1</span>)v-model的初始值是非数组，那么收集的就是checked（勾选 <span class="hljs-keyword">or</span> 未勾选，是布尔值）<br>(<span class="hljs-number">2</span>)v-model的初始值是数组，那么收集的的就是value组成的数组<br></code></pre></td></tr></table></figure><p>​备注：v-model的三个修饰符：<br>​  lazy：失去焦点再收集数据<br>​  number：输入字符串转为有效的数字<br>​  trim：输入首尾空格过滤</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>收集表单数据<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;userInfo.account&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.password&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;userInfo.age&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>性别：<br>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><br>女<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>爱好：<br>学习<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;study&quot;</span>&gt;</span><br>打游戏<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;game&quot;</span>&gt;</span><br>吃饭<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;eat&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>所属校区<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.city&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择校区<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shenzhen&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;wuhan&quot;</span>&gt;</span>武汉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>其他信息：<br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;userInfo.other&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;userInfo.agree&quot;</span>&gt;</span>阅读并接受<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;###&quot;</span>&gt;</span>《用户协议》<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">userInfo</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">account</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;female&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">hobby</span>:[],</span><br><span class="language-javascript"><span class="hljs-attr">city</span>:<span class="hljs-string">&#x27;beijing&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">other</span>:<span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">agree</span>:<span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">userInfo</span>))</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="14、过滤器"><a href="#14、过滤器" class="headerlink" title="14、过滤器"></a>14、过滤器</h3><p>过滤器：(定义、语法、备注)<br>                定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br>                语法：<br>                        1.注册过滤器：Vue.filter(name,callback) 或 <code>new Vue&#123;filters:&#123;&#125;&#125;</code><br>                        2.使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或  v-bind:属性 &#x3D; “xxx | 过滤器名”<br>                备注：<br>                        1.过滤器也可以接收额外参数、多个过滤器也可以串联<br>                        2.并没有改变原本的数据, 是产生新的对应的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>过滤器<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/dayjs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>显示格式化后的时间<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 计算属性实现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>现在是：&#123;&#123;fmtTime&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-comment">&lt;!-- methods实现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>现在是：&#123;&#123;getFmtTime()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 过滤器实现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>现在是：&#123;&#123;time | timeFormater&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 过滤器实现（传参） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>现在是：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 多个过滤器的串联 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>现在是1：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">:x</span>=<span class="hljs-string">&quot;msg | mySlice&quot;</span>&gt;</span>学校名字<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;msg | mySlice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//全局过滤器</span></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;mySlice&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">time</span>:<span class="hljs-number">1621561377603</span>, <span class="hljs-comment">//时间戳</span></span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好，111&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">fmtTime</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">getFmtTime</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//局部过滤器</span></span><br><span class="language-javascript"><span class="hljs-attr">filters</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">timeFormater</span>(<span class="hljs-params">value,str=<span class="hljs-string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span></span>)&#123;<span class="hljs-comment">//如果str有值使用str传的，如果没有则使用这里的&#x27;&#x27;里面默认的值</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;@&#x27;,value)</span></span><br><span class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title function_">dayjs</span>(value).<span class="hljs-title function_">format</span>(str)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app2&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;hello,222!&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="15、内置指令"><a href="#15、内置指令" class="headerlink" title="15、内置指令"></a>15、内置指令</h3><p>有哪些？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ada">v-bind  : 单向绑定解析表达式, 可简写为 :<span class="hljs-type">xxx</span><br>v-model  : 双向数据绑定<br>v-<span class="hljs-keyword">for</span>    : 遍历数组/对象/字符串<br>v-on      : 绑定事件监听, 可简写为@<br>v-<span class="hljs-keyword">if</span>   : 条件渲染（动态控制节点是否存存在）<br>v-<span class="hljs-keyword">else</span>   : 条件渲染（动态控制节点是否存存在）<br>v-show   : 条件渲染 (动态控制节点是否展示)<br>v-text指令 : 向其所在的节点中渲染文本内容。<br>v-html指令 : 向指定节点中渲染包含<span class="hljs-type">html</span>结构的内容。<br>v-cloak指令: 解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题<br>v-once指令 : 所在节点初次动态渲染后，就视为静态内容<br>v-pre指令  : 跳过其所在节点的编译过程<br></code></pre></td></tr></table></figure><h4 id="15-1、v-text指令"><a href="#15-1、v-text指令" class="headerlink" title="15-1、v-text指令"></a>15-1、v-text指令</h4><p>v-text指令：<br>            1.作用：向其所在的节点中渲染文本内容。<br>            2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-text指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;str&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">str</span>:<span class="hljs-string">&#x27;&lt;h3&gt;你好啊！&lt;/h3&gt;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="15-2、v-html指令"><a href="#15-2、v-html指令" class="headerlink" title="15-2、v-html指令"></a>15-2、v-html指令</h4><h5 id="v-html的安全性-cookie"><a href="#v-html的安全性-cookie" class="headerlink" title="v-html的安全性(cookie)"></a>v-html的安全性(cookie)</h5><p>v-html指令：<br>            1.作用：向指定节点中渲染包含html结构的内容。<br>            2.与插值语法的区别：<br>                    (1).v-html会替换掉节点中所有的内容，则不会。<br>                    (2).v-html可以识别html结构。<br>            3.严重注意：v-html有安全性问题！！！！<br>                    (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。<br>                    (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-html指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;str&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;str2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">new Vue(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">el:&#x27;#app&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">data:&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">name:&#x27;111&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">str:&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>你好啊！<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">str2:&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:location.href</span>=<span class="hljs-string">&quot;http://www.baidu.com?&quot;</span>+<span class="hljs-attr">document.cookie</span>&gt;</span>兄弟我找到你想要的资源了，快来！<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="15-3、v-cloak指令"><a href="#15-3、v-cloak指令" class="headerlink" title="15-3、v-cloak指令"></a>15-3、v-cloak指令</h4><p>v-cloak指令（没有值）：<br>            1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br>            2.使用css配合v-cloak可以解决网速慢时页面展示出的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-cloak指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">display</span>:none;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-cloak</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里可以调整延迟时间为5s --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/resource/5s/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="15-4、v-once指令"><a href="#15-4、v-once指令" class="headerlink" title="15-4、v-once指令"></a>15-4、v-once指令</h4><p>v-once指令：<br>            1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br>            2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-once指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里只会渲染一次打开页面后就让值定格在1了--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-once</span>&gt;</span>初始化的n值是:&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是:&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">n</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="15-5、v-pre指令"><a href="#15-5、v-pre指令" class="headerlink" title="15-5、v-pre指令"></a>15-5、v-pre指令</h4><p>v-pre指令：<br>        1.跳过其所在节点的编译过程。<br>        2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>v-pre指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>Vue其实很简单<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> &gt;</span>当前的n值是:&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">n</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="16、自定义指令"><a href="#16、自定义指令" class="headerlink" title="16、自定义指令"></a>16、自定义指令</h3><h4 id="16-1、回顾一个DOM操作"><a href="#16-1、回顾一个DOM操作" class="headerlink" title="16-1、回顾一个DOM操作"></a>16-1、回顾一个DOM操作</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.demo</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我创建一个输入框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)</span><br><span class="language-javascript">btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;input&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">input.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;demo&#x27;</span></span><br><span class="language-javascript">input.<span class="hljs-property">value</span> = <span class="hljs-number">99</span></span><br><span class="language-javascript">input.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(input)</span><br><span class="language-javascript"></span><br><span class="language-javascript">input.<span class="hljs-title function_">focus</span>()</span><br><span class="language-javascript"><span class="hljs-comment">// input.parentElement.style.backgroundColor = &#x27;skyblue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">parentElement</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="16-2、自定义指令操作"><a href="#16-2、自定义指令操作" class="headerlink" title="16-2、自定义指令操作"></a>16-2、自定义指令操作</h4><p>自定义指令总结：<br>    一、定义语法：</p><p>(1).<strong>局部指令</strong>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">Vue</span>(&#123;<br>directives:<span class="hljs-type"></span>&#123;指令名:<span class="hljs-type"></span>配置对象&#125;      <br>&#125;) <br>或<br><span class="hljs-keyword">new</span> <span class="hljs-type">Vue</span>(&#123;<br>directives&#123;指令名:<span class="hljs-type"></span>回调函数&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>(2).<strong>全局指令</strong>：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Vue.directive<span class="hljs-comment">(指令名,配置对象)</span><br>或<br>Vue.directive<span class="hljs-comment">(指令名,回调函数)</span><br></code></pre></td></tr></table></figure><p>​二、配置对象中常用的3个回调：<br>​(1).<strong>bind</strong>：指令与元素成功绑定时调用。<br>​(2).<strong>inserted</strong>：指令所在元素被插入页面时调用。<br>​(3).<strong>update</strong>：指令所在模板结构被重新解析时调用。</p><p>​三、备注：<br>​1.指令定义时不加v-，但使用时要加v-；<br>​2.指令名如果是多个单词，要使用<strong>kebab-case</strong>命名方式，不要用camelCase命名。                  （user-name式命名）</p><p><strong>案例如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>自定义指令<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。</span><br><span class="hljs-comment">需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>放大10倍后的n值是：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-big</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-fbind:value</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义全局指令</span></span><br><span class="language-javascript"><span class="hljs-comment">/* Vue.directive(&#x27;fbind&#x27;,&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">//指令与元素成功绑定时（一上来）</span></span><br><span class="hljs-comment"><span class="language-javascript">bind(element,binding)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">element.value = binding.value</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">//指令所在元素被插入页面时</span></span><br><span class="hljs-comment"><span class="language-javascript">inserted(element,binding)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">element.focus()</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;,</span></span><br><span class="hljs-comment"><span class="language-javascript">//指令所在的模板被重新解析时</span></span><br><span class="hljs-comment"><span class="language-javascript">update(element,binding)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">element.value = binding.value</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/* Vue.directive(&#x27;big&#x27;,function(element,binding)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;big&#x27;,this)//注意此处的this是window</span></span><br><span class="hljs-comment"><span class="language-javascript">// console.log(&#x27;big&#x27;)</span></span><br><span class="hljs-comment"><span class="language-javascript">element.innerText=binding.value*10</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">n</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">directives</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-comment">//big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。</span></span><br><span class="language-javascript"><span class="hljs-comment">/* &#x27;big-number&#x27;(element,binding)&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">// console.log(&#x27;big&#x27;)</span></span><br><span class="hljs-comment"><span class="language-javascript">element.innerText = binding.value * 10</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;, */</span></span><br><span class="language-javascript"><span class="hljs-title function_">big</span>(<span class="hljs-params">element,binding</span>)&#123;  <span class="hljs-comment">//element表示为元素，binding表示为指令与元素的一个关系绑定</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;big&#x27;</span>,<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//注意(directives)此处的this是window</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;big&#x27;)</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.dir(a)//console.dir(i) 表示输出(i)这个值到控制台</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(a instanceof HTMLElement)//instanceof是判断a是不是HTMLElement(网页元素)的实例</span></span><br><span class="language-javascript">element.<span class="hljs-property">innerText</span> = binding.<span class="hljs-property">value</span> * <span class="hljs-number">10</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">fbind</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-comment">//指令与元素成功绑定时（一上来）</span></span><br><span class="language-javascript"><span class="hljs-title function_">bind</span>(<span class="hljs-params">element,binding</span>)&#123;</span><br><span class="language-javascript">element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//指令所在元素被插入页面时</span></span><br><span class="language-javascript"><span class="hljs-title function_">inserted</span>(<span class="hljs-params">element,binding</span>)&#123;</span><br><span class="language-javascript">element.<span class="hljs-title function_">focus</span>()</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//指令所在的模板被重新解析时</span></span><br><span class="language-javascript"><span class="hljs-title function_">update</span>(<span class="hljs-params">element,binding</span>)&#123;</span><br><span class="language-javascript">element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span></span><br><span class="language-javascript"><span class="hljs-comment">// element.focus()//点击按钮后焦点依旧在这里</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="17、生命周期"><a href="#17、生命周期" class="headerlink" title="17、生命周期"></a>17、生命周期</h3><h4 id="17-1、引入生命周期"><a href="#17-1、引入生命周期" class="headerlink" title="17-1、引入生命周期"></a>17-1、引入生命周期</h4><p><strong>生命周期</strong>：<br>                1.又名：生命周期回调函数、生命周期函数、<strong>生命周期钩子</strong>。<br>                2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。<br>                3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>​4.生命周期函数中的this指向是vm 或 组件实例对象。<br>​5.第一次放入页面叫挂载，后面的叫更新</p><p><strong>什么是挂载(mounted)？</strong><br>                Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted</p><p>案例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>引出生命周期<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>你好啊<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;opacity&#125;&quot;</span>&gt;</span>欢迎学习Vue<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">a</span>:<span class="hljs-literal">false</span>,</span><br><span class="language-javascript"><span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted</span></span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>,<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> -= <span class="hljs-number">0.01</span></span><br><span class="language-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,<span class="hljs-number">16</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//通过外部的定时器实现（不推荐）</span></span><br><span class="language-javascript"><span class="hljs-comment">/* setInterval(() =&gt; &#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">vm.opacity -= 0.01</span></span><br><span class="hljs-comment"><span class="language-javascript">if(vm.opacity &lt;= 0) vm.opacity = 1</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;,16) */</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="17-2、分析生命周期-挂载、更新、与销毁"><a href="#17-2、分析生命周期-挂载、更新、与销毁" class="headerlink" title="17-2、分析生命周期(挂载、更新、与销毁)"></a>17-2、分析生命周期(挂载、更新、与销毁)</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071105178.png" alt="202203071105178"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>分析生命周期<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">:x</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前的n值是：&#123;&#123;n&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>点我n+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;bye&quot;</span>&gt;</span>点我销毁vm<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-comment">//template是母版，使用时用render函数渲染</span></span><br><span class="language-javascript"><span class="hljs-comment">// template:`</span></span><br><span class="language-javascript"><span class="hljs-comment">// &lt;div&gt; //不能使用template做完组件代替根元素 ，但是可以做为非根元素使用</span></span><br><span class="language-javascript"><span class="hljs-comment">// &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;</span></span><br><span class="language-javascript"><span class="hljs-comment">// &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;</span></span><br><span class="language-javascript"><span class="hljs-comment">// &lt;/div&gt;</span></span><br><span class="language-javascript"><span class="hljs-comment">// `,</span></span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">n</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;add&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>++</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">bye</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bye&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.$destroy()</span><br><span class="language-javascript"><span class="hljs-comment">//当vm.$destroy被调用时，完全销毁一个实例，清理它与其他实例的连接，解绑了(自定义)事件监听器。</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">watch</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">n</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;n变了&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">//此处没有vm中的_data、methods中的配置方法。</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">//此处开始有vm和_data、methods中的配置方法以及数据监测和数据代理。</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeMount&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">//此处呈现的是未经Vue编译的DOM结构，所有对DOM的操作都是不奏效的</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">//页面中呈现的是经Vue编译的DOM，至此初始化结束</span></span><br><span class="language-javascript"><span class="hljs-comment">//在此处可以进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件、等初始化操作。</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">//此处页面是新的，但是页面是旧的</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// 此时vm中的data、methods、指令等均可用，此时方法修改不会触发更新。</span></span><br><span class="language-javascript"><span class="hljs-comment">//在此阶段，一般进行关闭定时器、取消订阅消息、解绑自定义事件等。</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;destroyed&#x27;</span>)</span><br><span class="language-javascript">此时已经移除监听、子组件、(自定义)事件监听器。</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="17-3、总结生命周期"><a href="#17-3、总结生命周期" class="headerlink" title="17-3、总结生命周期"></a>17-3、总结生命周期</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">vm的一生(vm的生命周期)：<br>将要创建<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用beforeCreate函数<br>创建完毕<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用created函数<br>   (重要)将要挂载<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用beforeMount函数<br>挂载完毕<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用mounted函数<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;【重要的钩子】<br>将要更新<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用beforeUpdate函数<br>更新完毕<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用updated函数<br>   (重要)将要销毁<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用beforeDestroy函数<span class="hljs-operator">=</span>&gt;重要的钩子<br>销毁完毕<span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt;调用destroyed函数<br></code></pre></td></tr></table></figure><p><strong>常用的生命周期钩子</strong>：<br>            1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。<br>            2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。<br><strong>关于销毁Vue实例</strong><br>​1.销毁后借助Vue开发者工具看不到任何信息。<br>​2.销毁后自定义事件会失效，但原生DOM事件依然有效。<br>​3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>引出生命周期<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;opacity&#125;&quot;</span>&gt;</span>欢迎学习Vue<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;opacity = 1&quot;</span>&gt;</span>透明度设置为1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;stop&quot;</span>&gt;</span>点我停止变换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.$destroy()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted</span></span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>,<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setInterval&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> -= <span class="hljs-number">0.01</span></span><br><span class="language-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">1</span></span><br><span class="language-javascript">&#125;,<span class="hljs-number">16</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vm即将驾鹤西游了&#x27;</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="第二部分、Vue组件化编程"><a href="#第二部分、Vue组件化编程" class="headerlink" title="第二部分、Vue组件化编程"></a>第二部分、Vue组件化编程</h2><h3 id="1、模块与组件、模块化与组件化"><a href="#1、模块与组件、模块化与组件化" class="headerlink" title="1、模块与组件、模块化与组件化"></a>1、模块与组件、模块化与组件化</h3><h4 id="1-1、模块："><a href="#1-1、模块：" class="headerlink" title="1-1、模块："></a>1-1、模块：</h4><pre><code class="hljs">1. 理解: 向外提供特定功能的 js 程序, 一般就是一个 js 文件 2. 为什么: js 文件很多很复杂 3. 作用: 复用 js, 简化 js 的编写, 提高 js 运行效率 </code></pre><h4 id="1-2、组件："><a href="#1-2、组件：" class="headerlink" title="1-2、组件："></a>1-2、组件：</h4><pre><code class="hljs">1. 理解: 用来实现局部(特定)功能效果的代码集合(html/css/js/image…..) 2. 为什么: 一个界面的功能很复杂3. 作用: 复用编码, 简化项目编码, 提高运行效率。</code></pre><h4 id="1-3、模块化："><a href="#1-3、模块化：" class="headerlink" title="1-3、模块化："></a>1-3、模块化：</h4><p>当应用中的 js 都以模块来编写的, 那这个应用就是一个模块化的应用。</p><h4 id="1-4、组件化："><a href="#1-4、组件化：" class="headerlink" title="1-4、组件化："></a>1-4、组件化：</h4><p>当应用中的功能都是多组件的方式来编写的, 那这个应用就是一个组件化的应用。</p><h3 id="2、非单文件组件"><a href="#2、非单文件组件" class="headerlink" title="2、非单文件组件"></a>2、非单文件组件</h3><h4 id="2-1、基本使用"><a href="#2-1、基本使用" class="headerlink" title="2-1、基本使用"></a>2-1、基本使用</h4><p>一个文件包含有n个组件。</p><p>Vue中使用组件的三大步骤：<br>        一、<strong>定义组件(创建组件)</strong><br>        二、<strong>注册组件</strong><br>        三、<strong>使用组件(写组件标签)</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">一、如何定义一个组件？<br>使用Vue.<span class="hljs-built_in">extend</span>(<span class="hljs-keyword">options</span>)创建，其中<span class="hljs-keyword">options</span>和<span class="hljs-keyword">new</span> Vue(<span class="hljs-keyword">options</span>)时传入的那个<span class="hljs-keyword">options</span>几乎一样，但也有点区别；<br>区别如下：<br><span class="hljs-number">1</span>.<span class="hljs-keyword">el</span>不要写，为什么？ ——— 最终所有的组件都要经过一个<span class="hljs-keyword">vm</span>的管理，由<span class="hljs-keyword">vm</span>中的<span class="hljs-keyword">el</span>决定服务哪个容器。<br><span class="hljs-number">2</span>.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。<br>备注：使用template可以配置组件结构。<br><br>二、如何注册组件？<br><span class="hljs-number">1</span>.局部注册：靠<span class="hljs-keyword">new</span> Vue的时候传入components选项<br><span class="hljs-number">2</span>.全局注册：靠Vue.component(<span class="hljs-string">&#x27;组件名&#x27;</span>,组件)<br><br>三、编写组件标签：<br><span class="hljs-symbol">&lt;school&gt;</span>&lt;/school&gt;<br></code></pre></td></tr></table></figure><p>案例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>基本使用<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 第三步：编写组件标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 第三步：编写组件标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//第一步：创建school组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div class=&quot;demo&quot;&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-comment">// el:&#x27;#app&#x27;, //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。</span></span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">schoolName</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;002&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">schoolName</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//第一步：创建student组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> student = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">studentName</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">age</span>:<span class="hljs-number">18</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//第一步：创建hello组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//第二步：全局注册组件</span></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,hello)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//创建vm</span></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好啊！&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-comment">//第二步：注册组件（局部注册）</span></span><br><span class="language-javascript"><span class="hljs-attr">components</span>:&#123;</span><br><span class="language-javascript">school,</span><br><span class="language-javascript">student</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用对象是引用数据，你用我用大家用，函数返回值，是复印了一份新的给你，你随便改，影响不了原本 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2、几个注意点"><a href="#2-2、几个注意点" class="headerlink" title="2-2、几个注意点"></a>2-2、几个注意点</h4><p>1.<strong>关于组件名</strong>:<br>            一个单词组成：<br>                        第一种写法(首字母小写)：school<br>                        第二种写法(首字母大写)：School<br>            多个单词组成：<br>                        第一种写法(kebab-case命名)：<strong>my-school</strong><br>                        第二种写法(CamelCase命名)：<strong>MySchool</strong> (需要Vue脚手架支持)<br>            备注：<br>            (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。<br>            (2).可以使用name配置项指定组件在开发者工具中呈现的名字。<br>2.<strong>关于组件标签</strong>:<br>        第一种写法：<school></school><br>        第二种写法：<school/><br>        备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。<br>3.<strong>一个简写方式</strong>：<br>    const school &#x3D; Vue.extend(options) 可简写为：<strong>const school &#x3D; options</strong></p><p>案例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>几个注意点<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;222&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;002&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;欢迎学习Vue!&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">components</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">school</span>:s</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3、组件的嵌套"><a href="#2-3、组件的嵌套" class="headerlink" title="2-3、组件的嵌套"></a>2-3、组件的嵌套</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071106442.png" alt="202203071106442"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>组件的嵌套<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">//定义student组件</span></span><br><span class="language-xml"><span class="language-handlebars">const student = Vue.extend(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">name:&#x27;student&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">template:`</span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生年龄：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">age</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">`,</span></span><br><span class="language-xml"><span class="language-handlebars">data()&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">return &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">name:&#x27;222&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">age:18</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><br><span class="language-xml"><span class="language-handlebars">//定义school组件</span></span><br><span class="language-xml"><span class="language-handlebars">const school = Vue.extend(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">name:&#x27;school&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">template:`</span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">address</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">`,</span></span><br><span class="language-xml"><span class="language-handlebars">data()&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">return &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">name:&#x27;111&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">address:&#x27;111&#x27;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;,</span></span><br><span class="language-xml"><span class="language-handlebars">//注册组件（局部）</span></span><br><span class="language-xml"><span class="language-handlebars">components:&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">student</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><br><span class="language-xml"><span class="language-handlebars">//定义hello组件</span></span><br><span class="language-xml"><span class="language-handlebars">const hello = Vue.extend(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">template:`<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>`,</span></span><br><span class="language-xml"><span class="language-handlebars">data()&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">return &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">msg:&#x27;欢迎来学习！&#x27;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><br><span class="language-xml"><span class="language-handlebars">//定义app组件</span></span><br><span class="language-xml"><span class="language-handlebars">const app = Vue.extend(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">template:`</span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">`,</span></span><br><span class="language-xml"><span class="language-handlebars">components:&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">school,</span></span><br><span class="language-xml"><span class="language-handlebars">hello</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><br><span class="language-xml"><span class="language-handlebars">//创建vm</span></span><br><span class="language-xml"><span class="language-handlebars">new Vue(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">template:&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">el:&#x27;#root&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">//注册组件（局部）</span></span><br><span class="language-xml"><span class="language-handlebars">components:&#123;app&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-4、VueComponent"><a href="#2-4、VueComponent" class="headerlink" title="2-4、VueComponent"></a>2-4、VueComponent</h4><p>关于VueComponent：<br>                1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。<br>                2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。<br>                3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！<br>                4.关于this指向：<br>                        (1).组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>                        (2).new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。<br>                5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>VueComponent<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义school组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;school&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;001&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;showName&#x27;</span>,<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> test = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;span&gt;111&lt;/span&gt;`</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义hello组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;test&gt;&lt;/test&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好啊！&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">components</span>:&#123;test&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;@&#x27;,school)</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;#&#x27;,hello)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//创建vm</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">components</span>:&#123;school,hello&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-5、一个重要的内置关系"><a href="#2-5、一个重要的内置关系" class="headerlink" title="2-5、一个重要的内置关系"></a>2-5、一个重要的内置关系</h4><p>Demo.prototype   显示原型属性<br>Demo.__proto- -    隐式原型属性<br>实例的隐式原型属性，永远指向自己缔造者的原型对象<br>通过隐式原型链获取原型的属性，从自身沿着原型链一直找直到window的原型为空<br>通过显示原型链给原型(或者原型的原型)添加属性</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span>.一个重要的内置关系：<br>VueComponent.prototype.__proto__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Vue.prototype<br></code></pre></td></tr></table></figure><p>2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071106745.jpg" alt="202203071106745"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>一个重要的内置关系<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;Vue/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-number">99</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义school组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;school&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;button @click=&quot;showX&quot;&gt;点我输出x&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">`</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;111&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;001&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">showX</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//创建一个vm</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好&#x27;</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">components</span>:&#123;school&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义一个构造函数</span></span><br><span class="language-javascript"><span class="hljs-comment">/* function Demo()&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">this.a = 1</span></span><br><span class="hljs-comment"><span class="language-javascript">this.b = 2</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">//创建一个Demo的实例对象</span></span><br><span class="hljs-comment"><span class="language-javascript">const d = new Demo()</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(Demo.prototype) //显示原型属性</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(d.__proto__) //隐式原型属性</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(Demo.prototype === d.__proto__)</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">//程序员通过显示原型属性操作原型对象，追加一个x属性，值为99</span></span><br><span class="hljs-comment"><span class="language-javascript">Demo.prototype.x = 99</span></span><br><span class="hljs-comment"><span class="language-javascript"></span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;@&#x27;,d) */</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、ES6模块暴露与模块引入"><a href="#3、ES6模块暴露与模块引入" class="headerlink" title="3、ES6模块暴露与模块引入"></a>3、ES6模块暴露与模块引入</h3><h4 id="3-1、ES6一共有三种模块暴露方法"><a href="#3-1、ES6一共有三种模块暴露方法" class="headerlink" title="3-1、ES6一共有三种模块暴露方法"></a><strong>3-1、ES6一共有三种模块暴露方法</strong></h4><h5 id="1-统一暴露"><a href="#1-统一暴露" class="headerlink" title="(1)统一暴露"></a><strong>(1)统一暴露</strong></h5><p><strong>模块 module1</strong>：<code>module1.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun1() module1&#x27;</span>)<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun2() module1&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 统一暴露</span><br><span class="hljs-keyword">export</span> &#123;foo,bar&#125;<br></code></pre></td></tr></table></figure><h5 id="2-分别暴露"><a href="#2-分别暴露" class="headerlink" title="(2)分别暴露"></a><strong>(2)分别暴露</strong></h5><p><strong>模块 module2</strong>：<code>module2.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//多行暴露</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>,<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo() module2&#x27;</span>);<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar() module2&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>以上两种向外暴露方式在主文件引入时必须使用对象的解构赋值引用（不能使用变量接收的方式来映入）</strong></p><p><strong>主模块</strong>：<code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;foo,bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;.js/src/module2.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123;fun1,fun2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./js/src/module1.js&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="3-默认暴露"><a href="#3-默认暴露" class="headerlink" title="(3)默认暴露"></a><strong>(3)默认暴露</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;默认暴露方式&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;默认暴露&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认暴露的方式只允许有一个: <code>export default &#123;&#125;</code>且在主模块引入时可以使用定义变量来接收的方式！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入模块3</span><br><span class="hljs-keyword">import</span> module3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;.js/src/module3.js&#x27;</span><br> <br><span class="hljs-comment">// 使用模块</span><br>module3.<span class="hljs-title function_">foo</span>()<br>module3.<span class="hljs-title function_">bar</span>()<br></code></pre></td></tr></table></figure><h4 id="3-2、总结"><a href="#3-2、总结" class="headerlink" title="3-2、总结"></a>3-2、总结</h4><ul><li>对外暴露出的都是一个对象，但是不同的暴露方法实际暴露的对象有所不同</li><li>默认并暴露的实质就是使用 export ➕ 去除import关键字后的引入写法</li><li><strong>默认暴露在进行引入并暴露时不能进行简写</strong></li><li>import引入的文件会自动收集在文件的最上方，并按照引入的顺序执行</li></ul><h3 id="4、单文件组件"><a href="#4、单文件组件" class="headerlink" title="4、单文件组件"></a>4、单文件组件</h3><p>一个文件只包含有1个组件。</p><h6 id="School-vue组件"><a href="#School-vue组件" class="headerlink" title="School.vue组件"></a><strong>School.vue组件</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;!-- 组件的结构 --&gt;<br>&lt;div class=&quot;demo&quot;&gt;<br>&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;<br>&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// 组件交互相关的代码(数据、方法等等)<br>// export school = Vue.extend(&#123;...&#125;)分别暴露<br> export default &#123;<br>name:&#x27;School&#x27;,<br>data()&#123;<br>return &#123;<br>name:&#x27;111&#x27;,<br>address:&#x27;001&#x27;<br>&#125;<br>&#125;,<br>methods: &#123;<br>showName()&#123;<br>alert(this.name)<br>&#125;<br>&#125;,<br>&#125;<br>// export &#123;school&#125; 统一暴露<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>/* 组件的样式 */<br>.demo&#123;<br>background-color: orange;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h6 id="Student-vue组件"><a href="#Student-vue组件" class="headerlink" title="Student.vue组件"></a><strong>Student.vue组件</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br> export default &#123;<br>name:&#x27;Student&#x27;,<br>data()&#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>age:18<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h6 id="App-vue组件"><a href="#App-vue组件" class="headerlink" title="App.vue组件"></a><strong>App.vue组件</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;School&gt;&lt;/School&gt;<br>&lt;Student&gt;&lt;/Student&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>//引入组件<br>import School from &#x27;./School.vue&#x27;<br>import Student from &#x27;./Student.vue&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;<br>School,<br>Student<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h6 id="index-js-这个是引入vm，"><a href="#index-js-这个是引入vm，" class="headerlink" title="index.js (这个是引入vm，)"></a>index.js (这个是引入vm，)</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;App&gt;&lt;/App&gt;`</span>,<br><span class="hljs-attr">components</span>:&#123;<span class="hljs-title class_">App</span>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>练习一下单文件组件的语法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 准备一个容器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、Vue-CLI"><a href="#二、Vue-CLI" class="headerlink" title="二、Vue-CLI"></a>二、Vue-CLI</h1><p>分区作者：Cool小陈</p><h2 id="1、Vue脚手架安装与部署"><a href="#1、Vue脚手架安装与部署" class="headerlink" title="1、Vue脚手架安装与部署"></a>1、Vue脚手架安装与部署</h2><h4 id="1-1、依赖软件-nodejs"><a href="#1-1、依赖软件-nodejs" class="headerlink" title="1-1、依赖软件 nodejs"></a>1-1、依赖软件 nodejs</h4><p>1、下载nodejs  </p><p>​<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p>​<a href="https://registry.npmmirror.com/binary.html?path=node/">https://registry.npmmirror.com/binary.html?path=node/</a></p><p>​     X86  适用 32 windows</p><p>​     X64  适用 64 windows</p><p>2、下一步</p><p>​    安装目录: 不要中文不要有空格</p><p>​    c:&#x2F;program files&#x2F;nodejs</p><p> 1.3:  检测(windows-&gt;开始-&gt;运行-&gt;cmd)</p><p>node -v</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108445.png" alt="img"></p><h4 id="1-2、安装cnpm-工具-nodejs工具-npm-安装软件"><a href="#1-2、安装cnpm-工具-nodejs工具-npm-安装软件" class="headerlink" title="1-2、安装cnpm 工具(nodejs工具 npm 安装软件)"></a>1-2、安装cnpm 工具(nodejs工具 npm 安装软件)</h4><p> npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br> #npm 安装工具<br> #install 安装 uninstall 删除<br> #-g  全局<br> #<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 淘宝镜像站点<br> #检测</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108503.png" alt="202203071108503"></p><h4 id="1-3、安装vue-cli脚手架（安装一个3-x版本的Vue脚手架）"><a href="#1-3、安装vue-cli脚手架（安装一个3-x版本的Vue脚手架）" class="headerlink" title="1-3、安装vue-cli脚手架（安装一个3.x版本的Vue脚手架）"></a>1-3、安装vue-cli脚手架（安装一个3.x版本的Vue脚手架）</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @vue/cli<br>//<span class="hljs-built_in">npm</span> i -g @vue/cli<br></code></pre></td></tr></table></figure><h4 id="1-4、安装创建项目"><a href="#1-4、安装创建项目" class="headerlink" title="1-4、安装创建项目"></a>1-4、安装创建项目</h4><h5 id="1-4-1、vue-create-xxx安装"><a href="#1-4-1、vue-create-xxx安装" class="headerlink" title="1-4-1、vue create xxx安装"></a>1-4-1、vue create xxx安装</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>protest是项目名，自定义的<br>vue create protest<br></code></pre></td></tr></table></figure><p>这里会有选项出来，可以选第一项，但是建议选第三项，自定义（高手就选这个），选择特性以创建的项目为准</p><p>使用键盘上下键移动，回车选定，勾选特性用空格进行勾选</p><p>选了第三项之后，接下来出现的页面：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108065.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108874.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108136.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108679.png" alt="img"></p><p>选择Router</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108530.png" alt="img"></p><p>接下来，选择2.x，回车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108380.png" alt="img"></p><p>接下来，是否选用历史模式的路由，输入n或者y，看个人情况即可，回车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108511.png" alt="img"></p><p>接下来，ESLint选择选择第三项，回车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108285.png" alt="img"></p><p>接下来，何时进行ESLint语法效验，选第一项，回车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108940.png" alt="img"></p><p>接下来，babel,protcss等配置文件如何放置，选默认的第一项：单独使用文件进行配置，回车：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071108986.png" alt="img"></p><p>最后，是否保存为模板，以后创建项目的模板。看个人n和y都可以：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071109773.png" alt="img"></p><p>整个模板：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203081706548.png" alt="img"></p><p>加载完成后出现的页面：</p><p>输入cd 建的项目名称</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071109543.png" alt="img"></p><p>执行npm run serve后出现的页面：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071109120.png" alt="img"></p><p>Local和Network的两个地址（服务器的地址）都可以直接点开页面</p><p>到这里，项目创建完成</p><h5 id="1-4-2、基于ui界面创建vue项目"><a href="#1-4-2、基于ui界面创建vue项目" class="headerlink" title="1-4-2、基于ui界面创建vue项目"></a>1-4-2、基于ui界面创建vue项目</h5><p>执行一下命令，可以打开ui界面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vue ui</span><br></code></pre></td></tr></table></figure><p>安装Element-UI<br>Element-UI:是一套2.0的桌面组件库</p><p>1.在终端输入：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> element-ui -S<br></code></pre></td></tr></table></figure><p>2.在入口文件(src&#x2F;main.js)导入添加：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import ElementUI from <span class="hljs-string">&quot;element-ui&quot;</span><span class="hljs-comment">;</span><br>import <span class="hljs-string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span><span class="hljs-comment">;</span><br>Vue.use(ElementUI)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>额外的步骤：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071109499.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071109846.png" alt="img"></p><h2 id="2、分析脚手架"><a href="#2、分析脚手架" class="headerlink" title="2、分析脚手架"></a>2、分析脚手架</h2><h4 id="2-1、脚手架文件结构"><a href="#2-1、脚手架文件结构" class="headerlink" title="2-1、脚手架文件结构"></a>2-1、脚手架文件结构</h4><pre><code class="hljs">├── node_modules 放置node模块├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面//网站访问入口├── src         项目源码│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 开启移动端的理想视口 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置页签图标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入第三方样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置网页标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>脚手架基础<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 容器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="2-2、关于不同版本的Vue"><a href="#2-2、关于不同版本的Vue" class="headerlink" title="2-2、关于不同版本的Vue"></a>2-2、关于不同版本的Vue</h4><h5 id="main-js中的render函数"><a href="#main-js中的render函数" class="headerlink" title="main.js中的render函数"></a>main.js中的render函数</h5><p>esm代表es6中的muddle 使用vue.runtime.xxx.js可以节约空间</p><p>  关于不同版本的Vue：</p><p>​    1.vue.js与vue.runtime.xxx.js的区别：</p><p>​        (1).vue.js是完整版的Vue，包含：核心功能+模板解析器。</p><p>​        (2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</p><p>​    2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用</p><p>​      render函数接收到的createElement函数去指定具体内容。</p><p><strong>main.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">该文件是整个项目的入口文件</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//引入Vue,这里的vue是指运行版的Vue，即vue.runtime.xxx.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入App组件，它是所有组件的父组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-comment">//render函数完成了这个功能：将App组件放入容器中</span><br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br><span class="hljs-comment">// render:q=&gt; q(&#x27;h1&#x27;,&#x27;你好啊&#x27;) //箭头函数</span><br><br><span class="hljs-comment">// render(createElement) &#123;</span><br><span class="hljs-comment">// return createElement(&#x27;h1&#x27;,&#x27;你好啊&#x27;)</span><br><span class="hljs-comment">// &#125;,</span><br><br><span class="hljs-comment">// template:`&lt;h1&gt;你好啊&lt;/h1&gt;`,  //精简版不解析template</span><br><span class="hljs-comment">// components:&#123;App&#125;,</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-3、修改默认配置"><a href="#2-3、修改默认配置" class="headerlink" title="2-3、修改默认配置"></a>2-3、修改默认配置</h4><h5 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h5><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><p>2-4、</p><h2 id="3、ref属性"><a href="#3、ref属性" class="headerlink" title="3、ref属性"></a>3、ref属性</h2><h4 id="3-1、ref属性"><a href="#3-1、ref属性" class="headerlink" title="3-1、ref属性"></a>3-1、ref属性</h4><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h4 id="3-2、案例如下："><a href="#3-2、案例如下：" class="headerlink" title="3-2、案例如下："></a>3-2、案例如下：</h4><p>App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;<br>&lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;<br>&lt;School ref=&quot;sch&quot;/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>//引入School组件<br>import School from &#x27;./components/School&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;School&#125;,<br>data() &#123;<br>return &#123;<br>msg:&#x27;欢迎学习Vue！&#x27;<br>&#125;<br>&#125;,<br>methods: &#123;<br>showDOM()&#123;<br>console.log(this.$refs.title) //真实DOM元素<br>console.log(this.$refs.btn) //真实DOM元素<br>console.log(this.$refs.sch) //School组件的实例对象（vc）<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="4、props配置"><a href="#4、props配置" class="headerlink" title="4、props配置"></a>4、props配置</h2><h4 id="4-1、props配置项"><a href="#4-1、props配置项" class="headerlink" title="4-1、props配置项"></a>4-1、props配置项</h4><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br><span class="hljs-attr">name</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">//类型</span><br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必要性</span><br><span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;老王&#x27;</span> <span class="hljs-comment">//默认值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h4 id="4-2、案例如下"><a href="#4-2、案例如下" class="headerlink" title="4-2、案例如下"></a>4-2、案例如下</h4><p>App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot;/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Student from &#x27;./components/Student&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;Student&#125;<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>Student.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;<br>&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生年龄：&#123;&#123;myAge+1&#125;&#125;&lt;/h2&gt;<br>&lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>console.log(this)<br>return &#123;<br>msg:&#x27;我是一个学生&#x27;,<br>myAge:this.age<br>&#125;<br>&#125;,<br>methods: &#123;<br>updateAge()&#123;<br>this.myAge++<br>&#125;<br>&#125;,<br>//简单声明接收<br>// props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;] <br><br>//接收的同时对数据进行类型限制<br>/* props:&#123;<br>name:String,<br>age:Number,<br>sex:String<br>&#125; */<br><br>//接收的同时对数据：进行类型限制+默认值的指定+必要性的限制<br>props:&#123;<br>name:&#123;<br>type:String, //name的类型是字符串<br>required:true, //name是必要的<br>&#125;,<br>age:&#123;<br>type:Number,<br>default:99 //默认值<br>&#125;,<br>sex:&#123;<br>type:String,<br>required:true<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="5、mixin（混入）属性"><a href="#5、mixin（混入）属性" class="headerlink" title="5、mixin（混入）属性"></a>5、mixin（混入）属性</h2><h4 id="5-1、mixin-混入"><a href="#5-1、mixin-混入" class="headerlink" title="5-1、mixin(混入)"></a>5-1、mixin(混入)</h4><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><p>{<br>data(){….},<br>methods:{….}<br>….<br>}</p><p>第二步使用混入：</p><p>全局混入：<code>Vue.mixin(xxx)</code><br>局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><h4 id="5-2、案例如下："><a href="#5-2、案例如下：" class="headerlink" title="5-2、案例如下："></a>5-2、案例如下：</h4><p><strong>mix.js</strong>（这里定义了两个混入方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义了两个的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hunhe = &#123;<br><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;,<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好啊！&#x27;</span>)<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hunhe2 = &#123;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<br><span class="hljs-attr">y</span>:<span class="hljs-number">200</span><br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.js</strong>（这里是用了全局混入1和2）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1、这里引入了两个混入属性在mixin.js中</span><br><span class="hljs-keyword">import</span> &#123;hunhe,hunhe2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mixin&#x27;</span><br><br><span class="hljs-comment">//2、使用mixin.js中的两个混入效果</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(hunhe)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(hunhe2)<br></code></pre></td></tr></table></figure><p><strong>Student.vue</strong>（1这里引入混入，2并使用了局部混入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h2 @click=&quot;showName&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    //1、引入混入<br>// import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;<br><br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>sex:&#x27;男&#x27;<br>&#125;<br>&#125;,<br><br>//2、使用局部混入<br>// mixins:[hunhe,hunhe2]<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="6、插件"><a href="#6、插件" class="headerlink" title="6、插件"></a>6、插件</h2><h4 id="6-1、插件使用步骤"><a href="#6-1、插件使用步骤" class="headerlink" title="6-1、插件使用步骤"></a>6-1、插件使用步骤</h4><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">对象.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123;<br>    <span class="hljs-comment">// 1. 添加全局过滤器</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(....)<br><br>    <span class="hljs-comment">// 2. 添加全局指令</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(....)<br><br>    <span class="hljs-comment">// 3. 配置全局混入(合)</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(....)<br><br>    <span class="hljs-comment">// 4. 添加实例方法</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;...&#125;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myProperty</span> = xxxx<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h4 id="6-2、案例如下："><a href="#6-2、案例如下：" class="headerlink" title="6-2、案例如下："></a>6-2、案例如下：</h4><p> <strong>plugins.js</strong>（定义插件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-title function_">install</span>(<span class="hljs-params">Vue,x,y,z</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x,y,z)<br><span class="hljs-comment">//全局过滤器</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;mySlice&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">return</span> value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br>&#125;)<br><br><span class="hljs-comment">//定义全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;fbind&#x27;</span>,&#123;<br><span class="hljs-comment">//指令与元素成功绑定时（一上来）</span><br><span class="hljs-title function_">bind</span>(<span class="hljs-params">element,binding</span>)&#123;<br>element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span><br>&#125;,<br><span class="hljs-comment">//指令所在元素被插入页面时</span><br><span class="hljs-title function_">inserted</span>(<span class="hljs-params">element,binding</span>)&#123;<br>element.<span class="hljs-title function_">focus</span>()<br>&#125;,<br><span class="hljs-comment">//指令所在的模板被重新解析时</span><br><span class="hljs-title function_">update</span>(<span class="hljs-params">element,binding</span>)&#123;<br>element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span><br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//定义混入</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<br><span class="hljs-attr">y</span>:<span class="hljs-number">200</span><br>&#125;<br>&#125;,<br>&#125;)<br><br><span class="hljs-comment">//给Vue原型上添加一个方法（vm和vc就都能用了）</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你好啊&#x27;</span>)&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.js</strong>（引入并且使用插件的js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入插件</span><br><span class="hljs-keyword">import</span> plugins <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./plugins.js&#x27;</span><br><br><span class="hljs-comment">//应用（使用）插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(plugins,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>School.vue（使用mySlice全局过滤器、使用Vue原型上的hello方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h2&gt;学校名称：&#123;&#123;name | mySlice&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;<br>&lt;button @click=&quot;test&quot;&gt;点我测试一个hello方法&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;School&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;abcdefghighlim&#x27;,<br>address:&#x27;北京&#x27;,<br>&#125;<br>&#125;,<br>methods: &#123;<br>test()&#123;<br>this.hello()<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>Student.vue</strong>（使用fbind全局指令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;<br>&lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>sex:&#x27;男&#x27;<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="7、scoped样式"><a href="#7、scoped样式" class="headerlink" title="7、scoped样式"></a>7、scoped样式</h2><h4 id="7-1、scoped用法"><a href="#7-1、scoped用法" class="headerlink" title="7-1、scoped用法"></a>7-1、scoped用法</h4><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h4 id="7-2、案例如下："><a href="#7-2、案例如下：" class="headerlink" title="7-2、案例如下："></a>7-2、案例如下：</h4><p>App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1 class=&quot;title&quot;&gt;你好啊&lt;/h1&gt;<br>&lt;School/&gt;<br>&lt;Student/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Student from &#x27;./components/Student&#x27;<br>import School from &#x27;./components/School&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;School,Student&#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.title&#123;<br>color: red;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="7-3、Todo-list案例"><a href="#7-3、Todo-list案例" class="headerlink" title="7-3、Todo-list案例"></a>7-3、Todo-list案例</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203062101731.png" alt="img"></p><h4 id="7-4、总结TodoList案例"><a href="#7-4、总结TodoList案例" class="headerlink" title="7-4、总结TodoList案例"></a>7-4、总结TodoList案例</h4><h5 id="1、组件化编码流程："><a href="#1、组件化编码流程：" class="headerlink" title="1、组件化编码流程："></a>1、组件化编码流程：</h5><p>​(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p>​(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>​1).一个组件在用：放在组件自身即可。</p><p>​2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p>​(3).实现交互：从绑定事件开始。</p><h5 id="2、props适用于："><a href="#2、props适用于：" class="headerlink" title="2、props适用于："></a>2、props适用于：</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">(<span class="hljs-number">1</span>).父组件 <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; 子组件 通信<br><br>(<span class="hljs-number">2</span>).子组件 <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; 父组件 通信（要求父先给子一个函数）<br></code></pre></td></tr></table></figure><h5 id="3、使用v-model时要切记："><a href="#3、使用v-model时要切记：" class="headerlink" title="3、使用v-model时要切记："></a>3、使用v-model时要切记：</h5><p>​v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p><h5 id="4、修改props中的值的情况"><a href="#4、修改props中的值的情况" class="headerlink" title="4、修改props中的值的情况"></a>4、修改props中的值的情况</h5><p>​props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p><h5 id="5、数据在哪里，操作数据就在哪里"><a href="#5、数据在哪里，操作数据就在哪里" class="headerlink" title="5、数据在哪里，操作数据就在哪里"></a>5、数据在哪里，操作数据就在哪里</h5><p>关于表格中的删除效果和移动高亮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ddd</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-tag">button</span>&#123;<br><span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce条件统计</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//原来</span><br><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">foreach</span>((todo))=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(todo.<span class="hljs-property">done</span>) i++<br>&#125;<br><br><span class="hljs-comment">//用reduce后</span><br><span class="hljs-comment">/* const x = this.todos.reduce((pre,current)=&gt;&#123;</span><br><span class="hljs-comment">console.log(&#x27;@&#x27;,pre,current)</span><br><span class="hljs-comment">return pre + (current.done ? 1 : 0)</span><br><span class="hljs-comment">&#125;,0) */</span><br><span class="hljs-comment">//简写</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,todo</span>)=&gt;</span> pre + (todo.<span class="hljs-property">done</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) ,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="8、浏览器本地存储"><a href="#8、浏览器本地存储" class="headerlink" title="8、浏览器本地存储"></a>8、浏览器本地存储</h2><h4 id="8-1、webStorage"><a href="#8-1、webStorage" class="headerlink" title="8-1、webStorage"></a>8-1、webStorage</h4><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><pre><code class="hljs">该方法接受一个键名作为参数，返回键名对应的值。</code></pre></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><pre><code class="hljs">该方法接受一个键名作为参数，并把该键名从存储中删除。</code></pre></li><li><p><code> xxxxxStorage.clear()</code></p><pre><code class="hljs">该方法会清空存储中的所有数据。</code></pre></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><p>localStorage.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>localStorage<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>localStorage<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;deleteData()&quot;</span>&gt;</span>点我删除一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;deleteAllData()&quot;</span>&gt;</span>点我清空一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> p = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;msg&#x27;</span>,<span class="hljs-string">&#x27;hello!!!&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>,<span class="hljs-number">666</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(p))</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;msg&#x27;</span>))</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(result))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(localStorage.getItem(&#x27;msg3&#x27;))</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAllData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>sessionStorage.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>sessionStorage<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>sessionStorage<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;deleteData()&quot;</span>&gt;</span>点我删除一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;deleteAllData()&quot;</span>&gt;</span>点我清空一个数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> p = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;msg&#x27;</span>,<span class="hljs-string">&#x27;hello!!!&#x27;</span>)</span><br><span class="language-javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>,<span class="hljs-number">666</span>)</span><br><span class="language-javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(p))</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;msg&#x27;</span>))</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> result = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(result))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(sessionStorage.getItem(&#x27;msg3&#x27;))</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;msg2&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteAllData</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">sessionStorage.<span class="hljs-title function_">clear</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-2、TodoList案例添加本地存储"><a href="#8-2、TodoList案例添加本地存储" class="headerlink" title="8-2、TodoList案例添加本地存储"></a>8-2、TodoList案例添加本地存储</h4><p>把App.vue加一个监视属性并且设置它里面todos的初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">//1设置todos初始值，将todos:[]改成<br>todos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []<br><br>//2添加一个监视属性，并且进行深度监视<br>watch: &#123;<br>todos:&#123;<br>deep:true,<br>handler(value)&#123;<br>localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))<br>&#125;<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="9、组件自定义事件"><a href="#9、组件自定义事件" class="headerlink" title="9、组件自定义事件"></a>9、组件自定义事件</h2><h4 id="9-1、组件的自定义事件"><a href="#9-1、组件的自定义事件" class="headerlink" title="9-1、组件的自定义事件"></a>9-1、组件的自定义事件</h4><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @at1=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:at1=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">Demo</span> ref=<span class="hljs-string">&quot;demo&quot;</span>/&gt;<br>    ......<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">xxx</span>.$on(<span class="hljs-string">&#x27;at1&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;at1&#39;,数据)</code>   </p></li><li><p>解绑自定义事件<code>this.$off(&#39;at1&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;at1&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h4 id="9-2、TodoList案例添加自定义事件"><a href="#9-2、TodoList案例添加自定义事件" class="headerlink" title="9-2、TodoList案例添加自定义事件"></a>9-2、TodoList案例添加自定义事件</h4><p>MyHeader中的:addTodo&#x3D;”addTodo”改成@addTodo&#x3D;”addTodo”</p><p>然后把props中的addTodo删掉，然后使用</p><p>事件名.$emit(addTodo,value)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">//1将这里的&lt;MyHeader :addTodo=&quot;addTodo&quot;/&gt;改成<br>&lt;MyHeader @addTodo=&quot;addTodo&quot;/&gt;<br><br>//2找到props中可能存在的addTodo，然后删掉<br><br>//3在methods里面的add中添加this.$emit(&#x27;at1&#x27;,数据)<br>this.$emit(&#x27;addTodo&#x27;,todoObj)<br></code></pre></td></tr></table></figure><h2 id="10、全局事件总线"><a href="#10、全局事件总线" class="headerlink" title="10、全局事件总线"></a>10、全局事件总线</h2><h4 id="10-1、可以实现任意组件间的通信（图解）"><a href="#10-1、可以实现任意组件间的通信（图解）" class="headerlink" title="10-1、可以实现任意组件间的通信（图解）"></a>10-1、可以实现任意组件间的通信（图解）</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203092012786.jpg" alt="img"></p><p><strong>x组件需满足</strong></p><p>​1、所有的组件都能看见x组件</p><p>​2、x能被调用到（$on和$off以及$emit）</p><h4 id="10-2、全局事件总线（GlobalEventBus）"><a href="#10-2、全局事件总线（GlobalEventBus）" class="headerlink" title="10-2、全局事件总线（GlobalEventBus）"></a>10-2、全局事件总线（GlobalEventBus）</h4><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>在main.js中安装全局事件总线：</p><p>方法一、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Demo</span> = vue.<span class="hljs-title function_">extend</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>()<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = d<br></code></pre></td></tr></table></figure><p>方法二、（提倡这种方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>......<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线，$bus就是当前应用的vm</span><br>&#125;,<br>    ......<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h4 id="10-3、TodoList事件总线"><a href="#10-3、TodoList事件总线" class="headerlink" title="10-3、TodoList事件总线"></a>10-3、TodoList事件总线</h4><p>全局事件总线的本质是给组件绑定自定义事件，只不过这里的组件是this.$bus也就是Vue实例对象</p><h2 id="11、消息订阅与发布pubsub"><a href="#11、消息订阅与发布pubsub" class="headerlink" title="11、消息订阅与发布pubsub"></a>11、消息订阅与发布pubsub</h2><h4 id="11-1、消息订阅与发布"><a href="#11-1、消息订阅与发布" class="headerlink" title="11-1、消息订阅与发布"></a>11-1、消息订阅与发布</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203101346537.jpeg" alt="img"></p><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p><h4 id="11-2、使用方法"><a href="#11-2、使用方法" class="headerlink" title="11-2、使用方法"></a>11-2、使用方法</h4><p>1、调用pubsub.js库命令，安装pubsub：<code>npm i pubsub-js</code></p><p>2、在所用的地方引入库: <code>import pubsub from &#39;pubsub-js&#39;</code></p><ol><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pid</span> = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>) <span class="hljs-comment">//订阅消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(this.pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol><h4 id="11-3、TodoList案例pubsub"><a href="#11-3、TodoList案例pubsub" class="headerlink" title="11-3、TodoList案例pubsub"></a>11-3、TodoList案例pubsub</h4><h2 id="12、-nextTick（视图渲染完，操作DOM）"><a href="#12、-nextTick（视图渲染完，操作DOM）" class="headerlink" title="12、$nextTick（视图渲染完，操作DOM）"></a>12、$nextTick（视图渲染完，操作DOM）</h2><h4 id="12-1、nextTick使用"><a href="#12-1、nextTick使用" class="headerlink" title="12-1、nextTick使用"></a>12-1、nextTick使用</h4><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="13、vue封装的过度和动画"><a href="#13、vue封装的过度和动画" class="headerlink" title="13、vue封装的过度和动画"></a>13、vue封装的过度和动画</h2><h4 id="13-1、Vue封装的过度与动画"><a href="#13-1、Vue封装的过度与动画" class="headerlink" title="13-1、Vue封装的过度与动画"></a>13-1、Vue封装的过度与动画</h4><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/20210810141423589.png" alt="img"></p></li><li><p>写法：</p><p>3-1、准备好样式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 元素进入的样式：<br><span class="hljs-bullet">  1.</span> v-enter：进入的起点<br><span class="hljs-bullet">  2.</span> v-enter-active：进入过程中<br><span class="hljs-bullet">  3.</span> v-enter-to：进入的终点<br><span class="hljs-bullet">-</span> 元素离开的样式：<br><span class="hljs-bullet">  1.</span> v-leave：离开的起点<br><span class="hljs-bullet">  2.</span> v-leave-active：离开过程中<br><span class="hljs-bullet">  3.</span> v-leave-to：离开的终点<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css">- <span class="hljs-number">1</span>、案例如下过度写<br><span class="hljs-comment">/* 进入的起点、离开的终点 */</span><br><span class="hljs-selector-class">.hello-enter</span>,<span class="hljs-selector-class">.hello-leave-to</span>&#123;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>&#125;<br><span class="hljs-selector-class">.hello-enter-active</span>,<span class="hljs-selector-class">.hello-leave-active</span>&#123;<br><span class="hljs-attribute">transition</span>: <span class="hljs-number">0.5s</span> linear;<br>&#125;<br><span class="hljs-comment">/* 进入的终点、离开的起点 */</span><br><span class="hljs-selector-class">.hello-enter-to</span>,<span class="hljs-selector-class">.hello-leave</span>&#123;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);<br>&#125;<br>-/<span class="hljs-number">2</span>、案例如下动画写<br><span class="hljs-comment">/* .v-enter-active */</span><br><span class="hljs-selector-class">.hello-enter-active</span>&#123;<br>    <span class="hljs-attribute">animation</span>: at1 <span class="hljs-number">1s</span> linear;<br>&#125;<br><span class="hljs-comment">/* .v-leave-active */</span><br><span class="hljs-selector-class">.hello-leave-active</span>&#123;<br>    <span class="hljs-attribute">animation</span>: at1 <span class="hljs-number">1s</span> linear reverse;<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> at1 &#123;<br>    <span class="hljs-selector-tag">from</span>&#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);&#125;<br>    <span class="hljs-selector-tag">to</span>&#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3-2、使用<code>&lt;transition&gt;</code>包裹要过度元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;transition name=&quot;hello&quot;&gt;<br>     &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure><p>3-3、备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p><p>3-4、可以使用第三方动画库来实现动画效果</p></li></ol><h4 id="13-2、animate-css-开箱即用的动画库"><a href="#13-2、animate-css-开箱即用的动画库" class="headerlink" title="13-2、animate.css(开箱即用的动画库)"></a>13-2、animate.css(开箱即用的动画库)</h4><p>官网：  <a href="https://animate.style/">https://animate.style/</a></p><p>图片： <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312142830357.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">//安装animate.css库<br>npm install animate.css<br>//引入样式库<br>import &#x27;animate.css&#x27;<br>//存放库里面的样式属性（animate__animated animate__bounce），<br>//然后放置属性（enter-active-class）<br>//和效果动画（animate__swing）<br>&lt;transition-group <br>appear<br>name=&quot;animate__animated animate__bounce&quot; <br>enter-active-class=&quot;animate__swing&quot;<br>leave-active-class=&quot;animate__backOutUp&quot;<br>&gt;<br>&lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;<br>&lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;你好！&lt;/h1&gt;<br>&lt;/transition-group&gt;<br></code></pre></td></tr></table></figure><h2 id="14、配置代理"><a href="#14、配置代理" class="headerlink" title="14、配置代理"></a>14、配置代理</h2><h4 id="14-1、用脚手架去解决Ajax跨域的问题"><a href="#14-1、用脚手架去解决Ajax跨域的问题" class="headerlink" title="14-1、用脚手架去解决Ajax跨域的问题"></a>14-1、用脚手架去解决Ajax跨域的问题</h4><p>解压文件中的test_proxy_server.zip</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312152938034.png" alt="img"></p><p>在文件页面打开cmd 输入node server1，然后复制（<a href="http://localhost:5000/students%EF%BC%89%E7%BD%91%E5%9D%80%EF%BC%8C%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E8%BE%93%E5%85%A5%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%8E%B0%E6%98%AFAjax%E5%8F%91%E5%87%BA%E7%9A%84get%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%AB%AF%E5%8F%A3%E4%B9%9F%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%E4%BA%86">http://localhost:5000/students）网址，打开浏览器，输入页面发现是Ajax发出的get请求，端口也显示出来了</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312153010517.png" alt="img"></p><p>在文件页面打开cmd 输入node server1，然后复制（<a href="http://localhost:5000/students%EF%BC%89%E7%BD%91%E5%9D%80%EF%BC%8C%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E8%BE%93%E5%85%A5%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%8E%B0%E6%98%AFAjax%E5%8F%91%E5%87%BA%E7%9A%84get%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%AB%AF%E5%8F%A3%E4%B9%9F%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%E4%BA%86">http://localhost:5000/students）网址，打开浏览器，输入页面发现是Ajax发出的get请求，端口也显示出来了</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312153047582.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312153104722.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312153235116.png" alt="img"></p><h4 id="14-2、常用的发送一个Ajax请求的方式有哪些：（4种）"><a href="#14-2、常用的发送一个Ajax请求的方式有哪些：（4种）" class="headerlink" title="14-2、常用的发送一个Ajax请求的方式有哪些：（4种）"></a>14-2、常用的发送一个Ajax请求的方式有哪些：（4种）</h4><ul><li><p><strong>xhr</strong>(不常用)   new XMLHttpRequest() </p><p>​常用apixhr.open()   、 xhr.send()等</p></li><li><p><strong>jQuery</strong>(不常用，经常使用DOM操作) </p><p>​ 常用api $get  、  $post</p></li><li><p><strong>axios</strong>(promise风格)</p></li><li><p>vue-resource（不常用，在vue1.0流行）</p></li><li><p><strong>fetch</strong>(promise风格，但会包装两次promise)</p><p>最致密的是他IE中的兼容性极差</p></li></ul><h4 id="14-3、axios的使用与问题解决"><a href="#14-3、axios的使用与问题解决" class="headerlink" title="14-3、axios的使用与问题解决"></a>14-3、axios的使用与问题解决</h4><p>安装axios</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>axios的安装<br>npm i axios<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312154444234.png" alt="img"></p><p>引入axios</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">//引入axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios.js&#x27;</span><br></code></pre></td></tr></table></figure><p>设置一个按钮</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getStudents&quot;</span>&gt;</span>获取学生信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在methods中写请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">getStudents</span>(<span class="hljs-params"></span>)&#123;<br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:5000/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.<span class="hljs-property">data</span>)<br>&#125;,<br><span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.<span class="hljs-property">message</span>)<br>&#125;<br>)<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>发生跨域问题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312155344128.png" alt="img"></p><p>解决跨域问题的方式：</p><p>1、cors </p><p>2、jsonp script src（只能解决get请求post无法解决）</p><p>3、使用代理服务器(类似于生活中的房屋中介)</p><p>开启代理服务器方式{    1、nginx    2、vue-cli }</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/de8d3d54dd4ea9c641fee79e581cf09.jpg" alt="img"></p><h4 id="14-4、用脚手架的方式配置一个代理服务器"><a href="#14-4、用脚手架的方式配置一个代理服务器" class="headerlink" title="14-4、用脚手架的方式配置一个代理服务器"></a>14-4、用脚手架的方式配置一个代理服务器</h4><h5 id="14-4A、方式一"><a href="#14-4A、方式一" class="headerlink" title="14-4A、方式一"></a>14-4A、方式一</h5><h6 id="14-4A-1、配置方法"><a href="#14-4A-1、配置方法" class="headerlink" title="14-4A-1、配置方法"></a>14-4A-1、配置方法</h6><p>①在vue的脚手架官网搜索devServer.proxy（英文意思为开发中如何配置代理），②在vue.config.js中输入（这里的5000是你获取axios服务器的端口），③把methods中的axios请求的地址改成8080端口的（因为数据要发送到8080端口实现跨域）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">devServer: &#123;<br>    proxy: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span><br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312163144534.png" alt="img"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//修改端口号5000，改成8080端口</span><br>axios.get(<span class="hljs-string">&#x27;http://localhost:8080/students&#x27;</span>).then(<br><span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data)<br>&#125;,<br>error =&gt; &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message)<br>&#125;<br>)<br>&#125;,<br></code></pre></td></tr></table></figure><h6 id="14-4A-2、工作方式："><a href="#14-4A-2、工作方式：" class="headerlink" title="14-4A-2、工作方式："></a>14-4A-2、工作方式：</h6><p>若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</p><p>当你请求的内容代理服务器中原本就有则不会发送给5000的目标服务器public中有students，（即实现不了下面图片黄色箭头）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312163023400.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/2ddb28d274ee9ba6749fc158947b25f.jpg" alt="img"></p><h6 id="14-4A-3、方式一配置代理缺点"><a href="#14-4A-3、方式一配置代理缺点" class="headerlink" title="14-4A-3、方式一配置代理缺点"></a>14-4A-3、方式一配置代理缺点</h6><p>这种情况下只能配置一个单独的代理，并且不能灵活的控制走不走代理服务器。</p><h5 id="14-4B、方式二"><a href="#14-4B、方式二" class="headerlink" title="14-4B、方式二"></a>14-4B、方式二</h5><h6 id="14-4B-1、配置方法"><a href="#14-4B-1、配置方法" class="headerlink" title="14-4B-1、配置方法"></a>14-4B-1、配置方法</h6><p>下图两个颜色为配置的两套代理（分别为红色和绿色，且红色是精简版），并且这里’&#x2F;api’的意思是当你发送请求到代理服务器时，它会判断代理是否是 &#x2F;api 形式如果是走代理，否则不走。target 为请求跳转的目标地址，pathRewrite:{‘^&#x2F;api’:’’}这里是请求后发给目标地址是把&#x2F;api  替换成空字符串</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220312170245699.png" alt="img"></p><p>此时请求完还得改axios跳转代理服务器的路径为</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//原本</span><br>axios.get(&#x27;http://localhost:<span class="hljs-number">8080</span>/students&#x27;)<br><span class="hljs-comment">//修改后添加了个/api</span><br>axios.get(&#x27;http://localhost:<span class="hljs-number">8080</span>/api/students&#x27;)<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">/*<br>   changeOrigin设置为<span class="hljs-literal">true</span>时，服务器收到的请求头中的host为：localhost:<span class="hljs-number">5000</span><br>   changeOrigin设置为<span class="hljs-literal">false</span>时，服务器收到的请求头中的host为：localhost:<span class="hljs-number">8080</span><br>   changeOrigin默认值为<span class="hljs-literal">true</span><br>*/<br></code></pre></td></tr></table></figure><h6 id="14-4B-2、配置优缺点："><a href="#14-4B-2、配置优缺点：" class="headerlink" title="14-4B-2、配置优缺点："></a>14-4B-2、配置优缺点：</h6><ol><li><p>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</p></li><li><p>缺点：配置略微繁琐，请求资源时必须加前缀。</p></li></ol><h4 id="14-5、github案例"><a href="#14-5、github案例" class="headerlink" title="14-5、github案例"></a>14-5、github案例</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220314195847981.png" alt="img"></p><p>1、先在index.html中引入bootstrap样式</p><p>2、main.js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入App</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//关闭Vue的生产提示</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span><br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>3、App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;container&quot;&gt;<br>&lt;Search/&gt;<br>&lt;List/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Search from &#x27;./components/Search&#x27;<br>import List from &#x27;./components/List&#x27;<br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;Search,List&#125;<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>4、Search.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;section class=&quot;jumbotron&quot;&gt;<br>&lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;<br>&lt;div&gt;<br>&lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot;/&gt;&amp;nbsp;<br>&lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/section&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import axios from &#x27;axios&#x27;<br>export default &#123;<br>name:&#x27;Search&#x27;,<br>data() &#123;<br>return &#123;<br>keyWord:&#x27;&#x27;<br>&#125;<br>&#125;,<br>methods: &#123;<br>searchUsers()&#123;<br>//请求前更新List的数据<br>this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:true,errMsg:&#x27;&#x27;,users:[],isFirst:false&#125;)<br>axios.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then(<br>response =&gt; &#123;<br>console.log(&#x27;请求成功了&#x27;)<br>//请求成功后更新List的数据<br>this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:&#x27;&#x27;,users:response.data.items&#125;)<br>&#125;,<br>error =&gt; &#123;<br>//请求后更新List的数据<br>this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:error.message,users:[]&#125;)<br>&#125;<br>)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>5、List.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;row&quot;&gt;<br>&lt;!-- 展示用户列表 --&gt;<br>&lt;div v-show=&quot;info.users.length&quot; class=&quot;card&quot; v-for=&quot;user in info.users&quot; :key=&quot;user.login&quot;&gt;<br>&lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;<br>&lt;img :src=&quot;user.avatar_url&quot; style=&#x27;width: 100px&#x27;/&gt;<br>&lt;/a&gt;<br>&lt;p class=&quot;card-text&quot;&gt;&#123;&#123;user.login&#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;!-- 展示欢迎词 --&gt;<br>&lt;h1 v-show=&quot;info.isFirst&quot;&gt;欢迎使用！&lt;/h1&gt;<br>&lt;!-- 展示加载中 --&gt;<br>&lt;h1 v-show=&quot;info.isLoading&quot;&gt;加载中....&lt;/h1&gt;<br>&lt;!-- 展示错误信息 --&gt;<br>&lt;h1 v-show=&quot;info.errMsg&quot;&gt;&#123;&#123;info.errMsg&#125;&#125;&lt;/h1&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;List&#x27;,<br>data() &#123;<br>return &#123;<br>info:&#123;<br>isFirst:true,<br>isLoading:false,<br>errMsg:&#x27;&#x27;,<br>users:[]<br>&#125;<br>&#125;<br>&#125;,<br>mounted() &#123;<br>this.$bus.$on(&#x27;updateListData&#x27;,(dataObj)=&gt;&#123;<br>this.info = &#123;...this.info,...dataObj&#125;<br>&#125;)<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.album &#123;<br>min-height: 50rem; /* Can be removed; just added for demo purposes */<br>padding-top: 3rem;<br>padding-bottom: 3rem;<br>background-color: #f7f7f7;<br>&#125;<br><br>.card &#123;<br>float: left;<br>width: 33.333%;<br>padding: .75rem;<br>margin-bottom: 2rem;<br>border: 1px solid #efefef;<br>text-align: center;<br>&#125;<br><br>.card &gt; img &#123;<br>margin-bottom: .75rem;<br>border-radius: 100px;<br>&#125;<br><br>.card-text &#123;<br>font-size: 85%;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220313022050832.png" alt="img"></p><h2 id="15、vue-resource（不常用）"><a href="#15、vue-resource（不常用）" class="headerlink" title="15、vue-resource（不常用）"></a>15、vue-resource（不常用）</h2><h4 id="15-1、使用方法"><a href="#15-1、使用方法" class="headerlink" title="15-1、使用方法"></a>15-1、使用方法</h4><p>安装vue-resource</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i vue-resource<br></code></pre></td></tr></table></figure><p>在main.js中引入vue-resource插件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> vueResource <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-resource&#x27;</span><br></code></pre></td></tr></table></figure><p>在main.js中使用插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">vue.<span class="hljs-keyword">use</span>(vueResource)<br></code></pre></td></tr></table></figure><p>在一个vue实例内使用<strong>this.$http代替axios</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 在一个Vue实例内使用$http<br>this.$http.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then(<br>response =&gt; &#123;<br>console.log(&#x27;请求成功了&#x27;)<br>//请求成功后更新List的数据<br>this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:&#x27;&#x27;,users:response.data.items&#125;)<br>&#125;,<br>error =&gt; &#123;<br>//请求失败后更新List的数据<br>this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:error.message,users:[]&#125;)<br>&#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="16、插槽"><a href="#16、插槽" class="headerlink" title="16、插槽"></a>16、插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category&gt;<br>           &lt;div&gt;html结构1&lt;/div&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>               &lt;!-- 定义插槽 --&gt;<br>               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category&gt;<br>            &lt;template slot=&quot;center&quot;&gt;<br>              &lt;div&gt;html结构1&lt;/div&gt;<br>            &lt;/template&gt;<br><br>            &lt;template v-slot:footer&gt;<br>               &lt;div&gt;html结构2&lt;/div&gt;<br>            &lt;/template&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>               &lt;!-- 定义插槽 --&gt;<br>               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;<br>               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>&lt;Category&gt;<br>&lt;template scope=&quot;scopeData&quot;&gt;<br>&lt;!-- 生成的是ul列表 --&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/template&gt;<br>&lt;/Category&gt;<br><br>&lt;Category&gt;<br>&lt;template slot-scope=&quot;scopeData&quot;&gt;<br>&lt;!-- 生成的是h4标题 --&gt;<br>&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;<br>&lt;/template&gt;<br>&lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br><br>        &lt;script&gt;<br>            export default &#123;<br>                name:&#x27;Category&#x27;,<br>                props:[&#x27;title&#x27;],<br>                //数据在子组件自身<br>                data() &#123;<br>                    return &#123;<br>                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]<br>                    &#125;<br>                &#125;,<br>            &#125;<br>        &lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="17、动态组件"><a href="#17、动态组件" class="headerlink" title="17、动态组件"></a>17、动态组件</h2><h4 id="17-1、动态组件的is"><a href="#17-1、动态组件的is" class="headerlink" title="17-1、动态组件的is"></a>17-1、动态组件的is</h4><ul><li>动态组件就是几个组件放在一个挂载点下，然后根据父组件的某个变量来决定显示哪个，或者都不显示。</li><li>在挂载点使用 component 标签，然后使用 is &#x3D;“组件名”，它会自动去找匹配的组件名，如果有，则显示；</li></ul><p>看例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html部分 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">is</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js 部分</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-attr">one</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路一&lt;/div&gt;&#x27;</span>&#125;,<br>        <span class="hljs-attr">two</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路二&lt;/div&gt;&#x27;</span>&#125;,<br>        <span class="hljs-attr">thr</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路三&lt;/div&gt;&#x27;</span>&#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码注册了三个组件，在 <a href="https://so.csdn.net/so/search?q=component&spm=1001.2101.3001.7020">component</a> 标签里有个属性 is，is&#x3D;one，所以页面会渲染名字叫 one 的组件，显示结果如下：</p><blockquote><p>我是线路一</p></blockquote><p>如果给 is 属性绑定动态值，那么就可以实现组件的动态切换，例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html 部分 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in tabs&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change = item.id&quot;</span>&gt;</span><br>    &#123;&#123; item.text &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js 部分</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">change</span>: <span class="hljs-string">&#x27;one&#x27;</span> <span class="hljs-comment">// 默认显示组件 one</span><br>    <span class="hljs-attr">tabs</span>: [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;线路一&#x27;</span>&#125;,<br>        &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;线路二&#x27;</span>&#125;,<br>        &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;thr&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;线路三&#x27;</span>&#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">components</span>: &#123;<br>  <span class="hljs-attr">one</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路一&lt;/div&gt;&#x27;</span>&#125;,<br>    <span class="hljs-attr">two</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路二&lt;/div&gt;&#x27;</span>&#125;,<br>    <span class="hljs-attr">thr</span>: &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;我是线路三&lt;/div&gt;&#x27;</span>&#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码用 v-bind 给属性 is 动态传递了值，实现了组件的动态切换，效果如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220328093816322.png" alt="image-20220328093816322"></p><h4 id="17-2、动态组件的keep-alive"><a href="#17-2、动态组件的keep-alive" class="headerlink" title="17-2、动态组件的keep-alive"></a>17-2、动态组件的keep-alive</h4><p>在面试的时候，很多面试官再问vue的时候可能就会提一嘴，你知道keep-alive有什么作用吗？</p><p>keep-alive是vue内置的一个组件，而这个组件的作用就是能够缓存不活动的组件，我们能够知道，一般情况下，组件进行切换的时候，默认会进行销毁，如果有需求，某个组件切换后不进行销毁，而是保存之前的状态，那么就可以利用keep-alive来实现</p><p>我这里利用脚手架创建项目后会生成home和about两个组件，并且通过路由进行切换</p><p><strong>home组件</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// @ is an alias to /src</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/HelloWorld.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,</span><br><span class="language-xquery">  components: &#123;</span><br><span class="language-xquery">    HelloWorld</span><br><span class="language-xquery">  &#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>我在home组件中写了一个input输入框</p><p><strong>about组件</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery"> <span class="hljs-built_in"> name</span>:<span class="hljs-string">&quot;about&quot;</span></span><br><span class="language-xquery">&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>同样的about组件也放了一个输入框</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/20190418152028623.gif" alt="img"></p><p>当我们在home组件的输入框输入一些内容的时候，然后切换到about组件，在切换回home组件，我们会发现之前输入的内容被清空了，其实也容易理解，就是当切换到about组建的时候，home组件就被销毁了，输入框的值自然被清空了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220328094157688.png" alt="image-20220328094157688"></p><p>当切换到about组件的时候home组件的destroyed就触发了，所以home组件被销毁了</p><p>那么此时我们就可以利用keep-alive组件进行包裹router-view组件，将不活动的组件缓存起来</p><p><strong>App组件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>写完之后会发现当切换到about组件时，home组件中的destroyed并没有触发,并且home组件的值也保存了下来</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/20190418152115648.gif" alt="img"></p><p>但是这样也肯定不好，我们会发现，about组件的值也被缓存了，就是所有的路由组件都被缓存了，严重浪费性能，而且也不符合需求，我们现在只想缓存home组件</p><p>在keep-alive上有两个属性</p><p>字符串或正则表达式。只有匹配的组件会被缓存。</p><ul><li>include 值为字符串或者正则表达式匹配的组件name会被缓存。</li><li>exclude 值为字符串或正则表达式匹配的组件name不会被缓存。</li></ul><p>首先利用include实现，匹配到组件中定义的name，将进行缓存</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">keep</span>-alive <span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;<br>   &lt;router-<span class="hljs-keyword">view</span> /&gt;<br>&lt;/<span class="hljs-keyword">keep</span>-alive&gt;<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/20190418152128380.gif" alt="在这里插入图片描述"></p><p>我们会发现home已经被缓存了，但是about没有被缓存</p><p>而exclude就是排除了，这个就不在演示了，很简单，除了这个我们还可以利用路由中的meta属性来控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>      path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;home&#x27;</span>,<br>      meta:&#123;<br>        keepAlive:true<br>      &#125;,<br>      component: Home<br>    &#125;<br></code></pre></td></tr></table></figure><p>将home的路由规则钟的meta添加keepAlive属性为true，也就是当前路由组件要进行缓存</p><p>keep-alive代码可以结合v-if进行包裹，如果meta中的keepAlive为true进行缓存，否侧不进行缓存，这样可以更灵活一些</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$route.meta.keepAlive&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!$route.meta.keepAlive&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这样组件的缓存是实现了，但是还是会有一些问题，就是因为组件被缓存，并没有被销毁，所以组件在切换的时候也就不会被重新创建，自然也就不会调用created等生命周期函数，所以此时要使用activated与deactivated来获取当前组件是否处于活动状态</p><p>我在home组件里面写入了activated与deactivated生命周期函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">activated()&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;哎呀看见我了&quot;</span>)<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;----------activated--------&quot;</span>)<br>  &#125;,<br>  deactivated()&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;讨厌！！你又走了&quot;</span>)<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;----------deactivated--------&quot;</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/20190418152148371.gif" alt="img"></p><p>通过上面的gif图相信已经看得很清楚了，此时keep-Alive也就差不多了</p><h1 id="三、VueX"><a href="#三、VueX" class="headerlink" title="三、VueX"></a>三、VueX</h1><p>分区作者：Cool小陈</p><h2 id="1、理解vuex"><a href="#1、理解vuex" class="headerlink" title="1、理解vuex"></a>1、理解vuex</h2><h4 id="1-1-vuex-是什么"><a href="#1-1-vuex-是什么" class="headerlink" title="1-1 vuex 是什么"></a>1-1 vuex 是什么</h4><ol><li>概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的<strong>共享</strong>状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。 </li><li>Github 地址: <a href="https://github.com/vuejs/vuex">https://github.com/vuejs/vuex</a></li></ol><h4 id="1-2、图解vuex与全局事件总线的相似性"><a href="#1-2、图解vuex与全局事件总线的相似性" class="headerlink" title="1-2、图解vuex与全局事件总线的相似性"></a>1-2、图解vuex与全局事件总线的相似性</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220313170439575.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220313170408925.png" alt="img"></p><h4 id="1-3、-什么时候使用-Vuex"><a href="#1-3、-什么时候使用-Vuex" class="headerlink" title="1-3、 什么时候使用 Vuex"></a>1-3、 什么时候使用 Vuex</h4><p><strong>多个组件需要共享数据时</strong>    {</p><ol><li><p>多个组件依赖于同一状态 </p></li><li><p>来自不同组件的行为需要变更同一状态   }</p></li></ol><h4 id="1-4、求和案例-纯vue版本"><a href="#1-4、求和案例-纯vue版本" class="headerlink" title="1-4、求和案例-纯vue版本"></a>1-4、求和案例-纯vue版本</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220314132425439.png" alt="img"></p><h4 id="1-5、vuex的工作原理"><a href="#1-5、vuex的工作原理" class="headerlink" title="1-5、vuex的工作原理"></a>1-5、vuex的工作原理</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220314185828393.png" alt="img"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220315001031575.png" alt="img"></p><p>Actions、Mutations、State状态（这三个数据类型都是对象）</p><p>这三个东西都得经过store领导</p><p>dispatch(‘jia’,2) 第一个jia是这个实现的动作，第二个是动作的值</p><h2 id="2、vuex环境搭建"><a href="#2、vuex环境搭建" class="headerlink" title="2、vuex环境搭建"></a>2、vuex环境搭建</h2><h5 id="2-1、在vue2中使用npm-i-vuex-失败原因"><a href="#2-1、在vue2中使用npm-i-vuex-失败原因" class="headerlink" title="2-1、在vue2中使用npm i vuex 失败原因"></a>2-1、在vue2中使用npm i vuex 失败原因</h5><p>在2022年2月7日，vue3成为了默认版本，也就是说现在执行npm i vue，安装的直接就是vue3了，并且vue3成为默认版本的同时vuex也同时进行了更新升级到了最新的vuex4版本，npm i vuex安装的是vuex4，只能在vue3中去使用如果我们在vue2项目中使用vuex4就会出现如图所示报错，简单来说就是<br><strong>vue2要用vuex3的版本</strong><br><strong>vue3要用vuex4的版本</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220314193925147.png" alt="img"></p><h5 id="2-2、正确安装指令"><a href="#2-2、正确安装指令" class="headerlink" title="2-2、正确安装指令"></a>2-2、正确安装指令</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> vuex<span class="hljs-keyword">@3</span><br></code></pre></td></tr></table></figure><h5 id="2-3、后续创建命令"><a href="#2-3、后续创建命令" class="headerlink" title="2-3、后续创建命令"></a>2-3、后续创建命令</h5><p>1、在src文件夹下面创建store文件夹，然后再在store文件夹下创建index.js</p><p>index.js内容如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">//该文件用于创建Vuex中最为核心的store<br>//引入vue<br>import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>//引入Vuex<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>//应用Vuex插件<br>Vue.use(Vuex)<br><br>//准备actions——用于响应组件中的动作<br><span class="hljs-keyword">const</span> actions = &#123;&#125;<br>//准备mutations——用于操作数据（<span class="hljs-keyword">state</span>）<br><span class="hljs-keyword">const</span> mutations = &#123;&#125;<br>//准备<span class="hljs-keyword">state</span>——用于存储数据<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123;&#125;<br><br>//创建并暴露store<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>actions,<br>mutations,<br><span class="hljs-keyword">state</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>2、然后在main.js中引入store，并在创建vm实例的句子中添加store、</p><p>简约代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">......<br><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br>......<br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>store<br>&#125;)<br></code></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入App</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//引入插件</span><br><span class="hljs-keyword">import</span> vueResource <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-resource&#x27;</span><br><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-comment">//关闭Vue的生产提示</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><span class="hljs-comment">//使用插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(vueResource)<br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>store,<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-4、求和案例vuex版"><a href="#2-4、求和案例vuex版" class="headerlink" title="2-4、求和案例vuex版"></a>2-4、求和案例vuex版</h4><p>context（ministore，上下文）</p><p>如果没有涉及到action（业务逻辑）可以直接调用commit并且调用的符号必须大写</p><h2 id="3、VueX基本使用"><a href="#3、VueX基本使用" class="headerlink" title="3、VueX基本使用"></a>3、VueX基本使用</h2><h4 id="3-1、vuex开发工具"><a href="#3-1、vuex开发工具" class="headerlink" title="3-1、vuex开发工具"></a>3-1、vuex开发工具</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220326145047818.png" alt="image-20220326145047818"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220326152745838.png" alt="image-20220326152745838"></p><h4 id="3-2、vuex基本使用"><a href="#3-2、vuex基本使用" class="headerlink" title="3-2、vuex基本使用"></a>3-2、vuex基本使用</h4><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">//引用Vuex</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-comment">//响应组件中加的动作</span><br><span class="hljs-title function_">jia</span>(<span class="hljs-params">context,value</span>)&#123;<br><span class="hljs-comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span><br>context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;JIA&#x27;</span>,value)<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>    <span class="hljs-comment">//执行加</span><br><span class="hljs-title function_">JIA</span>(<span class="hljs-params">state,value</span>)&#123;<br><span class="hljs-comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span><br>state.<span class="hljs-property">sum</span> += value<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//初始化数据</span><br><span class="hljs-keyword">const</span> state = &#123;<br>   <span class="hljs-attr">sum</span>:<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>actions,<br>mutations,<br>state,<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h2 id="4、getters的使用"><a href="#4、getters的使用" class="headerlink" title="4、getters的使用"></a>4、getters的使用</h2><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">......<br><br><span class="hljs-keyword">const</span> getters = &#123;<br><span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br><span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>......<br>getters<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h2 id="5、四个map方法的使用"><a href="#5、四个map方法的使用" class="headerlink" title="5、四个map方法的使用"></a>5、四个map方法的使用</h2><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span><br>     ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-attr">subject</span>:<span class="hljs-string">&#x27;subject&#x27;</span>&#125;),<br>         <br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>(&#123;<span class="hljs-attr">bigSum</span>:<span class="hljs-string">&#x27;bigSum&#x27;</span>&#125;),<br><br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br><br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-string">&#x27;jiaWait&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：increment、decrement（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>    <br>    <span class="hljs-comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-string">&#x27;JIAN&#x27;</span>]),<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h2 id="6、模块化-命名空间"><a href="#6、模块化-命名空间" class="headerlink" title="6、模块化+命名空间"></a>6、模块化+命名空间</h2><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>&#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> personAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123; ... &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    countAbout,<br>    personAbout<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">personAbout</span>.<span class="hljs-property">list</span><br><span class="hljs-comment">//方式二：借助mapState读取：</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br><span class="hljs-comment">//方式二：借助mapGetters读取：</span><br>...<span class="hljs-title function_">mapGetters</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接dispatch</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapActions：</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接commit</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapMutations：</span><br>...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br></code></pre></td></tr></table></figure></li></ol><h2 id="7、耦合性"><a href="#7、耦合性" class="headerlink" title="7、耦合性"></a>7、耦合性</h2><p>耦合性，指的是组件间依赖关系的强弱程度</p><p>这里两个组件组件直接耦合性从“内容耦合”(一个模块直接使用另一个模块数据)</p><p>“控制耦合”(一个模块调用另一模块时，传递的是控制信号，被调用的模块根据控制信号的值，有选择的执行功能)，所以，解耦成立</p><h1 id="四、vue-router"><a href="#四、vue-router" class="headerlink" title="四、vue-router"></a>四、vue-router</h1><p>分区作者：Cool小陈</p><h2 id="1、路由"><a href="#1、路由" class="headerlink" title="1、路由"></a>1、路由</h2><h4 id="1-1、路由的理解"><a href="#1-1、路由的理解" class="headerlink" title="1-1、路由的理解"></a>1-1、路由的理解</h4><h5 id="1-1-1、vue-router的理解"><a href="#1-1-1、vue-router的理解" class="headerlink" title="1-1.1、vue-router的理解"></a>1-1.1、vue-router的理解</h5><p>​vue 的一个插件库，专门用来实现 SPA 应用</p><h5 id="1-1-2、生活中的路由器与编码中的路由"><a href="#1-1-2、生活中的路由器与编码中的路由" class="headerlink" title="1-1.2、生活中的路由器与编码中的路由"></a>1-1.2、生活中的路由器与编码中的路由</h5><ol><li><p>生活中的路由器是为了实现多台设备同时上网</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220330005147319.png" alt="image-20220330005147319"></p></li><li><p>编码里的路由器是为了实现SPA(single page web application)应用的切换</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220330005113667.png" alt="image-20220330005113667"></p></li></ol><h5 id="1-1-3、对SPA应用的理解"><a href="#1-1-3、对SPA应用的理解" class="headerlink" title="1-1.3、对SPA应用的理解"></a>1-1.3、对SPA应用的理解</h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220330005305857.png" alt="image-20220330005305857"></p><ol><li><p>单页 Web 应用（single page web application，SPA）。 </p></li><li><p>整个应用只有<strong>一个完整的页面</strong>。 </p></li><li><p>点击页面中的导航链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong> </p></li><li><p>数据需要通过 ajax 请求获取。</p></li></ol><h4 id="1-2、路由的理解"><a href="#1-2、路由的理解" class="headerlink" title="1-2、路由的理解"></a>1-2、路由的理解</h4><h5 id="1-2-1、什么是路由"><a href="#1-2-1、什么是路由" class="headerlink" title="1-2.1、什么是路由?"></a>1-2.1、什么是路由?</h5><ol><li><p>一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</p></li><li><p>key 为路径, value 可能是 function 或 component</p></li></ol><h5 id="1-2-2、路由分类"><a href="#1-2-2、路由分类" class="headerlink" title="1-2.2、路由分类"></a>1-2.2、路由分类</h5><p>​1、后端路由： </p><p>​1）理解：value 是 function, 用于处理客户端提交的请求。 </p><p>​2）工作过程：服务器接收到一个请求时, 根据<strong>请求路径</strong>找到匹配的<strong>函数</strong> 来处理请求, 返回响应数据。 </p><p>​2、前端路由： </p><p>​1）理解：value 是 component，用于展示页面内容。 </p><p>​2）工作过程：当浏览器的路径改变时, 对应的组件就会显示。</p><h4 id="1-3、基本使用"><a href="#1-3、基本使用" class="headerlink" title="1-3、基本使用"></a>1-3、基本使用</h4><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code> </p><p>2022年2月7日以后，vue-router的默认版本为4版本，并且vue-router4只能在vue3中去使用</p><p>vue-router3才能在vue2中，所有我们要指定版本去安装：<code>npm i vue-router@3</code></p></li><li><p>引入VueRouter：<code>import VueRouter from &#39;vue-router&#39;</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入VueRouter</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">//引入Luyou 组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><br><span class="hljs-comment">//创建router实例对象，去管理一组一组的路由规则</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;<br>]<br>&#125;)<br><br><span class="hljs-comment">//暴露router</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-view&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h2><p>​1、路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p><p>​2、通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p><p>​3、每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>​4、整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</p><h2 id="3-嵌套路由（多级路由）"><a href="#3-嵌套路由（多级路由）" class="headerlink" title="3.嵌套路由（多级路由）"></a>3.嵌套路由（多级路由）</h2><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span>,<br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">children</span>:[ <span class="hljs-comment">//通过children配置子级路由</span><br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>, <span class="hljs-comment">//此处一定不要写：/news</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-comment">//此处一定不要写：/message</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span><br>&#125;<br>]<br>&#125;<br>]<br></code></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h2><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;<br>&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>path:&#x27;/home/message/detail&#x27;,<br>query:&#123;<br>   id:666,<br>            title:&#x27;你好&#x27;<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h2><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/demo&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Demo</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;test&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Test</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br>                      <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">//给路由命名</span><br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;welcome&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Hello</span>,<br>&#125;<br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--简化前，需要写完整的路径 --&gt;<br>&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化后，直接通过名字跳转 --&gt;<br>&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化写法配合传递参数 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>name:&#x27;hello&#x27;,<br>query:&#123;<br>   id:666,<br>            title:&#x27;你好&#x27;<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h2><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符声明接收params参数</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span><br>&#125;<br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;<br>&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>name:&#x27;xiangqing&#x27;,<br>params:&#123;<br>   id:666,<br>            title:&#x27;你好&#x27;<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">params</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h2><p>​作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><br><span class="hljs-comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span><br><span class="hljs-comment">// props:&#123;a:900&#125;</span><br><br><span class="hljs-comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span><br><span class="hljs-comment">// props:true</span><br><br><span class="hljs-comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span><br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">id</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br><span class="hljs-attr">title</span>:route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br>      &#125;<br>    <span class="hljs-comment">//简单写法，结构赋值</span><br>    <span class="hljs-comment">//props(&#123;query&#125;)&#123;</span><br><span class="hljs-comment">//return &#123;</span><br><span class="hljs-comment">//id:query.id,</span><br><span class="hljs-comment">//title:query.title</span><br>    <span class="hljs-comment">//&#125;</span><br>    <br>    <span class="hljs-comment">//简单写法，结构赋值的连续写法</span><br>    <span class="hljs-comment">//props(&#123;query:&#123;id,title&#125;&#125;)&#123;</span><br><span class="hljs-comment">//return &#123;</span><br><span class="hljs-comment">//id,</span><br><span class="hljs-comment">//title</span><br><span class="hljs-comment">//&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h2><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h2 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h2><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//$router的两个API</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br><span class="hljs-attr">id</span>:xxx,<br><span class="hljs-attr">title</span>:xxx<br>&#125;<br>&#125;)<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br><span class="hljs-attr">id</span>:xxx,<br><span class="hljs-attr">title</span>:xxx<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">forward</span>() <span class="hljs-comment">//前进</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">back</span>() <span class="hljs-comment">//后退</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(n) <span class="hljs-comment">//可前进也可后退，里面要加参数正数前进，负数后退</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h2><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive include=&quot;News&quot;&gt; <br>    &lt;router-view&gt;&lt;/router-view&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h2><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h2 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h2><h4 id="12-1、作用：对路由进行权限控制"><a href="#12-1、作用：对路由进行权限控制" class="headerlink" title="12-1、作用：对路由进行权限控制"></a>12-1、作用：对路由进行权限控制</h4><h4 id="12-2、分类：全局守卫、独享守卫、组件内守卫"><a href="#12-2、分类：全局守卫、独享守卫、组件内守卫" class="headerlink" title="12-2、分类：全局守卫、独享守卫、组件内守卫"></a>12-2、分类：全局守卫、独享守卫、组件内守卫</h4><h5 id="12-2-1、全局守卫"><a href="#12-2-1、全局守卫" class="headerlink" title="12-2-1、全局守卫:"></a>12-2-1、全局守卫:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeEach，全局前置守卫&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;at1&#x27;</span>)&#123; <span class="hljs-comment">//权限控制的具体规则</span><br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;暂无权限查看&#x27;</span>)<br><span class="hljs-comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br><span class="hljs-comment">//全局后置守卫没有next</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;afterEach&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>)&#123; <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> <span class="hljs-comment">//修改网页的title</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;vue_test&#x27;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="12-2-2、独享守卫"><a href="#12-2-2、独享守卫" class="headerlink" title="12-2-2、独享守卫:"></a>12-2-2、独享守卫:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeEnter&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;at1&#x27;</span>)&#123;<br><span class="hljs-title function_">next</span>()<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;暂无权限查看&#x27;</span>)<br><span class="hljs-comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">next</span>()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="12-2-3、组件内守卫："><a href="#12-2-3、组件内守卫：" class="headerlink" title="12-2-3、组件内守卫："></a>12-2-3、组件内守卫：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//进入守卫：通过路由规则，进入该组件时被调用</span><br>beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>&#125;,<br><span class="hljs-comment">//离开守卫：通过路由规则，离开该组件时被调用</span><br>beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h2><h4 id="13-1、hash值"><a href="#13-1、hash值" class="headerlink" title="13-1、hash值"></a>13-1、hash值</h4><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p><ol><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li></ol><h4 id="13-2、服务器部署"><a href="#13-2、服务器部署" class="headerlink" title="13-2、服务器部署"></a>13-2、服务器部署</h4><p>生产模式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><p>部署服务器</p><p>node express步骤</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220412003449691.png" alt="image-20220412003449691"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>输入包名字<br>atguigu_test_server<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220412003712223.png" alt="image-20220412003712223"></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i express<br></code></pre></td></tr></table></figure><p>新建server.js</p><p>在server.js中输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-comment">//后面创建了static后解开</span><br><span class="hljs-comment">//app.use(express.static(__dirname+&#x27;/static&#x27;))</span><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/person&#x27;</span>,(req,res))=&gt;&#123;<br>res.<span class="hljs-property">send</span>&#123;(<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,<br><span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>)&#125;<br>&#125;<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">5005</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(!err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器启动成功了！&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>编辑好代码后输入在终端中输入node server启动服务器</p><p>在node下创建静态页面</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220412004707196.png" alt="image-20220412004707196"></p><h4 id="13-3、解决在history模式中404的问题"><a href="#13-3、解决在history模式中404的问题" class="headerlink" title="13-3、解决在history模式中404的问题"></a>13-3、解决在history模式中404的问题</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm i connect-history-api-fallback<br></code></pre></td></tr></table></figure><p>引入</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220412005439149.png" alt="image-20220412005439149"></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">history</span> =<span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;npm i connect-history-api-fallback&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>然后使用插件</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">app.use</span>(<span class="hljs-function"><span class="hljs-title">history</span>())</span><br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/image-20220412005606584.png" alt="image-20220412005606584"></p><h3 id="13-5、路由器工作的两种模式"><a href="#13-5、路由器工作的两种模式" class="headerlink" title="13-5、路由器工作的两种模式"></a>13-5、路由器工作的两种模式</h3><ol><li><p>hash模式：</p><ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li><p>history模式：</p><ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol><h1 id="五、Element-UI-组件库"><a href="#五、Element-UI-组件库" class="headerlink" title="五、Element UI 组件库"></a>五、Element UI 组件库</h1><p>分区作者：Cool小陈</p><h2 id="1、Vue-UI组件库"><a href="#1、Vue-UI组件库" class="headerlink" title="1、Vue UI组件库"></a>1、Vue UI组件库</h2><h3 id="1-1、移动端常用-UI-组件库"><a href="#1-1、移动端常用-UI-组件库" class="headerlink" title="1-1、移动端常用 UI 组件库"></a>1-1、移动端常用 UI 组件库</h3><ol><li><p>Vant <a href="https://youzan.github.io/vant">https://youzan.github.io/vant</a> </p></li><li><p>Cube UI <a href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a> </p></li><li><p>Mint UI <a href="http://mint-ui.github.io/">http://mint-ui.github.io</a></p></li></ol><h3 id="1-2、PC-端常用-UI-组件库"><a href="#1-2、PC-端常用-UI-组件库" class="headerlink" title="1-2、PC 端常用 UI 组件库"></a>1-2、PC 端常用 UI 组件库</h3><ol><li><p>Element UI <a href="https://element.eleme.cn/">https://element.eleme.cn</a> </p></li><li><p>IView UI <a href="https://www.iviewui.com/">https://www.iviewui.com</a></p></li></ol><h2 id="2、Element-UI-安装"><a href="#2、Element-UI-安装" class="headerlink" title="2、Element UI 安装"></a>2、Element UI 安装</h2><h3 id="2-1、npm-安装"><a href="#2-1、npm-安装" class="headerlink" title="2-1、npm 安装"></a>2-1、npm 安装</h3><p>推荐使用 npm 的方式安装，它能更好地和 <a href="https://webpack.js.org/">webpack</a> 打包工具配合使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i element-ui -S<br></code></pre></td></tr></table></figure><h3 id="2-2、CDN"><a href="#2-2、CDN" class="headerlink" title="2-2、CDN"></a>2-2、CDN</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引入样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入组件库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3、Element-UI引入方式"><a href="#2-3、Element-UI引入方式" class="headerlink" title="2-3、Element-UI引入方式"></a>2-3、Element-UI引入方式</h3><h4 id="2-3-1、完整引入"><a href="#2-3-1、完整引入" class="headerlink" title="2-3-1、完整引入"></a>2-3-1、完整引入</h4><p>在 main.js 中写入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入Vue</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入App</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">//引入ElementUI组件库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-comment">//引入ElementUI全部样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><span class="hljs-comment">//应用ElementUI</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-3-2、按需引入"><a href="#2-3-2、按需引入" class="headerlink" title="2-3-2、按需引入"></a>2-3-2、按需引入</h4><p>借助 [babel.config.js，我们可以只引入需要的组件，以达到减小项目体积的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>,<br>[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> &#125;],<br>  ],<br><span class="hljs-attr">plugins</span>:[<br>    [<br>      <span class="hljs-string">&quot;component&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>      &#125;<br>    ]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-comment">//按需引入</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Select</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><br><span class="hljs-comment">//应用ElementUI</span><br><span class="hljs-comment">//格式：Vue.component(Button.name, Button);</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(el-button, <span class="hljs-title class_">Button</span>);<br><span class="hljs-comment">//格式：Vue.component(Select.name, Select);</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(el-select, <span class="hljs-title class_">Select</span>);<br><span class="hljs-comment">/* 或写为</span><br><span class="hljs-comment"> * Vue.use(Button)</span><br><span class="hljs-comment"> * Vue.use(Select)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-4、使用时，借助界面使用即可"><a href="#2-4、使用时，借助界面使用即可" class="headerlink" title="2-4、使用时，借助界面使用即可"></a>2-4、使用时，借助界面使用即可</h3><h1 id="六、附加知识"><a href="#六、附加知识" class="headerlink" title="六、附加知识"></a>六、附加知识</h1><h3 id="1、js事件冒泡与事件委派"><a href="#1、js事件冒泡与事件委派" class="headerlink" title="1、js事件冒泡与事件委派"></a>1、js事件冒泡与事件委派</h3><h4 id="一、事件冒泡"><a href="#一、事件冒泡" class="headerlink" title="一、事件冒泡"></a>一、事件冒泡</h4><ul><li>指的是事件的向上传导,当后代元素上的事件被触发时,其<strong>祖先元素的相同事件</strong>也会被触发</li><li>如果不希望发生事件冒泡可以通过事件对象属性来取消冒泡</li></ul><p><strong>举例：</strong><br>其中body是爷爷，绿色div(我是box1)是爸爸，黄色span(我是span)是儿子，给这三代都绑上单击响应函数<br>实现代码</p><p>body代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span></span><br><span class="language-xml">我是box1</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>CSS代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br>#box1&#123;<br><span class="hljs-attr">width</span>: 200px;<br><span class="hljs-attr">height</span>: 200px;<br>background-<span class="hljs-attr">color</span>: yellowgreen;<br>&#125;<br><br>#s1&#123;<br>background-<span class="hljs-attr">color</span>: yellow;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>JS代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//为s1绑定一个单击响应函数</span><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;s1&quot;</span>);<br>s1.<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是span单击响应函数&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//为box1绑定一个单击响应函数</span><br><span class="hljs-keyword">var</span> box1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box1&quot;</span>);<br>box1.<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是box1单击响应函数&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//body绑定一个单击响应函数</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是body单击响应函数&quot;</span>)<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>触发效果如下：<br>当点击儿子(span)时，他，他爸爸(div)及他爷爷(body)都会触发各自的响应函数，它爸爸同理</p><p>实现终止冒泡</p><ul><li>通过事件对象cancelBubble属性来取消冒泡</li><li>event.cancelBubble &#x3D; true;</li><li>如终止儿子(span)冒泡，即它爸爸及它爷爷都不触发单击事件</li></ul><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">s1.<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br><span class="hljs-comment">//解决浏览器兼容问题</span><br>event=event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是span单击响应函数&quot;</span>);<br><span class="hljs-comment">//取消冒泡</span><br>event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二、事件委派-委托"><a href="#二、事件委派-委托" class="headerlink" title="二、事件委派(委托)"></a>二、事件委派(委托)</h4><p><strong>是什么</strong></p><ul><li>指将事件统一绑定给元素的共同的祖先元素</li><li>当后代上的事件触发时,会一直冒泡到祖先元素</li><li>通过祖先元素的响应函数来处理事件</li></ul><p><strong>下面举例子说明</strong><br>效果图：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/202203071103742.png" alt="img"><br>实现动态添加超链接并绑定事件</p><p>实现代码<br>body代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn01&quot;</span>&gt;</span>添加超链接<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: yellow;&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>超链接一<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>超链接二<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>超链接三<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>JS代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br><span class="hljs-keyword">var</span> u1= <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;u1&quot;</span>);<br><span class="hljs-comment">//点击按钮以后添加超链接</span><br><span class="hljs-keyword">var</span> btn01 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn01&quot;</span>);<br>btn01.<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br><span class="hljs-comment">//创建一个li</span><br><span class="hljs-keyword">var</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);<br>li.<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&quot;&lt;a href=&#x27;javascript:;&#x27; class=&#x27;link&#x27;&gt;新建超链接&lt;/a&gt;&quot;</span>;<br><br><span class="hljs-comment">//将li添加到ul中</span><br>u1.<span class="hljs-title function_">appendChild</span>(li);<br>&#125;<br><br>u1.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br><span class="hljs-comment">//解决浏览器兼容问题</span><br>event = event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * target</span><br><span class="hljs-comment"> *  -事件对象的target属性表示触发事件的对象</span><br><span class="hljs-comment"> *  -ul中包括li、文本及超链接，只有点击超链接触发事件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">className</span> == <span class="hljs-string">&quot;link&quot;</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是ul单击响应函数&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>事件冒泡是事件委托及事件传播的基础，得好好理解</p><h1 id="七、vue3"><a href="#七、vue3" class="headerlink" title="七、vue3"></a>七、vue3</h1><h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/575/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" alt="img"></p><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="/../../bundler.37740380.png" alt="bundler.37740380"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行</span><br>npm run dev<br></code></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//特殊情况</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> x1 = sum.<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> x2 = person.<span class="hljs-property">age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect配置的回调执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;<br>&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123;ref,customRef&#125; from &#x27;vue&#x27;<br>export default &#123;<br>name:&#x27;Demo&#x27;,<br>setup()&#123;<br>// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref<br>//自定义一个myRef<br>function myRef(value,delay)&#123;<br>let timer<br>//通过customRef去实现自定义<br>return customRef((track,trigger)=&gt;&#123;<br>return&#123;<br>get()&#123;<br>track() //告诉Vue这个value值是需要被“追踪”的<br>return value<br>&#125;,<br>set(newValue)&#123;<br>clearTimeout(timer)<br>timer = setTimeout(()=&gt;&#123;<br>value = newValue<br>trigger() //告诉Vue去更新界面<br>&#125;,delay)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br>let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref<br>return &#123;<br>keyword<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>......<br>    <span class="hljs-keyword">let</span> car = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奔驰&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>......<br>    <span class="hljs-keyword">const</span> car = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;teleport to=&quot;移动位置&quot;&gt;<br>&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>&lt;div class=&quot;dialog&quot;&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;<br>  v-on:click=&quot;handleNativeClickEvent&quot;<br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/09/04/Java/"/>
    <url>/2022/09/04/Java/</url>
    
    <content type="html"><![CDATA[<h1 id="💠Java基础"><a href="#💠Java基础" class="headerlink" title="💠Java基础"></a>💠Java基础</h1><h2 id="📓java语言特点"><a href="#📓java语言特点" class="headerlink" title="📓java语言特点"></a>📓java语言特点</h2><ul><li>Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。</li><li>具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。</li><li>Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。</li><li>Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。</li><li>Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。</li></ul><h2 id="📓JDK-与-JRE-有什么区别？"><a href="#📓JDK-与-JRE-有什么区别？" class="headerlink" title="📓JDK 与 JRE 有什么区别？"></a>📓JDK 与 JRE 有什么区别？</h2><ul><li>JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。</li><li>JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。</li><li>JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK。</li></ul><h2 id="📓标识符"><a href="#📓标识符" class="headerlink" title="📓标识符"></a>📓标识符</h2><ul><li><strong>标识符的含义</strong>：在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li><li><strong>命名规则</strong>：（<strong>硬性要求</strong>） 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头 标 识符不是关键字</li><li><strong>命名规范</strong>：（<strong>非硬性要求</strong>） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量 名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。</li></ul><h2 id="📓关键字"><a href="#📓关键字" class="headerlink" title="📓关键字"></a>📓关键字</h2><table><thead><tr><th align="left"></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td align="left"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td align="left">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td align="left"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td align="left">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td align="left">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td align="left"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="📓数据类型"><a href="#📓数据类型" class="headerlink" title="📓数据类型"></a>📓数据类型</h2><blockquote><ul><li>Java中，如果对整数不指定类型，默认时int类型，对小数不指定类型，默认是double类型。</li><li>基本类型由小到大，可以自动转换，但是由大到小，则需要强制类型转换。</li></ul></blockquote><h3 id="📙基础数据类型"><a href="#📙基础数据类型" class="headerlink" title="📙基础数据类型"></a>📙基础数据类型</h3><table><thead><tr><th align="left">基本类型</th><th align="left">位数</th><th align="left">字节</th><th align="left">默认值</th><th>取值范围</th><th>封装类</th></tr></thead><tbody><tr><td align="left"><code>byte</code></td><td align="left">8</td><td align="left">1</td><td align="left">0</td><td>-128 ~ 127</td><td>Byte</td></tr><tr><td align="left"><code>short</code></td><td align="left">16</td><td align="left">2</td><td align="left">0</td><td>-32768 ~ 32767</td><td>Short</td></tr><tr><td align="left"><code>int</code></td><td align="left">32</td><td align="left">4</td><td align="left">0</td><td>-2147483648 ~ 2147483647</td><td>Integer</td></tr><tr><td align="left"><code>long</code></td><td align="left">64</td><td align="left">8</td><td align="left">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>Long</td></tr><tr><td align="left"><code>char</code></td><td align="left">16</td><td align="left">2</td><td align="left">‘\u0000’</td><td>0 ~ 65535</td><td>Float</td></tr><tr><td align="left"><code>float</code></td><td align="left">32</td><td align="left">4</td><td align="left">0f</td><td>1.4E-45 ~ 3.4028235E38</td><td>Double</td></tr><tr><td align="left"><code>double</code></td><td align="left">64</td><td align="left">8</td><td align="left">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td><td>Boolean</td></tr><tr><td align="left"><code>boolean</code></td><td align="left">1</td><td align="left"></td><td align="left">false</td><td>true、false</td><td>Character</td></tr></tbody></table><h3 id="📙基础类型的后缀："><a href="#📙基础类型的后缀：" class="headerlink" title="📙基础类型的后缀："></a>📙<strong>基础类型的后缀：</strong></h3><p>long ： l 或 L<br>float： f 或 F；<br>double： d 或 D</p><h3 id="📙隐式转换"><a href="#📙隐式转换" class="headerlink" title="📙隐式转换"></a>📙隐式转换</h3><h4 id="📚复合运算符的隐式转换"><a href="#📚复合运算符的隐式转换" class="headerlink" title="📚复合运算符的隐式转换"></a>📚复合运算符的隐式转换</h4><ul><li>复合运算符（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）是可以将右边表达式的类型自动强制转换成左边的类型</li></ul><h4 id="📚整形字面常量隐式转换的限制"><a href="#📚整形字面常量隐式转换的限制" class="headerlink" title="📚整形字面常量隐式转换的限制"></a>📚整形字面常量隐式转换的限制</h4><ul><li><p>整形字面常量的大小超出目标类型所能表示的范围时，要手动强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<span class="hljs-comment">//编译错误，128超出byte类型所能表示的范围</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)<span class="hljs-number">128</span>;<span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure></li><li><p>对于传参数时，必须要显式地进行强制类型转换，明确转换的类型(编译器之所以这样要求，其实为了避免 方法重载出现的隐式转换 与 小类型自动转大类型 发生冲突)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    shortMethod(<span class="hljs-number">8</span>);<span class="hljs-comment">//编译错误</span><br>    shortMethod((<span class="hljs-type">short</span>)<span class="hljs-number">8</span>); <span class="hljs-comment">//编译通过</span><br>    longMethod(<span class="hljs-number">8</span>);<span class="hljs-comment">//编译通过，因为这是小类型变成大类型，是不需要强制类型转换的</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shortMethod</span><span class="hljs-params">(<span class="hljs-type">short</span> c)</span>&#123;<br>    System.out.println(c);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longMethod</span><span class="hljs-params">(<span class="hljs-type">short</span> l)</span>&#123;<br>    System.out.println(l);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="📚特殊的char类型"><a href="#📚特殊的char类型" class="headerlink" title="📚特殊的char类型"></a>📚特殊的char类型</h4><blockquote><p>char类型是一个无符号类型，所以char类型与其他基本类型不是子集与父集间的关系（其他类型都是有符号的类型）。也就是说，char类型与byte、short之间的转换都需要显式的强制类型转换（小类型自动转换成大类型失败）。</p></blockquote><ul><li>char类型与byte、short的相互转换，都需要显式地强类型制转换。</li><li>对于数值是负数的，都需要进行显式地强制类型转换，特别是在整形字面常量的隐式转换中。</li><li>char类型转换成int、long类型是符合 小类型转大类型的规则，即无需要强制类型转换。</li></ul><h4 id="📚java的运算结果的类型有两个性质："><a href="#📚java的运算结果的类型有两个性质：" class="headerlink" title="📚java的运算结果的类型有两个性质："></a>📚java的运算结果的类型有两个性质：</h4><ul><li>运算结果的类型必须是int类型或int类型以上。</li><li>最高类型低于int类型的，运算结果都为int类型。否则，运算结果与表达式中最高类型一致。</li></ul><h3 id="📙包装类型"><a href="#📙包装类型" class="headerlink" title="📙包装类型"></a>📙包装类型</h3><blockquote><p>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。</p></blockquote><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><p>所谓包装类，就是能够直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类。</p><p>以下用途:</p><ol><li>作为基本数据类型对应的类类型，提供了一系列实用的对象操作，如类型转换，进制转换等</li><li>集合不允许存放基本数据类型，故常用包装类</li><li>包含了每种基本类型的相关属性，如最大值，最小值，所占位数等</li></ol><blockquote><p>包装类都为final 不可继承<br>包装类型都继承了Number抽象类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱 调用了 Integer.valueOf(2)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;         <span class="hljs-comment">// 拆箱 调用了 X.intValue()</span><br></code></pre></td></tr></table></figure><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><blockquote><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</p></blockquote><h3 id="📙自动拆装箱"><a href="#📙自动拆装箱" class="headerlink" title="📙自动拆装箱"></a>📙自动拆装箱</h3><blockquote><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的 valueOf(int) 方法<br>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的 intValue方法</p></blockquote><ol><li>基本型和基本型封装型进行“&#x3D;&#x3D;”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较</li><li>两个Integer类型进行“&#x3D;&#x3D;”比较，如果其值在-128至127，那么返回true，否则返回false,</li><li>两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li><li>基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行比较。</li></ol><h3 id="📙缓存池"><a href="#📙缓存池" class="headerlink" title="📙缓存池"></a>📙缓存池</h3><p>包装类型内存使用 private static class IntegerCache，声明一个内部使用的缓存池</p><blockquote><p>如Integer中有个静态内部类IntegerCache，里面有个cache[],也就是Integer常量池，常量池的大小为一个字节（-128~127）<br>为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。</p></blockquote><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小。</p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values: true and false</li><li>all byte values</li><li>short values: between -128 and 127</li><li>int values: between -128 and 127</li><li>char: in the range \u0000 to \u007F</li></ul><h2 id="📓BigDecimal"><a href="#📓BigDecimal" class="headerlink" title="📓BigDecimal"></a>📓BigDecimal</h2><p>BigDecimal 主要用于处理解决精度丢失问题</p><blockquote><p>float和double类型主要是为了科学计算和工程计算而设计的。执行二进制浮点运算，这是为了在广泛的数字范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0f</span> - <span class="hljs-number">0.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.9f</span> - <span class="hljs-number">0.8f</span>;<br>System.out.println(a);<span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);<span class="hljs-comment">// 0.099999964</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="📓字符串"><a href="#📓字符串" class="headerlink" title="📓字符串"></a>📓字符串</h2><h3 id="📙String"><a href="#📙String" class="headerlink" title="📙String"></a>📙String</h3><p>String 被声明为 final，因此它不可被继承</p><ul><li>Java 8 中，String 内部使用 char 数组存储数据。</li><li>Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</li></ul><p>📄<strong>String不可变原因：</strong></p><ol><li><p>保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供&#x2F;暴露修改这个字符 串的⽅法。</p></li><li><p>String 类被 final 修饰导致其不能被继承，进⽽避免了⼦类破坏 String 不可变</p></li></ol><blockquote><p>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</p></blockquote><p>📄<strong>不可变的好处</strong></p><ol><li>可以缓存 hash 值</li><li>String Pool 的需要。如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li><li>安全性。String 经常作为参数，String 不可变性可以保证参数不可变。如网络传输</li><li>线程安全</li></ol><p>📄<strong>关于String使用new创建的问题：</strong></p><blockquote><ul><li><p>String str1 &#x3D; “aaa”; 是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)，</p></li><li><p>String str2 &#x3D; new String(“aaa”) ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 “aaa” 字符串对象）。</p></li></ul></blockquote><h4 id="📚String类型常量池"><a href="#📚String类型常量池" class="headerlink" title="📚String类型常量池"></a>📚<strong>String</strong>类型常量池</h4><p>String类型的常量池比较<strong>特殊</strong>。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><h3 id="📙StringBuffer"><a href="#📙StringBuffer" class="headerlink" title="📙StringBuffer"></a>📙StringBuffer</h3><p><code>StringBuffer</code>是可变类，对应的字符串的改变不会产生新的对象。</p><p><code>StringBuffer</code>的读写方法都使用了synchronized修饰，同一时间只有一个线程进行操作，所以是线程安全的</p><h3 id="📙StringBuilder"><a href="#📙StringBuilder" class="headerlink" title="📙StringBuilder"></a>📙StringBuilder</h3><p><code>StringBuilder</code>是可变类，对应的字符串的改变不会产生新的对象（线程不安全）。</p><h3 id="📙三者比较"><a href="#📙三者比较" class="headerlink" title="📙三者比较"></a>📙三者比较</h3><p>String、<code>StringBuilder</code>、<code>StringBuffer</code>三者的执行效率：<br><code>StringBuilder </code>&gt; <code>StringBuffer</code> &gt; String。这个实验结果是相对而言的，不一定在所有情况下都是这样。</p><blockquote><p>比如String str &#x3D; “hello”+ “world”的效率就比 <code>StringBuilder st = new StringBuilder().append(&quot;hello&quot;).append(&quot;world&quot;)</code>要高。</p></blockquote><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ol><h2 id="📓数组"><a href="#📓数组" class="headerlink" title="📓数组"></a>📓数组</h2><p><strong>数组初始化的两种方式：</strong></p><ul><li><p><strong>静态初始化</strong>（声明并初始化，此时不能指定容量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>动态初始化</strong>（先声明再初始化，此时必须指定容量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓变量存储位置"><a href="#📓变量存储位置" class="headerlink" title="📓变量存储位置"></a>📓变量存储位置</h2><ul><li><p>常量池：未经 new 的常量</p></li><li><p>堆区：成员变量的引用，new 出来的变量</p></li><li><p>栈区：局部变量的引用</p></li><li><p>成员变量的引用在堆区，是因为成员变量的所属对象在堆区，所以它也在堆区</p></li><li><p>局部变量的引用在栈区，是因为局部变量不属于某一个对象，在被调用时才被加载，所以在栈区。</p></li></ul><h2 id="📓Java程序初始化顺序"><a href="#📓Java程序初始化顺序" class="headerlink" title="📓Java程序初始化顺序"></a>📓Java程序初始化顺序</h2><p>在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。</p><p><strong>初始化一般遵循3个原则：</strong></p><ul><li>静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；</li><li>父类优先于子类进行初始化；</li><li>按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；</li></ul><p>🔸<strong>加载顺序</strong></p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="📓continue、break-和-return-的区别"><a href="#📓continue、break-和-return-的区别" class="headerlink" title="📓continue、break 和 return 的区别"></a>📓continue、break 和 return 的区别</h2><ol><li><p><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</p></li><li><p><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</p></li><li><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ul><li><p><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</p></li><li><p><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</p></li></ul></li></ol><h2 id="📓instanceof-关键字的作用"><a href="#📓instanceof-关键字的作用" class="headerlink" title="📓instanceof 关键字的作用"></a>📓instanceof 关键字的作用</h2><p>instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。</p><p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><h2 id="📓final、finally和finalize的区别"><a href="#📓final、finally和finalize的区别" class="headerlink" title="📓final、finally和finalize的区别"></a>📓final、finally和finalize的区别</h2><h3 id="📙final-关键字"><a href="#📙final-关键字" class="headerlink" title="📙final 关键字"></a>📙final 关键字</h3><h4 id="📚final-类"><a href="#📚final-类" class="headerlink" title="📚final 类"></a>📚<strong>final 类</strong></h4><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><h4 id="📚final-方法"><a href="#📚final-方法" class="headerlink" title="📚final 方法"></a><strong>📚final 方法</strong></h4><p>类中的 final 方法可以被子类继承，但是不能被子类修改，声明 final 方法的主要目的是防止该方法的内容被修改。</p><h4 id="📚final-变量"><a href="#📚final-变量" class="headerlink" title="📚final 变量"></a>📚final 变量</h4><blockquote><p>final变量能被显式地初始化并且只能初始化一次。</p></blockquote><ul><li><strong>修饰引用类型</strong>：被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</li><li><strong>修饰基础数据类型</strong>：final 使数值不变；</li></ul><h3 id="📙finally-关键字"><a href="#📙finally-关键字" class="headerlink" title="📙finally 关键字"></a>📙finally 关键字</h3><p>在异常处理的时候，提供 finally 块来执行任何的清除操作。如果抛出一个异常，那么相匹配的 catch 字句就会执行，然后控制就会进入 finally 块，前提是有 finally 块。例如：数据库连接关闭操作上</p><p>　　finally 作为异常处理的一部分，它只能用在 try&#x2F;catch 语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。</p><h3 id="📙finalize-关键字"><a href="#📙finalize-关键字" class="headerlink" title="📙finalize 关键字"></a>📙finalize 关键字</h3><p>finalize() 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 finalize() 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。要明白这个问题，先看一下虚拟机是如何判断一个对象该死的。</p><p>　　可以覆盖此方法来实现对其他资源的回收，例如关闭文件。</p><h2 id="📓transient关键字"><a href="#📓transient关键字" class="headerlink" title="📓transient关键字"></a>📓transient关键字</h2><p>Java 的 transient 关键字，只需要实现 Serilizable 接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h2 id="📓native关键字"><a href="#📓native关键字" class="headerlink" title="📓native关键字"></a>📓native关键字</h2><p>native（即 JNI，Java Native Interface），凡是一种语言，都希望是纯。比如解决某一个方案都喜欢就单单这个语言来写即可。Java 平台有个用户和本地 C 代码进行互操作的 API，称为 Java Native Interface (Java本地接口)。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209021723033.png" alt="img"></p><h2 id="📓static关键字"><a href="#📓static关键字" class="headerlink" title="📓static关键字"></a>📓static关键字</h2><ul><li><p><strong>静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p></li><li><p><strong>静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</p></li><li><p><strong>静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p></li><li><p><strong>静态内部类</strong></p></li></ul><p>  内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><ul><li><p><strong>静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓super关键字"><a href="#📓super关键字" class="headerlink" title="📓super关键字"></a>📓super关键字</h2><ol><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li><li>泛型中用于约束泛型的下界。如<code>&lt; ? super Apple&gt;</code></li></ol><h1 id="💠面向对象"><a href="#💠面向对象" class="headerlink" title="💠面向对象"></a>💠面向对象</h1><h2 id="📓继承"><a href="#📓继承" class="headerlink" title="📓继承"></a>📓继承</h2><p>🏳‍🌈<strong>接口没有继承Object类</strong></p><p>📄<strong>继承规则：</strong></p><ol><li><p>类与类之间的关系为继承，只能单继承，但可以多层继承。</p></li><li><p>类与接口之间的关系为实现，既可以单实现，也可以多实现。 </p></li><li><p>接口与接口之间的关系为继承，既可以单继承，也可以多继承。</p></li></ol><p>📄<strong>关于继承的3个点</strong></p><ol><li><p>⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性和⽅ 法⼦类是⽆法访问，只是拥有。</p></li><li><p>⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。</p></li><li><ol start="3"><li>⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。（以后介绍）。</li></ol></li></ol><h2 id="📓封装"><a href="#📓封装" class="headerlink" title="📓封装"></a>📓封装</h2><blockquote><p>封装是指把⼀个对象的状态信息（也就是属性）<strong>隐藏在对象内部</strong>，不允许外部对象直接访问对象的内 部信息。但是可以提供⼀些可以被外界访问的⽅法来操作属性。</p></blockquote><p>Java 中有三个访问权限修饰符：private、protected 以及 public，</p><ul><li>如果不加访问修饰符，表示包级可见。</li><li>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</li><li>private 仅自己可见</li><li>public 所有均可见</li></ul><blockquote><p>private 和 protected 不能修饰类。</p></blockquote><table><thead><tr><th>访问修饰符</th><th>同一个类</th><th>同包</th><th>不同包，子类</th><th>不同包，非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="📓多态"><a href="#📓多态" class="headerlink" title="📓多态"></a>📓多态</h2><p>📄<strong>多态的理解(多态的实现方式)</strong></p><ul><li><strong>方法重载</strong>（overload）：实现的是<strong>编译时的多态性</strong>（也称为前绑定）。</li><li><strong>方法重写</strong>（override）：实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西。</li></ul><p><strong>📄面相对象开发方式优点（B65）</strong></p><ul><li>较高的<strong>开发效率</strong>：可以把事物进行抽象，映射为开发的对象。</li><li>保证软件的<strong>鲁棒性</strong>：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。</li><li>保证软件的<strong>高可维护性</strong>：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</li></ul><h2 id="📓重载和重写的区别"><a href="#📓重载和重写的区别" class="headerlink" title="📓重载和重写的区别"></a>📓重载和重写的区别</h2><ul><li><p><strong>方法重写（子类与父类之间）</strong></p><blockquote><p><strong>“两同两小一大”原则</strong>：</p><ol><li>两同：方法名和参数列表相同</li><li>两小：返回值或声明异常比父类小（或相同）  </li><li>一大：访问修饰符比父类的大（或相同）</li></ol><p>细节如下：</p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote></li><li><p><strong>方法重载（同一个类中）</strong></p><p>在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不 同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是 否相同来判断重载。</p><blockquote><ul><li><p>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</p></li><li><p>被重载的方法可以改变返回类型；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。无法以返回值类型作为重载函数的区分标准。</p></li></ul></blockquote></li></ul><h2 id="📓接⼝和抽象类"><a href="#📓接⼝和抽象类" class="headerlink" title="📓接⼝和抽象类"></a>📓接⼝和抽象类</h2><h3 id="📙抽象类"><a href="#📙抽象类" class="headerlink" title="📙抽象类"></a>📙抽象类</h3><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><h3 id="📙接口"><a href="#📙接口" class="headerlink" title="📙接口"></a>📙接口</h3><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><ul><li>从 Java 8 开始，接口也可以拥有默认的方法实现</li><li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</li><li>接口的字段默认都是 static 和 final 的。</li></ul><h3 id="📙两者比较"><a href="#📙两者比较" class="headerlink" title="📙两者比较"></a>📙两者比较</h3><p>从设计层面上看</p><ul><li>抽象类的实现目的，是代码复用，一种模板设计的方式，可以让这些类都派生于一个抽象类。</li><li>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。</li></ul><p>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</p><ul><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p>设计上对比：</p><ul><li>抽象类： 拓展继承该抽象类的模块的类的行为功能（开放闭合原则）</li><li>接口：约束继承该接口的类行为（依赖倒置原则）</li></ul><h2 id="📓内部类"><a href="#📓内部类" class="headerlink" title="📓内部类"></a>📓内部类</h2><h3 id="📙成员内部类"><a href="#📙成员内部类" class="headerlink" title="📙成员内部类"></a>📙成员内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Coco&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123; <span class="hljs-comment">//内部类</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jayden&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>System.out.println(Outer.<span class="hljs-built_in">this</span>.name);<br>System.out.println(name);<br>System.out.println(age);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInnerClass</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br><span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> o.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>in.show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 <strong>public</strong> 、 <strong>protected</strong> 、 <strong>private</strong> 等。</li><li>Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。</li><li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 &#x3D; 外部类对象.new 内部类( )。</li><li>编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}</li><li>成员内部类中不能存在任何 static 的变量和方法,可以定义常量：<ol><li>因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过，非静态内部类的作用域是实例级别。</li><li>常量是在编译器就确定的,放到所谓的常量池了。</li></ol></li></ol><p><strong>:diamonds:温馨提示</strong></p><ol><li>外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name。</li></ol><h3 id="📙静态内部类"><a href="#📙静态内部类" class="headerlink" title="📙静态内部类"></a>📙静态内部类</h3><blockquote><p> static 修饰的内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Coco&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//静态内部类</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jayden&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>System.out.println(Outer.name);<br>System.out.println(name);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>i.show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；</li><li>如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 &#x3D; new 内部类();</li></ol><h3 id="📙方法内部类"><a href="#📙方法内部类" class="headerlink" title="📙方法内部类"></a>📙方法内部类</h3><blockquote><p>其作用域仅限于方法内，方法外部无法访问该内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Show</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//方法内部类</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;访问外部类:&quot;</span> + a);<br>System.out.println(<span class="hljs-string">&quot;访问内部类:&quot;</span> + c);<br>&#125;<br>&#125;<br><span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>i.print();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>o.show();<br>&#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><ol><li>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的</li><li>只能访问方法中定义的 final 类型的局部变量，因为：<ul><li>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。</li><li>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期，局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数，防止被篡改数据,而导致内部类得到的值不一致</li></ul></li></ol><h3 id="📙匿名内部类"><a href="#📙匿名内部类" class="headerlink" title="📙匿名内部类"></a>📙匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>            <span class="hljs-keyword">public</span> InnerClass <span class="hljs-title function_">getInnerClass</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span>   num,String str2)</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>()&#123; <span class="hljs-comment">//匿名内部类</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//实现抽象方法</span><br>                        <span class="hljs-keyword">return</span> number;<br>                    &#125;<br>                &#125;;        <span class="hljs-comment">/* 注意：分号不能省 */</span><br>            &#125;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>                <span class="hljs-type">OuterClass</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>();<br>                <span class="hljs-type">InnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> out.getInnerClass(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;chenssy&quot;</span>);<br>                System.out.println(inner.getNumber());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerClass</span> &#123; <span class="hljs-comment">//匿名内部类要实现的接口</span><br>            <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>;<br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</p></li><li><p>匿名内部类中是不能定义构造函数的。</p></li><li><p>匿名内部类中不能存在任何的静态成员变量和静态方法。</p></li><li><p>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</p></li><li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></li></ol><h2 id="📓类关系"><a href="#📓类关系" class="headerlink" title="📓类关系"></a>📓类关系</h2><p>👻类与类之间有三种关系：</p><p>（1）is-a 包括了继承（类）和实现（接口）关系；</p><p>（2）has-a包括了关联、聚合、组合关系；</p><p>（3）use-a包括了依赖关系；</p><p><em>注：依赖关系 &gt; 关联关系 &gt; 聚合关系 &gt; 组合关系</em></p><h2 id="📓equals与-x3D-x3D-的区别"><a href="#📓equals与-x3D-x3D-的区别" class="headerlink" title="📓equals与&#x3D;&#x3D;的区别"></a>📓equals与&#x3D;&#x3D;的区别</h2><ul><li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><p>细节：</p><blockquote><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是 否是指相同一个对象。比较的是真正意义上的指针操作。</p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object 中的equals方法返回的却是&#x3D;&#x3D;的判断。</p></blockquote><h2 id="📓Hashcode"><a href="#📓Hashcode" class="headerlink" title="📓Hashcode()"></a>📓Hashcode()</h2><h3 id="📙Hashcode-的作用"><a href="#📙Hashcode-的作用" class="headerlink" title="📙Hashcode()的作用"></a>📙Hashcode()的作用</h3><blockquote><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p></blockquote><p>**hashCode()**：hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值.</p><ul><li>对象按照自己不同的特征尽量的有不同的哈希码，作用是用于<strong>快速查找</strong></li><li>另一个应用就是hash集合的使用</li></ul><h3 id="📙为什么hashCode-和equals-方法要一起重写"><a href="#📙为什么hashCode-和equals-方法要一起重写" class="headerlink" title="📙为什么hashCode()和equals()方法要一起重写"></a>📙为什么hashCode()和equals()方法要一起重写</h3><p>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals ⽅法判断两个对象是相等 的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() ⽅法的话就可能会导致 equals ⽅法判断是相等的两个 对象， hashCode 值却不相等。</p><h2 id="📓java复制"><a href="#📓java复制" class="headerlink" title="📓java复制"></a>📓java复制</h2><p>对于基本类型，直接赋值复制，对于对象类型分为浅拷贝与深拷贝</p><ol><li>浅拷贝：对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><blockquote><p>深拷贝的另一种方式，使用序列化和反序列化，获取一个新对象。</p></blockquote><h2 id="📓序列化"><a href="#📓序列化" class="headerlink" title="📓序列化"></a>📓序列化</h2><blockquote><p>定义：🏷<strong>序列化</strong>：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是<strong>对象状态的保存与重建</strong>。</p><p><strong>🏷反序列化</strong>：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></blockquote><h2 id="📓枚举"><a href="#📓枚举" class="headerlink" title="📓枚举"></a>📓枚举</h2><p>枚举类比较使用&#x3D;&#x3D;，同样也可以使用equals方法，Enum类中重写了equals实际上还是调用&#x3D;&#x3D;方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns true if the specified object is equal to this</span><br><span class="hljs-comment">* enum constant.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> other the object to be compared for equality with this object.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span>  true if the specified object is equal to this</span><br><span class="hljs-comment">*          enum constant.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object other)</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>==other;<br>&#125;<br></code></pre></td></tr></table></figure><p>📚<strong>为什么使用&#x3D;&#x3D;比较？</strong></p><p>因为枚举类在jvm编译成class文件后，实际编译成使用final 修饰的class，final修饰就意味着实例化后不可修改，且都指向堆中的同一个对象</p><p>普通的一个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">t</span> &#123;<br>   SPRING,SUMMER,AUTUMN,WINTER;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">T</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(s, i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] values()<br>    &#123;<br>        T at[];<br>        <span class="hljs-type">int</span> i;<br>        T at1[];<br>        System.arraycopy(at = ENUM$VALUES, <span class="hljs-number">0</span>, at1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[i = at.length], <span class="hljs-number">0</span>, i);<br>        <span class="hljs-keyword">return</span> at1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title function_">valueOf</span><span class="hljs-params">(String s)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (T)Enum.valueOf(demo/T, s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T SPRING;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T SUMMER;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T AUTUMN;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T WINTER;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T ENUM$VALUES[];<br>    <span class="hljs-keyword">static</span><br>    &#123;<br>        SPRING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;SPRING&quot;</span>, <span class="hljs-number">0</span>);<br>        SUMMER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;SUMMER&quot;</span>, <span class="hljs-number">1</span>);<br>        AUTUMN = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;AUTUMN&quot;</span>, <span class="hljs-number">2</span>);<br>        WINTER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;WINTER&quot;</span>, <span class="hljs-number">3</span>);<br>        ENUM$VALUES = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[] &#123;<br>            SPRING, SUMMER, AUTUMN, WINTER<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓IO流"><a href="#📓IO流" class="headerlink" title="📓IO流"></a>📓IO流</h2><h3 id="📙分类"><a href="#📙分类" class="headerlink" title="📙分类"></a>📙分类</h3><p>📃Java 的 I&#x2F;O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入&#x2F;输出：NIO</li></ul><p>磁盘操作🌰</p><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。递归地输出一个目录下所有文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listAllFiles</span><span class="hljs-params">(File dir)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span> || !dir.exists()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dir.isFile()) &#123;<br>        System.out.println(dir.getName());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        listAllFiles(file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节操作🌰</p><p>使用字节流操作进行文件复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(String src, String dist)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dist);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">20</span> * <span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// read() 最多读取 buffer.length 个字节</span><br>    <span class="hljs-comment">// 返回的是实际读取的个数</span><br>    <span class="hljs-comment">// 返回 -1 的时候表示读到 eof，即文件尾</span><br>    <span class="hljs-keyword">while</span> (in.read(buffer, <span class="hljs-number">0</span>, buffer.length) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer);<br>    &#125;<br>    in.close();<br>    out.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>字符操作🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFileContent</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);<br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(line);<br>    &#125;<br>    <span class="hljs-comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span><br>    <span class="hljs-comment">// 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法</span><br>    <span class="hljs-comment">// 因此只要一个 close() 调用即可</span><br>    bufferedReader.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/inputStreamStructure.jpg" alt="avatar"></p><p>Java I&#x2F;O 使用了装饰者模式来实现。以 InputStream 为例，</p><p>📖InputStream 是抽象组件；</p><ul><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了文件字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p>📖InputStream的作用是用来表示那些从不同数据源产生输入的类。</p><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道“，工作方式与实际管道类似，即一端输入另一端输出</li><li>其他数据源，如Internet连接等</li></ol><p>📖Reader 与 Writer</p><ul><li>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</li><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h3 id="📙编码与解码"><a href="#📙编码与解码" class="headerlink" title="📙编码与解码"></a>📙编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>String 编码转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中文&quot;</span>;<br><span class="hljs-type">byte</span>[] bytes = str1.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(str2);<br></code></pre></td></tr></table></figure><h2 id="📓操作系统中的IO"><a href="#📓操作系统中的IO" class="headerlink" title="📓操作系统中的IO"></a>📓操作系统中的IO</h2><h3 id="📙常见I-x2F-O模型对比"><a href="#📙常见I-x2F-O模型对比" class="headerlink" title="📙常见I&#x2F;O模型对比"></a>📙常见I&#x2F;O模型对比</h3><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/ioModel.jpg" alt="avatar"></p><p>所有的系统I&#x2F;O都分为两个阶段：等待就绪和操作。</p><p>举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>需要说明的是<strong>等待就绪的阻塞是不使用CPU的，是在“空等”</strong>； 而<strong>真正的读写操作的阻塞是使用CPU的</strong>，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB&#x2F;s级别以上，可以理解为基本不耗时。</p><h3 id="📙BIO"><a href="#📙BIO" class="headerlink" title="📙BIO"></a>📙BIO</h3><p>传统的BIO中，read去读取网络的数据时，是无法预知对方是否已经发送数据的。因此在收到数据之前，能做的只有等待，直到对方把数据发过来，或者等到网络超时。</p><h3 id="📙NIO"><a href="#📙NIO" class="headerlink" title="📙NIO"></a>📙NIO</h3><p>NIO模式下，系统调用read，如果发现没数据已经到达，就会立刻返回-1。使用轮询的方式，不断的尝试有没有数据到达。没有得到数据就等一小会再试继续轮询。</p><p>NIO解决了线程阻塞的问题 ，但是会带来两个新问题：</p><ol><li>如果有IO连接都要检查，那么就得一个一个的read。这会带来大量的线程上下文切换（read是系统调用，每调用一次就得在用户态和核心态切换一次）</li><li>轮询的休息等待时间无法确定。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。</li></ol><h3 id="📙IO复用模型"><a href="#📙IO复用模型" class="headerlink" title="📙IO复用模型"></a>📙IO复用模型</h3><p><strong>定义</strong>：多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互，告诉操作系统要监视这些IO是否有事件发生。阻塞读取操作系统epoll方法回调的通知消息。</p><p>特点及相关说明：</p><ul><li>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住，没有达到IO多路复用的通知请求到来的效果。</li><li>IO多路复用说的是多个Socket或IO连接，只不过操作系统是一起监听他们的事件而已。</li></ul><blockquote><p>多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。</p></blockquote><ul><li>IO多路复用的关键API调用(select，poll，epoll_wait）总是Block的</li><li><strong>IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费</strong>，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输）。</li></ul><h4 id="📚epoll"><a href="#📚epoll" class="headerlink" title="📚epoll"></a>📚epoll</h4><p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p><ul><li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li><li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li><li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。<ul><li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似<strong>callback的回调机制</strong>,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li></ul></li></ul><h4 id="📚水平触发与边缘触发"><a href="#📚水平触发与边缘触发" class="headerlink" title="📚水平触发与边缘触发"></a>📚水平触发与边缘触发</h4><p>epoll除了性能优势，还有一个优点——同时支持水平触发(Level Trigger)和边沿触发(Edge Trigger)。</p><ul><li>水平触发只关心文件描述符中是否还有没完成处理的数据，如果有，不管怎样epoll_wait，总是会被返回。简单说——水平触发代表了一种“状态”。</li><li>边沿触发只关心文件描述符是否有新的事件产生，如果有，则返回；如果返回过一次，不管程序是否处理了，只要没有新的事件产生，epoll_wait不会再认为这个fd被“触发”了。简单说——边沿触发代表了一个“事件”。</li></ul><p>边沿触发把如何处理数据的控制权完全交给了开发者，提供了巨大的灵活性。比如，读取一个http的请求，开发者可以决定只读取http中的headers数据就停下来。在边沿触发下，开发者有机会更精细的定制这里的控制逻辑。</p><h3 id="📙信号驱动IO"><a href="#📙信号驱动IO" class="headerlink" title="📙信号驱动IO"></a>📙信号驱动IO</h3><p>在通道中安装一个信号器：映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。</p><p>阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。</p><h4 id="📚AIO"><a href="#📚AIO" class="headerlink" title="📚AIO"></a>📚AIO</h4><p>用了AIO可以废弃select，poll，epoll。 linux的AIO的实现方式是内核和应用共享一片内存区域，应用通过检测这个内存区域（避免调用nonblocking的read、write函数来测试是否来数据，因为即便调用nonblocking的read和write由于进程要切换用户态和内核态，仍旧效率不高）来得知fd是否有数据，可是检测内存区域毕竟不是实时的，你需要在线程里构造一个监控内存的循环，设置sleep，总的效率不如epoll这样的实时通知。</p><h3 id="📙相关资料"><a href="#📙相关资料" class="headerlink" title="📙相关资料"></a>📙相关资料</h3><ul><li>操作系统层面理解IO：<a href="https://www.cnblogs.com/twoheads/p/10712094.html">https://www.cnblogs.com/twoheads/p/10712094.html</a></li><li>图解IO：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41#wechat_redirect</a></li><li>把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。<ul><li>烧水的报警器一响，整个烧水过程就完成了。水已经是开水了。</li><li>钓鱼的报警器一响，只能说明鱼儿已经咬钩了，但是还没有真正的钓上来。</li></ul></li></ul><h2 id="📓Java-中的网络支持"><a href="#📓Java-中的网络支持" class="headerlink" title="📓Java 中的网络支持"></a>📓Java 中的网络支持</h2><p>基本概念</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；f</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h2 id="📓java-BIO-Blocking-IO-阻塞"><a href="#📓java-BIO-Blocking-IO-阻塞" class="headerlink" title="📓java BIO(Blocking IO 阻塞)"></a>📓java BIO(Blocking IO 阻塞)</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/socket.png" alt="avatar"></p><ul><li>在不考虑多线程的情况下，BIO是无法处理多个客户端请求的。</li><li>BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。</li><li>多线程情况下对于服务端，服务端只能用线程开启多个线程与客户端建立连接。</li></ul><p>BIO多线程情况下的缺点：内存消耗、线程上下文切换</p><ol><li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li><li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU 使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li><li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li></ol><h2 id="📓java-NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#📓java-NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="📓java NIO(Non-blocking&#x2F;New I&#x2F;O)"></a>📓java NIO(Non-blocking&#x2F;New I&#x2F;O)</h2><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><ol><li>首先需要注册当这几个事件到来的时候所对应的处理器，事件处理完毕移除SelectKey，若未移除，selector不会检查这些key是否有事件到来。</li><li>然后在合适的时机告诉事件选择器：对这个事件感兴趣。</li><li>其次，用一个死循环选择就绪的事件，会执行系统调用，还会阻塞的等待新事件的到来。（系统调用指的是操作系统的函数调用，Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP）</li><li>新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</li><li>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。</li></ol><blockquote><p>select会进行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p></blockquote><ul><li>NIO由原来的阻塞读写（占用线程）变成了<strong>单线程轮询事件</strong>，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</li></ul><h3 id="📙零拷贝"><a href="#📙零拷贝" class="headerlink" title="📙零拷贝"></a>📙零拷贝</h3><p>IO的拷贝：</p><ol><li>硬件（网卡）拷贝内核缓冲区 （读）</li><li>内核缓冲区拷贝到用户缓冲区 （读）</li><li>用户空间再拷贝到内核空间中的Socket buffer&#x2F;Write buffer中。（写）</li><li>最后再从Socket buffer中拷贝到网卡缓冲区&#x2F;硬件资源中。（写）</li></ol><p>零拷贝的实现： 使用直接内存，在内核缓冲区中开辟一块用户空间和内核空间共享的直接内存区域，减少了用户缓冲区的复制操作。</p><h3 id="📙事件驱动模型"><a href="#📙事件驱动模型" class="headerlink" title="📙事件驱动模型"></a>📙事件驱动模型</h3><p>Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。</p><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I&#x2F;O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/NIORefactor.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/NIORefactor.png" alt="avatar"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelHandler</span>&#123;<br>      <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadable</span><span class="hljs-params">(Channel channel)</span>;<br>      <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelWritable</span><span class="hljs-params">(Channel channel)</span>;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>&#123;<br>     Socket socket;<br>     Event event;<span class="hljs-comment">//读，写或者连接</span><br>   &#125;<br><br>   <span class="hljs-comment">//IO线程主循环:</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">IoThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>   Channel channel;<br>   <span class="hljs-keyword">while</span>(channel=Selector.select())&#123;<span class="hljs-comment">//选择就绪的事件和对应的连接</span><br>      <span class="hljs-keyword">if</span>(channel.event==accept)&#123;<br>         registerNewChannelHandler(channel);<span class="hljs-comment">//如果是新连接，则注册一个新的读写处理器</span><br>      &#125;<br>      <span class="hljs-keyword">if</span>(channel.event==write)&#123;<br>         getChannelHandler(channel).channelWritable(channel);<span class="hljs-comment">//如果可以写，则执行写事件</span><br>      &#125;<br>      <span class="hljs-keyword">if</span>(channel.event==read)&#123;<br>          getChannelHandler(channel).channelReadable(channel);<span class="hljs-comment">//如果可以读，则执行读事件</span><br>      &#125;<br>    &#125;<br>   &#125;<br>   Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="hljs-comment">//所有channel的对应事件处理器</span><br></code></pre></td></tr></table></figure><p>相关资料：</p><ul><li>NIO selectKey原理：<a href="https://blog.csdn.net/qq_32331073/article/details/81132937">https://blog.csdn.net/qq_32331073/article/details/81132937</a></li><li>美团NIO浅析: <a href="https://tech.meituan.com/2016/11/04/nio.html">https://tech.meituan.com/2016/11/04/nio.html</a></li></ul><h3 id="📙NIO与BIO区别"><a href="#📙NIO与BIO区别" class="headerlink" title="📙NIO与BIO区别"></a>📙NIO与BIO区别</h3><ul><li>通讯方式：NIO 通过Channel（通道） 进行读写，通道是双向的，可读也可写。而BIO使用的流读写是单向的。</li><li>BIO流是阻塞的，NIO流是不阻塞的。</li><li>BIO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。<ol><li>在面向流的I&#x2F;O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</li><li>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</li></ol></li></ul><p>NIO 带来了什么</p><ul><li>避免多线程</li><li>非阻塞I&#x2F;O，I&#x2F;O读写不再阻塞，而是返回0</li><li>单线程处理多任务</li><li>基于block的传输，通常比基于流的传输更高效</li><li>更高级的IO函数，zero-copy</li><li>事件驱动模型</li><li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li></ul><h3 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h3><p>在Reactor中实现读</p><ol><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><p>在Proactor中实现读：</p><ol><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ol><ul><li>两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；</li><li>不同点在于，异步情况下（Proactor)，当回调handler时，表示I&#x2F;O操作已经完成；同步情况下（Reactor)，回调handler时，表示I&#x2F;O设备可以进行某个操作（can read 或 can write)。</li></ul><h3 id="📙RMI-远程方法调用"><a href="#📙RMI-远程方法调用" class="headerlink" title="📙RMI 远程方法调用"></a>📙RMI 远程方法调用</h3><p>java支持，最早的远程调用，使用Remote接口，同时实现类别需要继承UnicastRemoteObject</p><p>通过Registry，注册发现远程方法，并调用接口。</p><h3 id="📙netty"><a href="#📙netty" class="headerlink" title="📙netty"></a>📙netty</h3><p>Netty 是一个 基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</p><ul><li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li><li>支持多种协议 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li></ul><p>支持多个交互模型 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/netty.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/netty.jpg" alt="avatar"></a></p><ul><li>Reactor分成两部分，mainReactor负责监听server socket，accept新连接；并将建立的socket分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据，对业务处理功能，其扔给worker线程池完成。</li></ul><p>Netty中的事件分为Inbond事件和Outbound事件。</p><ul><li>Inbound事件通常由I&#x2F;O线程触发，如TCP链路建立事件、链路关闭事件、读事件、异常通知事件等。</li><li>Outbound事件通常是用户主动发起的网络I&#x2F;O操作，如用户发起的连接操作、绑定操作、消息发送等。</li></ul><p>相比NIO ：</p><ul><li>NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂。Netty的出现正是为了解决这些问题。</li><li>解决了JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li><li>通过代码封装，简化了服务端与客户端的代码交互。</li><li>数据直接复制到directBuffer的工作缓冲区</li></ul><h2 id="📓泛型"><a href="#📓泛型" class="headerlink" title="📓泛型"></a>📓泛型</h2><h3 id="📙简介"><a href="#📙简介" class="headerlink" title="📙简介"></a>📙简介</h3><blockquote><p>泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数。<br>在集合中存储对象并在使用前进行类型转换是不方便的。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p></blockquote><p>📚使用<code>T, E or K,V</code>等被广泛认可的类型占位符。</p><p>📖泛型有三种常用的使用方式：泛型类，泛型接口和泛型方法。</p><p>📄限定通配符和非限定通配符:</p><ol><li>非限定通配符：<code>&lt;?&gt;</code>表示了非限定通配符，因为<code>&lt;?&gt;</code>可以用任意类型来替代。</li><li>限定通配符：一种是<code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的上界 ，另一种是<code>&lt;? super T&gt;</code>它通过确保类型必须是T的父类来设定类型的下界</li><li>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</li></ol><h3 id="📙类型擦除"><a href="#📙类型擦除" class="headerlink" title="📙类型擦除"></a>📙类型擦除</h3><p>📚类型擦除: Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p><ul><li>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。</li><li>类型擦除后保留的原始类型，最后在字节码中的类型变量变成真正类型。无论何时定义一个泛型，相应的原始类型都会被自动提供，无限定的变量用Object替换。</li></ul><p>泛型擦除的例子： 本应该只能储存Integer，在通过反射调用方法时，却可以添加String数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>   list.add(<span class="hljs-number">1</span>);  <span class="hljs-comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br>   list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-string">&quot;asd&quot;</span>);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>      System.out.println(list.get(i));<br>   &#125;<br>&#125;<br><span class="hljs-comment">// output</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//asd</span><br></code></pre></td></tr></table></figure><p>📚<strong>类型擦除后保留的原始类型</strong>：在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，另一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，另一个是String，所以取同一父类的最小级，为Object  </span><br>  <br><span class="hljs-comment">//这是一个简单的泛型方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">add</span><span class="hljs-params">(T x,T y)</span>&#123;  <br>    <span class="hljs-keyword">return</span> y;  <br>&#125;    <br></code></pre></td></tr></table></figure><p>Java不能实现真正的泛型，只能使用<strong>类型擦除来实现伪泛型</strong>，这样虽然不会有类型膨胀问题，但是也引起来许多新问题</p><p>📚<strong>PECS原则</strong><br>如果要从集合中<strong>读取类型T的数据，并且不能写入</strong>，可以使用 ? extends 通配符；(Producer Extends)</p><p> 如果要从集合中<strong>写入类型T的数据，并且不需要读取</strong>，可以使用 ? super 通配符；</p><p>(Consumer Super) 如果<strong>既要存又要取</strong>，那么就不要使用任何通配符。</p><p>参考：</p><h2 id="📓反射"><a href="#📓反射" class="headerlink" title="📓反射"></a>📓反射</h2><p>👻先看看知乎回答</p><p>　反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到 JVM，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><p>　　举个例子我们的项目底层有时是用 mysql，有时用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 Class tc &#x3D; Class.forName(“com.java.dbtest.TestConnection”); 通过类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle 则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出 Java 的特性了！</p><p>　　举多个例子，大家如果接触过 spring，会发现当你配置各种各样的 bean 时，是以配置文件的形式配置的，你需要用到哪些 bean 就配哪些，spring 容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><hr size=1 style="width:100%px;height:3px;border:none;border-top:3px double orange;"> <p>📄反射可以提供<strong>运行时</strong>的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><ol><li>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</li><li>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。</li><li>也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li></ol><p>📄Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><p>📄反射的<strong>优点</strong>：</p><ul><li><strong>可扩展性</strong>：应用程序可以利用全限定名创建可扩展对象的实例，如com.demo.Test。</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li><li>开发工具：如IDEA开发工具可以从反射中获取类的信息，帮助开发人员代码编写。</li></ul><p>📄反射的<strong>缺点</strong>：如果一个功能可以不用反射完成，那么最好就不用。</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。</li><li><strong>安全限制</strong>：使用反射技术要求程序必须在一个没有安全限制的环境中运行。</li><li>内部暴露：反射破坏了封装性，可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性</li></ul><p>📄反射的<strong>功能</strong>：</p><ul><li><p>在运行时判断任意一个对象所属的类</p></li><li><p>在运行时构造任意一个类的对象</p></li><li><p>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</p></li><li><p>在运行时调用任意一个对象的方法</p></li></ul><p><strong>重点</strong>：是运行时而不是编译时</p><p><strong>📄获得Class对象</strong></p><ul><li><p>调用运行时类本身的 <code>.class</code> 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Person.class;<br>System.out.println(clazz1.getName());<br></code></pre></td></tr></table></figure></li><li><p>通过运行时类的对象获取 <code>getClass()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> p.getClass();<br>System.out.println(clazz3.getName());<br></code></pre></td></tr></table></figure></li><li><p>使用 Class 类的 <code>forName</code> 静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br><span class="hljs-comment">// 在JDBC开发中常用此方法加载数据库驱动:</span><br>Class.forName(driver);<br></code></pre></td></tr></table></figure></li><li><p>（了解）通过类的加载器 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz5</span> <span class="hljs-operator">=</span> classLoader.loadClass(className);<br>System.out.println(clazz5.getName());<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓异常与错误"><a href="#📓异常与错误" class="headerlink" title="📓异常与错误"></a>📓异常与错误</h2><p>📃Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。</p><blockquote><p>其中 Error 用来表示 JVM 无法处理的错误，</p></blockquote><p>📃Exception 分为两种：</p><ol><li>受检异常 ：要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li>非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复<ul><li>运行时异常（runtime exception）</li><li>错误（Error）</li></ul></li></ol><p>📃RuntimeException是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。一般来说，RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</p><blockquote><p>常见RuntimeException异常：NullPointException、ClassCastException、IllegalArgumentException、IndexOutOfBoundException</p></blockquote><p>📃try语句return问题：<strong>如果try语句里有return，返回的是try语句块中变量值</strong>。详细执行过程如下：</p><ol><li>如果有返回值，就把返回值保存到局部变量中；</li><li>执行jsr指令跳到finally语句里执行；</li><li>执行完finally语句后，返回之前保存在局部变量表里的值。</li><li>针对对象引用的返回，如果finally中有修改值，返回的是引用的对象。 <strong>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</strong></li></ol><p>📃<strong>catch和finally语句不能同时省略！</strong></p><ul><li>用try-catch 捕获异常;</li><li>用try-finally 清除异常;</li><li>用try-catch-finally 处理所有的异常. 三者选一种即可</li></ul><p>📃Throwable 类常⽤⽅法</p><ul><li>String getMessage() : 返回异常发⽣时的简要描述 </li><li>String toString() : 返回异常发⽣时的详细信息</li><li>String getLocalizedMessage() : 返回异常对象的本地化信息。使⽤ Throwable 的⼦类覆盖这个⽅ 法，可以⽣成本地化信息。如果⼦类没有覆盖该⽅法，则该⽅法返回的信息与 getMessage() 返 回的结果相同</li><li>void printStackTrace() : 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h2 id="📓注解"><a href="#📓注解" class="headerlink" title="📓注解"></a>📓注解</h2><h3 id="📙什么是注解"><a href="#📙什么是注解" class="headerlink" title="📙什么是注解"></a>📙什么是注解</h3><p>　Annontation 是 Java5 开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来<strong>将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</strong>。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation 像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>　　Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <code>java.lang.annotation</code> 包中。</p><p>　　简单来说：注解其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。</p><h3 id="📙为什么要注解"><a href="#📙为什么要注解" class="headerlink" title="📙为什么要注解"></a>📙为什么要注解</h3><p>传统的方式，我们是通过配置文件 <code>.xml</code> 来告诉类是如何运行的。</p><p>有了注解技术以后，我们就可以通过注解告诉类如何运行</p><p>例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解…Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。</p><p>明显地可以看出，这样是非常直观的，并且 Servlet 规范是推崇这种配置方式的。</p><h3 id="📙内置注解"><a href="#📙内置注解" class="headerlink" title="📙内置注解"></a>📙内置注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p>🏷作用在代码的注解:</p><ul><li><code>@Override</code>: 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code>: 标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code>: 指示编译器去忽略注解中声明的警告。</li></ul><p>🏷作用在其他注解的注解(或者说<strong>元注解</strong>)是:</p><ul><li><code>@Retention</code> : 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code>: 标记这些注解是否包含在用户文档中。</li><li><code>@Target</code>: 标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code>: 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>🏷从 Java 7 开始，额外添加了 3 个注解:</p><ul><li><code>@SafeVarargs</code>: Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code>: Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li><code>@Repeatable</code>: Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h3 id="📙元注解"><a href="#📙元注解" class="headerlink" title="📙元注解"></a>📙元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><ol><li><p><code>@Documented</code>：注解是否将包含在JavaDoc中</p></li><li><p><code>@Retention</code>(什么时候使用该注解)</p><ul><li><code>RetentionPolicy.SOURCE</code> : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。<code>@Override</code>, <code>@SuppressWarnings</code>都属于这类注解。</li><li><code>RetentionPolicy.CLASS</code> : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li></ul></li><li><p>@Target（注解用于什么地方）</p><ul><li><code>ElementType.CONSTRUCTOR</code>: 用于描述构造器</li><li><code>ElementType.FIELD</code>: 成员变量、对象、属性（包括enum实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>: 用于描述局部变量</li><li><code>ElementType.METHOD</code>: 用于描述方法</li><li><code>ElementType.PACKAGE</code>: 用于描述包</li><li><code>ElementType.PARAMETER</code>: 用于描述参数</li><li><code>ElementType.TYPE</code>: 用于描述类、接口(包括注解类型) 或enum声明 常见的@Component、@Service</li></ul></li><li><p>@Inherited（是否允许子类继承该注解）</p><blockquote><p><code>@Inherited</code> 元注解是一个标记注解，<code>@Inherited</code> 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类</p></blockquote></li></ol><h3 id="📙自定义注解"><a href="#📙自定义注解" class="headerlink" title="📙自定义注解"></a>📙自定义注解</h3><ol><li>Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.</li><li>参数成员只能用 public 或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组</li><li>要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.ElementType.FIELD;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 水果名称注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(FIELD)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitName &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//属性写成类似方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="📓网络编程"><a href="#📓网络编程" class="headerlink" title="📓网络编程"></a>📓网络编程</h2><h3 id="📙网络编程基础"><a href="#📙网络编程基础" class="headerlink" title="📙网络编程基础"></a>📙网络编程基础</h3><ul><li>Java网络编程<code>API</code>建立在Socket基础之上</li><li>Java网络接口支持<code>IP</code>以上的所有高层协议</li></ul><p>📃java网络通信类：</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h3 id="📙Socket"><a href="#📙Socket" class="headerlink" title="📙Socket"></a>📙Socket</h3><blockquote><p>👻Socket，又称套接字，是在不同的进程间进行网络通讯的一种协议、约定或者说是规范。</p><p>对于Socket编程，它更多的时候是基于TCP&#x2F;UDP等协议做的一层封装或者说抽象，是一套系统所提供的用于进行网络通信相关编程的接口。</p></blockquote><p>📃Socket通信伪代码：</p><ol><li>服务器绑定端口：server &#x3D; new ServerSocket(PORT)</li><li>服务器阻塞监听：socket &#x3D; server.accept()</li><li>服务器开启线程：new Thread(Handle handle)</li><li>服务器读写数据：BufferedReader PrintWriter</li><li>客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)</li><li>客户端传输接收数据：BufferedReader PrintWriter</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209022105074.png" alt="img"></p><p><strong>Socket的特点</strong></p><ol><li>Socket基于TCP链接，数据传输有保障</li><li>Socket适用于建立长时间链接</li><li>Socket编程通常应用于即时通讯</li></ol>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2022/09/04/Netty/"/>
    <url>/2022/09/04/Netty/</url>
    
    <content type="html"><![CDATA[<h1 id="💠Netty"><a href="#💠Netty" class="headerlink" title="💠Netty"></a>💠Netty</h1><h2 id="📓netty-是什么"><a href="#📓netty-是什么" class="headerlink" title="📓netty 是什么"></a>📓netty 是什么</h2><ul><li>基于 NIO 的 RPC 框架的网络通信框架</li><li>极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程</li><li>支持多种协议 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li><li>自带编解码器解决 TCP 粘包&#x2F;拆包问题。</li></ul><h2 id="📓Reactor-模式"><a href="#📓Reactor-模式" class="headerlink" title="📓Reactor 模式"></a>📓Reactor 模式</h2><p>Reactor模式基于事件驱动，特别适合处理海量的I&#x2F;O事件</p><p>Reactor线程模型分为单线程模型、多线程模型以及主从多线程模型。</p><h3 id="📙单线程Reactor"><a href="#📙单线程Reactor" class="headerlink" title="📙单线程Reactor"></a>📙单线程Reactor</h3><p>单线程 Reactor 的优点是对系统资源消耗特别小，但是，没办法支撑大量请求的应用场景并且处理请求的时间可能非常慢 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor.jpg" alt="avatar"></a></p><h3 id="📙多线程Reactor"><a href="#📙多线程Reactor" class="headerlink" title="📙多线程Reactor"></a>📙多线程Reactor</h3><p>一个线程负责接受请求,一组NIO线程处理IO操作。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.png" alt="avatar"></a></p><h3 id="📙主从多线程Reactor"><a href="#📙主从多线程Reactor" class="headerlink" title="📙主从多线程Reactor"></a>📙主从多线程Reactor</h3><p>一组NIO线程负责接受请求，一组NIO线程处理IO操作。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.jpg" alt="avatar"></a></p><h2 id="📓java-IO比较"><a href="#📓java-IO比较" class="headerlink" title="📓java IO比较"></a>📓java IO比较</h2><ul><li><strong>同步阻塞IO（BIO）</strong>：用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行（客户端和服务器连接需要三次握手，使用简单，但吞吐量小）；</li><li><strong>同步非阻塞IO（NIO）</strong>：用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费（客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性）；</li><li><strong>异步非阻塞IO（AIO）</strong>：用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式（NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法）。</li></ul><h2 id="📓I-x2F-O多路复用模型"><a href="#📓I-x2F-O多路复用模型" class="headerlink" title="📓I&#x2F;O多路复用模型"></a>📓I&#x2F;O多路复用模型</h2><ul><li><strong>I&#x2F;O</strong> ：网络 I&#x2F;O</li><li><strong>多路</strong>：多个 TCP 连接</li><li><strong>复用</strong>：共用一个线程或进程</li></ul><h2 id="📓Netty的核心组件"><a href="#📓Netty的核心组件" class="headerlink" title="📓Netty的核心组件"></a>📓Netty的核心组件</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyAF.jpg" alt="avatar"></p><p>Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册到其上的Channel 处理 I&#x2F;O 操作，两者配合参与 I&#x2F;O 操作。</p><h3 id="📙Channel"><a href="#📙Channel" class="headerlink" title="📙Channel"></a>📙Channel</h3><p>Channel 接口是 Netty 对网络操作抽象类，它包括基本的 I&#x2F;O 操作，如 bind()、connect()、read()、write() 等。 比较常用的Channel接口实现类是NioServerSocketChannel（服务端）和NioSocketChannel（客户端），这两个 Channel 可以和 BIO 编程模型中的ServerSocket以及Socket两个概念对应上。</p><h3 id="📙EventLoop"><a href="#📙EventLoop" class="headerlink" title="📙EventLoop"></a>📙EventLoop</h3><p>EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。负责监听网络事件并调用事件处理器进行相关 I&#x2F;O 操作的处理。</p><p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程）,EventLoop 处理的 I&#x2F;O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p><p>客户端连接处理流程：</p><ol><li>当客户端通过 connect 方法连接服务端时，bossGroup 处理客户端连接请求。</li><li>当客户端处理完成后，会将这个连接提交给 workerGroup 来处理，然后 workerGroup 负责处理其 IO 相关操作。</li></ol><h3 id="📙ChannelHandler-和-ChannelPipeline"><a href="#📙ChannelHandler-和-ChannelPipeline" class="headerlink" title="📙ChannelHandler 和 ChannelPipeline"></a>📙ChannelHandler 和 ChannelPipeline</h3><p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p><p>ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">b.group(eventLoopGroup)<br>  .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyKryoDecoder</span>(kryoSerializer, RpcResponse.class));<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyKryoEncoder</span>(kryoSerializer, RpcRequest.class));<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KryoClientHandler</span>());<br>      &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="📙Bootstrap-和-ServerBootstrap-引导类"><a href="#📙Bootstrap-和-ServerBootstrap-引导类" class="headerlink" title="📙Bootstrap 和 ServerBootstrap 引导类"></a>📙Bootstrap 和 ServerBootstrap 引导类</h3><p>ServerBootstrap服务端启动： 1.首先你创建了两个 NioEventLoopGroup 对象实例：bossGroup 和 workerGroup。</p><ul><li>bossGroup : 用于处理客户端的 TCP 连接请求。</li><li>workerGroup ：负责每一条连接的具体读写数据的处理逻辑，真正负责 I&#x2F;O 读写操作，交由对应的 Handler 处理。</li><li>一般情况下我们会指定 bossGroup 的 线程数为 1（并发连接量不大的时候） ，workGroup 的线程数量为 CPU 核心数 *2 。另外，根据源码来看，使用 NioEventLoopGroup 类的无参构造函数设置线程数量的默认值就是 CPU 核心数 *2 。 2.接下来 我们创建了一个服务端启动引导&#x2F;辅助类：ServerBootstrap，这个类将引导我们进行服务端的启动工作。 3.通过 .group() 方法给引导类 ServerBootstrap 配置两大线程组，确定了<strong>线程模型</strong>。</li></ul><p>Bootstrap客户端启动： 1.创建一个 Bootstrap、NioEventLoopGroup 对象实例 2.通过 .group() 方法给引导类 Bootstrap 配置一个线程组 3.通过channel()方法给引导类 Bootstrap指定了 IO 模型为NIO 4.通过 .childHandler()给引导类创建一个ChannelInitializer ，然后指定了客户端消息的业务处理逻辑 ClientHandler 对象 5.调用 Bootstrap 类的 connect()方法进行连接，这个方法需要指定两个参数：IP、端口</p><h2 id="📓什么是-TCP-粘包-x2F-拆包"><a href="#📓什么是-TCP-粘包-x2F-拆包" class="headerlink" title="📓什么是 TCP 粘包&#x2F;拆包"></a>📓什么是 TCP 粘包&#x2F;拆包</h2><p>粘包与拆包：基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。</p><p>Netty 自带的解码器</p><ul><li>LineBasedFrameDecoder : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔。</li><li>DelimiterBasedFrameDecoder : 可以自定义分隔符解码器</li></ul><h2 id="📓其他"><a href="#📓其他" class="headerlink" title="📓其他"></a>📓其他</h2><p>Netty 长连接、心跳机制</p><ul><li>TCP连接三次握手、四次挥手耗费网络资源，且多次建立连接更消耗资源。因此使用长连接的方式，为了保证长连接的有效性，引入心跳机制，在空闲时刻也可以维持连接。</li></ul><p>Netty 的零拷贝</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java单元测试</title>
    <link href="/2022/09/04/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/04/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="💠java单元测试"><a href="#💠java单元测试" class="headerlink" title="💠java单元测试"></a>💠java单元测试</h1><h2 id="📓测试名词"><a href="#📓测试名词" class="headerlink" title="📓测试名词"></a>📓测试名词</h2><ul><li>单元测试：单元测试（模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。</li><li>集成测试：集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。</li><li>黑盒测试：被测程序看成是一个无法打开的黑盒，而工作人员在不考虑任何程序内部结构和特性的条件下，根据需求规格说明书设计测试实例，并检查程序的功能是否能够按照规范说明准确无误的运行。</li><li>白盒测试：借助程序内部的逻辑和相关信息，通过检测内部动作是否按照设计规格说明书的设定进行，检查每一条通路能否正常工作。白盒测试是从程序结构方面出发对测试用例进行设计。其主要用于检查各个逻辑结构是否合理，对应的模块独立路径是否正常以及内部结构是否有效。</li><li>冒烟测试：是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，并非对软件版本包的深入测试，是针对软件版本包进行详细测试之前的预测试，执行冒烟测试的主要目的是快速验证软件基本功能是否有缺陷。</li><li>回归测试：指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。</li><li>金丝雀测试：在金丝雀测试中，金丝雀是一小群体验最新软件更新的用户，他们的反馈可帮助开发团队决定是否应向所有用户提供新版本，或者更改应快速回滚，方法的名字来自过去在煤矿中用作有毒气体探测器的金丝雀鸟。 。金丝雀测试、金丝雀释放和金丝雀部署概念类似。</li></ul><h2 id="📓单元测试相关方法论"><a href="#📓单元测试相关方法论" class="headerlink" title="📓单元测试相关方法论"></a>📓单元测试相关方法论</h2><p>测试金字塔里的单元测试：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/unitTestTower.png" alt="avatar"></p><p>不同测试方法比较：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/UTCompare.png" alt="avatar"></p><h2 id="📓优缺点分析"><a href="#📓优缺点分析" class="headerlink" title="📓优缺点分析"></a>📓优缺点分析</h2><p>优点：</p><ol><li><p>开发人员：</p><ul><li>尽早发现缺陷，降低开发投入成本。开发人员可以快速验证他们所写代码，及早地发现代码中的问题。</li><li>新人融入。通过让新入职员工结合文档和运行单元测试，可以更快了解代码逻辑。</li><li>利于重构。通过单元测试，开发可以放心的修改重构代码，减少改代码时心理负担，提高重构的成功率。因为重构的代码通过单元测试，说明与原有逻辑一致。</li><li>改善设计。越是良好设计的代码，越容易编写单元测试，如果发现单测代码非常难写，一般表明被测试的代码包含了太多的依赖或职责，需要反思代码的合理性，进而推进代码设计的优化，形成正向循环。</li></ul></li><li><p>其他方面；</p><ul><li><p>单元测试触发快，每次项目构建可以触发run单元测试，保证每次发布修改不影响先前代码。</p></li><li><p>单元测试可以集成到代码合并流程里。在代码合并到发布分支之后，通过运行单元测试，保证分支代码的正确性再合并到master。</p><ul><li><blockquote><p>一般的流程是这样的：保护好“master”分支，不允许开发人员向该分支提交代码，而是让他们把代码提交到其他分支上。在将代码合并到 master 分支的时候，GitHub 要求先通过状态检查。Jenkins、CircleCI 和 TravisCI 都提供了状态检查钩子（hook），它们会从分支上获取代码并运行单元测试。如果通过了，就允许合并代码，否则就不允许。</p></blockquote></li></ul></li></ul></li></ol><p>缺点：</p><ol><li>开发的工作量变大。开发人员除了功能代码的开发外，还需要编写单元测试代码。</li><li>系统维护的工作量变大。随着项目复杂，代码量越来越大，单元测试的代码量也会越来越大。开发人员在维护系统代码的时候，也需要维护单元测试代码，加大开发人员的工作量。</li></ol><h2 id="📓TDD-测试驱动开发"><a href="#📓TDD-测试驱动开发" class="headerlink" title="📓TDD 测试驱动开发"></a>📓TDD 测试驱动开发</h2><p>TDD &#x3D; TFD + Refactoring (TFD – Test First Development)</p><p>TDD是测试驱动开发（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。</p><p>TDD的基本思路就是通过测试来推动整个开发的进行，要求开发人员在开发具体的功能代码之前，先编写方法对应的测试用例。</p><p>问题解释： TDD开发应该达到100%的单元测试覆盖率？</p><ol><li>TDD开发，首先就要保证单元测试的速度。如果单元测试包括了全部的数据库测试、redis缓存测试、ES等中间件功能的测试，那么在测试过程中就需要启动嵌入式的数据库等的中间件，导致整体的单元测试速度变慢。</li><li>单元测试代码应该着重于测试逻辑代码，对于DAO、外部接口使用mock的形式进行测试，才能保证单元测试的速度。</li><li>中间件功能的测试，不仅启动的时间慢，而且会耗费开发人员过多的精力到相关的测试中。 因此，TDD保证100%的单元测试覆盖率是不对的。满足<strong>逻辑代码</strong>100%覆盖即可，剩余的数据获取及中间件功能交互应留到集成测试中进行。</li></ol><h2 id="📓Junit测试"><a href="#📓Junit测试" class="headerlink" title="📓Junit测试"></a>📓Junit测试</h2><p>JUnit是一个Java编程语言编写的单元测试框架。需要区分的是Junit的版本，在Junit5中做了很多的改变。以下主要基于Junit4进行的说明。</p><h3 id="📙基本注解"><a href="#📙基本注解" class="headerlink" title="📙基本注解"></a>📙基本注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@BeforeClass 使用此注解的方法在测试类被调用之前执行</span><br><span class="hljs-comment">//@AfterClass 使用此注解的方法在测试类被调用结束退出之前执行</span><br><span class="hljs-comment">//一个类中有多少个@Test注解方法，以下对应注解方法就被调用多少次</span><br><span class="hljs-comment">//@Before 在每个@Test调用之前执行</span><br><span class="hljs-comment">//@After 在每个@Test调用之后执行</span><br><span class="hljs-comment">//@Test 使用此注解的方法为一个单元测试用例，一个测试类中可多次声明，每个注解为@Test只执行一次</span><br><span class="hljs-comment">//@Ignore 暂不执行的测试用例，会被JUnit4忽略执行</span><br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JunitDemo</span> &#123;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeClass method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is before method&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDemo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;hello junit world~&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test(expected = ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testException</span><span class="hljs-params">()</span> &#123;<br>        log.info(String.valueOf(<span class="hljs-number">123123</span>/<span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Test(timeout = 2000)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIgnore</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is ignore method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finish</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is after method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is afterClass method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📙spring相关测试"><a href="#📙spring相关测试" class="headerlink" title="📙spring相关测试"></a>📙spring相关测试</h3><p>启动spring容器相关注解</p><p>@SpringBootTest注解: 告诉Spring Boot查找一个主要的配置类（例如，一个带有@SpringBootApplication的类），并使用该类来启动Spring应用程序上下文。</p><ul><li>webEnvironment&#x3D;RANDOM_PORT: 使用webEnvironment &#x3D; RANDOM_PORT可以使用随机端口启动服务器（用于避免测试环境中的冲突），并使用@LocalServerPort注入端口。</li></ul><p>@AutoConfigureMockMvc: 使用Spring的MockMvc，并通过在测试用例上使用@AutoConfigureMockMvc注释，要求为测试用力注入该代码MockMvc代码。</p><p>@WebMvcTest : 在测试中，Spring Boot仅实例化了Web层，而不是整个上下文。 在具有多个控制器的应用程序中，甚至可以使用例如@WebMvcTest（HomeController.class）来仅请求实例化一个。</p><blockquote><p>可以加快整个applicaiton的启动速度，因为该注解只指定扫描了部分annotation</p></blockquote><p>@Runwith(SpringRunner.class): 说明了改测试用例要在什么环境下进行测试，在Junit4中需要将@RunWith（SpringRunner.class）添加到测试中，否则注释将被忽略。如果使用的是JUnit 5，则无需添加等效的@ExtendWith（ SpringExtension.class）（如@SpringBootTest）和其他@…Test注释已使用它进行注释。</p><ul><li><blockquote><p>@ExtendWith（ SpringExtension.class） 暂时未研究，主要是@Runwith的拓展类提供能力的增强，应用于Junit5中。</p></blockquote></li></ul><p>@MockBean:可用于为ApplicationContext中的bean定义Mockito模拟</p><p>@DirtiesContext：Spring @DirtiesContext从与测试关联的上下文缓存中删除脏的ApplicationContext</p><p>测试用例demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JunitSpringTestDemo</span> &#123;<br><br>    <span class="hljs-meta">@LocalServerPort</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UnitTestService unitTestService;<br><br>    <span class="hljs-meta">@MockBean</span><br>    <span class="hljs-keyword">private</span> TransactionTemplate transactionTemplate;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestRestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greetingShouldReturnDefaultMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">forObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:&quot;</span> + port + <span class="hljs-string">&quot;/learning/unit/one&quot;</span>, String.class);<br>        System.out.println(forObject);<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldReturnDefaultMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.mockMvc.perform(get(<span class="hljs-string">&quot;/unit/one&quot;</span>))<br>                .andDo(print())<br>                .andExpect(status().isOk())<br>                .andExpect(content().string(containsString(<span class="hljs-string">&quot;one&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> unitTestService.testJdbcTemplate();<br>        Assert.assertEquals(<span class="hljs-string">&quot;return result should be bbb&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓testNG"><a href="#📓testNG" class="headerlink" title="📓testNG"></a>📓testNG</h2><h3 id="📙基本介绍"><a href="#📙基本介绍" class="headerlink" title="📙基本介绍"></a>📙基本介绍</h3><p>TestNG不是一个JUnit扩展。它的灵感来源于JUnit。它的目的是优于JUnit的，尤其是当测试集成的类 -<a href="http://www.testng.org.cn/1723.html">与UnitTest比较</a></p><p>使用套件，指定某几个test中的group 为一个套件。在IDEA中直接运行xml文件，可以执行套件的测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE suite SYSTEM <span class="hljs-string">&quot;https://testng.org/testng-1.0.dtd&quot;</span> &gt;<br>&lt;suite name=<span class="hljs-string">&quot;testng-demo&quot;</span>&gt;<br>    &lt;test name=<span class="hljs-string">&quot;testGroup1&quot;</span>&gt;<br>        &lt;parameter name=<span class="hljs-string">&quot;dbconfig&quot;</span> value=<span class="hljs-string">&quot;db.properties!~&quot;</span> /&gt;<br>        &lt;parameter name=<span class="hljs-string">&quot;poolsize&quot;</span> value=<span class="hljs-string">&quot;10&quot;</span> /&gt;<br>        &lt;groups&gt;<br>            &lt;run&gt;<br>                &lt;include name=<span class="hljs-string">&quot;group1&quot;</span>/&gt;<br>            &lt;/run&gt;<br>        &lt;/groups&gt;<br>        &lt;classes&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>=<span class="hljs-string">&quot;TestNGDemo&quot;</span>/&gt;<br>        &lt;/classes&gt;<br>    &lt;/test&gt;<br><br>    &lt;test name=<span class="hljs-string">&quot;testGroup2&quot;</span>&gt;<br>        &lt;groups&gt;<br>            &lt;run&gt;<br>                &lt;include name=<span class="hljs-string">&quot;group2&quot;</span>/&gt;<br>            &lt;/run&gt;<br>        &lt;/groups&gt;<br>        &lt;classes&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>=<span class="hljs-string">&quot;TestNGDemo&quot;</span>/&gt;<br>        &lt;/classes&gt;<br>    &lt;/test&gt;<br>&lt;/suite&gt;<br></code></pre></td></tr></table></figure><ul><li>基本注解使用的demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNGDemo</span> &#123;<br><br>    <span class="hljs-meta">@BeforeSuite(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBeforeSuite</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;testBeforeSuite()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterSuite(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAfterSuite</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;testAfterSuite()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeClass&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is AfterClass&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeMethod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBeforeMethod</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterMethod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAfterMethod</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is afterMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeGroups(&quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupGroup1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;setupGroup1()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterGroups(&quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanGroup1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;cleanGroup1()&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is test1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;, expectedExceptions = ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testException</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is test2&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        log.info(<span class="hljs-string">&quot;After division the value of i is :&quot;</span>+ i);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(enabled = false)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIgnoreTestcase</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~ignore &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group2&quot;, timeOut = 5000)</span> <span class="hljs-comment">// time in mulliseconds</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testThisShouldPass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">4000</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;, dependsOnMethods = &quot;test1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDependOn</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is dependOnMethod~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;)</span><br>    <span class="hljs-meta">@Parameters(&#123; &quot;dbconfig&quot;, &quot;poolsize&quot; &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createConnection</span><span class="hljs-params">(String dbconfig, <span class="hljs-type">int</span> poolsize)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is parameter Test, parameter is: &#123;&#125;, &#123;&#125;&quot;</span>, dbconfig, poolsize);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group2&quot;, dataProvider = &quot;addDataProvider&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDataProvider</span><span class="hljs-params">( String data)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is testDataProvider, test data: &#123;&#125;&quot;</span>,data);<br>    &#125;<br><br>    <span class="hljs-meta">@DataProvider</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Object&gt; <span class="hljs-title function_">addDataProvider</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Object&gt; list = Lists.newArrayList();<br>        list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>        list.add((<span class="hljs-string">&quot;123wesdf&quot;</span>));<br>        <span class="hljs-keyword">return</span> list.iterator();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📙spring相关的使用"><a href="#📙spring相关的使用" class="headerlink" title="📙spring相关的使用"></a>📙spring相关的使用</h3><p>通过<code>extends AbstractTestNGSpringContextTests</code>提供一个测试使用的spring 上下文，类似于Junit4中@RunWith(SpringExtend)</p><blockquote><p>AbstractTestNGSpringContextTests is an abstract base test class that integrates the Spring TestContext Framework with explicit ApplicationContext testing support in a TestNG environment. When you extend AbstractTestNGSpringContextTests, you can access a protected applicationContext instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.</p></blockquote><h2 id="📓Mockito"><a href="#📓Mockito" class="headerlink" title="📓Mockito"></a>📓Mockito</h2><p>Mockito 主要用来辅助编写测试用例的。比如在微服务中的跨服务调用，在单个服务的单元测试中跨服务调用是不可能成功的，因为另外一个服务未启动，这是用就要使用mock 的方式，模拟服务请求返回的情形。</p><ul><li>以下为一个demo，在Mockito最常用的都是spy一个实例，在该实例调用某种方法是Mock回预期的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockitoTestDemo</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UnitTestService unitTestService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UnitTestService</span> <span class="hljs-variable">spy</span> <span class="hljs-operator">=</span> Mockito.spy(unitTestService);<br>        Mockito.when(spy.testSql()).thenReturn(<span class="hljs-string">&quot;fadsfasdfasdf&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spy.testSql();<br>        log.info(result);   <span class="hljs-comment">// return fadsfasdfasdf</span><br><br>        Mockito.when(spy.testParameter(Mockito.anyInt(),<br>                        Mockito.anyString(),<br>                        Mockito.any(),<br>                        Mockito.anyList(),<br>                        Mockito.anyMap()))<br>                .thenReturn(<span class="hljs-string">&quot;mock success&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> spy.testParameter(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sddf&quot;</span>, BigDecimal.ZERO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>        log.info(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓BDDMockito"><a href="#📓BDDMockito" class="headerlink" title="📓BDDMockito"></a>📓BDDMockito</h2><p>BDDMockito对比Mockito可以使用BDDMockito为各种Mockito方法提供BDD别名，代码看起来更易理解。</p><p>结合Testng的注解@BeforeClass，可以在一个测试用例类中直接把需要Mock的类方法及预期的返回值，设置好</p><ul><li><blockquote><p>Junit4中@BeforeClass，要求方法体内要为静态的。</p></blockquote></li><li><blockquote><p>BDDMockito 对于Mock类提供更为简便的表达</p></blockquote></li><li><blockquote><p>testng中对于@MockBean 需要配合使用 <code>@TestExecutionListeners(MockitoTestExecutionListener.class)</code></p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@TestExecutionListeners(MockitoTestExecutionListener.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BDDMockitoTestDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTestNGSpringContextTests</span> &#123;<br><br>    <span class="hljs-meta">@MockBean</span><br>    UnitInterface unitInterface;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>        given(unitInterface.register(anyString())).willReturn(<span class="hljs-string">&quot;register success&quot;</span>);<br>        given(unitInterface.calculate(anyDouble())).willThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Test(expectedExceptions = IllegalArgumentException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">calculate</span> <span class="hljs-operator">=</span> unitInterface.calculate(<span class="hljs-number">123.112d</span>);<br>        log.info(String.valueOf(calculate));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/09/04/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/09/04/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="💠java虚拟机"><a href="#💠java虚拟机" class="headerlink" title="💠java虚拟机"></a>💠java虚拟机</h1><p>虚拟机是物理机器的软件实现。Java 的开发遵循 write once run anywhere（“一次编写到处乱跑”）理念，它运行在 VM（虚拟机）上。编译器将 Java 文件编译成 Java.class 文件，之后，将 .class 文件输入到 JVM 中，加载并执行该类文件。下图是 JVM 的体系结构</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/heap-detail.jpg" alt="avatar"></p><h2 id="📓虚拟机内存区域"><a href="#📓虚拟机内存区域" class="headerlink" title="📓虚拟机内存区域"></a>📓虚拟机内存区域</h2><h3 id="📚程序计数器"><a href="#📚程序计数器" class="headerlink" title="📚程序计数器"></a>📚程序计数器</h3><p>定义：可以看作是当前线程所执行的字节码的行号指示器，为线程隔离的数据区。<br>java多线程切换时，每个线程独立的程序计数器，各条线程之间的计数器互不影响，独立存储，保证了线程切换后能恢复到正确的位置。</p><blockquote><p>唯一一个无OOM的区域</p></blockquote><h3 id="📚Java虚拟机栈"><a href="#📚Java虚拟机栈" class="headerlink" title="📚Java虚拟机栈"></a>📚Java虚拟机栈</h3><p>定义：每个方法执行的时候，Java虚拟机都会同步的创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><blockquote><p>栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息</p></blockquote><ul><li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)、</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚本地方法栈"><a href="#📚本地方法栈" class="headerlink" title="📚本地方法栈"></a>📚本地方法栈</h3><p>定义：为虚拟机使用到的本地(Native)方法服务。</p><ul><li>HotSpot直接把本方法栈和虚拟机栈合二为一。</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚Java堆"><a href="#📚Java堆" class="headerlink" title="📚Java堆"></a>📚Java堆</h3><p>定义:是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><ul><li>参数-Xmx和-Xms 最大堆内存和最小堆内存</li></ul><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/hotstop-heap.jpg" alt="avatar"></p><h3 id="📚方法区"><a href="#📚方法区" class="headerlink" title="📚方法区"></a>📚方法区</h3><p>定义：是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息(类名、方法描述、字段描述)、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><blockquote><p>JDK8以前使用<strong>永久代来实现方法区</strong><br>方法区类似于接口，永久代类似于实现类的关系。使用永久代的时候，可以设置内存上限，而且不同的虚拟机的实现不一样，因此更容易遇到内存溢出的问题。</p></blockquote><p><code>-XX:MaxMetaspaceSize</code>:设置元空间最大值，默认-1，不限制或者说仅受限于机器内存。 <code>-XX:MetaspaceSize</code>: 指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会根据收集结果对该值进行动态调整。 </p><h3 id="📚运行时常量池"><a href="#📚运行时常量池" class="headerlink" title="📚运行时常量池"></a>📚运行时常量池</h3><ul><li>定义：运行时常量池是方法区的一部分。Class文件除类字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，在类加载后存放到运行时常量池中。</li><li>运行时常量池具备动态性，运行期间可以将新的常量放入池中，当无法申请到空间抛出OutOfMemoryError异常。</li></ul><blockquote><p>在 Java 7 之前，JVM 将 Java String Pool 放置在 永久代空间(java7方法区的实现)中，该空间具有固定大小——它不能在运行时扩展并且不符合垃圾收集条件。<br>在永久代(而不是堆)中使用字符串的风险是，如果我们创建太多字符串，我们可能会从 JVM 中得到 OutOfMemory 错误。<br>从 Java 7 开始，Java String Pool 存储在 <strong>Heap 空间</strong>中，由 JVM 进行垃圾回收。 这种方法的优点是降低了 OutOfMemory 错误的风险，因为未引用的字符串将从池中删除，从而释放内存。</p></blockquote><h2 id="📓HotSpot-的后台线程"><a href="#📓HotSpot-的后台线程" class="headerlink" title="📓HotSpot 的后台线程"></a>📓HotSpot 的后台线程</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/hotspotThread.jpg" alt="avatar"></p><h2 id="📓内存区域溢出分析"><a href="#📓内存区域溢出分析" class="headerlink" title="📓内存区域溢出分析"></a>📓内存区域溢出分析</h2><h3 id="📚Java堆溢出"><a href="#📚Java堆溢出" class="headerlink" title="📚Java堆溢出"></a>📚Java堆溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMObject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚虚拟机栈和本地方法栈溢出"><a href="#📚虚拟机栈和本地方法栈溢出" class="headerlink" title="📚虚拟机栈和本地方法栈溢出"></a>📚虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈的溢出有StackOverflowError和OutOfMemoryError</p><p>导致StackOverflowError的两种行为</p><ol><li><code>-Xss</code>参数减少栈内存容量，递归过程导致堆栈溢出</li><li>定义大量本地变量，导致堆栈溢出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss128k</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        stackLength++;<br>        stackLeak();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> unused1,unused2; <span class="hljs-comment">// .... unused199</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内存溢出OutOfMemoryError的原因：因为创建一个线程的本地方法栈及虚拟机栈也是占用堆内存空间的，在内存有限的情况，创建一定数量的线程将导致内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss2M  设置每个线程的堆栈大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dontStop</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeakByThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    dontStop();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackOOM</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackOOM</span>();<br>        oom.stackLeakByThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚方法区和运行时常量池溢出"><a href="#📚方法区和运行时常量池溢出" class="headerlink" title="📚方法区和运行时常量池溢出"></a>📚方法区和运行时常量池溢出</h3><p>JDK1.7之前会产生永久代内存溢出的情况，而之后会产生内存溢出的情况，因为常量池移动到堆中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行时常量池溢出导致内存溢出 jdk7中</span><br><span class="hljs-comment">// 参数： -Xmx6M -XX:MaxMetaspaceSize=6M -XX:PermSize=6M</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">short</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            set.add(String.valueOf(i++).intern());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码增强生成大量的动态类导致的溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 借助CGlib 使方法区出现永久代内存溢出异常，在JDK7中导致内存空间溢出</span><br><span class="hljs-comment">// java 8 不会出现问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaMethodAreaOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>            enhancer.setSuperclass(OOMObject.class);<br>            enhancer.setUseCache(<span class="hljs-literal">true</span>);<br>            enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                    <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);<br>                &#125;<br>            &#125;);<br>            enhancer.create();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚本机直接内存溢出"><a href="#📚本机直接内存溢出" class="headerlink" title="📚本机直接内存溢出"></a>📚本机直接内存溢出</h3><p>特征是Heap dump很小，而程序中又间接使用了DirectMemory(如NIO)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//* 参数：-Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="hljs-comment">//* 本机直接内存溢出</span><br><span class="hljs-comment">//*</span><br><span class="hljs-comment">//*  -XX:MaxDirectMemorySize 用于指定直接内存大小</span><br><span class="hljs-comment">//* 真正申请内存分配的方法Unsafe::allocateMemory()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemoryOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredFields()[<span class="hljs-number">0</span>];<br>        unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)unsafeField.get(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            unsafe.allocateMemory(_1MB);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="hljs-comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="hljs-comment">     * at com.learning.jvm.memory.DirectMemoryOOM.main(DirectMemoryOOM.java:27)</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓四种引用类型"><a href="#📓四种引用类型" class="headerlink" title="📓四种引用类型"></a>📓四种引用类型</h2><blockquote><p>JDK1.2 之前，一个对象只有“已被引用”和”未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</p><p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p></blockquote><h3 id="📚强引用"><a href="#📚强引用" class="headerlink" title="📚强引用"></a>📚强引用</h3><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">//只要obj还指向Object对象，Object对象就不会被回收 obj = null; //手动置null</span><br></code></pre></td></tr></table></figure><h3 id="📚软引用"><a href="#📚软引用" class="headerlink" title="📚软引用"></a>📚软引用</h3><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="📚弱引用"><a href="#📚弱引用" class="headerlink" title="📚弱引用"></a>📚弱引用</h3><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="📚虚引用"><a href="#📚虚引用" class="headerlink" title="📚虚引用"></a>📚虚引用</h3><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h2 id="📓垃圾收集器与内存分配策略"><a href="#📓垃圾收集器与内存分配策略" class="headerlink" title="📓垃圾收集器与内存分配策略"></a>📓垃圾收集器与内存分配策略</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生而灭，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收问题。</p><h3 id="📚判断对象是否已死的方法"><a href="#📚判断对象是否已死的方法" class="headerlink" title="📚判断对象是否已死的方法"></a>📚判断对象是否已死的方法</h3><h4 id="📔引用计数法"><a href="#📔引用计数法" class="headerlink" title="📔引用计数法"></a>📔引用计数法</h4><p>定义：在对象中添加一个引用计数器，有一个地方引用时，计数器值加一，引用失效时减一。</p><ul><li>优点：原理简单，判定效率也很高。</li><li>缺点：难以解决对象之间互相循环引用的问题。</li></ul><h4 id="📔可达性分析算法"><a href="#📔可达性分析算法" class="headerlink" title="📔可达性分析算法"></a>📔可达性分析算法</h4><p>定义：通过一系列成为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。若某对象到GC Roots间没有任何引用链相连，证明此对象是不可能再被使用的。</p><p>GC Roots的对象分为以下几种：</p><ol><li>虚拟机栈中的引用对象，入线程调用方法堆栈的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象。如Java类的引用类型静态变量。</li><li>在方法区中常量引用对象，如字符串常量池的引用。</li><li>在本地方法栈中的JNI(Native方法)引用的对象。</li><li>Java虚拟机内部的引用，如基本类型对应的Class对象，一些常驻异常对象(<code>NullPointException</code>)等，还有系统类加载器。</li><li>所有被同步锁(synchronize关键字)持有的对象。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地缓存代码等。</li></ol><h4 id="📔三色标记算法"><a href="#📔三色标记算法" class="headerlink" title="📔三色标记算法"></a>📔三色标记算法</h4><p>三色标记算法：GCRoot如果想查找到存活对象，会根据可达分析算法分析，遍历整个引用链 ,按照是否访问过该对象分成三种不同的颜色盒子(容器)：白色、灰色、黑色盒子。</p><blockquote><p>白色：本对象没有被访问过 (没有被GCRoot扫描过，有可能是为垃圾对象)；<br>灰色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性没有被GCRoot扫描，该对象就是为灰色对象；如果该对象的属性被扫描的情况下，从灰色变为黑色。<br>黑色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性已经被GCRoot扫描过，该对象就是为黑色对象。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730951.png" alt="avatar"></p><p>三色标记算法缺陷：在并发标记阶段的时候，因为用户线程与GC线程同时运行，有可能会产生多标或者漏标；<br>多标–多标记(浮动垃圾)<br>漏标–漏标记</p><p><strong>浮动垃圾</strong></p><ol><li>并发标记：用户与GC线程同时运行，假设现在扫描到C对象，B对象变为黑色，用户线程执行C的属性E&#x3D;null,GC线程扫描C对象引用链，认为E对象是为可达对象，但是C对象根本没有引入到E对象，E对象应该是为垃圾对象，这种问题，可以在重新标记阶段(修正)修复。</li><li>并发清除阶段：用户与GC线程同时运行，会产生新的对象但是没有及时被GC清理。 只能在下一次GC清理垃圾的修复。</li></ol><p><strong>漏标问题</strong></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/mark-problem.png" alt="avatar"></p><ol><li>用户线程先执行C的E属性&#x3D;null；GC线程的GcRoot就扫描不到E。GC就认为E对象就是为垃圾对象，不可达对象。</li><li>用户线程执行B.E属性&#x3D;E；E对象就是应该是为可达对象。 因为GCRoot是从C开始，不会从黑色的B开始，就会导致漏标的情况发生。</li></ol><p>漏标的问题产生满足两个条件：</p><ol><li>至少有一个黑色对象指向了白色对象</li><li>在所有灰色对象扫描完整个链时，删除之前所有白色对象引用关系。</li></ol><p>CMS如何解决漏标问题—写屏障+增量更新方式</p><blockquote><p>满足一个条件(灰色对象与白色对象断开连接)，在并发标记阶段当我们黑色对象(B)引用关联白色对象(E)，记录下B黑色对象。<br>在重新标记阶段(所有用户线程暂停)，有将B对象变为灰色对象将整个引用链全部扫描。<br>缺点：遍历B整个链的效率非常低，有可能会导致用户线程等待的时间非常长。</p></blockquote><p>G1如何解决漏标问题—原始快照方式</p><blockquote><p>在C(灰色对象)断开E(白色)的时候，会记录原始快照，在重新标记阶段的时候以白色对象变为灰色为起始点扫描整个链，本次GC是不会被清理。<br>好处：如果假设B(黑色对象)引入该白色对象的时候，无需做任何遍历效率是非常高。<br>缺点：如果假设B(黑色对象) 没有引入该白色对象的时候，该白色对象在本次GC继续存活，只能放在下一次GC在做并发标记的时候清理。<br><strong>tips:以浮动垃圾(占内存空间)换让我们用户线程能够暂停的时间更加短。</strong></p></blockquote><p>总结： CMS收集器解决漏标问题：增量方式 如果现在B(黑色)对象引入白色对象，写屏障。</p><ul><li>好处：避免浮动垃圾</li><li>缺点扫描整个引用链效率比较低。</li></ul><p>G1收集器解决漏标问题：原始快照方式。</p><ul><li>好处：效率非常高，无需扫描整个引用链</li><li>缺点：可能会产生浮动垃圾。</li></ul><h2 id="📓回收方法区"><a href="#📓回收方法区" class="headerlink" title="📓回收方法区"></a>📓回收方法区</h2><p>方法区的回收主要是两部分内容：废弃的常量和不再使用的类型。</p><ul><li>废弃的常量的例子：字符串常量进入到常量池中，但当前系统有没有任何一个字符串对象的值为“java”，则该常量就会被系统清理出常量池。</li><li>不在使用的类，需同时满足一下三个条件：<ul><li>该类的所有实例已经被回收，也就是java对重不存在该类及其任何派生的子类实例。</li><li>加载该类的类加载器已经被回收。正常很难达成。如OSGi、JSP的重加载会产生。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h2 id="📓垃圾回收算法"><a href="#📓垃圾回收算法" class="headerlink" title="📓垃圾回收算法"></a>📓垃圾回收算法</h2><p>弱分代假说：绝大多数对象都是朝生夕灭。<br>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。<br>跨代引用假说：存在于新生代的对象可能会引用老年代的对象。因此该假说说明的是，存在互相引用关系的对象，是应该倾向于同时生存或者同时死亡。</p><blockquote><p>解决方案，在新生代上建立一个全局的数据结构(记忆集)，这个结构把老年代划分成若干小块，表示出老年代的哪一块内存会存在跨代引用。之后发生Minor GC时，只有包含跨代引用的小块内存才会加入到GC Root的扫描.</p></blockquote><h3 id="📚标记-清除算法"><a href="#📚标记-清除算法" class="headerlink" title="📚标记-清除算法"></a>📚标记-清除算法</h3><p><strong>算法实现</strong>：分为标记-清除两个阶段，首先根据上面的根搜索算法标记出所有需要回收的对象，在标记完成后，然后在统一回收掉所有被标记的对象。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730190.jpeg" alt="img"></p><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。</p><p><strong>不足：</strong></p><ul><li><strong>效率问题</strong>：标记和清除的效率都不高</li><li><strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集。</li></ul><h3 id="📚复制算法"><a href="#📚复制算法" class="headerlink" title="📚复制算法"></a>📚<strong>复制算法</strong></h3><p><strong>算法实现</strong>：将可用内存按容量划分为大小相等的两块区域，每次只使用其中一块，当这一块的内存用完了，就将还活着的对象复制到另一块区域上，然后再把已使用过的内存空间一次性清理掉。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730608.jpeg" alt="img"></p><p><strong>优点</strong>：每次都是只对其中一块内存进行回收，不用考虑内存碎片的问题，而且分配内存时，只需要移动堆顶指针，按顺序进行分配即可，简单高效。</p><p><strong>缺点</strong>：将内存分为两块，但是每次只能使用一块，也就是说，机器的一半内存是闲置的，这资源浪费有点严重。并且如果对象存活率较高，每次都需要复制大量的对象，效率也会变得很低。</p><h3 id="📚标记-整理算法"><a href="#📚标记-整理算法" class="headerlink" title="📚标记-整理算法"></a>📚标记-整理算法</h3><p><strong>算法实现</strong>：首先标记出所有存活的对象，然后让所有存活对象向一端进行移动，最后直接清理到端边界以外的内存。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730009.jpeg" alt="img"></p><p>　<strong>局限性</strong>：只有对象存活率很高的情况下，使用该算法才会效率较高。</p><h3 id="📚分代收集算法"><a href="#📚分代收集算法" class="headerlink" title="📚分代收集算法"></a>📚分代收集算法</h3><p><strong>算法实现</strong>：根据对象的存活周期不同将内存分为几块，然后不同的区域采用不同的回收算法。</p><ol><li>对于存活周期较短，每次都有大批对象死亡，只有少量存活的区域，采用复制算法，因为只需要付出少量存活对象的复制成本即可完成收集；</li><li>对于存活周期较长，没有额外空间进行分配担保的区域，采用标记-整理算法，或者标记-清除算法。</li></ol><p>　比如，对于 HotSpot 虚拟机，它将堆空间分为如下两块区域：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730405.png" alt="image-20220902215350103"></p><p>堆有新生代和老年代两块区域组成，而新生代区域又分为三个部分，分别是 Eden,From Surivor,To Survivor ,比例是8:1:1。</p><p>　　新生代采用复制算法，每次使用一块Eden区和一块Survivor区，当进行垃圾回收时，将Eden和一块Survivor区域的所有存活对象复制到另一块Survivor区域，然后清理到刚存放对象的区域，依次循环。</p><p>​老年代采用标记-清除或者标记-整理算法，根据使用的垃圾回收器来进行判断。</p><h3 id="📚新生代垃圾回收"><a href="#📚新生代垃圾回收" class="headerlink" title="📚新生代垃圾回收"></a>📚新生代垃圾回收</h3><ol><li>eden、 survivor From 复制到 survivor To，年龄+1。</li></ol><blockquote><p>首先，把 Eden 和 survivor From 区域中存活的对象复制到 survivor To 区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代区)，同时把这些对象的年龄+1(如果 ServicorTo 不够位置了就放到老年区)；</p></blockquote><ol><li>清空 eden、 survivor From。</li></ol><blockquote><p>然后，清空 Eden 和 survivor From 中的对象；</p></blockquote><ol><li>survivor To 和 survivor From 互换</li></ol><blockquote><p>最后， survivor To 和 survivor From 互换，原 survivor To 成为下一次 GC 时的 survivor From区。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></p></blockquote><p><strong>相关问题</strong></p><p>为什么需要Survivor区域？</p><blockquote><p>防止对象过早进入Old，导致Old频繁Full GC。Survivor具有预筛选保证，只有对象到一定岁数才会送往老年代，Survivor区可以减少被送到老年代的对象，进而减少Full GC发生。</p></blockquote><p>为什么需要两个Survivor区域？</p><blockquote><p>如果只有一个Survivor，每次垃圾回收年龄+1，会有部分对象进入老年代，导致Survivor的空间变成碎片化空间，最后触发minor gc。使用两个Survivor并进行交换，就保证了两个Survivor区，一个为空，另一个是非空且无碎片保存的。</p></blockquote><h2 id="📓GC垃圾收集器"><a href="#📓GC垃圾收集器" class="headerlink" title="📓GC垃圾收集器"></a>📓GC垃圾收集器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；<br>年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/garbage-collector.jpg" alt="avatar"></p><h3 id="📚Serial收集器"><a href="#📚Serial收集器" class="headerlink" title="📚Serial收集器"></a>📚Serial收集器</h3><ul><li>定义:一个单线程的垃圾收集器，在垃圾收集时必须暂停其他所有工作线程，直到收集结束。</li><li>对于新生代采取复制算法暂停所有线程，对于老年代使用标记-整理算法同样暂停所有线程。</li><li>缺点：需要暂停用户线程。</li><li>优点：<ol><li>简单高效、对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。</li><li>单核处理器或者处理器核心较少的环境来说，Serial由于没有线程交互的开销，可以专心做垃圾回收自然可以获得最高的单线程收集效率。</li></ol></li></ul><h3 id="📚Serial-Old收集器"><a href="#📚Serial-Old收集器" class="headerlink" title="📚Serial Old收集器"></a>📚Serial Old收集器</h3><ul><li>定义：使用标记-整理算法。</li><li>用途：可以Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器发生失败的后背方案。<img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/serial-1.jpg" alt="avatar"></li></ul><h3 id="📚ParNew收集器"><a href="#📚ParNew收集器" class="headerlink" title="📚ParNew收集器"></a>📚ParNew收集器</h3><ul><li><p>定义：Serial收集器的多线程并行版本。</p></li><li><p>唯一的优点仅有ParNew和Serial可以和CMS收集器配合工作，以后ParNew将会合并入CMS，成为其处理新生代的组成部分。</p></li><li><p>随着可以被使用的处理核心增加，ParNew对于垃圾收集时系统可以高效利用，默认开启的收集线程数和处理器核心数量相同。</p></li><li><p>新生代：标记复制。老年代：标记-整理</p></li><li><p>常使用参数：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parNew-1.jpg" alt="avatar"></p></li></ul><h3 id="📚Parallel-Scavenge-收集器"><a href="#📚Parallel-Scavenge-收集器" class="headerlink" title="📚Parallel Scavenge 收集器"></a>📚Parallel Scavenge 收集器</h3><p>定义：新生代收集器，同样基于标记-复制算法，能够并行收集的多线程收集器。特点是达到一个可控制的吞吐量。 <code>吞吐量= 运行客户代码时间/(运行用户代码时间+运行垃圾收集时间)</code></p><p>虚拟机完成用户任务及垃圾收集用了100分钟，其中垃圾收集用了1分钟，吞吐量&#x3D;99%</p><ul><li>-XX:MaxGCPauseMills：控制最大垃圾收集时间参数</li></ul><blockquote><p>允许设置的是一个大于0的毫秒数，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换区的。调小新生代会缩短垃圾回收时间，若调的太小会导致垃圾收集变得频繁。</p></blockquote><ul><li>-XX:GCTimeRatio：设置吞吐量大小时间<ul><li>设置的值应当是大于0小于100的整数，也就是垃圾回收时间占总时间的比率为吞吐量的倒数。</li><li>设置成19，那允许垃圾回收时间为总时间的5%(1&#x2F;(1+19))，默认值为99,允许最大1%的时间进行垃圾回收。</li></ul></li><li>-XX:+UseAdaptiveSizePolicy: 开启自适应的调整策略。</li></ul><h3 id="📚Parallel-Old收集器"><a href="#📚Parallel-Old收集器" class="headerlink" title="📚Parallel Old收集器"></a>📚Parallel Old收集器</h3><p>定义：Parallel Scavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。</p><blockquote><p>与Parallel Scavenge搭配作为“吞吐量优先”的收集器搭配组合</p></blockquote><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parallel.jpg" alt="avatar"></p><h3 id="📚CMS-Concurrent-Mark-Sweep-收集器"><a href="#📚CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="📚CMS(Concurrent Mark Sweep)收集器"></a>📚CMS(Concurrent Mark Sweep)收集器</h3><p>定义：一种以获取最短回收停顿时间为目标的收集器，工作于老年代。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行过程解析，基于标记-清除算法实现，具体大流程步骤如下：</p><ol><li>初始标记：仅仅标记一下GC Root对象能直接关联到的对象，速度很快，需要暂停所有线程。</li><li>并发标记：从GC Root关联对象开始遍历整个对象图的过程，可以与用户线程共同执行。</li><li>重新标记：因用户程序继续运行而导致标记产生变动的那部分对象的标记记录，通常比初始标记长远比并发标记段。</li><li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动对象，因此可以与用户线程共同执行。\</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/cms-1.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>主要流程:</p><ol><li>初始标记：STW，标记根对象。</li><li>并发标记：标记所有对象。</li><li>预清理：清理前准备以及控制停顿时间</li><li>重新标记：STW，修正并发标记数据</li><li>并发清理：清理垃圾</li><li>并发重置</li></ol><p>预清理：预清理是并发的，除了为正式清理做准备和检查以外，与清理还会尝试控制一次停顿时间。由于重新标记是独占CPU的，<strong>如果新声代GC后，立即触发一次重新标记，那么一次停顿时间可能很长</strong>。为了避免这种情况，预清理时，会可以等待一次新声代GC的发生，然后根据历史性能数据预测下一次新生代GC可能发生的时间，在当前时间和预测时间的中间时刻进行重新标记。最大程度上避免新生代GC和重新标记重合，尽可能减少一次停顿时间。</p><blockquote><p>开关<code>-XX:-CMSPrecleaningEnabled</code> 用来开关预清理</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730258.png" alt="avatar"></p><p>特点：</p><ol><li>对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用CPU不超过25%。若核心数量小于4，则占用CPU过大。</li><li>无法处理“浮动垃圾”，有可能出现并发模式失败进而导致一次Full GC。浮动垃圾为出现在标记过程结束之后产生的对象。因为CMS要支持收集过程中与用户线程并存，因此不能在老年代几乎被填满时再运行，需要预留一部分空间供并发收集的程序运行。</li></ol><blockquote><p>JDK5中设置CMS在老年代使用了68%便会激活，JDK6默认的设置提高到92%。当运行预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”。后备预案为冻结用户线程，启用Serial Old进行老年代的垃圾收集。<br>并发收集失败：收集过程中，老年代被填满；收集完成后，收集的空间仍然无法满足被使用；浮动垃圾</p></blockquote><ul><li>参数-XX:CMSFullGCsBeforeCompaction：作用是要求CMS收集器在执行过若干次不整理的Full GC之后，下一次先进行碎片整理</li></ul><p>常用参数:</p><ul><li><code>-XX:+UseConcMarkSweepGC</code>: 启用 CMS 回收器</li><li><code>-XX:ConcGCThreads</code>和<code>-XX:ParallelCMSThreads</code>：用来指定GC并发线程数量</li><li><code>-XX:CMSinitiatingOccupancyFraction</code>：可以设置触发CMS收集的百分比。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>： 参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。(默认值为0，表示每次FullGC都进行碎片整理)</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：开关可以使CMS在垃圾收集完成后，进行一次内存碎片整理，内存碎片的整理不是并发进行的。</li><li><code>-XX:-CMSPrecleaningEnabled</code>：用来开关预清理</li></ul><h3 id="📚Garbage-First-收集器"><a href="#📚Garbage-First-收集器" class="headerlink" title="📚Garbage First 收集器"></a>📚Garbage First 收集器</h3><p>G1是一种兼顾吞吐量和停顿时间的GC实现。<br>定义：面向服务端应用的垃圾收集器，基于Region的堆内存布局进行垃圾收集，每一个Region都可以根据需要扮演新生代的Eden空间、Survivor空间和老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要超过了一个Region一半的对象即可认为是大对象。对于Humongous区域，正常当做老年代一部分。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行步骤：</p><ol><li>初始标记：标记GC Root对象能直接关联的对象并修改TAMS指针的值为正确的空区域。需要暂停线程，但是时间很短，借用进行Minor GC时同步完成。</li><li>并发标记：根据GC Root进行可达性分析，扫描对象图。完成扫描后，处理SATB记录下并发时有引用变动的对象。</li><li>最终标记：短暂暂停用户线程，处理并发阶段结束后，少量的SATB记录。</li><li>筛选回收：更新Region的统计数据，进行回收价值和成本的排序，根据用户期望的停顿时间来构建回收集合。回收集合的存活对象复制到空的Region，再清理旧的Region。涉及到对象移动，需要暂停用户线程，使用多线程并行完成移动。</li></ol><p>G1整体是基于标记-整理算法实现的收集器，但从局部优势基于标记-复制算法实现。在执行标记整理的时候，还进行了压缩的工作，这是之前的垃圾收集器都没有的。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1.jpg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-memory.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>收集过程：</p><ol><li>新生代GC</li><li>并发标记周期</li><li>混合收集</li><li>如果需要会进行Full GC</li></ol><p><strong>并发标记周期</strong></p><p>执行流程</p><ol><li>初始标记: 标记从根节点直接可达的对象。这个阶段会伴随一次新生代GC，产生全局停顿。</li><li>根区域扫描: 由于初始标记必然伴随一次新生代GC，存活对象均移入survivor区。将扫描由<strong>survivor区</strong>直接可达的老年代区域(根区域扫描依赖survivor区对象)。如果同时需要新生代GC，那么GC就需要等待根区域扫描结束后才能进行。</li><li>并发标记: 扫描并查找整个堆的存活对象，并发过程可被新生代GC打断。</li><li>重新标记: CMS一样，重新标记也是会产生应用程序停顿的由于在并发标记过程中，应用程序依然在运行，因此标记结果可能需要进行修正，所以在此对上一次的标记结果进行补充。在G1中，这个过程使用SATB(Snapshot At-The-Beginning)算法完成,G1会在标记之初为存活对象创建个快照，这个快照有助于加速重新标记的速度。</li><li>独占清理: 这个阶段是会引起停顿的，它将计算各个区域的存活对象和GC回收比例并进行排序，识别可供混合回收的区域 在这个阶段，还会更新记忆集(Remembered Set), 该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段，需要这些信息。</li><li>井发清理阶段: 这里会识别并清理完全空闲的区域 它是井发的清理，不会引起停顿。</li></ol><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png" alt="avatar"></a></p><p>由于并发标记周期包含一次新生代GC，故新生代会被整理。但由于并发标记周期执行时，应用程序依然在运行。因此，并发标记周期结束后，又会有新的Eden空间被使用。并发标记周期执行前后最大的不同是在该阶段后，系统增加了一些标记为G的区域。这些区域被标记，是因为它们内部的垃圾比例较高，因此希望在后续的混合GC中进行收集(注意在并发标记周期中并未正式收集这些区域〉。</p><p><strong>并发回收阶段前后的可能情况</strong> <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-alloc.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729043.png" alt="avatar"></a></p><p><strong>混合回收</strong></p><p>定义：在并发标记周期中，虽然有部分对象被回收，但是总体上说，回收的比例是相当低的。但是在并发标记周期后，己经明确知道哪些区域含有比较多的垃圾对象，在混合回收阶段，就可以专门针对这些区域进行回收。当然G1会优先回收垃圾比例较高的区域，因为回收这些区域的性价比也比较高。这个阶段叫作混合回收。</p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png" alt="avatar"></a></p><p>混合GC会执行多次，直到回收了足够多的内存空间，然后，它会触发一次新生代GC。新生代GC后，又可能会发生一次并发标记周期的处理。最后，又会起混合GC的执行。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png" alt="avatar"></a></p><p><strong>必要时的Full GC</strong></p><p>并发收集由于让应用程序和GC线程交替工作，因此总是不能完全避免在特别繁忙的场合会出现在回收过程中内存不充足的情况。当遇到这种情况时，G1会转入一个Full GC进行回收。</p><blockquote><p>如果在混合GC时发生空间不足或者在新生代GC时，survivor区和老年代无法容纳幸存对象，都会导致一次Full GC产生。</p></blockquote><p>记忆集是G1中维护的一个数据结构，简称RS(Remembered Set)。每一个G1区域都有一个RS与之关联。<br>作用：由G1回收时，是按照区域回收的，如在回收区域A的对象 ，很可能并不回收区域B的对象。为了避免在整个堆中进行对象的可达性扫描。因此，G1在区域RS中，记录了在区域A中被其他区域引用的对象，这样在回收区域A时，只要将RS视为区域A根集的一部分即可，从而可避免做整个堆的扫描。</p><p>G1日志的一些术语：</p><ul><li>CT(Card Table): RS 就是依靠 CardTab 来记录哪些是存活对象的：</li><li>CSet(Collection Sets): Collection Sets表示被选取的、将要被收集的区域的集合</li><li>Ref Proc(处理弱引用、软引用的时间)</li><li>RefEnq(弱引用、软引用入队时间)</li><li>Free CSet(释放被回收的CSet中区域的时间，包括它们的RS)。</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">1 .<span class="hljs-number"> 619 </span>: [GC pause (young) (init al-mark)<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 03848843 </span>secs] <br>[Parallel Time :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>ms] <br>[GC Worker Start (ms) : 1619.3<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Max :<span class="hljs-number"> 1619 </span>. 3, Diff : 0.0] <br>[Ext Root Scanning (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>0.3 0.2<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span>, Max :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Diff : 0.1] <br>[Update RS (ms) :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 7 </span>5 .<span class="hljs-number"> 4 </span>2<span class="hljs-number"> 8 </span>. O<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 11 </span>.<span class="hljs-number"> 1 </span>, Min :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span>, Max:<span class="hljs-number"> 28 </span>.<span class="hljs-number"> 0 </span>, Diff : 22.8] <br>[Processed Buffers :<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 1 </span>4 <br>Sum :<span class="hljs-number"> 14 </span>, Avg :<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1 </span>, Max : 5, Diff : 4] <br>[Scan RS (ms) :<span class="hljs-number"> 4 </span>.<span class="hljs-number"> 6 </span>5 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>5 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 3 </span>.<span class="hljs-number"> 7 </span>, Min : 0.0 , Max:<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 2 </span>, Diff :<span class="hljs-number"> 5 </span>. 2] <br>[Object Copy (ms): 27.4<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 3 </span>9 .<span class="hljs-number"> 6 </span>27 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 22 </span>.<span class="hljs-number"> 9 </span>, Min :<span class="hljs-number"> 9 </span>.<span class="hljs-number"> 6 </span>, Max :<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 4 </span>, Diff : 17.7) <br>[Term nat on (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 1 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Min: 0.0 , Max:<span class="hljs-number"> 0 </span>. 1, Diff : 0.1] <br>[Termination Attempts :<span class="hljs-number"> 3 </span>1<span class="hljs-number"> 10 </span>5 <br>Sum :<span class="hljs-number"> 19 </span>, Avg:<span class="hljs-number"> 4 </span>, Min :<span class="hljs-number"> 1 </span>, Max :<span class="hljs-number"> 10 </span>, Diff: 9] <br>[GC Worker End (ms): 1657.<span class="hljs-number"> 3 </span>1657.<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span><br>Avg : 1657.2, Min:<span class="hljs-number"> 1657 </span>. 2, Max : 1657.3, Diff:<span class="hljs-number"> 0 </span>. 0) <br>[GC Worker (ms) :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>38 .<span class="hljs-number"> 0 </span>38.0<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span><br>Avg :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Min :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Max :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Diff :<span class="hljs-number"> 0 </span>. 1] <br>[GC Worker Other (ms) : 0.0<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.1<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span><br>Avg : 0.1 , Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Max : 0.1 , Diff : 0.1) <br>[Clear CT : 0.0 ms] <br>[Other :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 4 </span>ms] <br>[Choose CSet : 0.<span class="hljs-number"> 0 </span>ms] <br>[Ref Proc :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Ref Enq:<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>ms] <br>[Free CSet :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Eden : 32M(35M) - &gt;0B(35M) Survivors : 5120K-&gt;5120K Heap : 147M(200M) - &gt;147M <br>(200M )) <br>[Times : user=0 .<span class="hljs-number"> 16 </span>sys=0 .<span class="hljs-number"> 00 </span>, real=0 .<span class="hljs-number"> 04 </span>secs]<br></code></pre></td></tr></table></figure><hr><p>特点:</p><ol><li>避免在整个Java堆进行全区域的垃圾回收，而是让G1跟踪每个Region的垃圾回收的价值及回收所需的时间，在后台维护一个优先级表。根据用户设定的允许收集停顿时间，优先回收价值收益最大的Region。(使用参数-XX:MaxGCPauseMills指定)</li><li>G1收集器每个Region都需要自己的记忆集，记录跨区域引用，因此比其他收集器要耗费内存，大约为java堆内存容量10%~20%。</li><li>通过在Region中划分空间(使用两TAMS指针，标记一块区域)用于并发回收的新对象分配，解决并发标记阶段与用户线程互不干扰。同样若内存分配速度大于内存回收速度，可能冻结用户线程进行Full GC。</li><li>CMS使用增量更新算法，而G1使用原始快照(SATB)算法来解决，用户线程改变对象的引用关系，不打破原有的对象图结构，防止标记错误。</li><li>通过可靠停顿预测模型的建立：根据每个Region的回收成本，分析出收集的平均值、标准偏差、置信度等统计信息。</li></ol><ul><li>缺点：内存占用过高，在小内存应用上CMS的表现大于G1。</li></ul><p>常用参数：</p><ul><li><code>-XX:+UseG1GC</code>：标记打开 GI 集器开关</li><li><code>-XX:G1HeapRegionSize</code>: 参数Region的大小可通过该参数设定，取值范围为1M~32M，为2的N次幂。</li><li><code>-XX:MaxGCPauseMills</code>：设置用户设定的允许收集停顿时间时，默认为200毫秒。调的调小会导致每次的回收集只占内存的很小一部分，收集的速度慢于分配的速度导致垃圾堆积，进而引发Full GC。正常设置为100~300毫秒之间。</li><li><code>-XX:ParallelGCThreads</code>：用于设置并行回收时，GC的工作线程数量。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值是45，即当整个堆占用率达到45%时，执行并发标记周期。</li></ul><h3 id="📚CMS-与-G1-对比"><a href="#📚CMS-与-G1-对比" class="headerlink" title="📚CMS 与 G1 对比"></a>📚CMS 与 G1 对比</h3><p>G1计划作为并发标记扫描收集器(CMS)的长期替代品。</p><ol><li>垃圾回收理念不同：CMS基于分代收集理念设计。G1基于分区收集理念设计。</li><li>整理：G1在GC的时候都会做垃圾的碎片整理，而CMS收集器只在Full GC STW时才会做内存压缩整理。</li><li>可停顿时间：G1是一种兼顾吞吐量和停顿时间的 GC 实现，其可靠停顿预测模型可以设定目标收集停顿时间，可以实现更短的GC停顿。</li><li>对象记录算法：对于对象记录CMS使用增量更新算法，而G1使用原始快照(SATB,snapshot-at-the-beginning)记录存活对象。</li><li>收集方式：G1使用混合收集的方式。G1可以扫描年轻代和一小部分老年代，但这意味着比简单地只扫描老年代、完全的快得多。</li><li>String重复数据删除。G1可以配置针对String的重复数据进行删除，而重复的数据将指向同一个char[] array。<code>-XX:+UseStringDeduplication</code></li></ol><ul><li>CMS对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用内存不超过25%。若核心数量小于4，则占用内存过大。</li><li>G1针对具有大内存的多处理器机器，因为其<code>Remembered Sets</code>的记忆集的设计，需要占用更多内存。</li></ul><h3 id="📚其他的垃圾收集器"><a href="#📚其他的垃圾收集器" class="headerlink" title="📚其他的垃圾收集器"></a>📚其他的垃圾收集器</h3><ul><li>Shenandoah 收集器：仅存在OpenJdk，区别G1的特点为支持并发整理，使用转发指针和读屏障实现。</li><li>ZGC 收集器：Region具有动态性，并分为大中小三个Region，使用染色指针技术实现并发整理算法。</li><li>Epsilon收集器：无操作收集器。</li></ul><h3 id="📚选用收集器的三个因素"><a href="#📚选用收集器的三个因素" class="headerlink" title="📚选用收集器的三个因素"></a>📚选用收集器的三个因素</h3><ol><li>如果是数据分析、科学计算类任务，目标是尽快可以算出结果，那么吞吐量为主要关注点。如果为SLA应用，停顿时间直接影响任务质量，严重甚至会导致事务超时，那么延迟是主要的关注点。</li><li>使用运行的基础设施的指标。</li><li>JDK对应的版本。</li></ol><h3 id="📚java虚拟机监控工具"><a href="#📚java虚拟机监控工具" class="headerlink" title="📚java虚拟机监控工具"></a>📚java虚拟机监控工具</h3><h4 id="📔jps"><a href="#📔jps" class="headerlink" title="📔jps"></a>📔jps</h4><p>jps (JVM Process Status): 类似 UNIX 的 ps 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -l<br><span class="hljs-number">3796</span> sun.tools.jps.Jps<br><span class="hljs-number">2903</span> org.apache.catalina.startup.Bootstrap<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -m<br><span class="hljs-number">3811</span> Jps -m<br><span class="hljs-number">2903</span> Bootstrap start<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -v<br><span class="hljs-number">3828</span> Jps -Dapplication.home=/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_221</span>-amd64 -Xms8m<br><span class="hljs-number">2903</span> Bootstrap -Djava.util.logging.config.file=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=<span class="hljs-number">2048</span> -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=<span class="hljs-number">0027</span> -Dignore.endorsed.dirs= -Dcatalina.base=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Dcatalina.home=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Djava.io.tmpdir=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/temp<br></code></pre></td></tr></table></figure><h4 id="📔jstat"><a href="#📔jstat" class="headerlink" title="📔jstat"></a>📔jstat</h4><p>jstat( JVM Statistics Monitoring Tool): 用于收集 HotSpot 虚拟机各方面的运行数据;</p><p>jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jstat -gc -h3 <span class="hljs-number">2903</span> <span class="hljs-number">1000</span> <span class="hljs-number">10</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br></code></pre></td></tr></table></figure><h4 id="📔jinfo"><a href="#📔jinfo" class="headerlink" title="📔jinfo"></a>📔jinfo</h4><p>jinfo (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Users\SnailClimb&gt;jinfo  -flag MaxHeapSize <span class="hljs-number">17340</span><br>-XX:MaxHeapSize=<span class="hljs-number">2124414976</span><br>C:\Users\SnailClimb&gt;jinfo  -flag PrintGC <span class="hljs-number">17340</span><br>-XX:-PrintGC<br></code></pre></td></tr></table></figure><h4 id="📔jmap-和-jhat"><a href="#📔jmap-和-jhat" class="headerlink" title="📔jmap 和 jhat"></a>📔jmap 和 jhat</h4><p>jmap (Memory Map for Java) :生成堆转储快照;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jmap -dump:format=b,file=elasticfoam.bin <span class="hljs-number">2903</span><br>Dumping heap to /usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/elasticfoam.bin ...<br>Heap dump file created<br></code></pre></td></tr></table></figure><p>jhat (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果;<br>与上面的jmap配合使用，分析heapdump的堆信息，会生成具体的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jhat elasticfoam.bin <br>Reading from elasticfoam.bin...<br>Dump file created Sat Nov <span class="hljs-number">07</span> <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">33</span> CST <span class="hljs-number">2020</span><br>Snapshot read, resolving...<br>Resolving <span class="hljs-number">131419</span> objects...<br>Chasing references, expect <span class="hljs-number">26</span> dots..........................<br>Eliminating duplicate references..........................<br>Snapshot resolved.<br>Started HTTP server on port <span class="hljs-number">7000</span><br>Server is ready.<br></code></pre></td></tr></table></figure><h4 id="📔jstack"><a href="#📔jstack" class="headerlink" title="📔jstack"></a>📔jstack</h4><p>jstack (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333e668</span> (object <span class="hljs-number">0x00000000d5efe1c0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 1&quot;</span><br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333be88</span> (object <span class="hljs-number">0x00000000d5efe1d0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 2&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">1</span>(DeadLockDemo.java:<span class="hljs-number">31</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">1078694789.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">0</span>(DeadLockDemo.java:<span class="hljs-number">16</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1324119927.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><p>一个linux的排除高CUP线程的排查案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">top -c <span class="hljs-comment">//查看所有进程</span><br>top -Hp <span class="hljs-title function_">xxx</span><span class="hljs-params">(PID)</span>  <span class="hljs-comment">// 查看进程具体的线程ID cup情况</span><br>jstack -l pid &gt; filename <span class="hljs-comment">// 输出当前快照</span><br>cat filename| grep <span class="hljs-string">&#x27;线程ID(16进制)&#x27;</span> -C <span class="hljs-number">8</span>     <span class="hljs-comment">// 查找匹配线程，-C 查看前后多少行数据</span><br></code></pre></td></tr></table></figure><h4 id="📔jconsole"><a href="#📔jconsole" class="headerlink" title="📔jconsole"></a>📔jconsole</h4><p>JConsole:Java 监视与管理控制台，很强大，可以检测死锁，查看堆的内存释放情况。</p><blockquote><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.rmi.server.hostname=外网访问 ip 地址 <br>-Dcom.sun.management.jmxremote.port=<span class="hljs-number">60001</span>   <span class="hljs-comment">//监控的端口号</span><br>-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>   <span class="hljs-comment">//关闭认证</span><br>-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="📓类文件"><a href="#📓类文件" class="headerlink" title="📓类文件"></a>📓类文件</h2><h3 id="📚类文件结构"><a href="#📚类文件结构" class="headerlink" title="📚类文件结构"></a>📚类文件结构</h3><p>方法体出现ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/synchronizeMethod.jpg" alt="avatar"></p><p>方法体对应的访问范围 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729362.jpeg" alt="avatar"></p><h3 id="📚双亲委派模型"><a href="#📚双亲委派模型" class="headerlink" title="📚双亲委派模型"></a>📚双亲委派模型</h3><p>站在虚拟机角度，只存在两种不同的类加载器：</p><ol><li>启动类加载器BootStrap ClassLoader，由虚拟机实现，是虚拟机自身一部分。</li><li>其他所有的类加载器，由Java语言实现，独立于虚拟机之外，都是继承自抽象类java.lang.ClassLoader。</li></ol><p>java相关的三层类加载器</p><ul><li>启动类加载器BootStrap ClassLoader：负责加载存放在<code>&lt;JAVA HOME&gt;\lib</code>目录，或者被<code>-Xbootclaspath</code>参数，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要交给引导类加载器去处理，那直接使用<code>null</code>替代即可。</li><li>扩展类加载器Extension ClassLoader：负责加载<code>&lt;JAVA HOME&gt;\lib\ext</code>目录，或者被<code>java.ext.dirs</code>系统变量所指定的目录中所有的类库。</li><li>应用程序类加载器Application ClassLoader：负责加载用户类路径ClassPath上所有的类库。</li></ul><p>双亲委派模型加载过程：</p><ol><li>如果一个类加载器接收到类加载请求，它首先不会自己尝试加载这个类，而是把请求委托到父类执行。</li><li>每一层次的类加载器都会委托其父类加载器去完成，最终传到最顶层的启动类加载器中。</li><li>只有当所有父加载器都无法自己完成这个类加载请求，子加载器才会进行加载。</li></ol><p><strong>作用</strong>：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器(Bootstrcp ClassLoader)加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729346.jpeg" alt="avatar"></p><p>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚双亲委派模型缺陷"><a href="#📚双亲委派模型缺陷" class="headerlink" title="📚双亲委派模型缺陷"></a>📚双亲委派模型缺陷</h3><p>双亲委派模型很好的解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的类加载器进行加载)<br>双亲委派模型检查类是否己经加载的委托过程是单向的，这种方式虽然从结构上说比较清楚，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。而且<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访应用类就会出现问题。</p></blockquote><p>解决方法：引入从线程上下文获取classLoader</p><h3 id="📚破坏双亲委派模型"><a href="#📚破坏双亲委派模型" class="headerlink" title="📚破坏双亲委派模型"></a>📚破坏双亲委派模型</h3><p>破坏双亲委派模型，就是要实现自己的ClassLoader重写loadClass，在方法中重写自己加载的逻辑。这样类加载过程中就不会通过委派父类加载的方式进行加载数据。</p><p>三次破坏双亲委派模型：</p><ol><li>第一次破坏。JDK1.2时期，双亲委派模型出现前，用户自定义了一些类加载器。在引入双亲委派模型，为了兼容用户自定义的类加载器，添加新的<code>findClass()</code>方法，并引导用户重写该方法，而不是重写<code>loadClass()</code>方法。</li><li>第二次破坏，为该模型的缺陷导致。父类加载器无法访问底层类加载器负责的类</li><li>第三次破坏，引入热部署的机制。违反双亲委派的类加载过程。</li></ol><h4 id="📔JDBC破坏双亲委派模型"><a href="#📔JDBC破坏双亲委派模型" class="headerlink" title="📔JDBC破坏双亲委派模型"></a>📔JDBC破坏双亲委派模型</h4><p>不破坏双亲委派模型的情况(不使用JNDI服务)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.加载数据访问驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">//2.连接到数据&quot;库&quot;上去</span><br>Connection conn= DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDBC需要破坏双亲委派模式：<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>原生的JDBC中的类是放在<strong>rt.jar包</strong>(对应由启用类加载器BootStrapClassLoader)的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。</p></blockquote><blockquote><p>在JDBC4.0以后，开始支持使用SPI(Service Provider Interface)的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF&#x2F;services&#x2F;java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用如下：<br><code>Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;, &quot;root&quot;, &quot;&quot;);</code></p></blockquote><p>如何解决父加载器无法加载子级类加载器路径中的类？</p><blockquote><p>引入线程上下文件类加载器(Thread Context ClassLoader).在mysql jdbc连接中获取当前的类加载器，这就破坏的双亲委派的类加载过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(</span><br><span class="hljs-params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * When callerCl is null, we should check the application&#x27;s</span><br><span class="hljs-comment">     * (which is invoking this class indirectly)</span><br><span class="hljs-comment">     * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="hljs-comment">     * can be loaded from here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//callerCL为空的时候，其实说明这个ClassLoader是启动类加载器，但是这个启动类加载并不能识别rt.jar之外的类，这个时候就把callerCL赋值为Thread.currentThread().getContextClassLoader();也就是应用程序启动类</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">callerCL</span> <span class="hljs-operator">=</span> caller != <span class="hljs-literal">null</span> ? caller.getClassLoader() : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span>(DriverManager.class) &#123;<br>        <span class="hljs-comment">// synchronize loading of the correct classloader.</span><br>        <span class="hljs-keyword">if</span> (callerCL == <span class="hljs-literal">null</span>) &#123;<br>            callerCL = Thread.currentThread().getContextClassLoader();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="📔自定义类加载器"><a href="#📔自定义类加载器" class="headerlink" title="📔自定义类加载器"></a>📔自定义类加载器</h4><ol><li>加载非classpath下的类，从非标准的来源加载代码</li><li>加载加密过的类文件，使用秘钥进行解密。</li><li>热部署，简单粗暴的方法是自定义类加载器，加载目录外的类对象。使用定时任务或者触发起的方法，每次创建新的类加载器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> String classPath;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(String classPath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.classPath = classPath;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>        name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(classPath + <span class="hljs-string">&quot;/&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> fis.available();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>        fis.read(data);<br>        fis.close();<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            data = loadByte(name);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚类初始化的时机"><a href="#📚类初始化的时机" class="headerlink" title="📚类初始化的时机"></a>📚类初始化的时机</h3><p>虚拟机严格规范了有且只有6种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code> 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li></ol><ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行<code>getstatic</code>指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行<code>putstatic</code>指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行<code>invokestatic</code>指令时会初始化类。即程序调用类的静态方法。</li></ul><ol><li>使用 java.lang.reflect 包的方法对类进行反射调用时如<code>Class.forname(&quot;...&quot;).newInstance()</code>等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用<code>findStaticVarHandle</code>来初始化要调用的类。</li><li>当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="📚类的生命周期"><a href="#📚类的生命周期" class="headerlink" title="📚类的生命周期"></a>📚类的生命周期</h3><p>类的生命周期： 加载、连接[验证、准备、解析]、初始化、使用、卸载。</p><h4 id="📔加载"><a href="#📔加载" class="headerlink" title="📔加载"></a>📔加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><h4 id="📔验证"><a href="#📔验证" class="headerlink" title="📔验证"></a>📔验证</h4><p>验证的范围：文件格式、元数据、字节码、符号引用验证</p><h4 id="📔准备"><a href="#📔准备" class="headerlink" title="📔准备"></a>📔准备</h4><p>准备阶段是正式为类变量(即静态变量)分配内存并设置类变量初始值的阶段，jdk8中这些内存都将在java堆中分配。对于该阶段有以下几点需要注意：</p><ul><li>进行内存分配的仅包括类变量(static)，而不包括实例变量</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值(如0、0L、null、false等)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器&lt;client&gt;方法之中</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080</span><br><br></code></pre></td></tr></table></figure><h4 id="📔解析"><a href="#📔解析" class="headerlink" title="📔解析"></a>📔解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>以方法解析为例：</p><ol><li>解析出方法表的class_index项中索引的方法所属的类或接口的符号引用。</li><li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果存在返回直接引用。</li><li>同上在类C的父类查找直接引用。</li><li>上述简述了类的查找，具体细节见书本。返回直接引用后，会验证方法的访问权限，即<code>private、protected、public</code>，如果发现不具备方法的访问级别，抛出<code>IllegalAccessError</code>异常。</li></ol><h4 id="📔初始化"><a href="#📔初始化" class="headerlink" title="📔初始化"></a>📔初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤，这个阶段Java虚拟机才开始真正执行类中编写的java程序，将主导权移交给应用程序。</p><p>在准备阶段已经赋初始化零值的变量，在初始化阶段，会根据程序去初始化类变量和其他资源。<br>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。该方法是由编译器收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。</p><h4 id="📔卸载"><a href="#📔卸载" class="headerlink" title="📔卸载"></a>📔卸载</h4><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ul><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ul><h2 id="📓对象创建及使用"><a href="#📓对象创建及使用" class="headerlink" title="📓对象创建及使用"></a>📓对象创建及使用</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/objcreate.jpg" alt="avatar"></p><p>对象的创建</p><ol><li>类加载检查：虚拟机遇到new命令，先检查是否能在常量池定位到一个类的引用，检查这个符号代表的类是否已被加载、解析和初始化过。</li><li>分配内存：检查通过，在java堆中分配对象内存，具体看对象的内存分配。</li><li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</li><li>设置对象头：进行对象的必要设置如那个类的示例、hashcode、GC分代年龄等信息，这些信息存放在对象头中。</li><li>上述工作完成之后，java开始调用对象的构造函数。</li></ol><h2 id="📓对象分配内存的方式"><a href="#📓对象分配内存的方式" class="headerlink" title="📓对象分配内存的方式"></a>📓对象分配内存的方式</h2><ul><li>规整空间：指针碰撞，整理过内存用一个指针标记内存使用过的范围，后序分配内存只需要移动指针，仅把指针向空闲空间移动一段与对象大小相等的距离。</li><li>碎片空间：空闲链表(free list)，通过额外的维护的列表存储记录空闲的地址，将随机IO变为顺序IO，但带来了额外的空间消耗。</li></ul><blockquote><p>使用Serial、ParNew等带压缩过程的垃圾回收器，使用指针分配算法。而CMS这种基于清除的算法理论上使用空闲链表的方式分配。</p></blockquote><p>对象分配内存并发控制(<strong>内存分配并发解决方案</strong>)：</p><ul><li>CAS+失败重试</li><li>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB) ，每个线程在Java堆中预先分配一小块内存，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li></ul><h2 id="📓对象内存分布"><a href="#📓对象内存分布" class="headerlink" title="📓对象内存分布"></a>📓对象内存分布</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729670.jpeg" alt="avatar"></p><p>对象在堆内存中的存储布局可以分为三部分：对象头、实例数据(对象有效信息)和对齐填充(仅起占位符作用)\</p><p>Hotspot的对象头包括两部分信息：</p><ol><li>第一部分：存储对象自身的运行数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。</li><li>第二部分：类型指针，即对象指向它的类型愿数据的指针。</li></ol><h2 id="📓对象的访问"><a href="#📓对象的访问" class="headerlink" title="📓对象的访问"></a>📓对象的访问</h2><p>定义：java程序会通过栈上的reference数据来操作堆上的具体对象。具体的对象访问方式由虚拟机决定，主要有两种使用句柄和直接指针两种。</p><ul><li>使用句柄访问的话，java堆会划分一块内存作为句柄池。引用会指向句柄，而句柄中分为两块指针，一个是指向对象实例的指针，一个是指向对象类型数据的指针(指向方法区)。好处为整理内存是只需要整理实例的指针。</li><li>直接指针访问，引用直接指向堆中的对象实例，而对象实例中包含数据的类型数据的指针(指向方法区)，好处为减少了指向实例的时间定为开销。</li></ul><blockquote><p>HotSpot虚拟机主要使用第二种方式进行访问。</p></blockquote><h2 id="📓对象引用"><a href="#📓对象引用" class="headerlink" title="📓对象引用"></a>📓对象引用</h2><ul><li>强引用(Strongly Reference): Object obj &#x3D; new Object()。关系存在虚拟机就不会回收。</li><li>软引用(Soft Reference)：用来描述一些还有用但非必须的对象。在系统要发生内存溢出会收集软引用对象，若回收完成仍内存不足，才抛出内存异常。软引用可用于实现内存敏感缓存，其中内存管理是一个非常重要的因素。</li><li>弱引用(Weak Reference)：弱引用关联的对象只能生存到下一次垃圾收集发生为止。</li><li>虚引用(Phantom Reference)：最弱的引用，意义为一个对象设置虚引用关联的唯一目的是为了在该对象被收集时得到一个通知。</li></ul><p>对象死亡的调用，任何一个对象都会被系统调用一次，如果对象下一次面临回收它的finalize()不会再执行。</p><ul><li>Soft References in Java</li><li>Weak References in Java</li><li>Phantom References in Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent);<br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent, referenceQueue);<br><br>        referent = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent2</span> <span class="hljs-operator">=</span> weakReference1.get();<br>        System.out.println(<span class="hljs-string">&quot;after gc, reference get result: &quot;</span> + referent2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        List&lt;LargeObjectFinalizer&gt; references = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Object&gt; largeObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">largeObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            largeObjects.add(largeObject);<br>            references.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LargeObjectFinalizer</span>(largeObject, referenceQueue));<br>        &#125;<br><br>        largeObjects = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        Reference&lt;?&gt; referenceFromQueue;<br>        <span class="hljs-keyword">for</span> (PhantomReference&lt;Object&gt; reference : references) &#123;<br>            System.out.println(reference.isEnqueued());<br>            <span class="hljs-comment">// 此处获取为空</span><br>            System.out.println(<span class="hljs-string">&quot;get result&quot;</span> + reference.get());<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> ((referenceFromQueue = referenceQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            ((LargeObjectFinalizer)referenceFromQueue).finalizeResources();<br>            referenceFromQueue.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObjectFinalizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LargeObjectFinalizer</span><span class="hljs-params">(</span><br><span class="hljs-params">            Object referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> Object&gt; q)</span> &#123;<br>        <span class="hljs-built_in">super</span>(referent, q);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalizeResources</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// free resources</span><br>        System.out.println(<span class="hljs-string">&quot;clearing ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓栈上分配"><a href="#📓栈上分配" class="headerlink" title="📓栈上分配"></a>📓栈上分配</h2><p>栈上分配是Java虚拟机的一项优化技术，基本思想是对于那些线程私有的对象(指不能被其他线程访问到的对象)，可以把他们打散分配在栈上，而不是分配在堆上。</p><blockquote><p>分配在对象上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能</p></blockquote><h3 id="📚逃逸分析"><a href="#📚逃逸分析" class="headerlink" title="📚逃逸分析"></a>📚逃逸分析</h3><p>逃逸分析是编译语言中的一种优化分析，而不是一种优化的手段。通过对象的作用范围的分析，为其他优化手段提供分析数据从而进行优化。</p><blockquote><p>目的是判断对象的作用域是否可能逃逸出函数体</p></blockquote><p>对象逃逸的三种类型：</p><ol><li><code>GlobalEscape</code>: 对象逃逸出方法或线程，如静态对象、对象作为方法的返回值、是已确认为逃逸对象的对象字段等</li><li><code>ArgEscape</code>: 对象作为方法调用的参数，传递引用给方法，但是在调用过程中不是全局逃逸对象。</li><li><code>NoEscape</code>: 可以标量替换的对象。</li></ol><blockquote><p>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量(如：int，long等基本数据类型以及reference类型等)</p></blockquote><h3 id="📚标量替换"><a href="#📚标量替换" class="headerlink" title="📚标量替换"></a>📚标量替换</h3><p>标量可以理解成一种不可分解的变量，如java内部的基本数据类型、引用类型等。 与之对应的聚合量是可以被拆解的，如对象。</p><p>当通过逃逸分析一个对象只会作用于方法内部，虚拟机可以通过使用标量替换来进行优化。</p><h3 id="📚应用"><a href="#📚应用" class="headerlink" title="📚应用"></a>📚应用</h3><ul><li><code>-XX:+DoEscapeAnalysis</code>：用于开启逃逸分析</li><li><code>-XX:+EliminateAllocations</code>：用于开启标量替换，允许将对象打散分配在栈上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnStackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        u.id = <span class="hljs-number">5</span>;<br>        u.name = <span class="hljs-string">&quot;geym&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(e-b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果关闭逃逸分析或者标量替换的任何一个，再次执行程序就会看到大量的GC日志，说明栈上分配依赖逃逸分析和标亮替换的实现。</p><h2 id="📓TLAB"><a href="#📓TLAB" class="headerlink" title="📓TLAB"></a>📓TLAB</h2><p>TLAB，全称Thread Local Allocation Buffer, 即：线程本地分配缓存。这是一块线程专用的内存分配区域。TLAB占用的是eden区的空间。在TLAB启用的情况下(默认开启)，JVM会为每一个线程分配一块TLAB区域。</p><p>为什么需要TLAB？ 这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须<strong>线程同步</strong>，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。</p><p>局限性： TLAB空间一般不会太大(占用eden区)，所以大对象无法进行TLAB分配，只能直接分配到堆上。</p><p>分配策略：<br>一个100KB的TLAB区域，如果已经使用了80KB，当需要分配一个30KB的对象时，TLAB是如何分配的呢？ 此时，虚拟机有两种选择：第一，废弃当前的TLAB(会浪费20KB的空间)；第二，将这个30KB的对象直接分配到堆上，保留当前TLAB(当有小于20KB的对象请求TLAB分配时可以直接使用该TLAB区域)。 JVM选择的策略是：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，若小于refill_waste值，则会废弃当前TLAB，新建TLAB来分配新对象。</p><blockquote><p>【默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使系统的运行状态达到最优。】</p></blockquote><table><thead><tr><th>参数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>-XX:+UseTLAB</td><td>启用TLAB</td><td>默认启用</td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>设置允许空间浪费的比例</td><td>默认值：64，即：使用1&#x2F;64的TLAB空间大小作为refill_waste值</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁止系统自动调整TLAB大小</td><td></td></tr><tr><td>-XX:TLABSize</td><td>指定TLAB大小</td><td>单位：B</td></tr></tbody></table><h2 id="📓对象内存分配流程"><a href="#📓对象内存分配流程" class="headerlink" title="📓对象内存分配流程"></a>📓对象内存分配流程</h2><p>java对象分配流程</p><ol><li>首先运行栈上分配。编译器通过逃逸分析及标量替换，决定对象应该分配在栈上还是堆中。如果逃逸分析及标量替换其中一个未启用，则直接分配在堆中。如果决定分配在堆中，那么执行步骤2</li><li>进行TLAB分配。如果TLAB的空间<code>TALB_TOP+SIZE &lt;= TLAB_END</code>，对象可以直接分配在TLAB中，那么<code>TLAB_TOP</code>加上对象<code>SIZE</code>进行位置移动。若不能执行步骤3</li><li>重新申请一块TALB，并尝试存储对象。若对象过大仍无法存储在TLAB中，执行步骤4</li><li>判断是否满足进入老年代的条件(<code>PretenureSizeThreshold</code>参数)，若满足直接进入老年代，不满足进行新声代分配</li><li>将对象存储在新声代<code>Eden</code>中，<code>EDEN_TOP</code>指针移位。若新声代无法存储对象，执行<code>Young GC</code>，并尝试重新分配对象。</li><li><code>Young GC</code> 后重新分配对象，若仍然无法分配。对象直接进入老年代。</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/object-alloc.png" alt="image"></p><h2 id="📓JDK编译期"><a href="#📓JDK编译期" class="headerlink" title="📓JDK编译期"></a>📓JDK编译期</h2><h3 id="📚编译期做的工作"><a href="#📚编译期做的工作" class="headerlink" title="📚编译期做的工作"></a>📚编译期做的工作</h3><ol><li>默认构造器： 经过编译的代码,可以看到在编译阶段，如果我们没有添加构造器。那么Java编译器会为我们添加一个无参构造方法。</li><li>自动拆装箱</li><li>泛型与类型擦除</li><li>foreach优化成Iterator</li><li><code>String... args</code> 可变参数优化</li><li>switch支持case使用字符串及枚举类型优化，优化成hashcode匹配。</li><li>枚举，优化成final class</li><li>try-with-resources 优化，自动在finally中加入close语句</li><li>重写的优化，子类重写方法中会新增一个桥接方法。</li><li>匿名内部类：生成final 修饰的类</li></ol><h2 id="📓堆内存的设置要点"><a href="#📓堆内存的设置要点" class="headerlink" title="📓堆内存的设置要点"></a>📓堆内存的设置要点</h2><ol><li>新生代的内存大小设置建议：Sun官方推荐配置为整个堆的3&#x2F;8。</li><li>服务器的内存需要预留一部分给永久代、线程栈及NIO</li></ol><p>内存分配问题: 省略比较小的区域，可以总结JVM占用的内存：</p><blockquote><p>JVM内存 ≈ Java永久代 ＋ Java堆(新生代和老年代) ＋ 线程栈＋ Java NIO</p></blockquote><p>假设原来的内存分配是：6G(java堆) ＋ 600M(监控) ＋ 800M(系统)，剩余大约600m内存未分配。</p><p>现在分析这600M内存的分配情况：</p><ol><li>Linux保留大约200M，这部分是Linux正常运行的需要，</li><li>Java服务的线程数量是160个，JVM默认的线程栈大小是1M，因此使用160M内存，</li><li>Java NIO buffer，通过JMX查到最多占用了200m，</li><li>Java服务使用NIO大量读写文件，需要使用PageCache，正如前面分析，这个暂时不好定量估算大小。 前三项加起来已经560M，因此可以断定Linux物理内存不够使用。</li></ol><p>以下是sun公司的性能优化白皮书中提到的几个例子： 1．对于吞吐量的调优。机器配置：4G的内存，32个线程并发能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> <br><br>-Xmx3800m -Xms3800m 配置了最大Java Heap来充分利用系统内存。 <br>-Xmn2g 创建足够大的青年代(可以并行被回收)充分利用系统内存，防止将短期对象复制到老年代。 <br>-Xss128 减少默认最大的线程栈大小，提供更多的处理虚拟内存地址空间被进程使用。 <br>-XX:+UseParallelGC 采用并行垃圾收集器对年青代的内存进行收集，提高效率。 <br>-XX:ParallelGCThreads=<span class="hljs-number">20</span> 减少垃圾收集线程，默认是和服务器可支持的线程最大并发数相同，往往不需要配置到最大值。 <br></code></pre></td></tr></table></figure><p>2．尝试采用对老年代并行收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseParallelOldGC <br><br>-Xmx3550m -Xms3550m 内存分配被减小，因为ParallelOldGC会增加对于Native Heap的需求，因此需要减小Java Heap来满足需求。 <br>-XX:+UseParallelOldGC 采用对于老年代并发收集的策略，可以提高收集效率。 <br></code></pre></td></tr></table></figure><p>3．提高吞吐量，减少应用停顿时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:TargetSurvivorRatio=<span class="hljs-number">90</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> <br><br>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC 选择了并发标记交换收集器，它可以并发执行收集操作，降低应用停止时间，同时它也是并行处理模式，可以有效地利用多处理器的系统的多进程处理。 <br>-XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> 表示在青年代中Eden和Survivor比例，设置增加了Survivor的大小，越大的survivor空间可以允许短期对象尽量在年青代消亡。 <br>-XX:TargetSurvivorRatio=<span class="hljs-number">90</span> 允许<span class="hljs-number">90</span>%的空间被占用，超过默认的<span class="hljs-number">50</span>%，提高对于survivor的使用率。<br></code></pre></td></tr></table></figure><h2 id="📓CMS-ParNew收集器的流程梳理"><a href="#📓CMS-ParNew收集器的流程梳理" class="headerlink" title="📓CMS + ParNew收集器的流程梳理"></a>📓CMS + ParNew收集器的流程梳理</h2><h3 id="📚young区域-年轻代"><a href="#📚young区域-年轻代" class="headerlink" title="📚young区域(年轻代)"></a>📚young区域(年轻代)</h3><ol><li>对象首先分配到Eden，分配满了触发Young Gc(Minor Gc)，基于复制交换算法，晋升对象年龄+1。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></a></li><li>年龄到达老年代门槛的晋升老年代。<ul><li>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</li><li>晋升失败触发FULL GC的两种场景：<ol><li>空间分配担保失败：在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。</li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</li></ol></li></ul></li></ol><p>特殊：</p><ol><li><p>大对象通过直接进入老年代。</p></li><li><p>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保：当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域(实际上大多数情况下就是老年代) 进行分配担保，survior区无法容纳的对象直接晋升到老年代。。</p><blockquote><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 - XX:HandlePromotionFailure 参数的设置值是否允许担保失败 (Handle Promotion Failure)；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次 Full GC。</p></blockquote></li></ol><h3 id="📚old区域-老年代"><a href="#📚old区域-老年代" class="headerlink" title="📚old区域(老年代)"></a>📚old区域(老年代)</h3><h4 id="📔CMS-GC原因"><a href="#📔CMS-GC原因" class="headerlink" title="📔CMS GC原因"></a>📔CMS GC原因</h4><p>触发 CMS GC有：</p><ol><li>Old 区达到回收阈值</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败</li><li>扩容缩容</li><li>显式调用System.gc</li><li>并发模式失败(浮动垃圾导致)</li></ol><h4 id="📔CMS-GC-垃圾回收模式"><a href="#📔CMS-GC-垃圾回收模式" class="headerlink" title="📔CMS GC 垃圾回收模式"></a>📔CMS GC 垃圾回收模式</h4><p>CMS GC 的垃圾回收共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>CMS 在Background回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><h4 id="📔其他老年代问题"><a href="#📔其他老年代问题" class="headerlink" title="📔其他老年代问题"></a>📔其他老年代问题</h4><p>CMS 无法处理浮动垃圾(Floating Garbage)。CMS 的并发清理阶段，应用还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p><h2 id="📓Java虚拟机内存调优"><a href="#📓Java虚拟机内存调优" class="headerlink" title="📓Java虚拟机内存调优"></a>📓Java虚拟机内存调优</h2><p>jdk1.8前的参数设置 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729631.jpeg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/jvmGCType.jpg" alt="avatar"></p><h3 id="📚基本概念重述"><a href="#📚基本概念重述" class="headerlink" title="📚基本概念重述"></a>📚基本概念重述</h3><p>跨代引用解决方案</p><p>Card Table：中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。</p><p>内存分配</p><ol><li><strong>TLAB</strong>：Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li><li>CAS+失败重试</li></ol><p>Mutator：生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。</p><h4 id="📔工具整理"><a href="#📔工具整理" class="headerlink" title="📔工具整理"></a>📔工具整理</h4><h5 id="🏷命令行终端"><a href="#🏷命令行终端" class="headerlink" title="🏷命令行终端"></a>🏷命令行终端</h5><p>标准终端类：jps、jinfo、jstat、jstack、jmap</p><p>功能整合类：jcmd、vjtools、arthas、greys</p><h5 id="🏷可视化界面"><a href="#🏷可视化界面" class="headerlink" title="🏷可视化界面"></a>🏷可视化界面</h5><p>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</p><p>进阶：MAT、JProfiler</p><p>命令行推荐 Arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy、heaphero、fastthread ，美团内部的 Scalpel(一款自研的 JVM 问题诊断工具，暂时未开源)也比较好用。</p><h3 id="📚GC-调优目的"><a href="#📚GC-调优目的" class="headerlink" title="📚GC 调优目的"></a>📚GC 调优目的</h3><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h3 id="📚GC-调优策略"><a href="#📚GC-调优策略" class="headerlink" title="📚GC 调优策略"></a>📚GC 调优策略</h3><p><strong>策略 1</strong>：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2</strong>：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代(当然短命的大对象对于垃圾回收来说简直就是噩梦)。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3</strong>：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><blockquote><p>为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区(年龄是可以调的，默认是15)hotspots的markword的图中，用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。</p></blockquote><p><strong>策略 4</strong>：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。</p><p><strong>策略5</strong>：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：</p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote><h3 id="📚调优指标"><a href="#📚调优指标" class="headerlink" title="📚调优指标"></a>📚调优指标</h3><ul><li>延迟(Latency)：也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li>吞吐量(Throughput)：应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><h3 id="📚问题排查思路"><a href="#📚问题排查思路" class="headerlink" title="📚问题排查思路"></a>📚问题排查思路</h3><p>四种分析思路</p><ul><li><strong>时序分析</strong>：先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高(要有足够的时间 Gap)，那么整个问题影响链就可能是：</li></ul><blockquote><p>CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程Block增多 -&gt; RT 上涨。</p></blockquote><ul><li><strong>概率分析</strong>：使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：</li></ul><blockquote><p>慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨。</p></blockquote><ul><li><strong>实验分析</strong>：通过故障演练等方式对问题现场进行模拟，触发其中部分条件(一个或多个)，观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨。</p></blockquote><ul><li><strong>反证分析</strong>：对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨。</p></blockquote><h3 id="📚案例"><a href="#📚案例" class="headerlink" title="📚案例"></a>📚案例</h3><h4 id="📔美团技术案例-基于CMS-JDK1-8"><a href="#📔美团技术案例-基于CMS-JDK1-8" class="headerlink" title="📔美团技术案例(基于CMS JDK1.8)"></a>📔美团技术案例(基于CMS JDK1.8)</h4><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/gcProcess.jpg"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729841.jpeg" alt="avatar"></a></p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/localIssue.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729263.png" alt="avatar"></a></p><p><strong>场景一：动态扩容引起的空间震荡</strong></p><p>服务刚刚启动时 GC 次数较多，最大空间剩余很多但是依然发生 GC， GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整。</p><p>解决：尽量将成对出现的空间大小配置参数设置成固定的，</p><blockquote><p>如 -Xms 和 -Xmx，-XX:MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 等。</p></blockquote><p>策略：保证 Java 虚拟机的堆是稳定的，避免弹性伸缩带来的额外 GC 消耗，确保 -Xms 和 -Xmx 设置的是一个值(即初始值和最大值一致)，获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题</p><blockquote><p>在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。</p></blockquote><hr><p><strong>场景二：显式 GC 的去与留 (System.gc)</strong></p><p>除了扩容缩容会触发 CMS GC 之外，还有</p><ol><li>Old 区达到回收阈值.</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败等几种触发条件</li></ol><p>如果以上均不是GC发生的原因，那么就是代码中调用了 <code>System.gc </code>方法。</p><p>增加 -XX:+DisableExplicitGC 参数后，<code>System.gc </code>这个方法变成了一个空方法</p><p>CMS GC 共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>保留 <code>System.gc</code>：在显示触发System.gc会使用Foreground模式对Old区域进行垃圾收集造成，长时间的STW。<br>去掉 <code>System.gc</code>：DirectByteBuffer直接内存在分配空间会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory。若禁用<code>System.gc</code>，会导致已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放，于是就有发生 Direct Memory 的 OOM。</p><blockquote><p>-XX:+DisableExplicitGC 可以用于禁用System.gc</p></blockquote><p><strong>策略</strong>: 因为DirectByteBuffer经常用于Netty 等各种 NIO 框架使用，所以不应该去除<code>System.gc</code>，可以使用参数改变System.gc的触发类型为Background，该模式也会触发old的DirectByteMemory 的清理工作。</p><blockquote><p>-XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background<br>不止 CMS，在 G1 或 ZGC中开启 ExplicitGCInvokesConcurrent 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。</p></blockquote><hr><p><strong>场景三：MetaSpace 区 OOM</strong></p><p>现象：JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p><p>MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p><ul><li><strong>Klass MetaSpace</strong>：就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构. 这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</li><li><strong>NoKlass MetaSpace</strong>：专门来存 Klass 相关的其他的内容，比如 Method，<strong>ConstantPool</strong> 常量池等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容。</li></ul><p>MetaSpace 内存管理：类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的<br>MetaSpace 弹性伸缩：由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize</p><p>问题原因：为了避免弹性伸缩带来的额外 GC 消耗，我们会将 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。</p><blockquote><p>经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。</p></blockquote><p>策略： 给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p><p><strong>场景四：过早晋升</strong></p><p>现象：</p><ol><li>分配速率接近于晋升速率，对象晋升年龄较小</li><li>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大。</li></ol><p>原因：</p><ol><li>Young&#x2F;Eden 区过小：过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升， copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间</li><li>分配速率过大：可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</li></ol><p>设定固定的 MaxTenuringThreshold 值作为晋升条件：</p><ul><li>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生。Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</li><li>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</li></ul><blockquote><p>未设置情况，Hotspot 会使用动态计算的方式来调整晋升的阈值：<br>Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值(TargetSurvivorRatio &#x2F; 100，TargetSurvivorRatio 默认值为 50)进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费。</p></blockquote><p>策略：</p><ol><li>Young&#x2F;Eden 区过小：调整堆分区内存，一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。 如何设置Survivor面积，可以自己推算。</li><li>分配速率过大：<ul><li>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</li><li>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</li></ul></li></ol><hr><p><strong>场景五：CMS Old GC 频繁</strong></p><p>现象：Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。</p><blockquote><p>描述过于抽象，见文章</p></blockquote><hr><p><strong>场景六：单次 CMS Old GC 耗时长</strong></p><p>CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table 遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>由上述过程可以推断，大部分出问题的耗时都是出现在最终标记中。处理思路如下：</p><ol><li><p>分析Reference 处理和元数据处理 real 耗时是否正常，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段。</p></li><li><p>需要通过</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintReferenceGC</span><br></code></pre></td></tr></table></figure><p>参数开启。基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注</p><ul><li>对 FinalReference 的分析: 经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。</li><li><code>scrub symbol table</code> 表示清理元数据符号引用耗时，观察 MetaSpace 区的历史使用峰值，看是否有使用动态类加载或者 DSL 处理等。 如果MateSpace 数据没啥变化，可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理。</li></ul></li></ol><hr><p><strong>场景七：内存碎片&amp;收集器退化</strong></p><p>现象： 并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><p>原因：</p><ol><li><p>晋升失败：</p><ol><li>在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。 <strong>发生的条件是很苛刻</strong></li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。<ul><li>碎片空间问题-空间分配效率较低：连续空间使用指针碰撞，而有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问</li><li>碎片空间问题-空间利用效率变低: Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象</li></ul></li></ol></li><li><p>增量收集担保失败: 分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小,，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之不安全，进行FULL GC。</p></li><li><p>显式 GC： System.gc</p></li><li><p>并发模式失败(Concurrent Mode Failure):在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p><blockquote><p>概率较高，主要是由于 CMS 无法处理浮动垃圾(Floating Garbage)引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p></blockquote></li></ol><p>策略</p><ul><li>内存碎片：通过配置 -XX:UseCMSCompactAtFullCollection&#x3D;true 来控制 Full GC的过程中是否进行空间的整理(默认开启，注意是Full GC，不是普通CMS GC)，以及 -XX: CMSFullGCsBeforeCompaction&#x3D;n 来控制多少次 Full GC 后进行一次压缩。</li><li>增量收集：降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</li><li>浮动垃圾：视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</li></ul><hr><p><strong>场景八：堆外内存 OOM</strong></p><p>现象： 内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java 进程的 RES 甚至超过了 -Xmx 的大小。</p><p>JVM 的堆外内存泄漏，主要有两种的原因：</p><ol><li>通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。</li><li>代码中有通过 JNI 调用 Native Code 申请的内存没有释放。</li></ol><p>策略：在项目中添加 -XX:NativeMemoryTracking&#x3D;detail JVM参数后重启项目(需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗)。使用命令 jcmd pid VM.native_memory detail 查看内存分布。</p><p><strong>场景九：JNI 引发的 GC 问题</strong></p><blockquote><p>太抽象了</p></blockquote><h4 id="📔不恰当的数据结构导致内存过大"><a href="#📔不恰当的数据结构导致内存过大" class="headerlink" title="📔不恰当的数据结构导致内存过大"></a>📔不恰当的数据结构导致内存过大</h4><p>场景：-Xms4g -Xmx8g -Xmn1g 使用ParNew + CMS组合。业务上需要10min加载80MB的数据到内存，会产生100W HashMap entry， Minor GC超过500ms，因为新生代使用了标记复制算法\</p><p>方案：不从修改程序，仅从GC调优，可以直接去掉SurvivorRatio，让新生代存活的对象一次Minor GC就进入到老年代<code> -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0</code>(或者-XX:+AlwaysTenure)</p><h4 id="📔堆外内存导致溢出错误"><a href="#📔堆外内存导致溢出错误" class="headerlink" title="📔堆外内存导致溢出错误"></a>📔堆外内存导致溢出错误</h4><p>NIO使用直接内存复制，而虚拟机中最大最小内存直接设值成系统内存大小了</p><h4 id="📔异步系统Socket连接"><a href="#📔异步系统Socket连接" class="headerlink" title="📔异步系统Socket连接"></a>📔异步系统Socket连接</h4><p>Socket 使用BIO连接异步处理，导致了系统连接数过多，进而虚拟机崩溃</p><h4 id="📔Evosuite-自动生成单元测试"><a href="#📔Evosuite-自动生成单元测试" class="headerlink" title="📔Evosuite 自动生成单元测试"></a>📔Evosuite 自动生成单元测试</h4><p>表现：maven build时候单元测试需要一个多小时。</p><p>排查：</p><ol><li><code>jstat -gc pid</code> 结合日志观察GC情况。</li><li><code>jstack -l pid</code> 刷具体的运行线程。</li><li><code>jmap -heap pid</code> 导出堆的分配情况</li></ol><p>原因为Evosuite自动生成的test中存在：</p><ol><li>StringUtils的expend测试，延长字符串到1610613374长度。jdk8，String内部使用char数组。</li><li>调用Util类分配694225808 长度的ArrayList 数组空间，并分配元素。</li><li>死循环线程</li></ol><p>java进程垃圾回收器使用ParallelGC，新生代使用标记复制算法，老年代标记整理。 <code>s0：1g s1：3g eden：3g old：10g</code></p><p>结果： YGC出现大量复制工作，很耗费时间。每次分配的空间过大，经常需要FGC来分配空间。</p><p>解决处理：死循环线程、修改自动生成的test分配合理内存。</p><h4 id="📔其他建议"><a href="#📔其他建议" class="headerlink" title="📔其他建议"></a>📔其他建议</h4><ol><li><p>禁用偏向锁：偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。</p><blockquote><p>在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。</p></blockquote></li><li><p>主动式 GC： 观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC。必要时引入，会影响系统健壮性。</p></li><li><p>虚拟内存：启动初期有些操作系统(例如 Linux)并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。</p><blockquote><p>这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。</p></blockquote></li></ol><h2 id="📓JVM工具"><a href="#📓JVM工具" class="headerlink" title="📓JVM工具"></a>📓JVM工具</h2><ul><li><p>javac.exe是编译.java文件</p></li><li><p>java.exe是执行编译好的.class文件</p></li><li><p>javadoc.exe是生成Java说明文档</p></li><li><p>jdb.exe是Java调试器</p></li><li><p>javaprof.exe是剖析工具</p></li></ul><h2 id="📓JVM参数"><a href="#📓JVM参数" class="headerlink" title="📓JVM参数"></a>📓JVM参数</h2><p>常见配置汇总</p><h3 id="📚堆设置"><a href="#📚堆设置" class="headerlink" title="📚堆设置"></a>📚堆设置</h3><ul><li>-Xms:初始堆大小</li><li>-Xmx:最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><h3 id="📚收集器设置"><a href="#📚收集器设置" class="headerlink" title="📚收集器设置"></a>📚收集器设置</h3><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><h3 id="📚垃圾回收统计信息"><a href="#📚垃圾回收统计信息" class="headerlink" title="📚垃圾回收统计信息"></a>📚垃圾回收统计信息</h3><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h3 id="📚并行收集器设置"><a href="#📚并行收集器设置" class="headerlink" title="📚并行收集器设置"></a>📚并行收集器设置</h3><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</li></ul><h3 id="📚并发收集器设置"><a href="#📚并发收集器设置" class="headerlink" title="📚并发收集器设置"></a>📚并发收集器设置</h3><ul><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP</title>
    <link href="/2022/09/04/AOP/"/>
    <url>/2022/09/04/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote><p>AOP(Aspect Oriented Programming,面向切面编程)通过提供一种思考程序结构的方式来补充OOP(Object Oriented Programming,面向对象编程)。OOP模块化的关键单元是类，而在AOP中，模块化的单元是切面。切面可以实现跨多个类型和对像之间的事务管理、日志等方面的模块化。</p></blockquote><p>Spring框架中使用AOP主要有以下优势：</p><ul><li>提供声明式企业服务，特别是作为 EJB声明式服务的替代品。重要的是，这种服务是声明式事务管理。</li><li>允许用户实现自定义切面。在某些不适合用OOP编程的场景中，采用AOP来补充。</li><li>可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高开发效率。</li></ul><p>要使用Spring AOP 需要添加spring-aop 模块。</p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205052246547.png" alt="image-20220402110359545"></p><ul><li>Aspect（切面）：将关注点进行模块化。在Spring AOP中，切面可以使用常规类（基于模式的方法）或@Aspect注解的常规类来实现。</li><li>Join Point（连接点）：在程序执行过程中的某个特定的点。如某方法调用时或处理异常时。在Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>Advice（通知）：在七日面的某个特定的连接点上执行的动作。通知有各种类型，包括around、before和after等。许多AOP框架都是以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。</li><li>Pointcut（切入点）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（如当执行某个特定的方法时）。切入点表达式如何和连接点匹配是AOP的核心。Spring默认使用AspectJ切入点语法。</li><li>Introduction（引入）：声明额外的方法或某个类型的字段。Spring允许引入新的接口（及一个对应的实现）到任何被通知的对象。例如，可以使用一个引入来使bean实现IsModified接口，以便简化缓存机制。</li><li>Target Object（目标对象）：被一个或多个切面通知的对象。也有人把它称为Adviced（被通知）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个Proxied（被代理）对象。</li><li>AOP Proxy（AOP代理）：AOP框架创建的对象用来实现Aspect Contract（切面契约），包括通知方法执行等功能。在Spring中，AOP代理可以JDK动态代理或CGLIB代理。</li><li>Weaving（织入）：把切面连接到其他的应用程序类型或对象上，并创建一个Adviced （被通知）的对象。这些可以在编译时（如使用AspectJ编译器）、类加载时和运行完成时。</li></ul><h2 id="Advice（通知）类型"><a href="#Advice（通知）类型" class="headerlink" title="Advice（通知）类型"></a>Advice（通知）类型</h2><ul><li>Before Advice（前置通知）：在某连接点之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>After Returning Advice（返回后通知）：在某连接点正常完成后执行的通知，如果一个方法没有抛出异常，就正常返回。</li><li>After Throwing Advice（抛出异常后通知）：在方法抛出异常退出时执行的通知。</li><li>After （finally) Advice（最后通知）：当某连接点退出时执行的通知（不论是正常返回还是异常退出）。</li><li>Around Advice（环绕通知）：包围一个连接点的通知。如方法调用。这是很强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为，它也会选择是否继续执行连接点，或者直接返回它自己的返回值或抛出异常来结束执行。Around Advice是常用的一种通知类型。与AspectJ一样，Spring提供所有的类型的通知，推荐使用尽量简单的通知类型来实现需要的功能。例如，如果只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情，但最好使用After Returning通知，而不是使用环绕通知。用合适的通知类型可以使编程模型变得简单，并且能够避免很多潜在的错误。</li></ul><h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><p>Spring AOP默认使用标准的JDK动态代理，这样任何接口（或接口的set方法）都可以被代理。</p><p>Spring AOP也支持CGLIB代理，当需要代理类（而不是代理接口）时，CGLIB代理是很有必要的。如果一个业务对象并没有实现一个接口，就会默认使用CGLIB、</p>]]></content>
    
    
    <categories>
      
      <category>Spring MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令大全</title>
    <link href="/2022/09/04/Git/"/>
    <url>/2022/09/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p> <strong>一、创建与合并分支</strong> </p><p><strong>1、 从master分支创建dev分支并切换到dev分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout mastergit checkout -b dev<br></code></pre></td></tr></table></figure><p>其中，git checkout -b dev 等价于:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch devgit checkout dev<br></code></pre></td></tr></table></figure><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</p><p>（2）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  branch  -a<br></code></pre></td></tr></table></figure><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</p><p><strong>2、修改代码、提交代码（当前的操作是在dev分支上进行）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add a.html<br>git commit -m <span class="hljs-string">&quot;提交文件a.html&quot;</span><br></code></pre></td></tr></table></figure><p><strong>3、分支合并(将dev合并到master)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge dev<br></code></pre></td></tr></table></figure><p><strong>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d dev<br></code></pre></td></tr></table></figure><p><strong>5、删除后，查看分支(此时看不到dev分支了)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>6、总结 ：工作中经常从master创建新的分支，具体操作如下:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">master创建新分支：<br>git checkout master<br>git checkout -b  issues1234  // 从master分支创建issues1234分支<br>git push origin issues1234<br>git add ..<br>git commit -m <span class="hljs-string">&quot;***&quot;</span><br>git push origin issues1234<br></code></pre></td></tr></table></figure><blockquote><p>注意：将本地分支branch1推到远端的branch2操作步骤：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin branch1:branch2<br></code></pre></td></tr></table></figure><p><strong>7、删除分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D   issues1234  // 本地强制删除分支issues1234<br>git push origin  :issues1234  // 推到远程<br></code></pre></td></tr></table></figure><hr><p> <strong>二、解决冲突</strong> </p><p><strong>1、发生冲突的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></code></pre></td></tr></table></figure><p>其中，git使用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记文件中自己和别人产生冲突的部分。</p><p>在 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======</code>之间为自己的代码；&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p><strong>2、冲突解决后提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br>git add ***<br>git commit -m <span class="hljs-string">&quot;fix conflict&quot;</span><br>git push origin 分支名<br></code></pre></td></tr></table></figure><hr><p> <strong>三、Bug分支</strong> </p><p><strong>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p><strong>2、恢复储藏的代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop // 恢复的同时把stash内容删掉<br></code></pre></td></tr></table></figure><p>或者<img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181623625.png" alt="图片"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：git stash apply stash@&#123;0&#125;<br>git stash apply  // 恢复stash，但是stash内容并不删除<br>git stash drop // 在上面操作的基础上，以此来删除stash<br>注： git stash list // 查看全部的stash列表<br></code></pre></td></tr></table></figure><p><strong>3、将stash空间清空</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash clear<br></code></pre></td></tr></table></figure><p><strong>4、git stash pop 和 git stash apply 区别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">原来git stash pop stash@&#123;<span class="hljs-built_in">id</span>&#125;命令会在执行后将对应的stash <span class="hljs-built_in">id</span> 从stash list里删除，而 git stash apply stash@&#123;<span class="hljs-built_in">id</span>&#125; 命令则会继续保存stash <span class="hljs-built_in">id</span>。<br></code></pre></td></tr></table></figure><hr><p> <strong>四、版本回退</strong> </p><p><strong>1、回退至上一个版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD<br></code></pre></td></tr></table></figure><p><strong>2、回退至指定版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard  版本号<br></code></pre></td></tr></table></figure><p><strong>3、查看以往版本号(本地的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><p><strong>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><hr><p> <strong>五、撤销修改</strong> </p><p><strong>1、撤销修改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  checkout -- a.html<br></code></pre></td></tr></table></figure><blockquote><p>分两种情况分析：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。<br>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态<br></code></pre></td></tr></table></figure><blockquote><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p></blockquote><p><strong>2、撤销新建文件</strong></p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f ../aa.html<br></code></pre></td></tr></table></figure><p><strong>3、撤销新建文件夹</strong></p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -<span class="hljs-built_in">df</span> ./demo<br></code></pre></td></tr></table></figure><hr><p> <strong>六、对已push版本进行回退</strong> </p><p><strong>1、第一步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 版本号 // 本地回退到指定的版本<br></code></pre></td></tr></table></figure><p><strong>2、第二步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push  -f origin dev    //将远程的也回退到指定版本<br></code></pre></td></tr></table></figure><hr><p> <strong>七、本地同步远程删除的分支</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin -p  // 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了<br></code></pre></td></tr></table></figure><hr><p> <strong>八、删掉未与远程分支对应的本地分支</strong> </p><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch -p<br></code></pre></td></tr></table></figure><hr><p> <strong>九、查看远程库与本地分支的信息</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote show origin<br></code></pre></td></tr></table></figure><hr><p> <strong>十、标签管理</strong> </p><p><strong>1、给当前分支最新commit打标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0<br></code></pre></td></tr></table></figure><p><strong>2、比如现在周五，要给周一某个commit打标签，应执行以下步骤：</strong></p><p>（1）、查看log日志，找到相应的commit版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline --abbrev-commit<br>// 显示如下commit，比如我想在 <span class="hljs-string">&quot;34372b05&quot;</span>这个commit打标签44d2e20b fix bug34372b05 fix bug29554931 fix bug<br></code></pre></td></tr></table></figure><p>（2）、给指定的commit打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0 34372b05<br></code></pre></td></tr></table></figure><p>（3）、创建的标签只存在本地，推至远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0.0<br></code></pre></td></tr></table></figure><p>（4）、一次性推送未推至远程的本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --tags<br></code></pre></td></tr></table></figure><p>（5）、查询所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br></code></pre></td></tr></table></figure><p>（6）、查询标签详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show v1.0.0<br></code></pre></td></tr></table></figure><p>（7）、删除本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d v1.0.0<br></code></pre></td></tr></table></figure><p>（8）、删除远程标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 先从本地删除git tag -d v1.0.0<br>// 然后从远程删除git push origin :refs/tags/v1.0.0<br>// 最后可以在gitlab上查看是否真正的删除了标签<br></code></pre></td></tr></table></figure><p><strong>3、创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// git  tag  -a  版本号  -m  说明信息  commit版本号git tag -a v1.0.0 -m <span class="hljs-string">&quot;version 1.0.0 released&quot;</span> 34372b05(commit版本号)     <br>// 查看标签详细信息git show v1.0.0    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo一键发布文章</title>
    <link href="/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"/>
    <url>/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo一键发布文章"><a href="#Hexo一键发布文章" class="headerlink" title="Hexo一键发布文章"></a>Hexo一键发布文章</h1><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>刚开始使用hexo的时候简直无法忍受繁杂的部署命令,不仅要输入以下命令来更新，并且还要在指定的目录下打开 git bash，这让怕麻烦的我十分难受…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure><h2 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h2><p>注意事项：下面的命令中 D:&#x2F;Myblog&#x2F;hexo&#x2F;liblog 是我博客的文件夹路径，请替换为你自己博客的路径</p><p>任意目录打开 git bash ，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.fuck <span class="hljs-string">&#x27;!cd D:/Myblog/hexo/liblog;hexo clean;hexo g -d&#x27;</span><br>git fuck<br></code></pre></td></tr></table></figure><p>以后就可以在任意目录下通过 git fuck 来一键更新了。</p><h2 id="三、如何取消别名"><a href="#三、如何取消别名" class="headerlink" title="三、如何取消别名"></a>三、如何取消别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> alias.fuck<br></code></pre></td></tr></table></figure><h2 id="四、再简单些"><a href="#四、再简单些" class="headerlink" title="四、再简单些"></a>四、再简单些</h2><p>每次都要打开git bush再输入git fuck 还是有些麻烦，通过windows的bat脚本一键实现发布文章，新建一个文件后缀命名为bat,输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> 开始提交到git....<br>git fuck<br><span class="hljs-built_in">echo</span> 推送到git成功<br>@<span class="hljs-built_in">echo</span> off<br>pause<br></code></pre></td></tr></table></figure><p><strong>完美！！！</strong></p><p>只需点击这个bat文件就能够一键发布文章了</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSR303数据校验</title>
    <link href="/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <url>/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h1><blockquote><p>JSR 303 是Java为Bean数据合法校验提供的标准框架，已经包含在Java EE 6.0中。JSR是一个规范，它的核心接口时Validator，该接口根据目标对象类中所标注的校验注解进行数据校验，并得到校验结果。JSR303通过在Bean属性中标注类似@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p></blockquote><h2 id="JSR-303-包含注解"><a href="#JSR-303-包含注解" class="headerlink" title="JSR 303 包含注解"></a>JSR 303 包含注解</h2><table><thead><tr><th align="left">注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">@Null</td><td align="center">被注解的元素必须为null</td></tr><tr><td align="left">@NotNull</td><td align="center">被注解的元素必须不为null</td></tr><tr><td align="left">@AssertTrue</td><td align="center">被注解的元素必须为true</td></tr><tr><td align="left">@AssertFalse</td><td align="center">被注解的元素必须为false</td></tr><tr><td align="left">@Min(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@Max(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@DecimalMin(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@DecimalMax(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@Size</td><td align="center">被注解的元素的大小必须在指定的范围内</td></tr><tr><td align="left">@Digits(integer,fraction)</td><td align="center">被注解的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td align="left">@Past</td><td align="center">被注解的元素必须是一个过去的时间</td></tr><tr><td align="left">@Future</td><td align="center">被注解的元素必须是一个将来的时间</td></tr><tr><td align="left">@Pattern(regex&#x3D;,flag&#x3D;)</td><td align="center">被注解的元素必须符合指定的正则表达式</td></tr></tbody></table><h2 id="Hibernate-Vakudator"><a href="#Hibernate-Vakudator" class="headerlink" title="Hibernate Vakudator"></a>Hibernate Vakudator</h2><blockquote><p>Hibernate Vakudator是JSR303的一个参考实现，出来支持所有的标准注解外，还支持一些扩展注解</p></blockquote><table><thead><tr><th>注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td>@NotBlank(message&#x3D;)</td><td align="center">验证字符串非null,并且长度必须大于0</td></tr><tr><td>@Email</td><td align="center">被注解的元素必须是电子邮箱地址</td></tr><tr><td>@Length(min&#x3D;,max&#x3D;)</td><td align="center">被注解的字符串的大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td align="center">被注解的字符串必须非空</td></tr><tr><td>@Range(min&#x3D;,max&#x3D;,message&#x3D;)</td><td align="center">被注解的元素必须在合适的范围内</td></tr><tr><td>@URL</td><td align="center">被注解的元素必须是合法的URL</td></tr></tbody></table><h2 id="ValidationMessages-properties"><a href="#ValidationMessages-properties" class="headerlink" title="ValidationMessages.properties"></a>ValidationMessages.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">javax.validation.constraints.AssertFalse.message</span>     = <span class="hljs-string">必须为 false</span><br><span class="hljs-attr">javax.validation.constraints.AssertTrue.message</span>      = <span class="hljs-string">必须为 true</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMax.message</span>      = <span class="hljs-string">必须小于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMin.message</span>      = <span class="hljs-string">必须大于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Digits.message</span>          = <span class="hljs-string">数字值超出了边界（期望 &lt;&#123;integer&#125; digits&gt;.&lt;&#123;fraction&#125; digits&gt;）</span><br><span class="hljs-attr">javax.validation.constraints.Email.message</span>           = <span class="hljs-string">必须为格式规范的电子邮件地址</span><br><span class="hljs-attr">javax.validation.constraints.Future.message</span>          = <span class="hljs-string">必须是未来的日期</span><br><span class="hljs-attr">javax.validation.constraints.FutureOrPresent.message</span> = <span class="hljs-string">必须是现在或将来的日期</span><br><span class="hljs-attr">javax.validation.constraints.Max.message</span>             = <span class="hljs-string">必须小于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Min.message</span>             = <span class="hljs-string">必须大于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Negative.message</span>        = <span class="hljs-string">必须小于 0</span><br><span class="hljs-attr">javax.validation.constraints.NegativeOrZero.message</span>  = <span class="hljs-string">必须小于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.NotBlank.message</span>        = <span class="hljs-string">不得为空白</span><br><span class="hljs-attr">javax.validation.constraints.NotEmpty.message</span>        = <span class="hljs-string">不得为空</span><br><span class="hljs-attr">javax.validation.constraints.NotNull.message</span>         = <span class="hljs-string">不得为 null</span><br><span class="hljs-attr">javax.validation.constraints.Null.message</span>            = <span class="hljs-string">必须为 null</span><br><span class="hljs-attr">javax.validation.constraints.Past.message</span>            = <span class="hljs-string">必须是过去的日期</span><br><span class="hljs-attr">javax.validation.constraints.PastOrPresent.message</span>   = <span class="hljs-string">必须是过去或现在的日期</span><br><span class="hljs-attr">javax.validation.constraints.Pattern.message</span>         = <span class="hljs-string">必须与 &quot;&#123;regexp&#125;&quot; 匹配</span><br><span class="hljs-attr">javax.validation.constraints.Positive.message</span>        = <span class="hljs-string">必须大于 0</span><br><span class="hljs-attr">javax.validation.constraints.PositiveOrZero.message</span>  = <span class="hljs-string">必须大于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.Size.message</span>            = <span class="hljs-string">大小必须在 &#123;min&#125; 和 &#123;max&#125; 之间</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.CreditCardNumber.message</span>        = <span class="hljs-string">无效信用卡卡号</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Currency.message</span>                = <span class="hljs-string">无效货币（必须为 &#123;value&#125; 之一）</span><br><span class="hljs-attr">org.hibernate.validator.constraints.EAN.message</span>                     = <span class="hljs-string">无效 &#123;type&#125; 条形码</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Email.message</span>                   = <span class="hljs-string">电子邮件地址格式不规范</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ISBN.message</span>                    = <span class="hljs-string">无效 ISBN</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Length.message</span>                  = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.CodePointLength.message</span>         = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.LuhnCheck.message</span>               = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Luhn Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod10Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod11Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 11 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ModCheck.message</span>                = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，&#123;modType&#125; 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotBlank.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotEmpty.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ParametersScriptAssert.message</span>  = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Range.message</span>                   = <span class="hljs-string">必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.SafeHtml.message</span>                = <span class="hljs-string">可能具有不安全的 HTML 内容</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ScriptAssert.message</span>            = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.UniqueElements.message</span>          = <span class="hljs-string">必须仅包含唯一元素</span><br><span class="hljs-attr">org.hibernate.validator.constraints.URL.message</span>                     = <span class="hljs-string">必须为有效 URL</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CNPJ.message</span>                 = <span class="hljs-string">无效巴西企业纳税人登记号 (CNPJ)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CPF.message</span>                  = <span class="hljs-string">无效巴西个人纳税人登记号 (CPF)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.TituloEleitoral.message</span>      = <span class="hljs-string">无效巴西投票人身份证号</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.REGON.message</span>                = <span class="hljs-string">无效波兰纳税人识别号 (REGON)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.NIP.message</span>                  = <span class="hljs-string">无效 VAT 识别号 (NIP)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.PESEL.message</span>                = <span class="hljs-string">无效波兰身份证号 (PESEL)</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMax.message</span>        = <span class="hljs-string">必须短于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMin.message</span>        = <span class="hljs-string">必须长于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;<br>    &lt;version&gt;2.6.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-添加注解"><a href="#2-添加注解" class="headerlink" title="2.添加注解"></a>2.添加注解</h2><blockquote><p>在需要校验的字段上添加相应的注解进行校验，其中message是当校验不合法是提示的错误信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liziyuan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@email</span> liziyuan@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-07-08 08:58:02</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;pms_brand&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BrandEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@TableId</span><br>   <span class="hljs-keyword">private</span> Long brandId;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌名</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotBlank(message = &quot;品牌名称不能为空&quot;)</span><br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌logo地址</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@URL(message = &quot;logo必须是一个合法的URL地址&quot;)</span><br>   <span class="hljs-keyword">private</span> String logo;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 介绍</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String descript;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 显示状态[0-不显示；1-显示]</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Integer showStatus;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 检索首字母</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@Pattern(regexp = &quot;/~[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><br>   <span class="hljs-keyword">private</span> String firstLetter;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 排序</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-meta">@Min(value = 0,message = &quot;排序必须大于0&quot;)</span><br>   <span class="hljs-keyword">private</span> Integer sort;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Cotroller开启校验"><a href="#3-Cotroller开启校验" class="headerlink" title="3.Cotroller开启校验"></a>3.Cotroller开启校验</h2><blockquote><p>使用@Valid注解开启校验，其中参数BindingResult可以获取校验的结果。</p><ul><li>BindingResult：BindingResult扩展了Errors接口，同时可以获取数据绑定结果对象的信息。@Valid和BindingResult参数是成对出现的，并且在形参中出现的顺序是固定的，一前一后。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span>&#123;<br>        <span class="hljs-comment">//BindingResult 参数能够获取校验结果</span><br><span class="hljs-comment">//        获取校验的错误结果</span><br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            result.getFieldErrors().forEach((item)-&gt;&#123;<br><span class="hljs-comment">//                获取到错误提示</span><br>                String message=item.getDefaultMessage();<br>                 <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> item.getField();<span class="hljs-comment">//获取错误的属性的名字</span><br>                map.put(field,message);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-number">400</span>,<span class="hljs-string">&quot;提交数据不合法&quot;</span>).put(<span class="hljs-string">&quot;data&quot;</span>,map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>      brandService.save(brand);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h1><ol><li><p>编写一个自定义校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: liZiYuan</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Date: 2022/7/16  20:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Constraint(</span><br><span class="hljs-meta">        validatedBy = &#123;ListValueConstraintValidator.class&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ListValue &#123;<br>    String <span class="hljs-title function_">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&#123;com.zhang.common.valid.ListValue.message&#125;&quot;</span>;<br><br>    Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Payload</span>&gt;[] payload() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-type">int</span>[] vals()  <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>编写一个自定义的校验器 ConstrainValidator</p><p>实现ConstraintValidator&lt;Annotation, T&gt;接口,其中Annotation表示自定义的校验注解，T表示校验对象的类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListValueConstraintValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//初始化方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ListValue constraintAnnotation)</span> &#123;<br>        <span class="hljs-type">int</span>[] vals= constraintAnnotation.vals();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vals) &#123;<br>            set.add(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否校验成功</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 需要校验的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> constraintValidatorContext</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(Integer value, ConstraintValidatorContext constraintValidatorContext)</span> &#123;<br>        <span class="hljs-keyword">return</span> set.contains(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关联自定义的校验器和自定义的校验注解</p></li></ol><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><blockquote><p>@Validated是@Valid 的一次封装，是Spring提供的校验机制使用。@Valid不提供分组功能</p></blockquote><p><strong>@Valid和@Validated的区别</strong></p><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring的JSR-303规范，是标准JSR-303的一个变种），Javax提供了<code>@Valid</code>（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。</p><p><code>@Valid</code>属于Javax.validation包下，是jdk给提供的，是使用Hibernate validation的时候使用（java的JSR303声明了@Valid这类接口，而Hibernate-validator对其进行了实现）</p><p><code>@Validated</code>是org.springframework.validation.annotation包下的，是spring提供的，是只用Spring validator校验机制使用</p><p>在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p><p>1.分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Validated</span>：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制<br><span class="hljs-meta">@Valid</span>：作为标准的JSR-<span class="hljs-number">303</span>规范，还没有吸收分组的功能<br></code></pre></td></tr></table></figure><p><code>@Validated</code>会有分组的概念，后面默认是有一个Default.class,当你的@Validated后面没有加任何校验分组信息的时候默认会加Default分组,而对于被校验的对象的属性字段，如果你在属性的校验标签里面没有指定分组会添加到默认分组Default里面。所以如果你的对象里面的每个属性都指定了分组信息，而接口上面并没有添加分组信息会出现@Validated“失效的情况”，实际是因为它校验的是Default分组，而没有字段属于Default分组。上述校验不管加不加@ReqeustBody都能完成校验，但是都不能完成嵌套的校验。</p><p>特殊用法:</p><ul><li>分组: 当一个实体类需要多种验证方式时，例：对于一个实体类的id来说，新增的时候是不需要的，对于更新时是必须的, 可以通过groups对验证进行分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AllFiled</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">First</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Secend</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br><br>    <span class="hljs-meta">@NotBlank(message = &quot;姓名不能为空&quot;, groups = &#123;First.class, AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@NotEmpty(message = &quot;密码不能为空&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Length(min = 6, max = 10, message = &quot;密码长度只能在6-10之间&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@Min(value = 18, message = &quot;年龄最小为18&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Max(value = 60, message = &quot;年龄最大为60&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@AssertTrue(message = &quot;必须同意条款&quot;, groups = &#123;Secend.class, AllFiled.class&#125;)</span><br>    <span class="hljs-type">boolean</span> agree;<br>&#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;validate&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span>&#123;<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            List&lt;ObjectError&gt; list  = result.getAllErrors();<br>            <span class="hljs-keyword">for</span> (ObjectError error :<br>                    list) &#123;<br>                <span class="hljs-type">FieldError</span> <span class="hljs-variable">fieldError</span> <span class="hljs-operator">=</span> (FieldError)error;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">defaultMessage</span> <span class="hljs-operator">=</span> fieldError.getDefaultMessage();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldError.getField();<br>                map.put(field, defaultMessage);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当@Validated分组为空时, 只会验证没有分组的属性, 如上面的uid;</strong></p><p><strong>当@Validated{First.class}时, 只会验证分组为First.class的字段, 对于其他分组字段和未分组字段都为空</strong></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font style="color:red">注意</font></h1><p>添加全局异常处理时Controller层参数中不能加<code>BindingResult</code>参数，否则无法捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestControllerAdvice(basePackages = &quot;com.zhang.gulimall.product.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GulimallExceptionControllerAdvice</span> &#123;<br><br><span class="hljs-comment">//    @ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">handlerValidException</span><span class="hljs-params">(MethodArgumentNotValidException e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;校验异常处理&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;数据校验出现问题&#123;&#125;，异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());<br>         <span class="hljs-type">BindingResult</span> <span class="hljs-variable">bindingResult</span> <span class="hljs-operator">=</span> e.getBindingResult();<br>        Map&lt;String,String&gt; errorMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        bindingResult.getFieldErrors().forEach((filedError)-&gt;&#123;<br>            errorMap.put(filedError.getField(),filedError.getDefaultMessage());<br>        &#125;);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(<span class="hljs-string">&quot;data&quot;</span>,errorMap);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = RuntimeException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">hadleException</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.UNKNOW_EXCEPTION.getCode(),BizCodeEnum.UNKNOW_EXCEPTION.getMsg());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>好用的IDEA插件</title>
    <link href="/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><h2 id="1、Background-Image-Plus"><a href="#1、Background-Image-Plus" class="headerlink" title="1、Background Image Plus"></a>1、Background Image Plus</h2><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而<strong>Background Image Plus</strong>这个插件可以为IDEA设置<strong>自定义图片</strong>作为背景，而且还可以设置透明度，从此写代码乐趣十足!</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639600.jpeg" alt="图片"></p><p><strong>背景图设置效果如下：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639590.jpeg" alt="图片"></p><hr><h2 id="2、CodeGlance"><a href="#2、CodeGlance" class="headerlink" title="2、CodeGlance"></a>2、CodeGlance</h2><p><strong>CodeGlance</strong>是一款非常好用的<strong>代码地图</strong>插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639411.jpeg" alt="图片"></p><p><strong>放大镜效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639447.jpeg" alt="图片"></p><hr><h2 id="3、Translation"><a href="#3、Translation" class="headerlink" title="3、Translation"></a>3、Translation</h2><p>代码中经常遇到不认识的英文单词或者句子，很蒙蔽怎么办？</p><p><strong>Translation</strong>是一款非常好用的<strong>翻译插件</strong>，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639271.jpeg" alt="图片"></p><p><strong>翻译逐个单词：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639277.jpeg" alt="图片"></p><p><strong>翻译一段话：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639762.jpeg" alt="图片"></p><hr><h2 id="4、Rainbow-Brackets"><a href="#4、Rainbow-Brackets" class="headerlink" title="4、Rainbow Brackets"></a>4、Rainbow Brackets</h2><p>在代码非常复杂时，各种<strong>俄罗斯套娃式</strong>的括号简直让人心碎，<strong>Rainbow Brackets</strong>则是一款可以对<strong>成对括号</strong>进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639875.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639123.png" alt="图片"></p><hr><h2 id="5、Grep-Console"><a href="#5、Grep-Console" class="headerlink" title="5、Grep Console"></a>5、Grep Console</h2><p>默认情况下，IDEA控制台窗口在打印日志时都是一种颜色到底，比如各种<code>info</code>,<code>warn</code>,和<code>error</code>等类型的日志信息交织在一起，不好分辨。</p><p><strong>Grep Console</strong>插件则可以帮助我们自定义设置不用日志用不同的颜色进行标识，非常方便观看！</p><p><strong>设置自定义颜色：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639197.jpeg" alt="图片"></p><p><strong>着色后的日志打印效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639171.jpeg" alt="图片"></p><hr><h2 id="6、Statistic"><a href="#6、Statistic" class="headerlink" title="6、Statistic"></a>6、Statistic</h2><p>程序员天天闷头做项目、写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p><strong>Statistic</strong>则是一款可以做项目全局代码统计信息的小插件：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639241.jpeg" alt="图片"></p><hr><h2 id="7、Markdown-Navigator"><a href="#7、Markdown-Navigator" class="headerlink" title="7、Markdown Navigator"></a>7、Markdown Navigator</h2><p>很多人私信问说，你是用什么markdown编辑器写博客的呢？不瞒你说，用IDEA就可以很愉快的写博客了，装了一个<strong>Markdown Navigator</strong>插件即可方便的实现：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639787.jpeg" alt="图片"></p><hr><h2 id="8、RestfulToolkit"><a href="#8、RestfulToolkit" class="headerlink" title="8、RestfulToolkit"></a>8、RestfulToolkit</h2><ul><li>你知道你项目里到底写了多少个URL接口吗？</li><li>如何快速定位某个<code>URL</code>接口对应的<code>Controller</code>代码？</li><li>如何快速测试你的<code>Controller</code>接口？</li></ul><p><strong>RestfulToolkit</strong>则是一个可以解决上述问题的，非常方便的IDEA集成插件，从此<code>Postman</code>怕是要下岗了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639948.jpeg" alt="图片"></p><hr><h2 id="9、GsonFormat"><a href="#9、GsonFormat" class="headerlink" title="9、GsonFormat"></a>9、GsonFormat</h2><p>给你一段<code>Json</code>格式数据，除了手写之外，如何快速生成一个和该<code>Json</code>数据对应的<code>Java</code>对象？</p><p>比如一段<code>Json</code>格式数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;操作成功&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>GsonFormat</strong>则是一个<strong>JSON格式数据 → 对象</strong>的快速<strong>代码自动生成</strong>插件。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639900.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639827.png" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639896.jpeg" alt="图片"></p><hr><h2 id="10、MyBatis-Log-Plugin"><a href="#10、MyBatis-Log-Plugin" class="headerlink" title="10、MyBatis Log Plugin"></a>10、MyBatis Log Plugin</h2><p><code>Mybatis</code>的<code>xml</code>文件中的<code>SQL</code>语句都是拼装起来的，但有时候（比如在调试的时候）想把某个请求对应的后台具体<code>SQL</code>查询语句单独拿出来测试或验证，该怎么办呢？</p><p><strong>MyBatis Log Plugin</strong>这个插件既可以帮你完美地解决这个问题：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639995.jpeg" alt="图片"></p><hr><h2 id="11、Free-Mybatis-plugin"><a href="#11、Free-Mybatis-plugin" class="headerlink" title="11、Free Mybatis plugin"></a>11、Free Mybatis plugin</h2><p>除了全局搜索以外，如何方便地在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换？</p><p><strong>Free Mybatis plugin</strong>插件此时就可以大显身手了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639379.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639393.jpeg" alt="图片"></p><hr><h2 id="12、MyBatisX"><a href="#12、MyBatisX" class="headerlink" title="12、MyBatisX"></a>12、MyBatisX</h2><p>快速在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642594.png" alt="image-20220818164238523"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642440.png" alt="image-20220818164250365"></p><h2 id="13、Nyan-Progress-Bar"><a href="#13、Nyan-Progress-Bar" class="headerlink" title="13、Nyan Progress Bar"></a>13、Nyan Progress Bar</h2><p>让进度条变得好看，编程彩虹条</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181648858.png" alt="image-20220818164845828"></p><h2 id="14、SequenceDiagram"><a href="#14、SequenceDiagram" class="headerlink" title="14、SequenceDiagram"></a>14、SequenceDiagram</h2><p>查看代码执行时序图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181646385.png" alt="image-20220818164613306"></p><h2 id="15、Material-Theme-UI"><a href="#15、Material-Theme-UI" class="headerlink" title="15、Material Theme UI"></a>15、Material Theme UI</h2><p>代码主题切换，可以改变代码颜色搭配</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181647157.png" alt="image-20220818164727076"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2022/09/04/MyBatis/"/>
    <url>/2022/09/04/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="💠MyBatis"><a href="#💠MyBatis" class="headerlink" title="💠MyBatis"></a>💠MyBatis</h1><p>一个🌰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;resultMap id=&quot;ExtListBaseResultMap&quot; type=&quot;com.xy.tms.tran.entity.vo.TranSeaPlanListVo&quot;<br>           extends=&quot;com.xy.tms.tran.dao.TranSeaPlanMapper.BaseResultMap&quot;&gt;<br>    &lt;result column=&quot;sea_plan_detail_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;seaPlanDetailId&quot;/&gt;<br>    &lt;result column=&quot;ship_company_order_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;shipCompanyOrderNo&quot;/&gt;<br>    &lt;result column=&quot;materiel_code&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;materielCode&quot;/&gt;<br>    &lt;result column=&quot;materiel_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;materielName&quot;/&gt;<br>    &lt;result column=&quot;materiel_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;materielId&quot;/&gt;<br>    &lt;result column=&quot;status&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;status&quot;/&gt;<br>    &lt;result column=&quot;create_by&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;createBy&quot; /&gt;<br>    &lt;result column=&quot;create_by_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;createByName&quot; /&gt;<br>    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;<br>    &lt;result column=&quot;update_by&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;updateBy&quot; /&gt;<br>    &lt;result column=&quot;update_by_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;updateByName&quot; /&gt;<br>    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;<br>    &lt;collection property=&quot;sysRoleIdList&quot; javaType=&quot;java.util.ArrayList&quot; ofType=&quot;java.lang.String&quot; resultMap=&quot;itemResultId&quot;/&gt;<br>&lt;/resultMap&gt;<br><br>&lt;resultMap id=&quot;itemResult&quot; type=&quot;java.lang.String&quot;&gt;<br>    &lt;id column=&quot;role_name&quot; javaType=&quot;java.lang.String&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;role_name&quot;/&gt;<br>&lt;/resultMap&gt;<br><br>&lt;sql id=&quot;Base_Column_List&quot;&gt;<br>    tran_main_plan_id, organization_id, tran_order_id, tran_main_plan_no, plan_sort,<br>    tran_type, tran_type_desc, tran_method, tran_method_desc, start_station_id, end_station_id,<br>    audit_status, audit_status_desc, audit_time, audit_user, allot_status, allot_status_desc,<br>    delivery_status, delivery_status_desc, remark, create_by, create_by_name, create_time,<br>    update_by, update_by_name, update_time, version<br> &lt;/sql&gt;<br><br>&lt;select id=&quot;querySeaPlan&quot; parameterType=&quot;com.xy.tms.tran.entity.vo.TranSeaPlanQueryVo&quot;<br>        resultMap=&quot;ExtListBaseResultMap&quot;&gt;<br>    SELECT<br>    &lt;include refid=&quot;Base_Column_List&quot; /&gt;<br>    tsp.sea_plan_id sea_plan_id,<br>    tsp.status_desc status_desc, -- 状态,<br>    tsp.sea_plan_no sea_plan_no, -- 海运计划号,<br>    tsp.ship_company_order_no ship_company_order_no, -- 船公司订舱单号<br>    tsp.book_space_success_flag_desc book_space_success_flag_desc, -- 是否订舱成功,<br>    tsp.plan_date plan_date, -- 计划日期,<br>    tspd.materiel_code materiel_code, -- 物料编码,<br>    tspd.materiel_name materiel_name, -- 物料名称,<br>    CONCAT(ifnull(mm.materiel_spec,&#x27;&#x27;)<br>    ,ifnull(mm.packing_weight_unit_desc,&#x27;&#x27;),&#x27;/&#x27;,ifnull(mm.packing_pieces_unit_desc,&#x27;&#x27;)) as packing_spec_full_desc,<br>    -- 规格,<br>    pg.product_grade_name product_grade_name, -- 等级,<br>    mm.base_unit_desc base_unit_desc, -- 单位<br>    tspd.product_grade_id<br>    FROM tran_sea_plan tsp<br>    LEFT JOIN tran_sea_plan_detail tspd ON tsp.sea_plan_id = tspd.sea_plan_id<br>    LEFT JOIN mst_warehouse start_mw ON start_ml.location_id = start_mw.location_id<br>    AND start_mw.organization_id = tsp.organization_id<br>    LEFT JOIN mst_carrier mc ON tsp.ship_company_id = mc.carrier_id<br>    &lt;where&gt;<br>        &lt;trim prefixOverrides=&quot;and&quot;&gt;<br>       &lt;!-- &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt;  与上面等价 --&gt;<br>            &lt;if test=&quot;queryVo.seaPlanNo != null and queryVo.seaPlanNo != &#x27;&#x27;&quot;&gt;<br>                AND tsp.sea_plan_no LIKE concat(&#x27;%&#x27;,#&#123;queryVo.seaPlanNo&#125;, &#x27;%&#x27;)<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.organizationId != null and queryVo.organizationId != &#x27;&#x27;&quot;&gt;<br>                AND tsp.organization_id = #&#123;queryVo.organizationId&#125;<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.status != null and queryVo.status.size() &gt;0&quot;&gt;<br>                AND tsp.status IN<br>                &lt;foreach collection=&quot;queryVo.status&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;<br>                    #&#123;item&#125;<br>                &lt;/foreach&gt;<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.createTimeList != null and queryVo.createTimeList.size() == 2&quot;&gt;<br>                AND tsp.create_time<br>                BETWEEN #&#123;queryVo.createTimeList[0] &#125; AND #&#123;queryVo.createTimeList[1]  &#125;<br>            &lt;/if&gt;<br>            &lt;choose&gt;<br>                &lt;when test=&quot;isUpdate !=null &quot;&gt;<br>                    AND tsp.create_time = #&#123;isUpdate, jdbcType=INTEGER&#125;<br>                &lt;/when&gt;<br>                &lt;when test=&quot;isDelete != null&quot;&gt;<br>                    AND tsp.create_time  = #&#123;isDelete, jdbcType=INTEGER&#125;<br>                &lt;/when&gt;<br>                &lt;otherwise&gt;<br>                    AND tsp.create_time NOT NULL<br>                &lt;/otherwise&gt;<br>            &lt;/choose&gt;<br>            &lt;if test=&quot; userName != null and userName !=&quot;&quot; &quot;&gt; <br>            　　&lt;bind name= &quot; userNameLike &quot; value ＝ &quot;&#x27;%&#x27;＋ userName ＋ &#x27;%&#x27;&quot;/&gt;<br>            　　and username like #&#123;userNameLike&#125; <br>            &lt;/if&gt;　　<br>        &lt;/trim&gt;<br>    &lt;/where&gt;<br>    ORDER BY<br>    tsp.sea_plan_no DESC<br>&lt;/select&gt;<br><br>&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;<br>  update Author<br>    &lt;set&gt;<br>      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;<br>    &lt;/set&gt;<br>  where id=#&#123;id&#125;<br>&lt;/update&gt;<br><br>&lt;update id=&quot;updateAuthorIfNecessary2&quot;&gt;<br>  update Author<br>    &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;<br>        &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;<br>    &lt;/trim&gt;<br>  where id=#&#123;id&#125;<br>&lt;/update&gt;<br></code></pre></td></tr></table></figure><h2 id="📓执行流程"><a href="#📓执行流程" class="headerlink" title="📓执行流程"></a>📓执行流程</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisgo.png" alt="avatar"></p><ol><li>mapper.xml中的配置⽂件⾥的每条sql语句，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为带有Id信息的一个个MappedStatement对象，再通过⼀个HashMap集合保存起来。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement。</li><li>执⾏getMapper()⽅法，判断是否注册过mapper接⼝，注册了就会使⽤mapperProxyFactory去⽣成代理类MapperProxy执⾏⽬标⽅法时，会调⽤MapperProxy代理类的invoke()⽅法</li><li>此时会使用boundSql和对应的mapperStatement构造cacheKey,先进行缓存查询，命中直接返回。缓存<code>Map&lt;Method, MapperMethodInvoker&gt; methodCache =</code></li><li>缓存无命中,则创建connect连接，通过statement对象执行execute方法。</li><li>执⾏execute()⽅法返回结果使用resultSetHandler进行结果集的封装，添加到缓存中，最后返回结果。</li></ol><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisProcess.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisProcess.jpg" alt="avatar"></a></p><ul><li>四大组件:StatementHandler、Executor、ParameterHandler、ResultSetHandler</li></ul><p>下面的执行流程简要描述，只是为了辅助理解，相关初始化方法：</p><ol><li>Configuration中保存了，解析完xml的MapperStatement的HashMap<ul><li>Mybatis将Mapper接口注册到Spring的时候，将Mapper接口生成的BeanDefinition的beanClass设置为MapperFactoryBean</li></ul></li><li>Mapper接口初始化的时候通过MapperFactoryBean，进而调用MapperProxyFactory方法初始化及调用。</li><li>MapperProxy代理调用时，通过匹配权限名+ID 获取MapperStatement对象</li><li>MapperProxy进而MapperMethod的execute方法。</li><li>SqlSession 执行的时候会获取Configuration中的四大组件进行sql执行。</li><li>Configuration返回的四大组件是经过Interceptor代理封装过返回的代理对象。</li></ol><h2 id="📓Interceptor的实现原理"><a href="#📓Interceptor的实现原理" class="headerlink" title="📓Interceptor的实现原理"></a>📓Interceptor的实现原理</h2><p>Executor、ResultSetHandler、StatementHandler、ParameterHandler，这是Mybatis中的四大对象，也是拦截器的切入点。我们可以基于这四大对象的方法进行增强。因为这四个都是接口，我们可以利用动态代理进行方法的增强。</p><p>org.apache.ibatis.session.Configuration类，在新建接口对象的时候，通过调用interceptorChain：拦截器执行链的plugin方法，返回被拦截器包装后的代理对象。 因此对象调用的时候，会判断方法是否拦截进而进入拦截器的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">wrap</span><span class="hljs-params">(Object target, Interceptor interceptor)</span> &#123;<br>        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);<br>        Class&lt;?&gt; type = target.getClass();<br>        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);<br>        <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                    type.getClassLoader(),<br>                    interfaces,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(target, interceptor, signatureMap));<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());<br>            <span class="hljs-keyword">if</span> (methods != <span class="hljs-literal">null</span> &amp;&amp; methods.contains(method)) &#123;<br>                <span class="hljs-keyword">return</span> interceptor.intercept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Invocation</span>(target, method, args));<br>            &#125;<br>            <span class="hljs-keyword">return</span> method.invoke(target, args);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul><li><code>$&#123;&#125;</code>是文件中的变量占位符，它可以用于标签属性值和内部，属于静态文本替换，比如是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如<code>$&#123;driver&#125;</code>会被静态替换为com.mysql.jdbc.Driver。</li><li>#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue).</li><li>不转义字符串，有风险，同时存在sql注入.</li></ul><h2 id="📓Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#📓Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="📓Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>📓Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h2><p><code>&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为 sql 片段标签，通过标签引入 sql 片段</p><h2 id="📓通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#📓通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="📓通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>📓通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><ul><li>在 MyBatis 中，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为带有Id信息的一个个MappedStatement对象。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement。举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。</li><li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li><li>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。</li></ul><h2 id="📓MyBatis的分页"><a href="#📓MyBatis的分页" class="headerlink" title="📓MyBatis的分页"></a>📓MyBatis的分页</h2><p>MyBatis的分页有两种，一种是使用 RowBounds 对象进行分页，另一种是使用PageHelper进行分页</p><ul><li>使用 RowBounds 对象分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，对于数据量大的情况，使用这种分页方式会浪费内存</li><li>使用PageHelper 进行分页，它是在StatementHandler之前进行拦截，对MappedStatement进行分页sql的拼接操作，PageHelper只对紧跟着的第一个SQL语句起作用.</li><li>另外可以使用mybatis插件，声明拦截器进行sql的处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;</span><br><span class="hljs-meta">      @Signature(type = Executor.class,</span><br><span class="hljs-meta">              method = &quot;query&quot;,</span><br><span class="hljs-meta">              args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class,</span><br><span class="hljs-meta">                      CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">      @Signature(type = Executor.class,</span><br><span class="hljs-meta">              method = &quot;query&quot;,</span><br><span class="hljs-meta">              args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataPermissionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span>  &#123;&#125;  <br></code></pre></td></tr></table></figure><h2 id="📓MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#📓MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="📓MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>📓MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写</p><h2 id="📓MyBatis-的关联查询"><a href="#📓MyBatis-的关联查询" class="headerlink" title="📓MyBatis 的关联查询"></a>📓MyBatis 的关联查询</h2><p>关联对象查询，有两种实现方式：</p><ol><li>一种是使用嵌套查询，在resultMap中使用association标签关联嵌套查询的sql语句。<ul><li><code>&lt;association property=&quot;way&quot; column=&quot;wayId&quot; javaType=&quot;com.whx.bus.entity.Way&quot; select=&quot;selectWayById&quot;&gt;</code></li></ul></li><li>另一种是使用 标签指定resultMapId，将关联查询的记录映射到集合List中 - 去重复的原理是标签内的子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，可以有多个，代表了联合主键的语意。</li></ol><h2 id="📓MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#📓MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="📓MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>📓MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h2><p>不同的 Xml 映射文件，如果配置了 namespace,那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复</p><h2 id="📓MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#📓MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="📓MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>📓MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>MyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li><strong>ReuseExecutor</strong>：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li><strong>BatchExecutor</strong>：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</li><li>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</li><li>Mybatis的默认执行器是SimpleExecutor，需要配置在创建SqlSession对象的时候指定执行器的类型即可。</li></ul><h2 id="📓MyBatis-xml文件与内部数据结构之间的关系？"><a href="#📓MyBatis-xml文件与内部数据结构之间的关系？" class="headerlink" title="📓MyBatis xml文件与内部数据结构之间的关系？"></a>📓MyBatis xml文件与内部数据结构之间的关系？</h2><p><code>&lt;resultMap&gt;</code>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</p><p>每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 MappedStatement 对象。</p><p>标签内的 sql 会被解析为 BoundSql 对象。</p><h2 id="📓为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#📓为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="📓为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>📓为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取</p><p>而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><h2 id="📓mybatis与Hibernate区别"><a href="#📓mybatis与Hibernate区别" class="headerlink" title="📓mybatis与Hibernate区别"></a>📓mybatis与Hibernate区别</h2><ol><li>编写sql方面：hibernate不需要自己写sql语句，只需要写hql语句。而mybatis需要自己在配置文件中写sql语句，对开发人员的sql要求较高。</li><li>sql优化方面：由于hibernate自动生成sql语句，生成的语句开发人员不易优化。而mybatis的sql完全体现在配置文件中，就便于优化。</li><li>数据库迁移方面：由于hibernate的sql是自动生成的，会根据不同的数据库生成对应的语法，迁移性较高。而mybatis的因为都是写在配置文件，迁移数据库，就可能造成语法不支持的情况。</li><li>日志方面：hibernate拥有完整的日志系统，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等。而mybatis仅有基本的记录功能。</li><li>缓存方面：hibernate有更好的二级缓存机制，可以使用第三方缓存。而mybatis支持两级缓存，实际应用中应用性不高。<ul><li>mybatis一级缓存sqlSession级的缓存。二级缓存Mapper级别的缓存。</li><li>hibernate一级缓存session级别的。Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存</li></ul></li></ol><h2 id="📓mybatis的一二级缓存"><a href="#📓mybatis的一二级缓存" class="headerlink" title="📓mybatis的一二级缓存"></a>📓mybatis的一二级缓存</h2><p>一级缓存的作用域是SQlSession, Mabits默认开启一级缓存。 在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空。</p><ul><li>Mybatis的内部缓存使用一个HashMap，key为Statement Id + Offset + Limit + Sql + Params语句。Value为查询出来的结果集映射成的java对象。 SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。<ul><li>① select * from table limit 2,1; &#x2F;&#x2F;含义是跳过2条取出1条数据</li><li>② select * from table limit 2 offset 1; &#x2F;&#x2F;含义是从第1条数据开始取出2条数据,limit后面跟的是2条数据,offset后面是从第1条开始读取,即读取第2,3条。</li></ul></li><li>一级缓存脏读：对于不同的sqlsession A与B, A做update操作，只能刷新A自己的一级缓存，无法刷新B的一级缓存。所以，如果A与B操作同一条记录，就会有脏读。<ul><li>一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li></ul></li></ul><p>二级缓存作用域是Mapper级别的，默认是没有开启。MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别。</p><ul><li><p>二级缓存脏读：在两个不同的mapper中都涉及到</p><p>同一个表</p><p>的增删改查操作，当其中一个mapper对这张表进行查询操作，此时另一个mapper进行了更新操作刷新缓存，然后第一个mapper又查询了一次，那么这次查询出的数据是脏数据。</p><ul><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li></ul></li><li><p>mybatis：查询时，先进行二级缓存执行流程后，就会进入一级缓存的执行流程。（mapper级别的缓存可能是其他旧的sqlsession更新的，自己的sqlsession若存在缓存，则为较新的缓存。）</p></li></ul><p>总结：在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据</p><ul><li>美团技术团队mybatis缓存分析：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></li></ul><h2 id="📓千万级数据查询方案—-流式查询"><a href="#📓千万级数据查询方案—-流式查询" class="headerlink" title="📓千万级数据查询方案—- 流式查询"></a>📓千万级数据查询方案—- 流式查询</h2><ul><li>流式查询指的是查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器取一条查询结果。流式查询的好处是能够降低内存使用。</li><li>流式查询的过程当中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架（mybatis）就不负责关闭数据库连接了，需要应用在取完数据后自己关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cursor 还提供了三个方法：</span><br><br><span class="hljs-comment">// 1. isOpen()：用于在取数据之前判断 Cursor 对象是否是打开状态。只有当打开时 Cursor 才能取数据；</span><br><span class="hljs-comment">// 2. isConsumed()：用于判断查询结果是否全部取完。</span><br><span class="hljs-comment">// 3. getCurrentIndex()：返回已经获取了多少条数据</span><br><br><span class="hljs-comment">// 正常使用方案1 , 使用sql session</span><br><span class="hljs-keyword">try</span> (<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();  <span class="hljs-comment">// 1</span><br>        Cursor&lt;Foo&gt; cursor = <br>              sqlSession.getMapper(FooMapper.class).scan(limit)   <span class="hljs-comment">// 2</span><br>    ) &#123;<br>        cursor.forEach(foo -&gt; &#123; &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 方案2，使用编程式事务 TransactionTemplate</span><br><span class="hljs-comment">// 方案3，使用声明式事务 @Transaction</span><br></code></pre></td></tr></table></figure><h2 id="📓MyBatis的设计模式"><a href="#📓MyBatis的设计模式" class="headerlink" title="📓MyBatis的设计模式"></a>📓MyBatis的设计模式</h2><ul><li><p>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</p><ul><li><blockquote><p>SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p></blockquote></li></ul></li><li><p>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</p></li><li><p>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</p></li><li><p>单例模式，例如ErrorContext和LogFactory；</p></li><li><p>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</p></li><li><p>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</p></li><li><p>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</p></li><li><p>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</p></li><li><p>迭代器模式，例如迭代器模式PropertyTokenizer；</p></li></ul><h2 id="📓-Param的作用"><a href="#📓-Param的作用" class="headerlink" title="📓@Param的作用"></a>📓@Param的作用</h2><p>用来指定xml中<code>#&#123;&#125;</code> 指定的参数名。</p><ul><li>对于常规的参数映射，参数解析直接按照名称解析对应的K-V对应关系。</li><li>对于对象类型传递，对于单个对象参数传递，则直接解析成class，xml文件需要直接指定class中的字段<code>demoId</code>，不能用参数前缀名<code>demo.demoId</code></li><li>对于多对象参数的传递，参数可以使用别名代替。</li><li>参数解析方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperMethod</span>&#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">convertArgsToSqlCommandParam</span><span class="hljs-params">(Object[] args)</span> &#123;<br>      <span class="hljs-keyword">return</span> paramNameResolver.getNamedParams(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数获取方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaObject</span>&#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">PropertyTokenizer</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyTokenizer</span>(name);<br>        <span class="hljs-keyword">if</span> (prop.hasNext()) &#123;<br>              <span class="hljs-type">MetaObject</span> <span class="hljs-variable">metaValue</span> <span class="hljs-operator">=</span> metaObjectForProperty(prop.getIndexedName());<br>              <span class="hljs-keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> metaValue.getValue(prop.getChildren());<br>              &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> objectWrapper.get(prop);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="💠Drools规则引擎"><a href="#💠Drools规则引擎" class="headerlink" title="💠Drools规则引擎"></a>💠Drools规则引擎</h1><h2 id="📓使用场景"><a href="#📓使用场景" class="headerlink" title="📓使用场景"></a>📓使用场景</h2><p>对于多分支的if else，可以使用策略模式进行优化。但是对于过多分支的情况，会使得策略过多，难以维护。</p><p>在该种情况下，需求点为以下四点：</p><ul><li>第一，我们要简化if else结构,让业务逻辑和数据分离！</li><li>第二，分离出的业务逻辑必须要易于编写，至少单独编写这些业务逻辑，要比写代码快！</li><li>第三，分离出的业务逻辑必须要比原来的代码更容易读懂！</li><li>第四，分离出的业务逻辑必须比原来的易于维护，至少改动这些逻辑，应用程序不用重启！</li></ul><p>规则引擎满足以上的需求点，具体体现在如下： <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/other/ruleEnginExample.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/other/ruleEnginExample.jpg" alt="image"></a></p><p>参考资料：<a href="https://www.cnblogs.com/rjzheng/p/10996186.html">规则引擎的使用场景</a></p><p>使用规则引擎可以给系统带来如下优势：</p><ul><li>高灵活性：在规则保存在知识库中，可以在规则变动轻易做出修改。</li><li>容易掌控：规则比过程代码更易于理解，因此可以有效地来弥补业务分析师和开发人员之间的沟通问题。</li><li>降低复杂度：在程序中编写大量的判断条件，很可能是会造成一场噩梦。使用规则引擎却能够通过一致的表示形式，更好的处理日益复杂的业务逻辑。</li><li>可重用性：规则集中管理，可提高业务的规则的可重用性。而且，传统的代码程序通常会添加不必要的变数，很然进行重复利用。</li></ul><blockquote><p>需要留意的是，在业务规则没有太多变动，业务规则比较简单的情况下，是没有必要使用规则引擎的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON序列化</title>
    <link href="/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h1><h2 id="Jackson序列化与反序列化"><a href="#Jackson序列化与反序列化" class="headerlink" title="Jackson序列化与反序列化"></a>Jackson序列化与反序列化</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json"><a href="#对象转json" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象"><a href="#json转对象" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>mapper.readValue(json字符串数据，类.Class)<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(mapper.readValue(json, Person[].class));<br></code></pre></td></tr></table></figure><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><p><code>@JsonIgnore</code> 此注解用于属性上，作用是进行JSON操作时忽略该属性。</p></li><li><p><code>@JsonFormat</code> 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH-mm-ss”)。</p></li><li><p><code>@JsonProperty</code> 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</p></li></ul><h2 id="Gson序列化与反序列化"><a href="#Gson序列化与反序列化" class="headerlink" title="Gson序列化与反序列化"></a>Gson序列化与反序列化</h2><h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-1"><a href="#对象转json-1" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> gson.toJson(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> gson.toJson(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-1"><a href="#json转对象-1" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">Person</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> gson.fromJson(json,对象.class);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(gson.fromJson(json, Person[].class));<span class="hljs-comment">//转为对象list</span><br></code></pre></td></tr></table></figure><p><strong>json转为List和Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Test&gt; o = gson.fromJson(json, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;转换为的对象&gt;&gt;() &#123; &#125;.getType());<br>HashMap&lt;String,Test&gt; o1 = gson.fromJson(jsonMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;HashMap&lt;String,Test&gt;&gt;()&#123;&#125;.getType());<br></code></pre></td></tr></table></figure><h3 id="常用注解：-1"><a href="#常用注解：-1" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@SerializedName(&quot;name&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</li><li><code>@Expose(serialize = false,deserialize = false)</code>serialize:是否参与序列化，deserialize是否参与反序列化</li></ul><h2 id="FastJson序列化与反序列化"><a href="#FastJson序列化与反序列化" class="headerlink" title="FastJson序列化与反序列化"></a>FastJson序列化与反序列化</h2><h3 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.79<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-2"><a href="#对象转json-2" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-2"><a href="#json转对象-2" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><h3 id="常用注解：-2"><a href="#常用注解：-2" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@JSONField(name = &quot;personName&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称,还能够日期匹配 <code>@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</code>等，基本都在此注解基础上进行的配置。</li></ul><p><strong>经典案例</strong></p><p>将map中的某个值转为指定类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getData</span><span class="hljs-params">(TypeReference&lt;T&gt; typeReference)</span>&#123;<br>   <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> get(<span class="hljs-string">&quot;data&quot;</span>);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> JSON.parseObject(s, typeReference);<br>   <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">R</span> <span class="hljs-variable">skuHasStock</span> <span class="hljs-operator">=</span> wareFeignService.getSkuHasStock(skuIdList);<br>TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;SkuHasStockVo&gt;&gt;()&#123;&#125;;<br>stockMap = skuHasStock.getData(data).stream().collect(Collectors.toMap(SkuHasStockVo::getHasStock, SkuHasStockVo::getHasStock));<br></code></pre></td></tr></table></figure><h2 id="Kryo序列化与反序列化"><a href="#Kryo序列化与反序列化" class="headerlink" title="Kryo序列化与反序列化"></a>Kryo序列化与反序列化</h2><h3 id="导包-3"><a href="#导包-3" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>作为一个灵活的序列化框架，Kryo 并不关心读写的数据，作为开发者，你可以随意使用 Kryo 提供的那些开箱即用的序列化器。</p></blockquote><h3 id="Kryo-的注册"><a href="#Kryo-的注册" class="headerlink" title="Kryo 的注册"></a>Kryo 的注册</h3><p>和很多其他的序列化框架一样，Kryo 为了提供性能和减小序列化结果体积，提供注册的序列化对象类的方式。在注册时，会为该序列化类生成 int ID，后续在序列化时使用 int ID 唯一标识该类型。注册的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>可以明确指定注册类的 int ID，但是该 ID 必须大于等于 0。如果不提供，内部将会使用 int++的方式维护一个有序的 int ID 生成。</p><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>Kryo 不是线程安全的。每个线程都应该有自己的 Kryo 对象、输入和输出实例。</p><p>因此在多线程环境中，可以考虑使用 ThreadLocal 或者对象池来保证线程安全性。</p><h4 id="ThreadLocal-Kryo-解决线程不安全"><a href="#ThreadLocal-Kryo-解决线程不安全" class="headerlink" title="ThreadLocal + Kryo 解决线程不安全"></a>ThreadLocal + Kryo 解决线程不安全</h4><p>ThreadLocal 是一种典型的牺牲空间来换取并发安全的方式，它会为每个线程都单独创建本线程专用的 kryo 对象。对于每条线程的每个 kryo 对象来说，都是顺序执行的，因此天然避免了并发安全问题。创建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Kryo&gt;() &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// 在此处配置kryo对象的使用示例，如循环引用等</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;;<br>&#125;;<br><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryos.get();<br></code></pre></td></tr></table></figure><p>之后，仅需要通过 <code>kryos.get()</code> 方法从线程上下文中取出对象即可使用。</p><h4 id="对象池-Kryo-解决线程不安全"><a href="#对象池-Kryo-解决线程不安全" class="headerlink" title="对象池 + Kryo 解决线程不安全"></a>对象池 + Kryo 解决线程不安全</h4><p><strong>「池」</strong>是一种非常重要的编程思想，连接池、线程池、对象池等都是<strong>「复用」</strong>思想的体现，通过将创建的“对象”保存在某一个“容器”中，以便后续反复使用，避免创建、销毁的产生的性能损耗，以此达到提升整体性能的作用。</p><p>Kryo 对象池原理也是如此。Kryo 框架自带了对象池的实现，整个使用过程不外乎<strong>创建池、从池中获取对象、归还对象</strong>三步，以下为代码实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pool constructor arguments: thread safe, soft references, maximum capacity</span><br>Pool&lt;Kryo&gt; kryoPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>&lt;Kryo&gt;(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">8</span>) &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">create</span> <span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// Kryo 配置</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;<br>&#125;;<br><br><span class="hljs-comment">// 获取池中的Kryo对象</span><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br><span class="hljs-comment">// 将kryo对象归还到池中</span><br>kryoPool.free(kryo);<br></code></pre></td></tr></table></figure><p>创建 Kryo 池时需要传入三个参数，其中第一个参数用于指定是否在 Pool 内部使用同步，如果指定为 true，则允许被多个线程并发访问。第三个参数适用于指定对象池的大小的，这两个参数较容易理解，因此重点来说一下第二个参数。</p><p>如果将第二个参数设置为 true，Kryo 池将会使用 java.lang.ref.SoftReference 来存储对象。这允许池中的对象在 JVM 的内存压力大时被垃圾回收。Pool clean 会删除所有对象已经被垃圾回收的软引用。当没有设置最大容量时，这可以减少池的大小。当池子有最大容量时，没有必要调用 clean，因为如果达到了最大容量，Pool free 会尝试删除一个空引用。</p><p>创建玩 Kryo 池后，使用 kryo 就变得异常简单了，只需调用 <code>kryoPool.obtain()</code> 方法即可，使用完毕后再调用 <code>kryoPool.free(kryo)</code> 归还对象，就完成了一次完整的租赁使用。</p><p>理论上，只要对象池大小评估得当，就能在占用极小内存空间的情况下完美解决并发安全问题。如果想要封装一个 Kryo 的序列化方法，可以参考如下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>    <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br>    <span class="hljs-comment">// 使用 Output 对象池会导致序列化重复的错误（getBuffer返回了Output对象的buffer引用）</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Output</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(<span class="hljs-number">1024</span>, -<span class="hljs-number">1</span>)) &#123;<br>        kryo.writeClassAndObject(opt, obj);<br>        opt.flush();<br>        <span class="hljs-keyword">return</span> opt.getBuffer();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        kryoPool.free(kryo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2022/09/04/Servlet/"/>
    <url>/2022/09/04/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Servlet是Server Applet的简称，称为服务器端小程序或服务连接器，主要功能在于交互式地浏览和修改数据，生成动态Web内容。</p><h2 id="Servlet架构"><a href="#Servlet架构" class="headerlink" title="Servlet架构"></a>Servlet架构</h2><p>Java Servlet是运行在Web服务器或应用服务器上的程序，作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。</p><p>使用Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205030850264.png" alt="image-20220503085026177"></p><p>Servlet主要执行以下任务：</p><ul><li>读取客户端（浏览器）发送的显式数据，包括网页上的HTML表单或自定义的HTTP客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式HTTP请求数据，包括Cookies，媒体类型和浏览器能理解的压缩格式等。</li><li>处理数据并生成结果、这个过程可能需要访问数据库、执行RMI等远程过程调用、调用Web服务或者直接计算得出对应的响应。</li><li>发送显式数据（文档）到客户端（浏览器），该文档的格式可以是多种多样的，包括文本文件（HMTL、XML或JSON文件）、二进制文件（GIF图像）、Excel等。</li><li>发送隐式HTTP响应到客户端（浏览器），包括告诉浏览器或其他客户端被返回的文档类型（例如HTML）、设置Cookies和缓存参数以及其他类似的任务。</li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet生命周期可被定义为从创建Servlet直到其销毁的整个过程。以下是Servlet遵循的过程：</p><ul><li>Servlet通过调用init方法进行初始化。</li><li>Servlet通过service方法来处理客户端的请求。</li><li>Servlet通过调用destroy方法终止。</li><li>最后，Servlet是由JVM的垃圾回收器进行垃圾回收的。</li></ul><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>init方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时不再调用。因此，它用于一次性初始化。</p><p>Servlet创建于用户第一次调用对应Servlet的URL时，但是也可以指定Servlet在服务器第一次启动时被调用。</p><p>用户调用一个Servlet就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候交给doGet或doPost方法。init方法简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。</p><p>init方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service方法"><a href="#Service方法" class="headerlink" title="Service方法"></a>Service方法</h3><p>service方法是执行实际任务的主要方法。Servlet容器调用service方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service方法检查HTTP请求类型（GET、POST、PUT、DELETE等），并在适当的时候调用doGet、doPost、doPut、doDelete等方法。</p><p>下面是该方法的特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service方法由容器调用，会在适当的时候调用doGet、doPost、doPut、doDelete等方法，所以不用对service方法做任何动作，只需要根据来自客户端的请求类型来重写doGet、doPost方法即可。</p><h3 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet()方法"></a>doGet()方法</h3><p>当Servlet容器接收到GET请求时，会将请求由doGet方法处理。处理逻辑写在重写的doGet方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doPost方法"><a href="#doPost方法" class="headerlink" title="doPost方法"></a>doPost方法</h3><p>当Servlet容器接收到POST请求时，会将请求由doPost方法处理。处理逻辑写在重写的doPost方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="destroy方法"><a href="#destroy方法" class="headerlink" title="destroy方法"></a>destroy方法</h3><p>当Servlet容器确定Servlet应该从服务器中移除时，将调用Servlet接口的destroy方法以允许Servlet释放它使用的任何资源和保存任何持久化的状态。例如，当想要借省内存资源或它被关闭时，容器可以执行destroy方法。</p><p>Servlet容器调用destroy方法之前，它必须让当前正在执行service方法的任何线程完成执行或超过服务器定义的事件限制。</p><p>一旦调用Servlet实例的destroy方法，容器就无法再路由其他请求到该Servlet实例。如果容器需要再次使用该Servlet，就必须用该Servlet类的一个新实例。在destroy方法完成后，Servlet容器必须释放Servlet实例以便垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>doGet处理 HTTP GET 请求</li><li>doPost处理 HTTP POST请求</li><li>doPut处理 HTTP PUT 请求</li><li>doDelete 处理 HTTP DELETE请求</li><li>doHead处理 HTTP HEAD 请求</li><li>doOptions处理 HTTP OPTIONS 请求</li><li>doTrace 处理 HTTP TRACE 请求</li></ul><h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><p>通俗点说，所谓容器，就是放东西的地方，Servlet容器自然就是方Servlet的地方。在Servlet开发中，我们需要按照Servlet的规范写代码，那么这样的代码就能在Servlet容器中运行。容器会按照规则加载类，并运行它。</p><p>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。</p><p>常见的Servlet容器有 Tomcat、Jetty、Oracle Application Server、Oracle Weblogic、JBoss Application Server等。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2022/09/04/Swagger/"/>
    <url>/2022/09/04/Swagger/</url>
    
    <content type="html"><![CDATA[<h1 id="SpingBoot整合swagger"><a href="#SpingBoot整合swagger" class="headerlink" title="SpingBoot整合swagger"></a>SpingBoot整合swagger</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-新建swagger配置类。"><a href="#2-新建swagger配置类。" class="headerlink" title="2.新建swagger配置类。"></a>2.新建swagger配置类。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/.*&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-给Controller加上注解"><a href="#3-给Controller加上注解" class="headerlink" title="3.给Controller加上注解"></a>3.给Controller加上注解</h2><p>首先要在整个类前面加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/&quot;,description = &quot;这是所有get方法&quot;)</span><br></code></pre></td></tr></table></figure><p>然后在每个接口前加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;通过这个方法可以获取到cookies&quot;,httpMethod = &quot;GET&quot;)</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/odl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/odl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OdlController</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取交换机信息 ++++++交换机+++++++++++</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 交换机信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;获取交换机信息&quot;,httpMethod = &quot;GET&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/getOvsTable&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;HostAndOvs&gt;&gt; <span class="hljs-title function_">getOvsTable</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">final</span> com.zhang.odl_sflow.entity.odlentity.tableflow.<span class="hljs-type">JsonRootBean</span> <span class="hljs-variable">flowInfo</span> <span class="hljs-operator">=</span> odlService.getFlowInfo(<span class="hljs-string">&quot;openflow:1&quot;</span>);<br>        <span class="hljs-keyword">final</span> List&lt;HostAndOvs&gt; hostInformation = RInfo.getHostInformation(odlService.getHostInfo());<br>        <span class="hljs-keyword">return</span> ResultUtils.success(hostInformation,<span class="hljs-string">&quot;获取流表信息成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4.常用注解"></a>4.常用注解</h2><p><strong>@Api</strong> 标识⼀个java类型是⽂档类，⽤controller类的类名上<br><strong>@ApiMode</strong>l 表⽰⼀个实体类&#x2F;模型⽂档，⽤在类名上；<br><strong>@ApiModelProperty</strong> 作⽤在属性上，添加属性描述；<br><strong>@ApiOperation</strong> 作⽤在接⼝类的⽅法上，控制⽅法的相关描述；<br><strong>@ApiImplicitParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，只能作⽤在⽅法上；<br><strong>@ApiImplicitParams</strong> 作⽤在接⼝⽅法上，@ApiImplicitParam参数组；<br><strong>@ApiParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，属性基本与@ApiImplicitParam⼀样，但可以作⽤在⽅法、参数、属性上；<br>下⾯分别对每个注解的常⽤参数作讲解。<br><strong>@Api</strong>：<br>value：字符串，对controller类的作⽤描述，代替原来的description(已过时)，⼀般⽤此属性；<br>tags：字符串数组，标签组，同样可以描述controller的作⽤；<br><strong>@ApiModel</strong><br>value：字符串，模型的简短别名，使得在⽂档的导航中便于识别；<br>description：字符串，模型的附加描述；<br><strong>@ApiOperation</strong><br>value：字符串，⽅法的功能描述；<br>tags：字符串数组，标签组，同样可以描述⽅法的作⽤；<br>response：ClassType，显⽰指出返回的对象类型；在响应⽰例中会显⽰出改对象的字段以及⽰例、描述；<br>code：响应代码，默认200，⼀般不改；<br><strong>@ApiModelProperty</strong><br>value：字符串，字段描述；<br>required：boolean；指定参数是否必须，默认false；<br>example：字符串，参数值的⽰例<br><strong>@ApiImplicitParam</strong><br>name：字符串，参数名；<br>value：字符串，参数描述；<br>defaultValue：字符串，参数默认值；<br>required：boolean，标识是否必须传值，默认false；<br>dataType：字符串，参数类型，可以是某个类名，也可以是基本数据类型的引⽤类名，如Integer；<br>example：字符串，参数值⽰例；<br><strong>@ApiImplicitParams</strong></p><p>value：@ApiImplicitParam类型数组，当⽅法有多个@ApiImplicitParam参数时，需要放到@ApiImplicitParams注解中</p><h2 id="5-访问端口："><a href="#5-访问端口：" class="headerlink" title="5.访问端口："></a>5.访问端口：</h2><p><code>http://IP:SpirngBoot工程端口/swagger-ui.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914031.png" alt="image-20220703093631903"></p><p>如果有强迫症不要basic-error-cotroller的话改下配置类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<span class="hljs-comment">// 对所有api进行监控</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.zhang.odl_sflow.controller&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问就没有了basic-error-cotroller了</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914990.png" alt="image-20220703093825196"></p><h2 id="高版本SpringBoot报错："><a href="#高版本SpringBoot报错：" class="headerlink" title="高版本SpringBoot报错："></a>高版本SpringBoot报错：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.context.ApplicationContextException: Failed to start bean <span class="hljs-string">&#x27;documentationPluginsBootstrapper&#x27;</span>; nested exception is java.lang.NullPointerException<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">181</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.access$<span class="hljs-number">200</span>(DefaultLifecycleProcessor.java:<span class="hljs-number">54</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:<span class="hljs-number">356</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at java.lang.Iterable.forEach(Iterable.java:<span class="hljs-number">75</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:<span class="hljs-number">155</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:<span class="hljs-number">123</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:<span class="hljs-number">935</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="hljs-number">586</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="hljs-number">147</span>) ~[spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="hljs-number">734</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="hljs-number">408</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">308</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1306</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1295</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at com.zhang.odl_sflow.OdlSFlowApplication.main(OdlSFlowApplication.java:<span class="hljs-number">11</span>) [classes/:na]<br>Caused by: java.lang.NullPointerException: <span class="hljs-literal">null</span><br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">112</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">109</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.ComparatorOrdering.compare(ComparatorOrdering.java:<span class="hljs-number">37</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at java.util.TimSort.countRunAndMakeAscending(TimSort.java:<span class="hljs-number">355</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.TimSort.sort(TimSort.java:<span class="hljs-number">220</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.Arrays.sort(Arrays.java:<span class="hljs-number">1438</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at com.google.common.collect.Ordering.sortedCopy(Ordering.java:<span class="hljs-number">855</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:<span class="hljs-number">57</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">138</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">135</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.Iterators$<span class="hljs-number">7.</span>transform(Iterators.java:<span class="hljs-number">750</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">52</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">50</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">249</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">209</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.FluentIterable.toList(FluentIterable.java:<span class="hljs-number">614</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.defaultContextBuilder(DocumentationPluginsBootstrapper.java:<span class="hljs-number">111</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.buildContext(DocumentationPluginsBootstrapper.java:<span class="hljs-number">96</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:<span class="hljs-number">167</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">178</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>... <span class="hljs-number">14</span> common frames omitted<br><br></code></pre></td></tr></table></figure><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>这个问题困扰了我很久，也在网上找了好多资料，也有些人说springboot版本升级的导致的问题。<br>找到的解决办法有两种：</p><ol><li>将springboot降级到2.5.7，但这也只是暂时解决问题的办法，不是长久之计；</li><li>从SpringFox迁移到SpringDoc，这种方式虽然可以处理问题，但对于已经上线的项目来说改动量还是有点大。<br>这上面两种解决方案都不是我最想要的，最近对Spring Boot 2.6.0的文档进行研究发现，2.6.0开始使用基于PathPatternParser的路径匹配，而Springfox版本一直没有更新还是使用的AntPathMatcher导致了这个问题，要处理问题也很简单，修改yaml文件，将SpringBoot路劲匹配模式修改为AntPathMatcher就可以了，配置如下：spring.mvc.pathmatch.matching-strategy&#x3D;ANT_PATH_MATCHER</li></ol><p>修改application.yml文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><h1 id="SpringBoot整合Kenife4j"><a href="#SpringBoot整合Kenife4j" class="headerlink" title="SpringBoot整合Kenife4j"></a>SpringBoot整合Kenife4j</h1><h2 id="1-导包-1"><a href="#1-导包-1" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;<br>   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;<br>   &lt;version&gt;3.0.3&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-新建配置类"><a href="#2-新建配置类" class="headerlink" title="2.新建配置类"></a>2.新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 必须启用swagger</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@EnableKnife4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">defaultApi2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2) <span class="hljs-comment">// 选择swagger2版本</span><br>                .useDefaultResponseMessages(<span class="hljs-literal">false</span>)<br>                <span class="hljs-comment">// 接口文档的基本信息</span><br>                .apiInfo(apiInfo())<br>                .select()<br>                <span class="hljs-comment">// 这里指定Controller扫描包路径(项目路径也行)</span><br>                <span class="hljs-comment">// 方式一：配置扫描：所有想要在swagger界面统一管理的接口，都必须在此包下</span><br>                <span class="hljs-comment">// .apis(RequestHandlerSelectors.basePackage(&quot;com.company.project.web.controller.entrance&quot;))</span><br>                <span class="hljs-comment">// 方式二：只有当方法上有@ApiOperation注解时，才能生成对应的接口文档</span><br>                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))<br>                <span class="hljs-comment">// 路径使用any风格（指定所有路径）</span><br>                .paths(PathSelectors.any())<br>                .build();<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置文档信息主页的内容说明</span><br><span class="hljs-comment">     * @param:</span><br><span class="hljs-comment">     * @return: springfox.documentation.service.ApiInfo 文档信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;接口项目 后台服务API接口文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;服务相关接口(knife4j)&quot;</span>)<br>                <span class="hljs-comment">// 服务Url（网站地址）</span><br>                .termsOfServiceUrl(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;liziyuan&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;mc1753343931&quot;</span>))<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-添加注解"><a href="#3-添加注解" class="headerlink" title="3.添加注解"></a>3.添加注解</h2><p>同Swagger</p><h2 id="4-访问端口"><a href="#4-访问端口" class="headerlink" title="4.访问端口"></a>4.访问端口</h2><p><code>http://IP:SpirngBoot工程端口/doc.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914933.png" alt="image-20220713093946919"></p><h2 id="5-报错解决方案"><a href="#5-报错解决方案" class="headerlink" title="5.报错解决方案"></a>5.报错解决方案</h2><p>同Swagger</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务哪些情况会失效？</title>
    <link href="/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
    <url>/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring事务失效"><a href="#Spring事务失效" class="headerlink" title="Spring事务失效"></a>Spring事务失效</h1><ol><li><h4 id="访问权限问题"><a href="#访问权限问题" class="headerlink" title="访问权限问题"></a>访问权限问题</h4><p>java的访问权限主要有4种：private、default、protected、public，如果事务方法的访问权限不是定义为public，这样会导致事务失效，因为spring要求被代理方法必须是public的。翻开源码，可以看到，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则返回null，即不支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> TransactionAttribute <span class="hljs-title function_">computeTransactionAttribute</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//........</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="方法用final修饰"><a href="#方法用final修饰" class="headerlink" title="方法用final修饰"></a>方法用final修饰</h4><p>如果事务方法用final修饰，会导致事务失效，因为spring事务底层原理使用了aop也就是通过jdk动态代理或者cglib，帮助我们生成了代理类，在代理类中实现的事务功能。但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p></li><li><h4 id="对象没有被spring管理"><a href="#对象没有被spring管理" class="headerlink" title="对象没有被spring管理"></a>对象没有被spring管理</h4><p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法就不会生成事务。</p></li><li><h4 id="表不支持事务"><a href="#表不支持事务" class="headerlink" title="表不支持事务"></a>表不支持事务</h4><p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的，因为myisam存储引擎不支持事务。</p></li><li><h4 id="方法内部调用"><a href="#方法内部调用" class="headerlink" title="方法内部调用"></a>方法内部调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-built_in">this</span>.updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，update方法上没有加@Transactional注解，调用有@Transactional注解的updateOrder方法，updateOrder方法上的事务会失效。因为发生了自身调用，调用该类自己的方法，而没有经过spring的代理类，只有在外部调用事务才会生效。</p><p><strong>解决：</strong></p><ul><li><p>再加一个serviece,将内部调用改为外部调用</p></li><li><p>使用编程式事务</p></li><li><p>使用AopContexct.currentProxy()获取代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        ((OrderService)AopContexct.currentProxy()).updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="未开启事务"><a href="#未开启事务" class="headerlink" title="未开启事务"></a>未开启事务</h4><p>如果是spring项目，则需要再配置文件中手动配置事务相关参数，如果忘记了配置，事务肯定是失效的。如果是spingboot项目，那么不需要手动配置。因为springboot已经在<code>DataSourceTransactionManagerAutoConfiguration</code>类中帮我们开启了事务。</p></li><li><h4 id="吞了异常"><a href="#吞了异常" class="headerlink" title="吞了异常"></a>吞了异常</h4><p>有时候事务不会回滚，有可能是在代码中手动catch了异常，因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况喜爱spring事务不会回滚。如果想要spring事务能够正常回滚必须抛出它能够处理的异常</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/"/>
    <url>/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务-Seata"><a href="#分布式事务-Seata" class="headerlink" title="分布式事务-Seata"></a>分布式事务-Seata</h1><h2 id="一、本地事务"><a href="#一、本地事务" class="headerlink" title="一、本地事务"></a>一、本地事务</h2><blockquote><p>在<code>JavaEE</code>企业级开发的应用领域，为了<strong>保证数据</strong>的<strong>完整性</strong>和<strong>一致性</strong>，必须引入数据库事务的概念，所以事务管理是企业级应用程序开发中必不可少的技术。</p><p>所谓<strong>本地事务</strong>，是指在单个数据源上进行数据的访问和更新，它<strong>仅在当前工程内有效</strong>。</p></blockquote><h3 id="1-1-ACID特性"><a href="#1-1-ACID特性" class="headerlink" title="1.1 ACID特性"></a>1.1 ACID特性</h3><ul><li>数据库事务的四大<strong>特性</strong>：原子性(<code>Atomicity</code> )、一致性( <code>Consistency</code> )、隔离性或独立性( <code>Isolation</code>) 和持久性(<code>Durabilily</code>)，简称就是 <code>ACID</code>。<ul><li><strong>原子性</strong>：一系列的操作整体不可拆分，要么同时成功，要么同时失败。</li><li><strong>一致性</strong>：数据在事务的前后，业务整体一致。</li><li><strong>隔离性</strong>：事务之间互相隔离。</li><li><strong>持久性</strong>：一旦事务成功，数据一定会落盘在数据库。</li></ul></li><li>在以往的单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易地整体回滚。就比如买东西业务，扣库存，下订单，账户扣款，是一个整体，<strong>必须同时成功或者失败</strong>。一个事务开始，代表以下的<strong>所有操作</strong>都在<strong>同一个连接</strong>里面。</li></ul><h3 id="1-2-隔离级别"><a href="#1-2-隔离级别" class="headerlink" title="1.2 隔离级别"></a>1.2 隔离级别</h3><ul><li><code>READ UNCOMMITTED</code>（<strong>脏读</strong>）：该隔离级别的事务会<strong>读到其它未提交事</strong>务的数据。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203395.webp" alt="image-20220709182208960"></p><ul><li><code>READ COMMITTED</code>（<strong>不可重复读</strong>）：一个事务可以读取另一个已提交的事务，<strong>多次读取会造成不一样的结果</strong>。<code>Oracle</code> 和 <code>SQL Server</code> 的默认隔离级别。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203393.webp" alt="image-20220709183324143"></p><ul><li><code>REPEATABLE READ</code>（<strong>虚读&#x2F;幻读</strong>）：该隔离级别是 <code>MySQL</code> 默认的隔离级别，一个事务可以<strong>读取另一个事务已提交的数据</strong>，<strong>读取的数据前后相比多了点或者少了点</strong>。<code>MySQL</code> 的 <code>InnoDB</code> 引擎可以通过<code>next-key locks</code> 机制来避免<strong>幻读</strong>。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709185135362"></p><ul><li><code>SERIALIZABLE</code>（<strong>序列化</strong>）：这是数据库<strong>最高的隔离级别</strong>，在该隔离级别下事务都是<strong>串行顺序执行</strong>的，<code>MySQL</code> 数据库的 <code>InnoDB</code> 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题，但是<strong>执行效率差</strong>，性能开销也最大，所以基本没人会用。</li></ul><h3 id="1-3-事务的传播行为"><a href="#1-3-事务的传播行为" class="headerlink" title="1.3 事务的传播行为"></a>1.3 事务的传播行为</h3><ul><li><strong>PROPAGATION_REQUIRED</strong>： ：如果当前<strong>没有</strong>事务，就<strong>创建</strong>一个新事务，如果当前<strong>存在</strong>事务，就<strong>加入</strong>该事务，该设置是<strong>最常用的设置</strong>。</li><li>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：：创建新事务，<strong>无论当前存不存在事务，都创建新事务</strong>。</li><li>PROPAGATION_NOT_SUPPORTED：：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： ：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED： ：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li><li>七种事务传播机制<strong>最常用</strong>的就<strong>两种</strong>：<ul><li>REQUIRED：一个事务，要么成功，要么失败。</li><li>REQUIRES_NEW：两个不同事务，彼此之间没有关系。一个事务失败了不影响另一个事务。</li></ul></li></ul><h3 id="1-4-本地事务在分布式下的问题"><a href="#1-4-本地事务在分布式下的问题" class="headerlink" title="1.4 本地事务在分布式下的问题"></a>1.4 本地事务在分布式下的问题</h3><p><strong>1.4.1 问题一：远程服务假失败</strong></p><ul><li>远程服务其实成功了，由于网络故障没有返回，导致订单回滚，库存却扣减。</li><li>假失败就是我们在订单服务调库存服务时， <strong>库存锁定成功</strong>，然后由于<strong>服务器</strong>慢、卡顿、等<strong>故障</strong>原因，本地事务提交了之后，<strong>一直没返回</strong>到订单服务。此时再看订单服务，因为调用库存服务时间太长了，库存服务迟迟没有返回结果，可能就会<strong>触发</strong> <code>feign</code> 的<strong>超时机制</strong>，在调用远程服务这里<strong>抛异常</strong>：<code>read time out</code> 读取超时，但是这个异常并不是我们手动抛的锁库存异常，而是 <code>feign</code> 的异常并且订单服务，设计的回滚机制，是只要<strong>一出现异常就会全部回滚</strong>，导致最终<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709064805120"></p><p><strong>1.4.2 问题二：调用新服务出现异常之后，已经执行的服务不会回滚</strong></p><ul><li>假设库存锁定成功，将结果返回到了订单服务，我们根据结果又调用了积分服务，让它扣减积分，结果<strong>积分服务</strong>内部出现<strong>异常</strong>，积分数据回滚此时再看订单服务，<strong>订单服务感知到</strong>我们手动抛的<strong>积分异常</strong>，订单数据回滚，但是<strong>库存服务</strong>，却<strong>不会有任何感知</strong>。其结果就是<strong>积分、订单数据全部回滚，库存给锁定了</strong>，也是<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203387.webp" alt="image-20220709064934354"></p><p><strong>1.4.3 总结</strong>：</p><ul><li><strong>本地事务</strong>，在分布式系统，<strong>只能控制住自己的回滚</strong>，控制不了其它服务的回滚。</li><li>产生<strong>分布式事务问题</strong>的最大原因，就是<strong>网络问题</strong> + <strong>分布式机器</strong>。</li></ul><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">假设我们有一个下单的事务场景，它会涉及调用库存、订单、会员功能。<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>在<strong>单体应用</strong>下，我们将三个功能的代码写到一个系统，而且都是连接同一数据库，这样的话很容易就能控制事务，若其中一个失败，则整个事务都会回滚。</li><li>而在<strong>分布式系统</strong>下，我们拆分了很多的微服务，它们都是独立部署且每个服务都有自己操作的数据库，那这样我们想要完成整个下单逻辑，我们就要远程调用这三个机器的各个方法。</li><li>但是，由于分布式系统会<strong>经常出现</strong>机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…等<strong>异常情况</strong>。所以，<strong>分布式事务</strong>是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是<strong>无法避免</strong>。</li></ul><h2 id="三、相关概述及理论"><a href="#三、相关概述及理论" class="headerlink" title="三、相关概述及理论"></a>三、相关概述及理论</h2><h3 id="3-1-CAP理论"><a href="#3-1-CAP理论" class="headerlink" title="3.1 CAP理论"></a>3.1 CAP理论</h3><blockquote><p><code>CAP</code> 指的是一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。</p><p><code>CAP</code> 原则指的是，这三个要素<strong>最多</strong>只能<strong>同时实现两点</strong>，<strong>不可能三者兼顾</strong>。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203402.webp" alt="image-20220709071207113"></p><ul><li><p>一致性</p><p>（Consistency）：</p><ul><li>在分布式系统中的<strong>所有数据备份</strong>，在<strong>同一时刻</strong>是否<strong>同样的值</strong>。（等同于所有节点访问同一份最新的数据副本）。</li><li>比如我们有三个节点，当我给节点1保存了值，那么我再请求节点2、3的数据时，响应的数据也应该是这个最新的值。</li></ul></li><li><p>可用性</p><p>（Availability） ：</p><ul><li>在集群中一<strong>部分节点故障</strong>后，集群<strong>整体是否还能响应</strong>客户端的读写请求。（对数据更新具备高可用性）。</li></ul></li><li><p>分区容错性</p><p>（Partition Tolerance） ：</p><ul><li>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是<strong>区间通信可能失败</strong>。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</li></ul></li></ul><h3 id="3-2-CAP为什么不能三者兼顾？"><a href="#3-2-CAP为什么不能三者兼顾？" class="headerlink" title="3.2 CAP为什么不能三者兼顾？"></a>3.2 CAP为什么不能三者兼顾？</h3><ul><li><strong>满足一致性</strong>：假设我们有三个节点，当客户端有一个请求进来，我们所有的节点完成数据备份，此时满足了我们的一致性<code>C</code>的需求。</li><li><strong>可用性与一致性冲突</strong>：再次假设，当节点1向节点2、3要求同步备份数据时，此时节点3发生了网络故障，也就是分区容错性。接下来我们就会考虑，能否<strong>满足可用性</strong>？若让其满足的话（允许客户端请求负载到节点3读取数据），但是由于上次发生故障导致节点3的数据没有更新，则此时<strong>读到的数据</strong>就出现了<strong>不一致</strong>。所以当你想要满足一致性，就必须让节点3不能被访问，既然不能被访问相当于又不可用。**<code>C</code>和<code>A</code>无法同时做到**。</li><li>在<strong>分布式系统</strong>里，因为我们这个<strong>网络肯定会出现问题</strong>，所以我们<strong>永远都要满足分区容错</strong>。则就需要在一致性与可用性做出选择。</li><li>选择可用性+分区容错性（<code>AP</code>）的情况下，我们不去在意读到的数据是否一致，这种场景实现相对简单。</li><li>若选择一致性+分区容错性（<code>CP</code>）的情况下，是如何保证它们之间一致的？我们在分布式系统里边一般会有一些<strong>一致性算法</strong>，典型的代表，比如说Google的Chubby分布式锁服务，采用了<code>Paxos</code>算法；etcd分布式键值数据库，采用了<code>Raft</code>算法；ZooKeeper分布式应用协调服务，Chubby的开源实现，采用<code>ZAB</code>算法。</li></ul><h3 id="3-3-Raft算法实现分布式系统一致性"><a href="#3-3-Raft算法实现分布式系统一致性" class="headerlink" title="3.3 Raft算法实现分布式系统一致性"></a>3.3 Raft算法实现分布式系统一致性</h3><ul><li>由于 <code>Paxos</code> 算法过于晦涩难懂且难以实现，后提出了一种更<strong>易于理解</strong>和实现并能等价于 <code>Paxos</code> 算法<strong>的共识算法</strong> - <code>Raft </code>算法。</li><li><code>Raft</code> 算法有<strong>两个核心概念</strong>：<ul><li><strong>领导选举</strong>（关注角色、心跳时间、自旋时间）-&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">Leader的选举过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">acehi.github.io&#x2F;thesecretli…</a></li><li><strong>日志复制</strong> -&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">日志复制过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">acehi.github.io&#x2F;thesecretli…</a></li></ul></li><li>通过它们来保证我们整个集群的一致性，即使有分区错误，我们也能保持一致性。</li></ul><h3 id="3-4-Base理论"><a href="#3-4-Base理论" class="headerlink" title="3.4 Base理论"></a>3.4 Base理论</h3><blockquote><p>是对 <code>CAP</code> 理论的延伸，思想是即使无法做到强一致性（<code>CAP</code> 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。</p></blockquote><ul><li>强一致与弱一致是<strong>对立</strong>概念。<strong>强一致性</strong>也叫做<strong>线性一致性</strong>，除此以外，所有其它的一致性都是弱一致性的特殊情况。所谓强一致性，即数据备份是<strong>同步</strong>的，<strong>弱一致性</strong>，即数据备份是<strong>异步</strong>的。</li><li><strong>基本可用</strong>（Basically Available）：指分布式系统在出现故障的时候，<strong>允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，基本可用绝<strong>不等价于系统不可用</strong>。就比如：<ul><li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒（查询故障节点不行，就换其它机器进行查询，允许查询速度慢一点）。</li><li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><strong>软状态</strong>（ Soft State） ：指允许系统存在<strong>中间状态</strong>，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的<strong>延时</strong>就是软状态的体现。<code>MySQL Replication</code> 的异步复制也是一种体现。</li><li><strong>最终一致性</strong>（ Eventual Consistency）：指系统中的所有数据副本<strong>经过一定时间</strong>后，最终能够<strong>达到一致</strong>的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h2 id="四、常见解决方案"><a href="#四、常见解决方案" class="headerlink" title="四、常见解决方案"></a>四、常见解决方案</h2><h3 id="4-1-2PC-模式"><a href="#4-1-2PC-模式" class="headerlink" title="4.1 2PC 模式"></a>4.1 2PC 模式</h3><blockquote><p><code>2PC</code> 就是我们说的<strong>二阶段提交</strong>，又叫做 <code>XA Transactions</code>。<code>MySQL</code> 从 5.5 版本开始支持，<code>SQL Server</code> 2005 开始支持，<code>Oracle</code> 7 开始支持。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203435.webp" alt="image-20220709074848470"></p><ul><li>假设我们这有一个本地资源管理器（相当于每个服务的事务管理器），一个事务管理器（相当于总的事务管理器）。</li><li>协调事务处理共为<strong>两个阶段</strong>：<ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交</strong>（<code>PreCommit</code>）此操作，并<strong>反映是否可以提交</strong>。</li><li>第二阶段：事务协调器<strong>要求</strong>每个数据库<strong>提交数据</strong>。</li><li>其中，如果有<strong>任何一个</strong>数据库<strong>否决</strong>此次提交，那么所有数据库都会被要求<strong>回滚</strong>它们在此事务中的那部分信息。</li></ul></li><li><strong>优点</strong>：<ul><li><code>XA 协议</code>比较<strong>简单</strong>，而且一旦商业数据库实现了 <code>XA 协议</code>，使用分布式事务的成本也比较低。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>性能不理想</strong>，特别是在交易下单链路，往往并发量很高，无法满足高并发场景。</li><li>目前在商业数据库支持的比较理想，在 <strong>mysql 数据库中支持的不太理想</strong>，<code>mysql</code> 的 <code>XA</code> 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</li><li>许多 <code>nosql</code> 也没有支持 <code>XA</code>，这让 <code>XA</code> 的<strong>应用场景</strong>变得<strong>非常狭隘</strong>。</li></ul></li><li><strong>总结</strong>：了解即可，使用场景非常少。</li></ul><h3 id="4-2-3PC-模式"><a href="#4-2-3PC-模式" class="headerlink" title="4.2 3PC 模式"></a>4.2 3PC 模式</h3><blockquote><p>三阶段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一个<strong>改良版本</strong>，引入了两个新的特性。</p></blockquote><ul><li>协调者和参与者均<strong>引入超时机制</strong>，通过超时机制来解决 <code>2PC</code> 的同步阻塞问题，<strong>避免事务</strong>资源<strong>被永久锁定</strong>。</li><li>把二阶段演变为三阶段，二阶段提交协议中的第一阶段”准备阶段”一分为二，形成了新的 <code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code> 三个阶段组成事务处理协议。</li><li><strong>优点</strong>：<code>3PC</code> 相比较于 <code>2PC</code> 最大的优点就是<strong>降低了参与者的阻塞范围</strong>，并且能够在协调者出现<strong>单点故障后继续达成一致</strong>。</li><li><strong>缺点</strong>：虽然通过超时机制解决了资源永久阻塞的问题，但是 <code>3PC</code> <strong>依然存在数据不一致的问题</strong>。当参与者接收到 <code>PreCommit</code> 消息后，如果网络出现分区，此时协调者与参与者无法进行正常通信，这种情况下，参与者依然会进行事务的提交。</li><li><strong>总结</strong>：通过了解 <code>2PC</code> 和 <code>3PC</code> 之后，我们可以知道这<strong>两种方案都无法彻底解决分布式下的数据一致性</strong>。</li></ul><h3 id="4-3-柔性事务-TCC-事务补偿方案"><a href="#4-3-柔性事务-TCC-事务补偿方案" class="headerlink" title="4.3 柔性事务-TCC 事务补偿方案"></a>4.3 柔性事务-TCC 事务补偿方案</h3><blockquote><p>补偿事务<code>TCC</code>，全称<code>Try-Confirm-Cancel</code>。</p></blockquote><ul><li><strong>什么是柔性事务</strong>？<ul><li>刚性事务：遵循 <code>ACID</code> 原则，强一致性。</li><li>柔性事务：遵循 <code>BASE</code> 理论，最终一致性。与刚性事务不同，柔性事务<strong>允许一定时间</strong>内，不同节点的数据<strong>不一致</strong>，<strong>但要求最终一致</strong>。</li></ul></li><li><strong>TCC核心思想</strong>：针对每个操作都要注册一个与其对应的确认（<code>Try</code>）和补偿（<code>Cancel</code>）。<ul><li><strong>Try阶段</strong>：做一些<strong>业务检查</strong>以及一些资源预留，它需要后续的<code>Confirm</code>一起才能构成一个完成的业务逻辑。</li><li><strong>Comfirm阶段</strong>：<strong>确认提交</strong>，<code>Try</code> 阶段所有分支事务执行成功后开始执行 <code>Confirm</code> 。</li><li><strong>Cancel阶段</strong>：业务执行出错需要<strong>回滚</strong>。</li></ul></li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203449.webp" alt="image-20220709082734127"></p><ul><li><p>总结</p><p>：</p><ul><li><code>2PC</code> 通常是在跨库<code>DB</code>里，而 <code>TCC</code> 是在<strong>应用层</strong>面。</li><li><code>TCC</code> 每个业务逻辑代码都要实现<code>Try</code>、<code>Confirm</code>、<code>Cacnel</code>接口，<strong>开发难度大</strong>，所以所对<strong>应用的倾入性非常强</strong>。</li></ul></li></ul><h3 id="4-4-柔性事务-最大努力通知方案"><a href="#4-4-柔性事务-最大努力通知方案" class="headerlink" title="4.4 柔性事务-最大努力通知方案"></a>4.4 柔性事务-最大努力通知方案</h3><blockquote><p>方案主要用在<strong>与第三方系统通讯</strong>时，比如：调用微信或支付宝支付后的支付结果通知。这种 方案也是结合 <code>MQ</code> 进行实现，例如：通过 <code>MQ</code> 发送 <code>http</code> 请求，<strong>设置最大通知次数</strong>，<strong>达到通知次数后即不再通知</strong>。</p></blockquote><ul><li><strong>应用场景</strong>：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对 账文件），支付宝的支付成功异步回调。</li><li><strong>案例说明</strong>：我们现在有一个大业务，调用了积分、库存和订单业务。当订单和库存都执行结束，但是在做用户积分扣减时<strong>失败</strong>了，然后订单模块就会<strong>发送一条消息</strong>给 <code>MQ</code>。接下来由订阅了消息队列的订单及库存服务接收消息，当它们都<strong>收到消息后</strong>，库存服务就会解锁库存，订单服务就会解锁订单，<strong>完成事务的回滚</strong>。既然是最大努力通知，期间就会<strong>不断发送</strong>业务处理失败的消息，<strong>直至</strong>对应业务<strong>返回处理成功</strong>的消息，<strong>就不再进行通知</strong>了。</li></ul><h3 id="4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul><li><strong>实现</strong>：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，<strong>实时消息服务只记录消息数据</strong>，而不是真正的发送。业务处理服务在<strong>业务事务提交之后</strong>，向实时消息服务<strong>确认发送</strong>。只有在得到确认发送指令后，实时消息服务<strong>才会真正发送</strong>。</li><li><strong>关键点</strong>（防止消息丢失）：<ul><li>做好消息确认机制 <code>Publisher</code>，<code>Consumer</code> 手动 <code>ack</code>。</li><li>每一个发送的消息都在数据库做好记录，定期将失败的消息再次发送一遍。</li></ul></li><li><strong>消息记录表</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mq_message` (<br>`message_id` <span class="hljs-type">CHAR</span> ( <span class="hljs-number">32</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br>`to_exchane` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`routing_key` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`class_type` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`message_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">1</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,<br>`create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `message_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="五、分布式事务框架-Seata"><a href="#五、分布式事务框架-Seata" class="headerlink" title="五、分布式事务框架-Seata"></a>五、分布式事务框架-Seata</h2><blockquote><p><code>Seata</code> 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。<code>Seata</code> 将为用户提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h3 id="5-1-核心概念及原理"><a href="#5-1-核心概念及原理" class="headerlink" title="5.1 核心概念及原理"></a>5.1 核心概念及原理</h3><ul><li>TC - 事务协调者：维护全局和分支事务的状态，<strong>驱动</strong>全局事务<strong>提交或回滚</strong>。</li><li>TM - 事务管理器：<strong>定义全局</strong>事务的<strong>范围</strong>（开始全局事务、提交或回滚全局事务）。</li><li>RM - 资源管理器：<strong>管理分支</strong>事务处理的<strong>资源</strong>，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li><li><strong>工作原理</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203454.webp" alt="image-20220709125044911"></p><ul><li><p>流程描述</p><p>：</p><ul><li>假设我们现在要执行一个大的下单业务 Business，<strong>大业务</strong>的 <code>TM</code>（事务管理器）先会告诉 <code>TC</code>（事务协调者）它要准备跨服<strong>开启</strong>一个<strong>全局事务</strong>。</li><li>开始全局事务后，接下来它调用第一个微服务的事务方法的时候，Storage 服务就会在 <code>TC</code>（事务协调者）<strong>注册</strong>一下，我们称为<strong>分支事务</strong>。相当于它的 <code>RM</code>（资源管理器）会告诉 <code>TC</code>（事务协调者），它有一个分支事务，并且它要实时<strong>汇报</strong>它的<strong>事务状态</strong>，它这个分支是提交成功还是失败回滚， <code>TC</code>（事务协调者）都能实时的知道。</li><li>接下来调我们第二个远程服务 Order，及第三个远程服务 Account也是同理注册分支事务，并且实时汇报状态。</li><li><strong>大事务只要一开启</strong>，每调一个小事务，<code>TC</code>（事务协调者）<strong>都知道</strong>这个<strong>小事务成了还是败了</strong>。</li><li>假设其中最后一个分支事务失败了，需要进行回滚。这个时候，<code>TC</code>（事务协调者）知道我们的大事务，已经调成功两个了，并且前两个事务都已经提交了，但是第三个事务给回滚了，<code>TC</code>（事务协调者）就会<strong>命令前两个事务也回滚</strong>。</li></ul></li></ul><h3 id="5-2-AT模式"><a href="#5-2-AT模式" class="headerlink" title="5.2 AT模式"></a>5.2 AT模式</h3><p><strong>5.2.1 相关概念</strong>：</p><ul><li><code>AT</code>模式（自动事务Auto Transaction）是<code>Seata</code>最<strong>主推的</strong>分布式事务解决方案，它是基于<code>XA</code>演进而来。</li><li><code>AT</code> 模式是一种<strong>无侵入</strong>的分布式事务解决方案，也就是说我们<strong>不需要再编写多余的代码来实现</strong>这个模式，<strong>只需要</strong>在方法中<strong>添加上指定的注解</strong>即可。</li><li>在 AT 模式下，用户只需关注自己的“业务 <code>SQL</code>”，用户的 “业务 <code>SQL</code>” 作为一阶段，<code>Seata</code> 框架会<strong>自动生成</strong>事务的<strong>二阶段提交和回滚</strong>操作。</li><li>AT模式支持的数据库有：<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>和 <code>TiDB</code>。</li></ul><p><strong>5.2.2 模式概述</strong>：</p><ul><li><p><strong>前提</strong>：我们如果要使用该模式，那么<strong>每一个</strong>要使用分布式事务的<strong>数据库</strong>都需要一个 <code>UNDO_LOG</code> 表（即回滚日志表）。</p></li><li><p><strong>效果</strong>：该模式下 <code>TC</code>（事务协调者） 只要调分支事务，<strong>成功</strong>之后就会<strong>提交事务</strong>，但是如果有一个分支事务<strong>失败</strong>了，失败的这个可以<strong>自己进行回滚</strong>。</p></li><li><p>处理逻辑</p><p>：</p><ul><li>某个服务除了它常规的业务表以外，我们会额外去创建一个回滚日志表。它是在<code>RM</code>（资源管理器）部分完成的，会在<strong>每一个数据库单元处理时</strong>均会生成一条<code>log</code>数据。</li><li>对于已提交的事务要进行回滚，它会利用<strong>魔改数据库进行反向补偿</strong>。比如：我们这有条加二的记录，原来它的值是八，加二以后变成十，结果被人给回滚了。</li><li>它先在 <code>UNDO_LOG</code> 里面记录了一下这条<strong>记录没改变之前的值</strong>。如果它失败回滚了，那它就回过头把我们数据库里边的这个十再改回去，改成八。所以，它相当于在我们事务执行之前，它先读取一下这个状态是几，最后再改回来。</li></ul></li></ul><h3 id="5-3-Seata-服务搭建"><a href="#5-3-Seata-服务搭建" class="headerlink" title="5.3 Seata 服务搭建"></a>5.3 Seata 服务搭建</h3><p><strong>5.3.1 组件版本关系</strong>：</p><blockquote><p>每个 <code>Spring Cloud Alibaba</code> 版本及其自身所适配的各组件对应版本如下表所示（<strong>避免版本不兼容</strong>带来未知问题）。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203640.webp" alt="image-20220708081609199"></p><p><strong>5.3.2 Docker下安装 Seata</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.下载镜像（注意：此处版本号请参考组件版本关系图！）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.启动容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name seata-server -p 8091:8091 seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.创建存放配置的文件夹。</span><br>mkdir -p /home/seata/config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.拷贝配置文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> seata-server:/seata-server/resources /home/seata/config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.编辑配置文件（参考下面截图）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home/seata/config/resources</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim registry.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在registry.conf指定seata配置的位置（config &#123;<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;nacos&quot;</span>&#125;）。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在file.conf中指定事务日志存储类型（store &#123;mode = <span class="hljs-string">&quot;db&quot;</span>&#125;），若使用mysql-8版本则需要额外修改以下两项配置，否则报错。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">driverClassName = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata?serverTimezone=UTC&quot;</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203629.webp" alt="image-20220708100915057"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">6.停止容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.移除旧容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">8.启动新容器并挂载配置。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d \</span><br><span class="language-bash">--name seata-server \</span><br><span class="language-bash">-p 8091:8091 \</span><br><span class="language-bash">-e SEATA_IP=yourIp（公网IP） \</span><br><span class="language-bash">-v /home/seata/config/resources:/seata-server/resources \</span><br><span class="language-bash">seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker update seata-server --restart=always</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.3.3 验证Seata服务启动成功</strong>：</p><ul><li>查看容器日志（Server started …）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs seata-server</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>访问注册中心后台（成功注册）：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">http://yourIp:8848/nacos<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203674.webp" alt="image-20220708101405016"></p><h3 id="5-4-项目整合"><a href="#5-4-项目整合" class="headerlink" title="5.4 项目整合"></a>5.4 项目整合</h3><p><strong>5.4.1 数据库添加 UNDO_LOG 表</strong>：</p><blockquote><p>每一个要使用分布式事务的数据库都需要一个 <code>UNDO_LOG</code> 表。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log` (<br>`id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`branch_id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`xid` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`context` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`rollback_info` LONGBLOB <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_created` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`ext` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br><span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` ( `xid`, `branch_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li><code>branch_id</code>：分支事务ID。</li><li><code>xid</code>：全局事务ID（<code>Seata</code> 服务端地址+ ID）。</li><li><code>context</code>：回滚信息序列化和压缩格式。</li><li><code>rollback_info</code>：回滚信息。</li><li><code>log_status</code>：日志状态（<code>0</code>表示正常，<code>1</code>表示全局已完成）。</li><li><code>log_created</code>：创建时间。</li><li><code>log_modified</code>：修改时间。</li></ul><p><strong>5.4.2 依赖引入</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">        <span class="hljs-comment">&lt;!--需要分布式事务的服务引入 seata-starter--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.3 配置代理数据源</strong>：</p><blockquote><p>配置代理数据源实现分支事务，如果没有注入，事务无法成功回滚。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySeataConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DataSourceProperties dataSourceProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要将 DataSourceProxy 设置为主数据源，否则事务无法回滚。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSourceProperties 数据源属性配置。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> DataSource&#125;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(DataSourceProperties dataSourceProperties)</span> &#123;<br><br>        <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> dataSourceProperties.initializeDataSourceBuilder()<br>                .type(HikariDataSource.class).build();<br><br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(dataSourceProperties.getName())) &#123;<br>            dataSource.setPoolName(dataSourceProperties.getName());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceProxy</span>(dataSource);<br>    &#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.4 微服务中添加配置文件</strong>：</p><blockquote><p><strong>方式一</strong>（此处使用）：<strong>每个</strong>要使用分布式事务的<strong>微服务</strong>服务中（<code>src/main/resources/</code>），都要添加这两个文件（<code>registry.conf</code>、<code>file.conf</code>）。</p><p><strong>方式二</strong>：也可以将 <code>Nacos</code> 作为统一配置中心，去配置 <code>Seata</code> 的 <code>file.conf</code> 各项参数，实现集群的配置共享，并结合 <code>application.properties/yml</code> + <code>registry.conf</code> 完成微服务整合。</p></blockquote><ul><li><code>registry.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---注册中心配置---</span><br><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="hljs-comment">  # 指定类型为nacos注册中心（根据项目所使用的注册中心进行选择），默认是&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">eureka</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serviceUrl</span> = <span class="hljs-string">&quot;http://localhost:1001/eureka&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">weight</span> = <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">redis</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:6379&quot;</span><br>    <span class="hljs-attr">db</span> = <span class="hljs-string">&quot;0&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">sofa</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:9603&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">region</span> = <span class="hljs-string">&quot;DEFAULT_ZONE&quot;</span><br>    <span class="hljs-attr">datacenter</span> = <span class="hljs-string">&quot;DefaultDataCenter&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">addressWaitTime</span> = <span class="hljs-string">&quot;3000&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---配置中心---</span><br><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="hljs-comment">  # 指定seata配置的位置，默认&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;file&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">apollo</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">app.id</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br>    <span class="hljs-attr">apollo.meta</span> = <span class="hljs-string">&quot;http://192.168.1.204:8801&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # 关联 `file.conf` 文件中配置的seata参数。</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><ul><li><code>file.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---网络传输配置---</span><br><span class="hljs-attr">transport</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # tcp udt unix-domain-socket</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;TCP&quot;</span><br><span class="hljs-comment">  #NIO NATIVE</span><br>  <span class="hljs-attr">server</span> = <span class="hljs-string">&quot;NIO&quot;</span><br><span class="hljs-comment">  #enable heartbeat</span><br>  <span class="hljs-attr">heartbeat</span> = <span class="hljs-string">true</span><br><span class="hljs-comment">  #thread factory for netty</span><br>  <span class="hljs-attr">thread-factory</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">boss-thread-prefix</span> = <span class="hljs-string">&quot;NettyBoss&quot;</span><br>    <span class="hljs-attr">worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerNIOWorker&quot;</span><br>    <span class="hljs-attr">server-executor-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerBizHandler&quot;</span><br>    <span class="hljs-attr">share-boss-worker</span> = <span class="hljs-string">false</span><br>    <span class="hljs-attr">client-selector-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientSelector&quot;</span><br>    <span class="hljs-attr">client-selector-thread-size</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">client-worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientWorkerThread&quot;</span><br><span class="hljs-comment">    # netty boss thread size,will not be used for UDT</span><br>    <span class="hljs-attr">boss-thread-size</span> = <span class="hljs-string">1</span><br><span class="hljs-comment">    #auto default pin or 8</span><br>    <span class="hljs-attr">worker-thread-size</span> = <span class="hljs-string">8</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">shutdown</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # when destroy server, wait seconds</span><br>    <span class="hljs-attr">wait</span> = <span class="hljs-string">3</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">serialization</span> = <span class="hljs-string">&quot;seata&quot;</span><br>  <span class="hljs-attr">compressor</span> = <span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---当前微服务在seata服务器中注册的信息配置---</span><br><span class="hljs-attr">service</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 事务分组，默认：$&#123;spring.applicaiton.name&#125;-fescar-service-group。</span><br>  <span class="hljs-attr">vgroup_mapping.applicaiton-name-fescar-service-group</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">  # 仅支持单节点，不要配置多地址，这里的default要和事务分组的值一致。</span><br>  <span class="hljs-attr">default.grouplist</span> = <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span><br><span class="hljs-comment">  # 降级，当前不支持。</span><br>  <span class="hljs-attr">enableDegrade</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  # 禁用全局事务。</span><br>  <span class="hljs-attr">disable</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br>  <span class="hljs-attr">max.commit.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br>  <span class="hljs-attr">max.rollback.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---客户端相关工作的机制---</span><br><span class="hljs-attr">client</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">async.commit.buffer.limit</span> = <span class="hljs-string">10000</span><br>  <span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">retry.internal</span> = <span class="hljs-string">10</span><br>    <span class="hljs-attr">retry.times</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">report.retry.count</span> = <span class="hljs-string">5</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---事务日志存储配置---</span><br><span class="hljs-comment"># 注意：该部分配置仅在seata-server中使用，如果选择db请配合seata.sql使用。</span><br><span class="hljs-comment">## transaction log store </span><br><span class="hljs-attr">store</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## store mode: file、db</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;file&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## file store</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br>    <span class="hljs-attr">max-branch-session-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # globe session size , if exceeded throws exceptions</span><br>    <span class="hljs-attr">max-global-session-size</span> = <span class="hljs-string">512</span><br><span class="hljs-comment">    # file buffer size , if exceeded allocate new buffer</span><br>    <span class="hljs-attr">file-write-buffer-cache-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # when recover batch read size</span><br>    <span class="hljs-attr">session.reload.read_size</span> = <span class="hljs-string">100</span><br><span class="hljs-comment">    # async, sync</span><br>    <span class="hljs-attr">flush-disk-mode</span> = <span class="hljs-string">async</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## database store</span><br>  <span class="hljs-attr">db</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br>    <span class="hljs-attr">datasource</span> = <span class="hljs-string">&quot;dbcp&quot;</span><br><span class="hljs-comment">    ## mysql/oracle/h2/oceanbase etc.</span><br>    <span class="hljs-attr">db-type</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br>    <span class="hljs-attr">user</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">min-conn</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">max-conn</span> = <span class="hljs-string">3</span><br>    <span class="hljs-attr">global.table</span> = <span class="hljs-string">&quot;global_table&quot;</span><br>    <span class="hljs-attr">branch.table</span> = <span class="hljs-string">&quot;branch_table&quot;</span><br>    <span class="hljs-attr">lock-table</span> = <span class="hljs-string">&quot;lock_table&quot;</span><br>    <span class="hljs-attr">query-limit</span> = <span class="hljs-string">100</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## the lock store mode: local、remote</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;remote&quot;</span><br><br>  <span class="hljs-attr">local</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in user&#x27;s database</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">remote</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in the seata&#x27;s server</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">recovery</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">asyn-committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">rollbacking-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">timeout-retry-delay</span> = <span class="hljs-string">30</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">transaction</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">undo.data.validation</span> = <span class="hljs-string">true</span><br>  <span class="hljs-attr">undo.log.serialization</span> = <span class="hljs-string">&quot;jackson&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## metrics settings</span><br><span class="hljs-attr">metrics</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">enabled</span> = <span class="hljs-string">false</span><br>  <span class="hljs-attr">registry-type</span> = <span class="hljs-string">&quot;compact&quot;</span><br><span class="hljs-comment">  # multi exporters use comma divided</span><br>  <span class="hljs-attr">exporter-list</span> = <span class="hljs-string">&quot;prometheus&quot;</span><br>  <span class="hljs-attr">exporter-prometheus-port</span> = <span class="hljs-string">9898</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><p><strong>5.4.5 添加全局事务注解</strong>：</p><ul><li><strong>主业务</strong>方法添加<strong>全局事务</strong>注解：<code>@GlobalTransactional</code></li><li><strong>分支业务</strong>方法添加<strong>本地事务</strong>注解：<code>@Transactional</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@GlobalTransactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String userId, String commodityCode, <span class="hljs-type">int</span> orderCount)</span> &#123;<br>        ......<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="5-5-更多官方示例"><a href="#5-5-更多官方示例" class="headerlink" title="5.5 更多官方示例"></a>5.5 更多官方示例</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 整合 nacos</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-nacos-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 jpa</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-jpa-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 dubbo</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-dubbo-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 ShardingSphere</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-shardingsphere-seata</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务是一种去中心化的应用架构方案。相对于单体式应用来说，微服务应用具有耦合性低、扩展性高、更灵活、能更高效交付的特点。</p><p>从名称上看。微服务的“微”涵盖了以下几层含义：</p><ul><li>服务按功能进行一定粒度的拆分，每一块都有独立的职责。</li><li>由于做了拆分，每一个微服务的开发都是独立进行的，因此这种架构的交付节奏可以更加灵活</li><li>微服务应用的部署及应用都是隔离的，这保证了整个应用架构可以按需进行扩展</li></ul><h2 id="微服务基础设施"><a href="#微服务基础设施" class="headerlink" title="微服务基础设施"></a>微服务基础设施</h2><p>微服务架构本质上是一种面向服务的分布式系统，为了解决分布式所带来的一系列管理问题，微服务通常需要依赖一些基础设施来保证架构的完整性。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在一个微服务集群中，由于服务的种类，实例数量由很多，仅通过人工配置的方式会加大工作量。而且这些服务实例的信息可能随时会发生变化，比如我们可能需要对某个服务做在线的扩容，或者因为故障处理而隔离某些节点。因此，需要由一个自动化的服务注册组件来完成这件事。服务注册通常需要记录当前可用的服务实例信息，并提供服务注册表API。服务的调用方可以通过API获得所需服务的实例信息，并实时订阅服务实例的变化。</p><p>通常服务注册的实现方式是心跳，即注册表于服务实例之间保持一个稳定的心跳检测，根据心跳的状态来判断服务实例是否存货。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>既然大量的微服务实例都记录到了服务注册表中，那么服务的调用方则应该通过服务发现组件来动态地可调用地服务实例信息。在微服务架构中，服务地发现有两种实现方式。</p><ol><li><p><strong>客户端发现</strong></p><p>客户端发现是指由调用方来完成目标服务实例信息地发现。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955546.png" alt="image-20220528195417255"></p></li><li><p><strong>服务端发现</strong></p><p>服务端发现是一种代理式地架构，即服务器间调用统一使用负载均衡器来实现。这与客户端发现的差别在于：服务实例的发现由负载均衡器来完成，并且所有的微服务接口调用都由该组件来代理</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955537.png" alt="image-20220528195428061"></p><p>这种方式的好处是可以屏蔽被调用服务的一些内部细节，并增加一些公共的能力，比如接口鉴权、流量控制、日志记录等。但是弊端也很明显，由于所有接口调用都需要经过该负载均衡器，所以该组件很容易形成瓶颈，一旦负载均衡器故障将会产生全局的影响</p><p>服务发现的实现方法无论是客户端发现还是服务器端发现，都离不开以下两点：</p><ul><li>依赖服务注册表组件来发现可用的服务</li><li>提供包括，目标实例的路由，如何在多个实例中挑选合适的节点取决于路由的算法，常见的包括随机路由、轮询路由、动态压力路由。</li></ul></li></ol><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>API网关是外部系统接入微服务集群的唯一入口。我们可以将微服务架构看作一个整体，其内部的微服务职责划分、服务间的交互调用对于外部来说是不可见的。那么为了对外提供体验一致的访问接口，微服务需要一个统一的API网关，所有外部系统对微服务的调用都经过API网关组件。</p><p>API网关组件通常具备的功能包括但不限于：</p><ul><li>接入鉴权</li><li>传输加密</li><li>请求路由</li><li>流量控制</li><li>灰度发布</li></ul><h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>在系统的节点实例变多后，实例故障的概率会增加。而且一旦故障发生，服务间的调用关系会导致故障大面积”传染“，通过人工进行实例故障隔离的方式效率较低，这就需要微服务能自动检测问题并自动做出应对。这种检测及应对能力通常由服务容错组件提供，一些手段如下：</p><ul><li>请求重试：在某些关键业务出现问题时，尝试进行请求的重试。</li><li>流量控制：这需要先对系统的容错做出明确的规划，然后对读物实例上的流量进行实时监控，一旦发现超过阈值则拒绝请求，这样就可以避免整个系统全面瘫痪。</li><li>服务熔断：根据一定的规则判断目标服务是否已经失效，规则的设计可以基于某个时间窗口的调用失败率进行计算，如果超过阈值则执行熔断（快速返回错误信息）</li></ul><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>对微服务实例保持足够的监控是非常重要的，而通常架构上需要对服务监控组件进行单独考虑。监控的目的是及时发现问题并采取一定的合理规避措施，以保证服务的SLA质量。通产在微服务监控服务中提供如下功能：</p><ul><li>业务日志采集：比如系统中用户注册、上下线等信息</li><li>运行指标采集：比如CPU、内存占用、JVM堆内存大小，或某些接口流量等</li><li>监控警告：对业务日志、运行指标信息进行分析、根据结果做出一定的判断和处理</li><li>调用链路跟踪：用于业务流程在分布式调用中出现问题时提供定位手段，调用链路需要借助一些特定的技术实现，比如服务埋点、跟踪树等。</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>传统的服务实例配置是通过本地文件(XML&#x2F;YAML&#x2F;PROPERTIES)实现的，比如数据库连接池的大小、接口请求流量的阈值等。对于配置的一些改动往往需要重新发布并重启服务，在存在实例时情况变得很不乐观。想象一下对于某个配置项的调整，你可能需要做几十次的发布动作。</p><p>通过将这些配置信息注册到统一的配置中心服务，微服务通过配置中心获取其所需要的配置，这样便免去了各种繁冗的发布工作。此外，如果服务实现了配置的动态感知及自动更新，则还可以实现各种平滑的动作。比如在数据库连接池的大小设置发生了变化时，实例可以自动感知而不需要重启。</p><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>微服务架构推崇采用轻量化的接口调用方式，比如使用HTTP&#x2F;REST。在项目实战中，我们还应该做出更统一的规范化定义，并形成公共的接口调用组件。这部分需要考虑的内容包括：</p><ul><li>数据的传输，比如HTTP还是TCP</li><li>数据的编码，比如JSON还是XML，或是二进制</li><li>数据的内容，比如是否采用固有的消息头定义</li><li>数据的安全，如是否使用TLS&#x2F;SSL实现加密，如何对接口权限进行校验等</li></ul><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>以Docker为代表的容器技术是微服务的最佳组合。通过使用容器作为基础设施，微服务能够实现快速部署、快速迭代的目。Kubernetes是当今容器标准化平台代表，其提供了强大的容器生命周期管理功能，可用于部署、扩展和管理所有的微服务容器。对微服务的自治、敏捷管理来说，容器的无状态、弹性伸缩能力无疑是最契合的。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282051685.png" alt="image-20220528205051510"></p><h2 id="CAP与BASE理论"><a href="#CAP与BASE理论" class="headerlink" title="CAP与BASE理论"></a>CAP与BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论又被称为CAP理论，指的是一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，三者不可兼得，而最多只能同时拥有两者</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282106926.png" alt="image-20220528210623871"></p><p>一致性（C）：分布式系统中节点的数据，在同一时刻拥有同样的值。对于每一次读操作都能够读到最新写入的数据</p><p>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求，即保持高可用</p><p>分区容忍性（P）：在出现网络分区（中断）后，系统是否还能继续保持运作。分区相当于对于通信条件的要求，如果出现了分区的情况，则势必会影响数据的一致性，即同步出现时延。此时系统就必须在一致性和可用性上做出选择。</p><p>实际上，CAP理论中忽略了网络时延对于系统的影响，在现实中网络时延一定是真实存在的，也就是P一定是存在的。因此分布式系统如果选择了高可用（AP），那么就会造成访问节点之间的数据不一致（牺牲一致性）。如果选择了一致性（CP），那么必须淘汰数据的备用点，而只访问主节点（牺牲高可用性）。CA的场景是无法存在的，因为网络通信失败的情况一定会存在。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论可被看作是CAP理论的一个补充，主要来源对大规模互联网系统分布式实践的总结。该理论由以下几个短语组成（BASE）。</p><ul><li>Basically Available（基本可用）</li><li>Soft State（软状态）</li><li>Eventually Consistent（最终一致性）</li></ul><p>实质上，BASE是对于一致性和可用性进行权衡的结果，其主要思想是在系统无法实现强一致性的情况下，根据应用的业务特点来做出一些权衡及补充，并使系统达到最终一致性。在达到最终一致性之前，系统会处于一个中间状态，具备以下特征：</p><ol><li>基本可用：即损失部分可用性，比如响应时间变长，或者部分服务被降级</li><li>软状态：数据会存在中间状态（不一致），但该状态不会影响系统的基本使用。</li></ol><p>在经过一段时间之后，系统应该能达到最终真正一致的状态，比如数据复制经过一段时间后真正完成同步。</p><p>相比CAP理论来说，BASE理论将一致性分成了强一致性和弱一致性，并在充分考虑网络时延、系统吞吐量的情况下选择了一种基本可用（弱一致性）的处理思路，这无疑更加适用于现有分布式系统。</p><h2 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h2><blockquote><p> <strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p></blockquote><p><strong>为什么需要RPC?</strong></p><p>两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。</p><p>通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。我们不需要了解底层网络编程的具体细节。</p><p>简单讲：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272135904.png" alt="image-20220527213236293"></p><p><strong>RPC相关概念：</strong></p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong>：代理类，把调用方法、类、方法参数传递到服务端</li><li><strong>服务端 Stub（桩）</strong>：接收到客户端执行方法的请求，返回给客户端的类</li><li><strong>网络传输</strong>：提供两端的数据传输服务<ol><li>实现方式：Socket、Netty</li></ol></li></ol><p><strong>原理如下：</strong></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: RpcRequest；</li><li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。</li></ol><hr><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><ul><li><p><strong>RMI（JDK自带）</strong></p><p>JDK自带的RPC，有很多局限性，不推荐使用。</p></li><li><p><strong>Dubbo</strong></p><p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</p></li><li><p><strong>gRPC</strong></p><p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</p></li><li><p><strong>Hessian</strong></p><p>Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送<strong>二进制数据</strong>。</p></li><li><p><strong>Thrift</strong></p><p>Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p></li></ul><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p><strong>服务调用关系</strong></p><ul><li>服务提供者：暴露接口给其他微服务调用</li><li>服务消费者：调用其他微服务的接口</li><li>提供者和消费者是<strong>相对</strong>的</li></ul><p><strong>eureka的作用</strong></p><ul><li>消费者该如何获取服务提供者信息？<ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者如何选择？<ul><li>服务消费者利用负载均衡算法，从列表中挑选一个</li></ul></li><li>消费者如何感知服务提供者健康状态？<ul><li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被踢除</li></ul></li></ul><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272158268.png" alt="image-20220527215852205"></p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><strong>Nacos服务分级存储模型</strong></p><ul><li>一级是服务，例如userService</li><li>二级是集群，例如杭州或上海</li><li>三级是实例：</li></ul><p><strong>NacosRule负载均衡策略</strong></p><ul><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其他集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ul><p>实例的权重控制</p><ul><li>Nacos控制台可以设置实例的权重值，0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ul><p><strong>Nacos环境隔离（namespace)</strong></p><ul><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见</li></ul><h2 id="Nacos与Eureka对比"><a href="#Nacos与Eureka对比" class="headerlink" title="Nacos与Eureka对比"></a>Nacos与Eureka对比</h2><p><strong>共同点：</strong></p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><p><strong>区别：</strong></p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><p>DataID命名规则：服务名称+环境.yaml(例如：userservice-dev.yaml)</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205280834487.png" alt="image-20220528083411388"></p><p><strong>将配置交给Nacos管理的步骤</strong></p><ul><li>在Nacos中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时nacos读取哪个文件</li></ul><p><strong>配置自动刷新</strong></p><ul><li>在需要注入配置文件中内容的类上添加注解@RefreshScope</li><li>也可以使用@ConfigurationProperties注解</li></ul><p>注：在nacos配置中，服务名.yaml文件是所有环境共享的环境</p><p>多种配置优先级如下：</p><p>服务名-profile.yaml &gt; 服务名称.yaml &gt; 本地配置</p><h2 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h2><p><strong>使用步骤：</strong></p><ul><li>引入依赖</li><li>添加@EnableFeignClients注解</li><li>编写FeignClient接口</li><li>使用FeignClient中定义的方法代替RestTemplate</li></ul><p><strong>Feign底层的客户端实现：</strong></p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>Feign性能优化主要为：</p><ul><li>使用连接池代替默认的URLConnection</li><li>日志级别最好采用basic或none</li></ul><h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><p><strong>网关功能</strong></p><ul><li>身份认证和权限校验</li><li>服务路由，将用户请求路由到微服务，并实现负载均衡</li><li>对用户请求做限流</li></ul><p>网关搭建步骤：</p><ul><li>创建项目，引入服务发现和gateway依赖</li><li>配置application.yml,包括服务基本信息、nacos地址、路由</li><li>路由配置包括：<ul><li>路由id：路由的唯一标识</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates):判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ul></li></ul><p><strong>路由过滤器GateWayFilter</strong></p><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281829903.png" alt="image-20220528182922800"></p><p>过滤器的作用：</p><ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由的请求生效</li><li>defaultFiler对所有的路由都生效</li></ul><p><strong>GlobalFIlter全局过滤器</strong></p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样，区别在于GatewayFilter通过配置定义，处理逻辑是固定的，而GlobalFilter的逻辑需要自己写代码实现。通过实现GlobalFilter接口实现。</p><p>实现全局过滤器步骤：</p><ul><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口(指定过滤器的执行顺序)</li><li>编写处理逻辑</li></ul><p><strong>过滤器执行顺序：</strong></p><p>请求进入网关会碰到三类过滤器：当前路由过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281900990.png" alt="image-20220528190022922"></p><ul><li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><strong>雪崩问题（微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况）</strong></p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>船壁模式：限定每个业务使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离</li><li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li><p>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也就是默认的模式</p></li><li><p>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>满足下面条件可以使用关联模式</p><ul><li>两个有竞争关系的资源</li><li>一个优先级高，一个优先级低</li></ul></li><li><p>链路：统计从指定链路访问到本资源的请求，触发阈值，对指定链路限流</p></li></ul><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。默认的处理方式</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</li></ul><blockquote><p>**热点参数限流:**分别统计参数值相同的请求，之后判断是否超过QPS阈值。</p></blockquote><h3 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h3><blockquote><p>虽然限流可以尽量避免因高并发引起的服务故障，但服务还会因为其他原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了</p></blockquote><p><strong>Feign整合Sentinel的步骤：</strong></p><ul><li>在application.yml中配置：feign.sentinel.enable&#x3D;true</li><li>在FeignClient编写FallbackFactory并注册为Bean(继承FallbackFactory并指定泛型为要降级的类)</li><li>将FallbackFactory配置到FeignClient中(在FeignClient中添加注解)</li></ul><p><strong>线程隔离</strong></p><ul><li><p>线程池隔离</p><p>优点：</p><ul><li>支持主动超时</li><li>支持异步调用</li></ul><p>缺点：</p><ul><li>线程的额外开销较大</li></ul><p>场景：</p><ul><li>低扇出</li></ul></li><li><p>信号量隔离(Sentinel默认采用)</p><p>优点：</p><ul><li>轻量级、无额外开销</li></ul><p>缺点：</p><ul><li>不支持主动超时</li><li>不支持异步调用</li></ul><p>场景：</p><ul><li>高频调用</li><li>高扇出</li></ul></li></ul><h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><p>断路器熔断策略有三种：满调用、异常比例、异常数</p><ul><li>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</li><li>异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</li><li>异常数：统计只当时间内的调用，如果调用次数超过指定请求数，并且出现异常的次数达到阈值则触发熔断。</li></ul><h3 id="授权规则及规则持久化"><a href="#授权规则及规则持久化" class="headerlink" title="授权规则及规则持久化"></a>授权规则及规则持久化</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li>白名单：来源（origin）在白名单内的调用者允许访问。</li><li>黑名单：来源（origin）在黑名单内的调用者不允许访问</li></ul><p><strong>自定义异常结果</strong></p><blockquote><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口</p><p><strong>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源</strong></p></blockquote><p><strong>Sentinel有三种配置管理模式</strong></p><ul><li>原始模式：保存在内存</li><li>pull模式：保存在本地文件或数据库，定时去读取</li><li>push模式：保存在nacos，监听变更实时更新</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>解决分布式事务的思想和模型</strong></p><ul><li>全局事务：整个分布式事务</li><li>分支事务：分布式事务中包含的每个子系统的事务</li><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚</li></ul><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata事务管理中的三个重要角色：</p><ul><li>TC（Transaction Coordinator）-事务协调者：维护全局和分支事务的状态，协调全局事务或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开启全局事务、提交或回滚事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205310925047.png" alt="image-20220531092538924"></p><p><strong>Seata提供了四种不同的分布式事务解决方案：</strong></p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致性的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><blockquote><p>XA模式原理：XA规范是X&#x2F;Open 组织定义的分布式事务处理（DTP，Distribute Transaction Processing）标准，XA规范描述了全局的TM与与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311015892.png" alt="image-20220531101529812"></p><p><strong>Seata的XA模式</strong></p><p>Seata的XA模式做了一些调整，但大体相似：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311025929.png" alt="image-20220531102528868"></p><p>RM一阶段的工作：</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<ul><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ul></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p>XA模式的优点：</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用的数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源，等二阶段结束才释放，性能差</li><li>依赖关系型数据库实现事务</li></ul><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><blockquote><p>AT模式同样是分阶段提交的事务模型，不够弥补了XA模式中资源锁定周期过长的缺陷</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311225992.png" alt="image-20220531122532913"></p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复到数更新前</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311231089.png" alt="image-20220531123104030"></p><p><strong>AT模式和XA模式的区别：</strong></p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚</li><li>XA模式强一致性；AT模式最终一致性</li></ul><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>Try：资源的检测和预留</li><li>Confirm:完成资源操作业务，要求Try成功Confirm一定能成功</li><li>Cancel：预留资源释放，可以理解为try的反向操作</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206011624351.png" alt="image-20220601162444229"></p><p><strong>TCC模式的各个阶段任务：</strong></p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p><strong>TCC的优点：</strong></p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模式，无需生成快照，无需使用全局锁，性能强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p><strong>TCC缺点：</strong></p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li></ul><p><strong>TCC的空回滚和业务悬挂</strong></p><ol><li>当某分支事务的try阶段阻塞，可能导致全局事务超时而触发二阶段的cancel操作。再未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚</li><li>对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止空回滚后的try操作，避免悬挂</li></ol><h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga模式时Seata提供的长事务解决方案。也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>而阶段：成功则什么都不做，失败则通过补偿业务来回滚</li></ul><p>Saga模式优点：</p><ul><li>事务参与者可以甚至时间驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不能编写TCC中的三个阶段，实现简单</li></ul><p>Saga缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>基本概念：</p><p>生产者（Publisher）：发布消息到 RabbitMQ 中的交换机（Exchange）上。</p><p>交换机（Exchange）：和生产者建立连接并接收生产者的消息。</p><p>消费者（Consumer）：监听 RabbitMQ 中的 Queue 中的消息。</p><p>队列（Queue）：Exchange 将消息分发到指定的 Queue，Queue 和消费者进行交互。</p><p>路由（Routes）：交换机转发消息到队列的规则。</p></blockquote><p><strong>同步调用的优点：</strong></p><ul><li>时效性较强，可以立即得到结果</li></ul><p><strong>同步调用的问题：</strong></p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><p><strong>异步通信的优点：</strong></p><ul><li>耦合度低</li><li>吞吐量提升</li><li>故障隔离</li><li>流量削峰</li></ul><p><strong>异步调用的缺点：</strong></p><ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂了，业务没有明显的流程线，不好追踪管理</li></ul><p><strong>RabbiMQ结构</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290841532.png" alt="image-20220529084151441"></p><ul><li>channel：操作MQ的工具</li><li>exchange：路由消息到队列中</li><li>queue：缓存消息</li><li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li></ul><p><strong>常见消息类型：</strong></p><ul><li><p>基本消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290846599.png" alt="image-20220529084644566"></p></li><li><p>工作消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849809.png" alt="image-20220529084907773"></p></li><li><p>发布订阅，又根据交换机类型不同分为三种：</p><ul><li><p>Fanout Exchange：广播</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848092.png" alt="image-20220529084855058"></p></li><li><p>Direct Exchange：路由</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848603.png" alt="image-20220529084840572"></p></li><li><p>Topic Exchange：主题</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849222.png" alt="image-20220529084938191"></p></li></ul></li></ul><h2 id="基本消息队列"><a href="#基本消息队列" class="headerlink" title="基本消息队列"></a>基本消息队列</h2><p>基本消息队列的消息发送流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ul><p>基本消息队列的消息接收流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消息行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ul><p><strong>如下代码实现：</strong></p><p>publisher如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.MessageProperties;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>       <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br><br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定对应的消息队列</span><br>        <span class="hljs-comment">//参数1：队列名称，如果队列不存在自动创建</span><br>        <span class="hljs-comment">//参数2：用来定义队列是否要持久化</span><br>        <span class="hljs-comment">//擦书3：exclusive是否独占队列</span><br>        <span class="hljs-comment">//参数4：autoDelete 是否在消费完成后自动删除队列</span><br>        <span class="hljs-comment">//参数5：额外附加参数</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//发布消息</span><br>        <span class="hljs-comment">//参数1：交换机名称，参数2队列名称，参数3：传递消息额外设置，参数4：消息的具体内容</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="hljs-string">&quot;hello rabbitmq&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        channel.close();<br>        connection.close()；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br><span class="hljs-comment">//    @Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>       <span class="hljs-comment">//参数1：消费哪个队列的消息，参数2：开启消息的自动确认机制，参数3：消费时的回调接口</span><br>        channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;new StringBody=&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>        channel.close();<br>        connection.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        Consumer consumer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br>        consumer.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本消息对列SpringAMQP使用</strong></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在配置文件中添加mq连接信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">rabbitmq-springboot</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">154.253</span><span class="hljs-number">.41</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/ems</span><br></code></pre></td></tr></table></figure></li><li><p>在publisher服务中添加一个测试类，编写发送消息的消息提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    String queueName=<span class="hljs-string">&quot;hello&quot;</span>;<br>    String message=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    rabbitTemplate.convertAndSend(queueName,message);<span class="hljs-comment">//发送到哪个队列以及发送什么消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><span class="hljs-comment">//监听哪个队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><span class="hljs-comment">//处理监听行为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receviel</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//参数是Publisher发送的消息类型</span><br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="工作消息队列"><a href="#工作消息队列" class="headerlink" title="工作消息队列"></a>工作消息队列</h2><blockquote><p>Work queue工作队列，可以提高消息处理速度，避免队列消息堆积</p></blockquote><p>util连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>publisher如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Provider &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>        <span class="hljs-keyword">assert</span> connection != null;<br>        Channel channel=connection.create<span class="hljs-constructor">Channel()</span>;<br>        channel.queue<span class="hljs-constructor">Declare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">true</span>,<span class="hljs-params">false</span>,<span class="hljs-params">false</span>,<span class="hljs-params">null</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;i++)<br>        channel.basic<span class="hljs-constructor">Publish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">null</span>,(<span class="hljs-params">i</span>+<span class="hljs-string">&quot;hello work quene&quot;</span>)</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>close<span class="hljs-constructor">ConnectionAndChannel(<span class="hljs-params">channel</span>,<span class="hljs-params">connection</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//每次只能消费一个消息</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<span class="hljs-comment">//参数1：确认队列中哪个具体消息，参数2：是否开启多个消息同时确认</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo.workquene;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;消费者-2：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工作消息队列SpringAMQP使用</strong></p><p>前三步同上面基础消息队列，也可以指定每次取多少条消息，处理完成才继续取消息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">listener:<br>  direct:<br>    prefetch: 1 #每次只能获取一条消息，处理完成后才能获取下一个消息<br></code></pre></td></tr></table></figure><ol><li><p>发送多条消息</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;work模型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者端添加多个消费者共同处理消息</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class WorkCumstomer &#123;<br><br>    <span class="hljs-variable">@RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    public void <span class="hljs-built_in">recevi1</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-1&quot;</span>+message);<br>    &#125;<br><br>    @<span class="hljs-selector-tag">RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">recevi2</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-2&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Fanout-Exchange-广播"><a href="#Fanout-Exchange-广播" class="headerlink" title="Fanout Exchange(广播)"></a>Fanout Exchange(广播)</h2><blockquote><p>Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的queue</p></blockquote><p>基本使用步骤：</p><p>连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span>  ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connectionFactory != <span class="hljs-literal">null</span>;<br>        Channel channel=connectionFactory.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//参数1：交换机名称，参数2：交换机类型  fanout 广播类型</span><br>        channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fanout type message&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fanout Exchange SpringAMQP使用：</strong></p><p>前两步同基础消息队列</p><p><strong>方式一注解：</strong></p><ol><li><p>定义pulisher发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanout</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;FanOut的模型发送的消息&quot;</span>);<span class="hljs-comment">//参数一是exchange，参数二是routingKey，参数三是消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>consumer消费端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>方式二配置类：</strong></p><p>也可以使用配置的方式声明消费者绑定的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//声明交换机</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue&quot;</span>);<span class="hljs-comment">//声明队列</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">fanoutBinfing</span><span class="hljs-params">(Queue fanoutQueue,FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue).to(fanoutExchange);<span class="hljs-comment">//绑定队列和交换机</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者使用直接指定队列即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(msg);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Direct-Exchange-路由"><a href="#Direct-Exchange-路由" class="headerlink" title="Direct Exchange(路由)"></a>Direct Exchange(路由)</h2><blockquote><p>DIrect Exchange会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）。</p></blockquote><ul><li>每一个Queue都与Exchange设置一个BindingKey（BindingKey可以指定多个）；</li><li>发布者发送消息时，指定消息的RoutingKey；</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列；</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291028289.png" alt="image-20220529102816194"></p><p>util连接工具类：</p><p>public class ConnectionRabbitMq {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//基于rout key 绑定队列和交换机</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费这-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;warning&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">//发送消息</span><br>        String routingKey=<span class="hljs-string">&quot;warning&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;log_direct&quot;</span>,routingKey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这是direct模型发布的基于rout key:[&quot;</span>+routingKey+<span class="hljs-string">&quot;]发送的消息&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Direct Exchange SpringAMQP使用：</strong></p><p>前两部同基础消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouteCumstomer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = &quot;direct&quot;),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者1</span><br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = ExchangeTypes.DIRECT),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者2</span><br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRoute</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;发送--info--key的信息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Topic-Exchange-主题"><a href="#Topic-Exchange-主题" class="headerlink" title="Topic Exchange(主题)"></a>Topic Exchange(主题)</h2><blockquote><p>Topic Exchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以 . 分割</p></blockquote><p>Queue与Exchange指定BindingKey时可以使用通配符：</p><ul><li>#：代表0个或多个单词</li><li>*：代表一个单词</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291044031.png" alt="image-20220529104430167"></p><p>基础使用步骤：</p><p>util连接工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String routekey=<span class="hljs-string">&quot;user.save.all&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routekey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这里是topic动态类型模型[&quot;</span>+routekey+<span class="hljs-string">&quot;]&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Topic Exchange SpringAMQP使用</strong></p><p>前面两部同基本消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;user.save&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;order.#&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopic</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;order&quot;</span>,<span class="hljs-string">&quot;user.save 路由消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>SpringAMQP中消息的序列化和反序列化是怎么实现的？</p><ul><li>利用MessageConverter实现的，默认是JDK的序列化</li><li>注意发送方与接收方必须使用相同的MessageConverter</li></ul><p><strong>RabbitMQ相关文章：</strong></p><p><a href="http://docs.javaboy.org/rabbitmq/message_push_pull/#_3-2-work-queues">江南一点雨</a></p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><blockquote><p>elasticsearch是一款非常强大的开源搜索引擎，可以帮我们从海量数据中快速找到需要的内容。</p><p>elasticsearch结合Kibana、logstash、Beats，也就是elastic stack(ELK)。被广泛应用在日志数据分析、实时监控等领域</p></blockquote><pre><code class="hljs"> ![image-20220529142245490](https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291422577.png)</code></pre><p><strong>文档和词条：</strong></p><ul><li>每一条数据就是一个文档</li><li>对文档中的内容分词，得到的词语就是词条</li></ul><p><strong>正向索引：</strong></p><ul><li>基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</li></ul><p><strong>倒排索引：</strong></p><ul><li>对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时先根据词条查询到文档id，而后获取文档。</li></ul><p><strong>索引</strong></p><ul><li>索引（index）：相同类型的文档的集合</li><li>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</li></ul><h2 id="Ik分词器安装使用"><a href="#Ik分词器安装使用" class="headerlink" title="Ik分词器安装使用"></a>Ik分词器安装使用</h2><p>下载与Elasticsearch版本相同的ik分词器</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>将下载的包解压后放到Elasticsearch中的plugins目录下，（踩坑日记–需要重新创建一个ik文件夹将解压后的ik分词器的内容复制到ik目录下才可以正常使用）</p><p><strong>Ik分词器的扩展与停用词</strong></p><p>在Ik分词器config目录下打开IKAnalyzer.cfg.xml进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br> <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291543388.png" alt="image-20220529154352092"></p><p>在字典中添加相关词语即可</p><p><strong>IK分词器有两种模式：</strong></p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2><p>安装同IK分词器，下载解压复制到plugins目录下，重启即可</p><p><strong>自定义分词器步骤：</strong></p><ul><li>创建索引库，在settings中配置，可以包含三部分</li><li>character filter</li><li>tokenizer</li><li>filter</li></ul><p><strong>例如：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;analysis&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;py&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;py&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;pinyin&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_joined_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_original&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;limit_first_letter_length&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">16</span><br>                    <span class="hljs-attr">&quot;remove_duplicated_term&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;none_chinese_pinyin_tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;standard&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单数据类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h2 id="索引库基本操作"><a href="#索引库基本操作" class="headerlink" title="索引库基本操作"></a>索引库基本操作</h2><ul><li>创建索引：PUT&#x2F;索引名称</li><li>查询索引：GET&#x2F;索引名称</li><li>删除索引：DELETE&#x2F;索引名称</li><li>添加字段：PUT&#x2F;索引库名&#x2F;_mapping</li></ul><p><strong>创建索引库</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>修改索引库</strong></p><p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br>如下示例：<br>PUT /heima/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;heima&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;aliases&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;properties&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;age&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;routing&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;allocation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;include&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;_tier_preference&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;data_content&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;provided_name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;creation_date&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1653818826936&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;uuid&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5dw1G0dkR1CbIV1CN6-MXA&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;created&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8010299&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;acknowledged&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="文档基本操作"><a href="#文档基本操作" class="headerlink" title="文档基本操作"></a>文档基本操作</h2><ul><li>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;索引库名&#x2F;文档id</li><li>修改文档:<ul><li>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>增量修改：POST &#x2F;索引库名&#x2F;update&#x2F;文档id {“doc”{字段}}</li></ul></li></ul><p><strong>新建文档的DSL语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值4&quot;</span><br>     <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ......<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ziyuan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;result&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;created&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima/_doc/<span class="hljs-number">1</span><br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;firstName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;lastName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ziyuan&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名/_doc/删除的文档id<br></code></pre></td></tr></table></figure><p><strong>修改文档</strong></p><ul><li><p>全量修改，会删除旧文档，添加新文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span>，<br>         ........<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>增量修改，修改指定字段值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;新的值&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="DSL查询分类"><a href="#DSL查询分类" class="headerlink" title="DSL查询分类"></a>DSL查询分类</h2><blockquote><p>Elasticsearch提供了基于JSON的DSL来定义查询，常见的查询类型包括如下：</p></blockquote><ul><li>查询所有：查询出所有数据，一般测试用。例如：match_all</li><li>全文检索（full text)查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>malti_match_query</li></ul></li><li>精确查询：根据精确词条查找数据，一般是查询keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li>地理(geo)查询：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li>复合(compound)查询：复合查询可以将上述各种查询条件组合起来，合并查询条件，例如：<ul><li>bool</li><li>boosting</li><li>constant_score</li><li>dis_max</li><li>function_score</li></ul></li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合可(aggregations)可以实现对文档数据的统计、分析、运算。常见的有三类：</p><ul><li>桶(Bucket)聚合：用来对文档做分组<ul><li>TermAggregation：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li>度量(Metric)聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小是</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li>管道(Pipeline)聚合：其他聚合的结果为基础的聚合</li></ul><h2 id="分词器组成"><a href="#分词器组成" class="headerlink" title="分词器组成"></a>分词器组成</h2><p>elasticsearch中分词（analyzer）的组成包括三部分：</p><ul><li>character filter：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换，同义词处理、拼音处理</li></ul><h2 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h2><p>elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配用户输入内容开头的词条并返回。为了提高补全查询效率，对于文档中字段的类型有一些约束：</p><ul><li>参数补全查询的字段必须是completion类型</li><li>字段的内容一般是用来补全的多个词条形成的数组</li></ul><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;completion&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Sony&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;WH-1000XM3&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>completion suggestion查询</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /test/_search<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;tittle_suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;s&quot;</span><span class="hljs-comment">//关键字,</span><br>            <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tittle&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//补全查询的字段</span><br>            <span class="hljs-attr">&quot;skip_duplicates&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//跳过重复的</span><br>            <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-comment">//获取10条结果</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零拷贝技术</title>
    <link href="/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><blockquote><p>零拷贝（zero-copy）是一种I&#x2F;O操作优化技术，可以快速高效地将数据从文件按系统移动到网络接口，而不需要将其从内核空间复制到用户空间，其在FTP或者HTTP等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用NIO和Epoll传输时才可使用该特性。需要注意，他不能用于实现了数据加密或者压缩的文件系统上，只能传输文件的原始内容。这类原始内同也包括加密了的文件内容。</p></blockquote><h2 id="传统I-x2F-O操作"><a href="#传统I-x2F-O操作" class="headerlink" title="传统I&#x2F;O操作"></a>传统I&#x2F;O操作</h2><ol><li><p>读操作</p><ol><li>应用程序发起读数据操作，触发read()系统调用。这时操作系统会进行一次上下文切换（把用户空间切换到内核空间）。</li><li>通过磁盘控制器把数据复制到内核缓冲区（页缓存）中，这里发生了一次DMA Copy。</li><li>然后内核将数据复制到用户空间的应用缓冲区中，发生了一次CPU Copy。</li><li>read调用返回后，会再进行一次上下文切换（把内核空间切换到用户空间）</li></ol><p>上述读过程，发生2次上下文切换和2次数据复制（一次是DMA Copy，一次是CPU Copy)。</p><p>DMA Copy是内核从磁盘上面读取数据，这是不消耗CPU时间的，是通过磁盘控制器完成的。</p></li><li><p>写操作</p><ol><li>应用程序发起写操作，触发write()系统调用，操作进行一次上下文切换（从用户空间到内核空间）</li><li>把数据复制到内核缓冲区Socket缓冲区，做了一次CPU Copy。</li><li>内核空间再把数据复制到磁盘或其他存储器（网卡，进行网络传输），进行了DMA Copy。</li><li>写入结束返回，又从内核空间切换到用户空间。</li></ol><p>上述写操作，也发生了2次上下文切换和2次数据复制（一次DMA Copy，一次CPU Copy）</p></li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082231556.png" alt="image-20220608223134442"></p><p><strong>总结：</strong></p><p>传统的I&#x2F;O读写操作，总共进行了4次上下文的切换，4次的数据复制动作。数据在内核空间和应用空间之间来回复制，其实并没有做任何有意义的逻辑，就是单纯的复制而已。所以这个机制太浪费时间，而且浪费CPU时间。</p><h2 id="零拷贝技术原理"><a href="#零拷贝技术原理" class="headerlink" title="零拷贝技术原理"></a>零拷贝技术原理</h2><p>零拷贝主要是用来解决操作系统在处理I&#x2F;O操作时，频繁复制数据的问题。零拷贝技术主要有mmap+write、sendfile、splice等几种方式。</p><ol><li><p><strong>虚拟内存</strong></p><p>所有的现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：</p><ul><li>多个虚拟内存可以指向同一个物理地址</li><li>虚拟内存空间可以远远大于物理内存空间</li></ul><p>利用上面的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在I&#x2F;O操作时 就不需要来回复制了。</p><p><strong>虚拟内存原理</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082245288.png" alt="image-20220608224540237"></p></li><li><p>mmap&#x2F;write方式</p><p>使用mmap&#x2F;write方式替代原来的传统I&#x2F;O方式，就是利用了虚拟内存的特性。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082252877.png" alt="image-20220608225254819"></p><p>整体流程的核心区别是，把数据读取到内核缓冲区后，应用程序进行数据写入操作时，直接把内核的Read Buffer的数据复制到Socket Buffer以便写入，这次内核之间的复制也是需要CPU参与的。</p><p>上述流程就少了一个CPU Copy，提升了I&#x2F;O的速度。不过发现上下文的切换还是4次并没有减少，这是因为还是要应用程序发起write操作。</p></li><li><p>sendfile方式</p><p>从linux2.1版本开始，Linux引入了sendfile来简化操作。sendfile方式可以替换上面的mmap&#x2F;write方式来进一步优化。</p><p>sendfile将以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mmap();<br>write();<br></code></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendfile()<br></code></pre></td></tr></table></figure><p>这样就减少了上下文切换，因为少了一个应用程序发起write操作，直接发起sendfile操作。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082305384.png" alt="image-20220608230549337"></p><p>sendfile方式只有3次数据复制（其中只有一次CPU copy）以及2次上下文切换。</p></li><li><p>带有scatter&#x2F;gather的sendfile方式</p><p>Linux2.4内核进行了优化，提供了带有scatter&#x2F;gather的sendfile操作，这个操作可以把最后一次CPU copy去除。其原理就是在内核空间Read Buffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到Socket Buffer中，这样就不需要复制，其本质和虚拟内存的解决方法思路一样，就是内存地址的记录。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082314110.png" alt="image-20220608231408062"></p><p>scatter&#x2F;gatter的sendfile只有2次数据复制（都是DMA Copy）以及2次上下文切换。CPU copy已经完全没有。不过这一种收集复制功能是需要硬件及驱动程序支持的。</p></li><li><p>splice方式</p><p>splice调用和sendfile非常类似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，另外一个表示输出设备。与sendfile不同的是，splice允许任意两个文件之间互相连接，而并不是文件到socket进行数据传输。对于一个文件描述符发送数据到socket这种特例来说，一直都是使用sendfile系统调用，而splice一直依赖只是一种机制，它并不仅是sendfile的功能，也就是说，sendfile只是splice的一个子集。</p></li></ol><p><strong>总结：</strong></p><p>无论是传统I&#x2F;O方式，还是引入了零拷贝之后，2次DMA Copy是都少不了的。因为两次DMA都是依赖硬件完成的。所以，所谓零拷贝，都是为了减少CPU copy及减少了上下文的切换。</p><table><thead><tr><th></th><th><strong>CPU拷贝</strong></th><th><strong>DMA拷贝</strong></th><th><strong>系统调用</strong></th><th><strong>上下文切换</strong></th></tr></thead><tbody><tr><td>传统方式</td><td>2</td><td>2</td><td>read&#x2F;write</td><td>4</td></tr><tr><td>内存映射</td><td>1</td><td>2</td><td>mmap&#x2F;write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile with dma<br> scatter&#x2F;gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2022/09/03/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2022/09/03/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>说到跨域，首先需要解释下为什么会出现这样的跨域问题。这其实都源于浏览器的同源策略。</p><p>同源策略是浏览器中的一个重要的安全策略，是<code>Netscape</code>公司在1995年引入。同源策略的作用就是为了限制不同源之间的交互，从而能够有效避免<code>XSS</code>、<code>CSFR</code>等浏览器层面的攻击。</p><p>同源指的是两个请求接口<code>URL</code>的协议（<code>protocol</code>）、域名（<code>host</code>）和端口（<code>por</code>t）一致。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935132.png" alt="图片">同源策略</p><p>比如以下例子：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935180.png" alt="图片">同源与非同源接口</p><p>说到浏览器的攻击手段，<code>XSS</code>指的是恶意攻击者往<code>Web</code>页面里插入恶意<code>HTML</code>代码，利用的是用户对指定网站的信任。</p><p>而<code>CSFR</code>指的是跨站请求伪造，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。</p><p>由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了Web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求是发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。这实际上利用的是网站对用户网页浏览器的信任。</p><p>所以根据浏览器的是否同源判定，可以有选择的限制网站的一些行为。比如非同源的站点会被限制访问<code>cookie</code>、<code>localStorage</code>以及<code>IndexDB</code>，同时也无法获取网页<code>DOM</code>以及<code>JavaScript</code>对象，甚至<code>AJAX</code>的请求也会被拦截。</p><p>这样一来，就能够有效限制利用浏览器以及历史访问站点来进行攻击的目的。</p><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>本质上浏览器不允许跨域请求好像是件好事，因为这样对于前端来说更安全。人家辛辛苦苦设计的同源策略，为啥会成为咱们的一个问题呢。</p><p>其实这也是没办法的事，毕竟前后端分离的项目，迫不得已就是需要进行跨域请求。比如在本地开发的环境中，很有可能端口号不一样。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935152.png" alt="图片"></p><p>本地环境中的跨域问题</p><p>在线上环境中，也同样会出现这样的情况。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935094.png" alt="图片"></p><p>线上环境中的跨域问题</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-JSONP跨域"><a href="#1-JSONP跨域" class="headerlink" title="1 JSONP跨域"></a><strong>1 JSONP跨域</strong></h4><p>上面所提到的跨域问题其实都是因为使用了<code>AJAX</code>&#x2F;<code>XMLHttpRequest</code>&#x2F;<code>Fetch API</code>的方式来发起请求，但是其实在Web页面上调用JS文件是不受跨域的影响的。不仅如此，拥有src属性的标签都拥有跨域的能力。</p><p>于是JSONP就是利用上述特点的跨域解决方案。JSONP的原理就是通过发送带有Callback参数的GET请求，服务端将接口返回数据拼凑到Callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到Callback函数返回的数据。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935305.png" alt="图片">JSONP跨域</p><p>前端代码只需要在页面中插入<code>&lt;script&gt;</code>标签，定义好回调函数，同时通过<code>src</code>请求后端接口即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;</span><br><span class="language-javascript">    script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.b.domain.com:8080/main?callback=handleCallback&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 回调函数</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后端则需要在对应接口将客户端发送的<code>callback</code>参数作为函数名来包裹住<code>JSON</code>数据，返回数据至客户端。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">handleCallback</span>(&#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;status&quot;</span>: “<span class="hljs-number">0</span><span class="hljs-string">&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p><code>JSONP</code>看起来很方便，但是实际上限制很大。由于<code>script</code>、<code>img</code>这些带<code>src</code>属性的标签，在引入外部资源时，使用的都是<code>GET</code>请求。所以<code>JSONP</code>也只能使用<code>GET</code>发送请求，这也是这种方式已经逐渐被淘汰的原因。</p><h4 id="2-代理跨域"><a href="#2-代理跨域" class="headerlink" title="2 代理跨域"></a>2 代理跨域</h4><p>既然跨域问题是浏览器自己的一种保护措施，那么实际上能够通过在前后端之间加一道代理层来变相进行跨域请求。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935290.png" alt="图片">代理跨域</p><p><strong>Webpack Server代理</strong></p><p>在<code>webpack</code>中可以通过配置<code>proxy</code>来快速获得接口代理的能力，同时前端请求的<code>URL</code>不需要带域名，代理服务器会自动自动将请求映射为同域请求。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935546.png" alt="图片">img</p><p>可在前端<code>webpack.config.js</code>配置代理：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nim">module.exports = &#123;<br>  ...<br>  output: <span class="hljs-meta">&#123;...&#125;</span>,<br>  devServer: &#123;<br>    port: <span class="hljs-number">3000</span>,<br>    proxy: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        target: <span class="hljs-string">&quot;http://localhost:3001&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  plugins: []<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Nginx反向代理</strong></p><p>实现思路其实与<code>webpack</code>代理一致，无非是通过<code>Nginx</code>作为跳板机而已。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935522.png" alt="图片">Nginx反向代理</p><p>举个<code>Nginx</code>配置的例子，就是把本地端口<code>3000</code>代理到<code>3001</code>，这样在本地就能够进行跨域调试了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">3000</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-section">location</span> /api &#123;<br>        <span class="hljs-attribute">proxy_pass</span>   http://localhost:3001;  <span class="hljs-comment">#反向代理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Node中间件代理</strong></p><p>原理都是类似的，只不过是将代理操作设置在了后端。若是<code>node</code>项目的话，可以直接利用<code>http-proxy-middleware</code>插件进行代理。本质上<code>webpack</code>也是用这个包做代理服务的，只不过现在把这个放在服务端。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935631.png" alt="图片">node中间件代理</p><p>一个<code>node</code>+<code>express</code>+<code>http-proxy-middleware</code>的例子：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-keyword">var</span> app = express();<br><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, proxy(&#123;<br>    <span class="hljs-comment">// 代理跨域目标接口</span><br>    target: <span class="hljs-string">&#x27;http://localhost:3001&#x27;</span>,<br>    changeOrigin: <span class="hljs-keyword">true</span>,<br><br>    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span><br>    onProxyRes: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(proxyRes, req, res)</span> </span>&#123;<br>        res.header(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>);<br>        res.header(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>);<br>    &#125;,<br>&#125;));<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h4 id="3-CORS跨域"><a href="#3-CORS跨域" class="headerlink" title="3 CORS跨域"></a>3 CORS跨域</h4><p>CORS（<code>Cross-Origin Resource Sharing</code>）是指跨域资源共享，它是一个浏览器侧的机制，能够允许服务器标示除了它自己以外的其它域，这样浏览器就可以进行跨域访问加载资源。</p><p>一般现代浏览器都支持<code>CORS</code>跨域，只有那种古老的浏览器，比如<code>IE10</code>以下的才不支持。</p><p>这意味着，实际上浏览器虽然会采取同源策略来限制跨域访问，但是同时又给服务端提供了一个选择，即通过<code>CORS</code>来可选的提供跨域能力。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935610.png" alt="图片">CORS跨域</p><p>比如上图这个例子，左边代表的是前端网页，右边代表的是服务器。前端部署在<code>domain-a</code>域名下，但是有两个资源需要请求来自不同域名的资源。</p><p>当资源来源与前端本身所在的域不一致时，便会发生跨域请求。此时可通过<code>CORS</code>来控制是否允许进行跨域资源的请求。</p><p><code>CORS</code>是浏览器提供的能力，而实现<code>CORS</code>的控制和通信是在服务端进行。也就是只要服务端对相应域允许<code>CORS</code>，那么便可进行跨域通信。</p><p><strong>简单请求</strong></p><p>浏览器根据请求方法以及<code>HTTP</code>头部信息将<code>CORS</code>请求分成两类，简单请求和非简单请求。</p><p>若满足下列条件，则视为简单请求：</p><ul><li>请求方法属于<code>GET</code>、<code>POST</code>、<code>HEAD</code>中的一种</li><li>HTTP头部仅包含<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>。</li></ul><p>其中Content-Type的值仅限于<code>text/plain</code> <code>multipart/form-data</code> <code>application/x-www-form-urlencoded</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935822.png" alt="图片">简单请求</p><ul><li>请求中的任意<code>XMLHttpRequestUpload</code>对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code>对象可以使用<code>XMLHttpRequest.upload</code>属性访问。</li><li>请求中没有使用<code>ReadableStream</code>对象。</li></ul><p>简单请求的流程很简单：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935750.png" alt="图片">简单请求流程</p><ul><li>浏览器发出<code>CORS</code>请求时，在头部添加<code>Origin</code>字段(最后一行)，表明请求域：比如</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /resources/public-data/ HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: bar.other<br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Macintosh; U; Intel Mac OS X <span class="hljs-number">10</span>.<span class="hljs-number">5</span>; en-US; rv:<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">1</span>b3pre) Gecko/<span class="hljs-number">20081130</span> Minefield/<span class="hljs-number">3</span>.<span class="hljs-number">1</span>b3pre<br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Accept</span>-Language: en-us,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">Accept</span>-Encoding: gzip,deflate<br><span class="hljs-attribute">Accept</span>-Charset: ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>,utf-<span class="hljs-number">8</span>;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span>,*;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">Connection</span>: keep-alive<br><span class="hljs-attribute">Referer</span>: http://foo.example/examples/access-control/simpleXSInvocation.html<br><span class="hljs-attribute">Origin</span>: http://foo.exampl<br></code></pre></td></tr></table></figure><p>服务端收到Origin，决定是否同意跨域请求:</p><ul><li>如果同意请求，服务端会在返回的响应中添加<code>CORS</code>相关的头部，比如其中<code>Access-Control-Allow-Origin</code>是必须字段，表示能接受请求的域名，<code>*</code>表示任意域名。</li><li>若不同意请求，服务端会返回一个正常的<code>HTTP</code>响应，由于不包含<code>Access-Control-Allow-Origin</code>，会被浏览器发现，从而抛出本文最上面的错误。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 01 Dec 2008 00:23:53 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.0.61<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>*<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=2, max=100<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/xml<br></code></pre></td></tr></table></figure><p><strong>非简单请求</strong></p><p>不满足简单请求之外的请求，都是非简单请求。</p><p>非简单请求的特点是，在发送正式请求之前，会先发起一个预检请求。只要当服务端同意预检请求时，才会发送正式的请求。</p><p>比如这里举一个例子，假设需要发送一个请求，该请求包含自定义的头部字段<code>X-PINGOTHER</code>，同时<code>Content-Type</code>为<code>application/xml</code>。</p><p>可以看出这个请求是妥妥的非简单请求，所以需要走预检流程。</p><ul><li><p>预检请求用的是<code>OPTIONS</code>请求方法，在请求头部会表明<code>Origin</code>，同时还需要带上两个特殊的头部字段。</p></li><li><ul><li><code>Access-Control-Request-Method</code>：用于表明正式请求会用到哪些<code>HTTP</code>请求方法，比如例子中的<code>POST</code>;</li><li><code>Access-Control-Request-Headers</code>：用于表明正式请求会用哪些额外发送的头部字段，比如例子中的<code>X-PINGOTHER</code>和<code>Content-Type</code>。</li></ul></li><li><p>服务端接收到预检请求后，会检查上面这几个字段，确定是否可以接受跨域请求。如果可以，就会在响应的头部中添加<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段用来表示可接受的请求方法和请求头。</p></li><li><p>浏览器接收到了预检成功的响应后，才会开始发起正式请求，正式请求的过程就跟简单请求基本一致了。也就是在请求头中添加<code>Origin</code>字段，同时服务端的响应也返回相应的<code>CORS</code>必须字段。</p></li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202204121935837.png" alt="图片">非简单请求流程</p><p>虽然说<code>CORS</code>跨域的方案是浏览器支持的机制，但是实现确实在服务端。但是其实工作量并不大，只需要设置允许跨域的域名、<code>HTTP</code>头部以及请求方式等参数即可。</p><p>比如在<code>node</code>+<code>express</code>的项目只需要添加以下代码就可以实现任意域名跨域的目的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.all(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-keyword">function</span> (req: express.Request, res: express.Response, <span class="hljs-keyword">next</span>: express.NextFunction) &#123;<br>  <span class="hljs-regexp">//</span>设置允许跨域的域名，*代表允许任意域名跨域<br>  res.header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-regexp">//</span>允许的header类型<br>  res.header(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-regexp">//</span>跨域允许的请求方式<br>  res.header(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method.toLowerCase() === <span class="hljs-string">&#x27;options&#x27;</span>)<br>    res.sendStatus(<span class="hljs-number">200</span>)  <span class="hljs-regexp">//</span>让options尝试请求快速结束<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>跨域问题是<code>Web</code>开发中很常见的问题，解决起来其实也并不复杂。除了上面的方案，也还存在像<code>Iframe</code>、<code>postMessag</code>e以及<code>websocket</code>等方案。</p><p>但是总的来说不如上面这三种常用，一个比较正经的前后端分离项目更多的还是使用<code>CORS</code>方案进行跨域。省时省力又省心。</p>]]></content>
    
    
    <categories>
      
      <category>Http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单例模式的定义"><a href="#一、单例模式的定义" class="headerlink" title="一、单例模式的定义"></a>一、单例模式的定义</h1><p><strong>定义：</strong> 确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>这样做的好处是：有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。</p><h1 id="二、单例模式的设计要素"><a href="#二、单例模式的设计要素" class="headerlink" title="二、单例模式的设计要素"></a>二、单例模式的设计要素</h1><ul><li>一个私有构造函数 （确保只能单例类自己创建实例）</li><li>一个私有静态变量 （确保只有一个实例）</li><li>一个公有静态函数 （给使用者提供调用方法）</li></ul><p>简单来说就是，单例类的构造方法不让其他人修改和使用；并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一次实例。</p><h1 id="三、单例模式的6种实现及各实现的优缺点"><a href="#三、单例模式的6种实现及各实现的优缺点" class="headerlink" title="三、单例模式的6种实现及各实现的优缺点"></a>三、单例模式的6种实现及各实现的优缺点</h1><h2 id="（一）懒汉式（线程不安全）"><a href="#（一）懒汉式（线程不安全）" class="headerlink" title="（一）懒汉式（线程不安全）"></a>（一）懒汉式（线程不安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。</p><p><strong>优点：</strong> 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。</p><p><strong>缺点：</strong> 线程不安全，多线程环境下，如果多个线程同时进入了 if (uniqueInstance &#x3D;&#x3D; null) ，若此时还未实例化，也就是uniqueInstance &#x3D;&#x3D; null，那么就会有多个线程执行 uniqueInstance &#x3D; new Singleton(); ，就会实例化多个实例；</p><h2 id="（二）饿汉式（线程安全）"><a href="#（二）饿汉式（线程安全）" class="headerlink" title="（二）饿汉式（线程安全）"></a>（二）饿汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">uniqueInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。</p><p><strong>优点：</strong> 提前实例化好了一个实例，避免了线程不安全问题的出现。</p><p><strong>缺点：</strong> 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。</p><h2 id="（三）懒汉式（线程安全）"><a href="#（三）懒汉式（线程安全）" class="headerlink" title="（三）懒汉式（线程安全）"></a>（三）懒汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getUinqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 实现和 线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上 加了一把 锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。</p><p><strong>优点：</strong> 延迟实例化，节约了资源，并且是线程安全的。</p><p><strong>缺点：</strong> 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方***使线程阻塞，等待时间过长。</p><h2 id="（四）双重检查锁实现（线程安全）"><a href="#（四）双重检查锁实现（线程安全）" class="headerlink" title="（四）双重检查锁实现（线程安全）"></a>（四）双重检查锁实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明:</strong> 双重检查数相当于是改进了 线程安全的懒汉式。线程安全的懒汉式 的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。</p><p><strong>为什么使用 volatile 关键字修饰了 uniqueInstance 实例变量 ？</strong></p><p>uniqueInstance &#x3D; new Singleton(); 这段代码执行时分为三步：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>正常的执行顺序当然是 1&gt;2&gt;3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。<br>单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。<br>例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getUniqueInstance()，发现 uniqueInstance 不为空，便获取 uniqueInstance 实例，但是其实此时的 uniqueInstance 还没有初始化。</p><p>解决办法就是加一个 volatile 关键字修饰 uniqueInstance ，volatile 会禁止 JVM 的指令重排，就可以保证多线程环境下的安全运行。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。</p><p><strong>缺点：</strong> volatile 关键字，对性能也有一些影响。</p><h2 id="（五）静态内部类实现（线程安全）"><a href="#（五）静态内部类实现（线程安全）" class="headerlink" title="（五）静态内部类实现（线程安全）"></a>（五）静态内部类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getUniqueInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；且线程安全；性能也提高了。</p><h2 id="（六）枚举类实现（线程安全）"><a href="#（六）枚举类实现（线程安全）" class="headerlink" title="（六）枚举类实现（线程安全）"></a>（六）枚举类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-comment">//添加自己需要的操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeThing</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。</p><p><strong>优点：</strong> 写法简单，线程安全，天然防止反射和反序列化调用。</p><ul><li><strong>防止反序列化</strong><br><strong>序列化：</strong>把java对象转换为字节序列的过程；<br><strong>反序列化：</strong> 通过这些字节序列在内存中新建java对象的过程；<br><strong>说明：</strong> 反序列化 将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例。<br><strong>枚举类天然防止反序列化。</strong><br>其他单例模式 可以通过 重写 readResolve() 方法，从而防止反序列化，使实例唯一重写 readResolve() :</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException&#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、单例模式的应用场景"><a href="#四、单例模式的应用场景" class="headerlink" title="四、单例模式的应用场景"></a>四、单例模式的应用场景</h1><p><strong>应用场景举例：</strong></p><ul><li>网站计数器。</li><li>应用程序的日志应用。</li><li>Web项目中的配置对象的读取。</li><li>数据库连接池。</li><li>多线程池。</li><li>……</li></ul><p><strong>使用场景总结：</strong></p><ul><li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能。</li><li><strong>经常使用的对象，但实例化时耗费时间或者资源多</strong>，如数据库连接池，使用单例模式，可以提高性能，降低资源损坏。</li><li><strong>使用线程池之类的控制资源时</strong>，使用单例模式，可以方便资源之间的通信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为型设计模式</title>
    <link href="/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><h2 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h2><ol><li><p>定义：指定义一系列算法，并将每一种算法封装起来，让它们可以相互替换。策略模式能让算法独立于使用它地客户而变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172310354.png" alt="image-20220817230912880"></p></li></ol><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><ol><li><p>定义：指定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一种算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172316967.png" alt="image-20220817231640910"></p></li></ol><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ol><li><p>定义：指在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在以后将对象恢复到原先保存的状态，也叫Token模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172329323.png" alt="image-20220817232930270"></p></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol><li><p>定义：指定义对象之间的一种一对多的依赖关系，每当一个对象状态发生变化时，其相关依赖对象都能得到通知并被自动更新，又叫发布订阅模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172341700.png" alt="image-20220817234137646"></p></li></ol><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><ol><li><p>定义：指为了避免请求发送者与接收者耦合在一起，让多个对象都有可能接收到请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到所有对象处理为止。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172351970.png" alt="image-20220817235111917"></p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li><p>定义：指提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。迭代器模式又称为游标（Cursor），属于对象行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182049174.png" alt="image-20220818204949129"></p></li></ol><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ol><li><p>定义：指将一个请求封装为一个对象，从而使用不同的请求对客户进行参数化；对请求排队或记录日志，以及支持可撤销的操作。又称为动作模式或事务模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182042698.png" alt="image-20220818204238289"></p></li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ol><li><p>定义：允许一个对象在其内部状态发生变化的时改变其行为，使对象看起来似乎修改了它的类，状态模式又称为状态对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191851046.png" alt="image-20220819185056958"></p></li></ol><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><ol><li><p>定义：指用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立改变它们之间地交互，又称为调停者模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191930922.png" alt="image-20220819193014879"></p></li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><ol><li><p>定义：指一个作用于某对象结构中各元素地操作，它可以在不改变各元素地类地前提下，定义作用于这些元素的新操作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327947.png" alt="image-20220819232709871"></p></li></ol><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ol><li><p>定义：指定义语言的文法，并简历一个解释器来解释该语言中的句子，这里的”句子“是指使用规定格式和语法的代码，它是一宗类行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327119.png" alt="image-20220819232720065"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型设计模式</title>
    <link href="/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><strong>简单工厂模式</strong></h3><ol><li><p>定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p></li><li><p>结构图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171532554.png" alt="image-20220817153224447"></p></li></ol><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><ol><li><p>定义：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171542970.png" alt="image-20220817154249929"></p></li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a><strong>抽象工厂模式</strong></h3><ol><li><p>定义：提供一个创建一些列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171612449.png" alt="image-20220817161256362"></p></li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><strong>建造者模式</strong></h3><ol><li><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171621982.png" alt="image-20220817162143936"></p></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><strong>原型模式</strong></h3><ol><li><p>定义：使用原型实例指定待创建对象的类型，并通过复制这个原型来创建新的对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171628276.png" alt="image-20220817162807225"></p></li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><ol><li>定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</li><li>结构图：</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171634647.png" alt="image-20220817163425608"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构型设计模式</title>
    <link href="/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol><li><p>定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646024.png" alt="image-20220817164417326"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646005.png" alt="image-20220817164608352"></p></li></ol><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ol><li><p>定义：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171653072.png" alt="image-20220817165346023"></p></li></ol><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ol><li><p>定义：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171742358.png" alt="image-20220817174218295"></p></li></ol><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ol><li><p>定义：动态地给一个对象增加一些额外地职责。就扩展功能而言，装饰器模式提供了一种比使用子类更加灵活地替代方案。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171750349.png" alt="image-20220817175012294"></p></li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ol><li><p>定义：为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171754294.png" alt="image-20220817175427249"></p></li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ol><li><p>定义：运用共享技术有效地支持大量细粒度对象地复用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171802090.png" alt="image-20220817180248038"></p></li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li><p>定义：给某一个对象提供一个代理或占位符，并由代理对象来控制源对象地访问。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171809332.png" alt="image-20220817180918277"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种设计模式应用场景</title>
    <link href="/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/"/>
    <url>/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式应用场景"><a href="#设计模式应用场景" class="headerlink" title="设计模式应用场景"></a>设计模式应用场景</h1><ol><li>如何确保系统中一个类只有一个实例？单例模式</li><li>如何将对象的创建和对象的使用分离？简单工厂模式</li><li>如何通过不同的工厂来创建不同类型的对象？工厂方法模式</li><li>如何设计一个能够闯将一些列产品对象的工厂？抽象工厂模式</li><li>如何通过克隆来得到一个一模一样的对象？原型模式</li><li>如何一步步创建一个包含多个组成部分的复杂对象？建造者模式</li><li>如何在不修改现有系统的前提下重用没有源码的第三方类库？适配器模式</li><li>如何避免在多层继承结构中类的个数出现爆炸式增长？桥接模式</li><li>如何使用面向对象的方式来处理软件系统中的树形结构？组合模式</li><li>如何不通过继承的方式来扩展类的功能？装饰器模式</li><li>如何为复杂子系统提供一个统一的入口？外观模式</li><li>如何实现对象的多次复用以节省系统资源？享元模式</li><li>如何提供一种间接访问机制来实现对象的远程访问或受限访问？代理模式</li><li>如何让多个对象都有机会来处理同一个请求？责任链模式</li><li>如何将请求的发送者和请求的接收者完全解耦？命令模式</li><li>如何自定义一个简单的语言？解释器模式</li><li>如何遍历一个聚合对象中的元素？迭代器模式</li><li>如何协调多个对象之间复杂的相互调用？中介者模式</li><li>如何实现对象之间一对多的联动？观察者模式</li><li>如何设计和实现一个具有多个状态的对象？状态模式</li><li>如何在不修改现有代码的前提下更换一种算法？策略模式</li><li>如何为一个复杂算法的某些步骤提供多种实现方式？模板方法模式</li><li>如何操作一个包含多种类型对象的复杂结构？访问者模式</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计模式基础</title>
    <link href="/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h1><h2 id="软件设计模式定义"><a href="#软件设计模式定义" class="headerlink" title="软件设计模式定义"></a>软件设计模式定义</h2><p>软件设计模式是一套被反复使用，经过分类编目的代码设计经验的总结。使用软件设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。</p><p>软件设计模式定义有如下定义：</p><ol><li>软件设计模式是对代码设计经验的总结，且经过分类编目。</li><li>软件设计模式的根本目的是提高代码的重用性和可靠性。代码重用性是指相同功能的代码，不必多次编写。代码可靠性是指增加新功能时，对原来的功能没有影响。可靠性也体现了可扩展和可维护。</li><li>代码可读性是指编程的规范，便于其他程序员阅读和理解。</li></ol><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>软件设计模式的基本要素是指模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等。其中，软件设计模式的基本要素包括以下4个方面。</p><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ol><p>软件设计模式的基本结构由4部分构成，即问题描述、前提条件（环境或越苏条件）、解法（关联解法和其他相关设计模式）和效果（优&#x2F;缺点和已知应用），如下</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021813509.png" alt="image-20220502181256391"></p><h1 id="GoF设计模式及其分类"><a href="#GoF设计模式及其分类" class="headerlink" title="GoF设计模式及其分类"></a>GoF设计模式及其分类</h1><p>GoF的23中设计模式如下：</p><table>    <tbody style="text-align:center;vertical-align:middle;">        <tr >            <td colspan="2">创建型模式</td>            <td colspan="2">结构型模式</td>            <td colspan="2">行为型模式</td>        </tr>         <tr>            <td>类创建型模型</td>            <td>对象创建型模式</td>            <td>类结构型模式</td>            <td>对象结构型模式</td>            <td>类行为型模式</td>            <td>对象行为模式</td>        </tr>            <td>工厂方法模式</td>            <td></td>            <td>类适配器模式</td>            <td>对象适配模式</td>            <td></td>            <td>职责链模式</td>        </tr>        <tr>            <td></td>            <td>抽象工厂模式</td>            <td></td>            <td>桥接模式</td>            <td></td>            <td>命令模式</td>        </tr>        <tr>            <td></td>            <td>单例模式</td>            <td></td>            <td>代理模式</td>            <td></td>            <td>迭代器模式</td>        </tr>        <tr>            <td></td>            <td>建造者模式</td>            <td></td>            <td>组合模式</td>            <td></td>            <td>中介模式</td>        </tr>        <tr>            <td></td>            <td>原型模式</td>            <td></td>            <td>装饰模式</td>            <td></td>            <td>备忘录模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>享元模式</td>            <td></td>            <td>观察者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>外观模式</td>            <td></td>            <td>状态模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>策略模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>访问者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>模板方法模式</td>            <td></td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>解释器模式</td>            <td></td>        </tr>    </tbody></table><h2 id="创建型设计模式、结构型设计模式和行为型设计模式"><a href="#创建型设计模式、结构型设计模式和行为型设计模式" class="headerlink" title="创建型设计模式、结构型设计模式和行为型设计模式"></a>创建型设计模式、结构型设计模式和行为型设计模式</h2><p>软件设计模式有多种分类方法。根据模式目的（模式是用来做什么的）可分为创建型、结构型和行为型3种。</p><p>根据软件设计模式的处理范围，可以分为类模式和对象模式两种。</p><ul><li>类模式处理类和子类之间的关系是通过继承在编译时刻就被确定下来的，这些关系是属于静态的。</li><li>对象模式是处理对象之间的关系，这些关系是时刻变化运行的，具有动态性。</li></ul><p>根据软件设计模式的使用级别，可以分为基本设计模式、常用设计模式和高级设计模式3种。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>使用UML表示类间的4种基本关系：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021924361.png" alt="image-20220502191536437"></p><ol><li><p>关联关系：是类与类之间最常见的一种关系。他是一种结构化关系，用于表示一类对象与另一类对象之间的有（has a）联系。（通俗说是将一个类的对象作为另一个类的属性），在UML类图中，关联关系用实线（或实线带箭头–指向被关联类）连接有关联对象所对应的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013167.png" alt="image-20220502200907721"></p><ol><li><p>聚合关系（聚合关系是特殊的关联关系）具有如下特征：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象可以脱离整体而独立存在；</li><li>在代码实现时，成员对象可以通过构造器或setter方法注入；</li></ul><p>UMl类图表示聚合关系时，使用待空心菱形的实线表示（指向聚合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013175.png" alt="image-20220502201321550"></p></li><li><p>组合关系（组合关系表示类之间整体和部分的关系，其中整体类可控制成员类的声明周期，部分对象与整体对象之间具有同生共死的关系。）特征如下：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象与整体对象具有统一的生存期，当整体对象消亡时，成员对象也会消亡；</li><li>代码实现时，成员对象可在整体类声明或构造方法中实例化；</li></ul><p>在UML类图中，组合关系用待实心菱形的直线表示（指向组合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022015552.png" alt="image-20220502201549514"></p></li></ol></li><li><p>依赖关系：指两个事物之间的一种语义关系，表示一个事物发生变化时会影响另一个事物。依赖关系通常是一种使用关系，为临时性的关联。在代码中，依赖关系是通过定义被依赖类型的局部变量、方法参数及返回值类型等方式来体现。</p><p><font style="color:red;">注意：</font>关联关系使用成员变量（全局变量），而依赖关系使用局部变量。</p><p>在UML类图中依赖关系使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022017088.png" alt="image-20220502201724053"></p></li><li><p>泛化关系（即继承关系，也称”is a”关系。泛化关系用于描述父类与子类之间的关系，父类又称基类或超类，子类又称派生类。</p><p>在UML类图的泛化关系使用空心三角形的直线来表示（指向基类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022019078.png" alt="image-20220502201917032"></p></li><li><p>实现关系（指接口与实现类之间的实现，可实现接口中声明的所有抽象方法。</p><p>在UML类图中使用待空心三角形的虚线来表示实现关系（指向接口）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022021510.png" alt="image-20220502202141469"></p></li></ol><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。设计原则也是学习软件设计模式的基础，每种设计模式都会符合若干设计原则。</p><table><thead><tr><th align="center">名称</th><th align="center">简介</th><th align="center">重要性</th></tr></thead><tbody><tr><td align="center">开闭原则</td><td align="center">软件实体对扩展是开发的，但对修改是关闭的，即在不修改软件实体的基础上扩展其功能</td><td align="center">★★★★★</td></tr><tr><td align="center">里氏替换原则</td><td align="center">所有引用基类的地方必须透明地使用其子类对象。或者说，一个可以接收基类对象的地方必然可以接受一个子类对象</td><td align="center">★★★★★</td></tr><tr><td align="center">依赖倒置原则</td><td align="center">针对抽象层编程，而不应针对具体类编程</td><td align="center">★★★★★</td></tr><tr><td align="center">合成-聚合复用原则</td><td align="center">在关系中应尽量多地使用组合和聚合的关联关系，少使用甚至不使用继承关系</td><td align="center">★★★★</td></tr><tr><td align="center">单一职责原则</td><td align="center">类的职责要单一，不能将太多的职责放在一个类中</td><td align="center">★★★★</td></tr><tr><td align="center">迪米特法则</td><td align="center">一个软件实体对其他实体的引用应越少越好。或者说，如果两个类不必彼此直接通信，那么这两个类就不因该发生直接</br>的相互作用，而是通过引入一个第三方发生间接交互</td><td align="center">★★★</td></tr><tr><td align="center">接口隔离原则</td><td align="center">使用多个专门的接口来取代一个统一的接口</td><td align="center">★★</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
