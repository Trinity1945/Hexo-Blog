<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/09/04/%F0%9F%92%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/09/04/%F0%9F%92%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="💠java虚拟机"><a href="#💠java虚拟机" class="headerlink" title="💠java虚拟机"></a>💠java虚拟机</h1><p>虚拟机是物理机器的软件实现。Java 的开发遵循 write once run anywhere（“一次编写到处乱跑”）理念，它运行在 VM（虚拟机）上。编译器将 Java 文件编译成 Java.class 文件，之后，将 .class 文件输入到 JVM 中，加载并执行该类文件。下图是 JVM 的体系结构</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/heap-detail.jpg" alt="avatar"></p><h2 id="📓虚拟机内存区域"><a href="#📓虚拟机内存区域" class="headerlink" title="📓虚拟机内存区域"></a>📓虚拟机内存区域</h2><h3 id="📚程序计数器"><a href="#📚程序计数器" class="headerlink" title="📚程序计数器"></a>📚程序计数器</h3><p>定义：可以看作是当前线程所执行的字节码的行号指示器，为线程隔离的数据区。<br>java多线程切换时，每个线程独立的程序计数器，各条线程之间的计数器互不影响，独立存储，保证了线程切换后能恢复到正确的位置。</p><blockquote><p>唯一一个无OOM的区域</p></blockquote><h3 id="📚Java虚拟机栈"><a href="#📚Java虚拟机栈" class="headerlink" title="📚Java虚拟机栈"></a>📚Java虚拟机栈</h3><p>定义：每个方法执行的时候，Java虚拟机都会同步的创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><blockquote><p>栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息</p></blockquote><ul><li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)、</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚本地方法栈"><a href="#📚本地方法栈" class="headerlink" title="📚本地方法栈"></a>📚本地方法栈</h3><p>定义：为虚拟机使用到的本地(Native)方法服务。</p><ul><li>HotSpot直接把本方法栈和虚拟机栈合二为一。</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚Java堆"><a href="#📚Java堆" class="headerlink" title="📚Java堆"></a>📚Java堆</h3><p>定义:是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><ul><li>参数-Xmx和-Xms 最大堆内存和最小堆内存</li></ul><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/hotstop-heap.jpg" alt="avatar"></p><h3 id="📚方法区"><a href="#📚方法区" class="headerlink" title="📚方法区"></a>📚方法区</h3><p>定义：是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息(类名、方法描述、字段描述)、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><blockquote><p>JDK8以前使用<strong>永久代来实现方法区</strong><br>方法区类似于接口，永久代类似于实现类的关系。使用永久代的时候，可以设置内存上限，而且不同的虚拟机的实现不一样，因此更容易遇到内存溢出的问题。</p></blockquote><p><code>-XX:MaxMetaspaceSize</code>:设置元空间最大值，默认-1，不限制或者说仅受限于机器内存。 <code>-XX:MetaspaceSize</code>: 指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会根据收集结果对该值进行动态调整。 </p><h3 id="📚运行时常量池"><a href="#📚运行时常量池" class="headerlink" title="📚运行时常量池"></a>📚运行时常量池</h3><ul><li>定义：运行时常量池是方法区的一部分。Class文件除类字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，在类加载后存放到运行时常量池中。</li><li>运行时常量池具备动态性，运行期间可以将新的常量放入池中，当无法申请到空间抛出OutOfMemoryError异常。</li></ul><blockquote><p>在 Java 7 之前，JVM 将 Java String Pool 放置在 永久代空间(java7方法区的实现)中，该空间具有固定大小——它不能在运行时扩展并且不符合垃圾收集条件。<br>在永久代(而不是堆)中使用字符串的风险是，如果我们创建太多字符串，我们可能会从 JVM 中得到 OutOfMemory 错误。<br>从 Java 7 开始，Java String Pool 存储在 <strong>Heap 空间</strong>中，由 JVM 进行垃圾回收。 这种方法的优点是降低了 OutOfMemory 错误的风险，因为未引用的字符串将从池中删除，从而释放内存。</p></blockquote><h2 id="📓HotSpot-的后台线程"><a href="#📓HotSpot-的后台线程" class="headerlink" title="📓HotSpot 的后台线程"></a>📓HotSpot 的后台线程</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/hotspotThread.jpg" alt="avatar"></p><h2 id="📓内存区域溢出分析"><a href="#📓内存区域溢出分析" class="headerlink" title="📓内存区域溢出分析"></a>📓内存区域溢出分析</h2><h3 id="📚Java堆溢出"><a href="#📚Java堆溢出" class="headerlink" title="📚Java堆溢出"></a>📚Java堆溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMObject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚虚拟机栈和本地方法栈溢出"><a href="#📚虚拟机栈和本地方法栈溢出" class="headerlink" title="📚虚拟机栈和本地方法栈溢出"></a>📚虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈的溢出有StackOverflowError和OutOfMemoryError</p><p>导致StackOverflowError的两种行为</p><ol><li><code>-Xss</code>参数减少栈内存容量，递归过程导致堆栈溢出</li><li>定义大量本地变量，导致堆栈溢出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss128k</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        stackLength++;<br>        stackLeak();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> unused1,unused2; <span class="hljs-comment">// .... unused199</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内存溢出OutOfMemoryError的原因：因为创建一个线程的本地方法栈及虚拟机栈也是占用堆内存空间的，在内存有限的情况，创建一定数量的线程将导致内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss2M  设置每个线程的堆栈大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dontStop</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeakByThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    dontStop();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackOOM</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackOOM</span>();<br>        oom.stackLeakByThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚方法区和运行时常量池溢出"><a href="#📚方法区和运行时常量池溢出" class="headerlink" title="📚方法区和运行时常量池溢出"></a>📚方法区和运行时常量池溢出</h3><p>JDK1.7之前会产生永久代内存溢出的情况，而之后会产生内存溢出的情况，因为常量池移动到堆中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行时常量池溢出导致内存溢出 jdk7中</span><br><span class="hljs-comment">// 参数： -Xmx6M -XX:MaxMetaspaceSize=6M -XX:PermSize=6M</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">short</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            set.add(String.valueOf(i++).intern());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码增强生成大量的动态类导致的溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 借助CGlib 使方法区出现永久代内存溢出异常，在JDK7中导致内存空间溢出</span><br><span class="hljs-comment">// java 8 不会出现问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaMethodAreaOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>            enhancer.setSuperclass(OOMObject.class);<br>            enhancer.setUseCache(<span class="hljs-literal">true</span>);<br>            enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                    <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);<br>                &#125;<br>            &#125;);<br>            enhancer.create();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚本机直接内存溢出"><a href="#📚本机直接内存溢出" class="headerlink" title="📚本机直接内存溢出"></a>📚本机直接内存溢出</h3><p>特征是Heap dump很小，而程序中又间接使用了DirectMemory(如NIO)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//* 参数：-Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="hljs-comment">//* 本机直接内存溢出</span><br><span class="hljs-comment">//*</span><br><span class="hljs-comment">//*  -XX:MaxDirectMemorySize 用于指定直接内存大小</span><br><span class="hljs-comment">//* 真正申请内存分配的方法Unsafe::allocateMemory()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemoryOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredFields()[<span class="hljs-number">0</span>];<br>        unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)unsafeField.get(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            unsafe.allocateMemory(_1MB);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="hljs-comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="hljs-comment">     * at com.learning.jvm.memory.DirectMemoryOOM.main(DirectMemoryOOM.java:27)</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓四种引用类型"><a href="#📓四种引用类型" class="headerlink" title="📓四种引用类型"></a>📓四种引用类型</h2><blockquote><p>JDK1.2 之前，一个对象只有“已被引用”和”未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</p><p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p></blockquote><h3 id="📚强引用"><a href="#📚强引用" class="headerlink" title="📚强引用"></a>📚强引用</h3><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">//只要obj还指向Object对象，Object对象就不会被回收 obj = null; //手动置null</span><br></code></pre></td></tr></table></figure><h3 id="📚软引用"><a href="#📚软引用" class="headerlink" title="📚软引用"></a>📚软引用</h3><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="📚弱引用"><a href="#📚弱引用" class="headerlink" title="📚弱引用"></a>📚弱引用</h3><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="📚虚引用"><a href="#📚虚引用" class="headerlink" title="📚虚引用"></a>📚虚引用</h3><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h2 id="📓垃圾收集器与内存分配策略"><a href="#📓垃圾收集器与内存分配策略" class="headerlink" title="📓垃圾收集器与内存分配策略"></a>📓垃圾收集器与内存分配策略</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生而灭，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收问题。</p><h3 id="📚判断对象是否已死的方法"><a href="#📚判断对象是否已死的方法" class="headerlink" title="📚判断对象是否已死的方法"></a>📚判断对象是否已死的方法</h3><h4 id="📔引用计数法"><a href="#📔引用计数法" class="headerlink" title="📔引用计数法"></a>📔引用计数法</h4><p>定义：在对象中添加一个引用计数器，有一个地方引用时，计数器值加一，引用失效时减一。</p><ul><li>优点：原理简单，判定效率也很高。</li><li>缺点：难以解决对象之间互相循环引用的问题。</li></ul><h4 id="📔可达性分析算法"><a href="#📔可达性分析算法" class="headerlink" title="📔可达性分析算法"></a>📔可达性分析算法</h4><p>定义：通过一系列成为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。若某对象到GC Roots间没有任何引用链相连，证明此对象是不可能再被使用的。</p><p>GC Roots的对象分为以下几种：</p><ol><li>虚拟机栈中的引用对象，入线程调用方法堆栈的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象。如Java类的引用类型静态变量。</li><li>在方法区中常量引用对象，如字符串常量池的引用。</li><li>在本地方法栈中的JNI(Native方法)引用的对象。</li><li>Java虚拟机内部的引用，如基本类型对应的Class对象，一些常驻异常对象(<code>NullPointException</code>)等，还有系统类加载器。</li><li>所有被同步锁(synchronize关键字)持有的对象。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地缓存代码等。</li></ol><h4 id="📔三色标记算法"><a href="#📔三色标记算法" class="headerlink" title="📔三色标记算法"></a>📔三色标记算法</h4><p>三色标记算法：GCRoot如果想查找到存活对象，会根据可达分析算法分析，遍历整个引用链 ,按照是否访问过该对象分成三种不同的颜色盒子(容器)：白色、灰色、黑色盒子。</p><blockquote><p>白色：本对象没有被访问过 (没有被GCRoot扫描过，有可能是为垃圾对象)；<br>灰色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性没有被GCRoot扫描，该对象就是为灰色对象；如果该对象的属性被扫描的情况下，从灰色变为黑色。<br>黑色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性已经被GCRoot扫描过，该对象就是为黑色对象。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730951.png" alt="avatar"></p><p>三色标记算法缺陷：在并发标记阶段的时候，因为用户线程与GC线程同时运行，有可能会产生多标或者漏标；<br>多标–多标记(浮动垃圾)<br>漏标–漏标记</p><p><strong>浮动垃圾</strong></p><ol><li>并发标记：用户与GC线程同时运行，假设现在扫描到C对象，B对象变为黑色，用户线程执行C的属性E&#x3D;null,GC线程扫描C对象引用链，认为E对象是为可达对象，但是C对象根本没有引入到E对象，E对象应该是为垃圾对象，这种问题，可以在重新标记阶段(修正)修复。</li><li>并发清除阶段：用户与GC线程同时运行，会产生新的对象但是没有及时被GC清理。 只能在下一次GC清理垃圾的修复。</li></ol><p><strong>漏标问题</strong></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/mark-problem.png" alt="avatar"></p><ol><li>用户线程先执行C的E属性&#x3D;null；GC线程的GcRoot就扫描不到E。GC就认为E对象就是为垃圾对象，不可达对象。</li><li>用户线程执行B.E属性&#x3D;E；E对象就是应该是为可达对象。 因为GCRoot是从C开始，不会从黑色的B开始，就会导致漏标的情况发生。</li></ol><p>漏标的问题产生满足两个条件：</p><ol><li>至少有一个黑色对象指向了白色对象</li><li>在所有灰色对象扫描完整个链时，删除之前所有白色对象引用关系。</li></ol><p>CMS如何解决漏标问题—写屏障+增量更新方式</p><blockquote><p>满足一个条件(灰色对象与白色对象断开连接)，在并发标记阶段当我们黑色对象(B)引用关联白色对象(E)，记录下B黑色对象。<br>在重新标记阶段(所有用户线程暂停)，有将B对象变为灰色对象将整个引用链全部扫描。<br>缺点：遍历B整个链的效率非常低，有可能会导致用户线程等待的时间非常长。</p></blockquote><p>G1如何解决漏标问题—原始快照方式</p><blockquote><p>在C(灰色对象)断开E(白色)的时候，会记录原始快照，在重新标记阶段的时候以白色对象变为灰色为起始点扫描整个链，本次GC是不会被清理。<br>好处：如果假设B(黑色对象)引入该白色对象的时候，无需做任何遍历效率是非常高。<br>缺点：如果假设B(黑色对象) 没有引入该白色对象的时候，该白色对象在本次GC继续存活，只能放在下一次GC在做并发标记的时候清理。<br><strong>tips:以浮动垃圾(占内存空间)换让我们用户线程能够暂停的时间更加短。</strong></p></blockquote><p>总结： CMS收集器解决漏标问题：增量方式 如果现在B(黑色)对象引入白色对象，写屏障。</p><ul><li>好处：避免浮动垃圾</li><li>缺点扫描整个引用链效率比较低。</li></ul><p>G1收集器解决漏标问题：原始快照方式。</p><ul><li>好处：效率非常高，无需扫描整个引用链</li><li>缺点：可能会产生浮动垃圾。</li></ul><h2 id="📓回收方法区"><a href="#📓回收方法区" class="headerlink" title="📓回收方法区"></a>📓回收方法区</h2><p>方法区的回收主要是两部分内容：废弃的常量和不再使用的类型。</p><ul><li>废弃的常量的例子：字符串常量进入到常量池中，但当前系统有没有任何一个字符串对象的值为“java”，则该常量就会被系统清理出常量池。</li><li>不在使用的类，需同时满足一下三个条件：<ul><li>该类的所有实例已经被回收，也就是java对重不存在该类及其任何派生的子类实例。</li><li>加载该类的类加载器已经被回收。正常很难达成。如OSGi、JSP的重加载会产生。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h2 id="📓垃圾回收算法"><a href="#📓垃圾回收算法" class="headerlink" title="📓垃圾回收算法"></a>📓垃圾回收算法</h2><p>弱分代假说：绝大多数对象都是朝生夕灭。<br>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。<br>跨代引用假说：存在于新生代的对象可能会引用老年代的对象。因此该假说说明的是，存在互相引用关系的对象，是应该倾向于同时生存或者同时死亡。</p><blockquote><p>解决方案，在新生代上建立一个全局的数据结构(记忆集)，这个结构把老年代划分成若干小块，表示出老年代的哪一块内存会存在跨代引用。之后发生Minor GC时，只有包含跨代引用的小块内存才会加入到GC Root的扫描.</p></blockquote><h3 id="📚标记-清除算法"><a href="#📚标记-清除算法" class="headerlink" title="📚标记-清除算法"></a>📚标记-清除算法</h3><p><strong>算法实现</strong>：分为标记-清除两个阶段，首先根据上面的根搜索算法标记出所有需要回收的对象，在标记完成后，然后在统一回收掉所有被标记的对象。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730190.jpeg" alt="img"></p><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。</p><p><strong>不足：</strong></p><ul><li><strong>效率问题</strong>：标记和清除的效率都不高</li><li><strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集。</li></ul><h3 id="📚复制算法"><a href="#📚复制算法" class="headerlink" title="📚复制算法"></a>📚<strong>复制算法</strong></h3><p><strong>算法实现</strong>：将可用内存按容量划分为大小相等的两块区域，每次只使用其中一块，当这一块的内存用完了，就将还活着的对象复制到另一块区域上，然后再把已使用过的内存空间一次性清理掉。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730608.jpeg" alt="img"></p><p><strong>优点</strong>：每次都是只对其中一块内存进行回收，不用考虑内存碎片的问题，而且分配内存时，只需要移动堆顶指针，按顺序进行分配即可，简单高效。</p><p><strong>缺点</strong>：将内存分为两块，但是每次只能使用一块，也就是说，机器的一半内存是闲置的，这资源浪费有点严重。并且如果对象存活率较高，每次都需要复制大量的对象，效率也会变得很低。</p><h3 id="📚标记-整理算法"><a href="#📚标记-整理算法" class="headerlink" title="📚标记-整理算法"></a>📚标记-整理算法</h3><p><strong>算法实现</strong>：首先标记出所有存活的对象，然后让所有存活对象向一端进行移动，最后直接清理到端边界以外的内存。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730009.jpeg" alt="img"></p><p>　<strong>局限性</strong>：只有对象存活率很高的情况下，使用该算法才会效率较高。</p><h3 id="📚分代收集算法"><a href="#📚分代收集算法" class="headerlink" title="📚分代收集算法"></a>📚分代收集算法</h3><p><strong>算法实现</strong>：根据对象的存活周期不同将内存分为几块，然后不同的区域采用不同的回收算法。</p><ol><li>对于存活周期较短，每次都有大批对象死亡，只有少量存活的区域，采用复制算法，因为只需要付出少量存活对象的复制成本即可完成收集；</li><li>对于存活周期较长，没有额外空间进行分配担保的区域，采用标记-整理算法，或者标记-清除算法。</li></ol><p>　比如，对于 HotSpot 虚拟机，它将堆空间分为如下两块区域：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730405.png" alt="image-20220902215350103"></p><p>堆有新生代和老年代两块区域组成，而新生代区域又分为三个部分，分别是 Eden,From Surivor,To Survivor ,比例是8:1:1。</p><p>　　新生代采用复制算法，每次使用一块Eden区和一块Survivor区，当进行垃圾回收时，将Eden和一块Survivor区域的所有存活对象复制到另一块Survivor区域，然后清理到刚存放对象的区域，依次循环。</p><p>​老年代采用标记-清除或者标记-整理算法，根据使用的垃圾回收器来进行判断。</p><h3 id="📚新生代垃圾回收"><a href="#📚新生代垃圾回收" class="headerlink" title="📚新生代垃圾回收"></a>📚新生代垃圾回收</h3><ol><li>eden、 survivor From 复制到 survivor To，年龄+1。</li></ol><blockquote><p>首先，把 Eden 和 survivor From 区域中存活的对象复制到 survivor To 区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代区)，同时把这些对象的年龄+1(如果 ServicorTo 不够位置了就放到老年区)；</p></blockquote><ol><li>清空 eden、 survivor From。</li></ol><blockquote><p>然后，清空 Eden 和 survivor From 中的对象；</p></blockquote><ol><li>survivor To 和 survivor From 互换</li></ol><blockquote><p>最后， survivor To 和 survivor From 互换，原 survivor To 成为下一次 GC 时的 survivor From区。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></p></blockquote><p><strong>相关问题</strong></p><p>为什么需要Survivor区域？</p><blockquote><p>防止对象过早进入Old，导致Old频繁Full GC。Survivor具有预筛选保证，只有对象到一定岁数才会送往老年代，Survivor区可以减少被送到老年代的对象，进而减少Full GC发生。</p></blockquote><p>为什么需要两个Survivor区域？</p><blockquote><p>如果只有一个Survivor，每次垃圾回收年龄+1，会有部分对象进入老年代，导致Survivor的空间变成碎片化空间，最后触发minor gc。使用两个Survivor并进行交换，就保证了两个Survivor区，一个为空，另一个是非空且无碎片保存的。</p></blockquote><h2 id="📓GC垃圾收集器"><a href="#📓GC垃圾收集器" class="headerlink" title="📓GC垃圾收集器"></a>📓GC垃圾收集器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；<br>年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/garbage-collector.jpg" alt="avatar"></p><h3 id="📚Serial收集器"><a href="#📚Serial收集器" class="headerlink" title="📚Serial收集器"></a>📚Serial收集器</h3><ul><li>定义:一个单线程的垃圾收集器，在垃圾收集时必须暂停其他所有工作线程，直到收集结束。</li><li>对于新生代采取复制算法暂停所有线程，对于老年代使用标记-整理算法同样暂停所有线程。</li><li>缺点：需要暂停用户线程。</li><li>优点：<ol><li>简单高效、对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。</li><li>单核处理器或者处理器核心较少的环境来说，Serial由于没有线程交互的开销，可以专心做垃圾回收自然可以获得最高的单线程收集效率。</li></ol></li></ul><h3 id="📚Serial-Old收集器"><a href="#📚Serial-Old收集器" class="headerlink" title="📚Serial Old收集器"></a>📚Serial Old收集器</h3><ul><li>定义：使用标记-整理算法。</li><li>用途：可以Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器发生失败的后背方案。<img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/serial-1.jpg" alt="avatar"></li></ul><h3 id="📚ParNew收集器"><a href="#📚ParNew收集器" class="headerlink" title="📚ParNew收集器"></a>📚ParNew收集器</h3><ul><li><p>定义：Serial收集器的多线程并行版本。</p></li><li><p>唯一的优点仅有ParNew和Serial可以和CMS收集器配合工作，以后ParNew将会合并入CMS，成为其处理新生代的组成部分。</p></li><li><p>随着可以被使用的处理核心增加，ParNew对于垃圾收集时系统可以高效利用，默认开启的收集线程数和处理器核心数量相同。</p></li><li><p>新生代：标记复制。老年代：标记-整理</p></li><li><p>常使用参数：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parNew-1.jpg" alt="avatar"></p></li></ul><h3 id="📚Parallel-Scavenge-收集器"><a href="#📚Parallel-Scavenge-收集器" class="headerlink" title="📚Parallel Scavenge 收集器"></a>📚Parallel Scavenge 收集器</h3><p>定义：新生代收集器，同样基于标记-复制算法，能够并行收集的多线程收集器。特点是达到一个可控制的吞吐量。 <code>吞吐量= 运行客户代码时间/(运行用户代码时间+运行垃圾收集时间)</code></p><p>虚拟机完成用户任务及垃圾收集用了100分钟，其中垃圾收集用了1分钟，吞吐量&#x3D;99%</p><ul><li>-XX:MaxGCPauseMills：控制最大垃圾收集时间参数</li></ul><blockquote><p>允许设置的是一个大于0的毫秒数，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换区的。调小新生代会缩短垃圾回收时间，若调的太小会导致垃圾收集变得频繁。</p></blockquote><ul><li>-XX:GCTimeRatio：设置吞吐量大小时间<ul><li>设置的值应当是大于0小于100的整数，也就是垃圾回收时间占总时间的比率为吞吐量的倒数。</li><li>设置成19，那允许垃圾回收时间为总时间的5%(1&#x2F;(1+19))，默认值为99,允许最大1%的时间进行垃圾回收。</li></ul></li><li>-XX:+UseAdaptiveSizePolicy: 开启自适应的调整策略。</li></ul><h3 id="📚Parallel-Old收集器"><a href="#📚Parallel-Old收集器" class="headerlink" title="📚Parallel Old收集器"></a>📚Parallel Old收集器</h3><p>定义：Parallel Scavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。</p><blockquote><p>与Parallel Scavenge搭配作为“吞吐量优先”的收集器搭配组合</p></blockquote><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parallel.jpg" alt="avatar"></p><h3 id="📚CMS-Concurrent-Mark-Sweep-收集器"><a href="#📚CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="📚CMS(Concurrent Mark Sweep)收集器"></a>📚CMS(Concurrent Mark Sweep)收集器</h3><p>定义：一种以获取最短回收停顿时间为目标的收集器，工作于老年代。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行过程解析，基于标记-清除算法实现，具体大流程步骤如下：</p><ol><li>初始标记：仅仅标记一下GC Root对象能直接关联到的对象，速度很快，需要暂停所有线程。</li><li>并发标记：从GC Root关联对象开始遍历整个对象图的过程，可以与用户线程共同执行。</li><li>重新标记：因用户程序继续运行而导致标记产生变动的那部分对象的标记记录，通常比初始标记长远比并发标记段。</li><li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动对象，因此可以与用户线程共同执行。\</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/cms-1.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>主要流程:</p><ol><li>初始标记：STW，标记根对象。</li><li>并发标记：标记所有对象。</li><li>预清理：清理前准备以及控制停顿时间</li><li>重新标记：STW，修正并发标记数据</li><li>并发清理：清理垃圾</li><li>并发重置</li></ol><p>预清理：预清理是并发的，除了为正式清理做准备和检查以外，与清理还会尝试控制一次停顿时间。由于重新标记是独占CPU的，<strong>如果新声代GC后，立即触发一次重新标记，那么一次停顿时间可能很长</strong>。为了避免这种情况，预清理时，会可以等待一次新声代GC的发生，然后根据历史性能数据预测下一次新生代GC可能发生的时间，在当前时间和预测时间的中间时刻进行重新标记。最大程度上避免新生代GC和重新标记重合，尽可能减少一次停顿时间。</p><blockquote><p>开关<code>-XX:-CMSPrecleaningEnabled</code> 用来开关预清理</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730258.png" alt="avatar"></p><p>特点：</p><ol><li>对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用CPU不超过25%。若核心数量小于4，则占用CPU过大。</li><li>无法处理“浮动垃圾”，有可能出现并发模式失败进而导致一次Full GC。浮动垃圾为出现在标记过程结束之后产生的对象。因为CMS要支持收集过程中与用户线程并存，因此不能在老年代几乎被填满时再运行，需要预留一部分空间供并发收集的程序运行。</li></ol><blockquote><p>JDK5中设置CMS在老年代使用了68%便会激活，JDK6默认的设置提高到92%。当运行预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”。后备预案为冻结用户线程，启用Serial Old进行老年代的垃圾收集。<br>并发收集失败：收集过程中，老年代被填满；收集完成后，收集的空间仍然无法满足被使用；浮动垃圾</p></blockquote><ul><li>参数-XX:CMSFullGCsBeforeCompaction：作用是要求CMS收集器在执行过若干次不整理的Full GC之后，下一次先进行碎片整理</li></ul><p>常用参数:</p><ul><li><code>-XX:+UseConcMarkSweepGC</code>: 启用 CMS 回收器</li><li><code>-XX:ConcGCThreads</code>和<code>-XX:ParallelCMSThreads</code>：用来指定GC并发线程数量</li><li><code>-XX:CMSinitiatingOccupancyFraction</code>：可以设置触发CMS收集的百分比。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>： 参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。(默认值为0，表示每次FullGC都进行碎片整理)</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：开关可以使CMS在垃圾收集完成后，进行一次内存碎片整理，内存碎片的整理不是并发进行的。</li><li><code>-XX:-CMSPrecleaningEnabled</code>：用来开关预清理</li></ul><h3 id="📚Garbage-First-收集器"><a href="#📚Garbage-First-收集器" class="headerlink" title="📚Garbage First 收集器"></a>📚Garbage First 收集器</h3><p>G1是一种兼顾吞吐量和停顿时间的GC实现。<br>定义：面向服务端应用的垃圾收集器，基于Region的堆内存布局进行垃圾收集，每一个Region都可以根据需要扮演新生代的Eden空间、Survivor空间和老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要超过了一个Region一半的对象即可认为是大对象。对于Humongous区域，正常当做老年代一部分。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行步骤：</p><ol><li>初始标记：标记GC Root对象能直接关联的对象并修改TAMS指针的值为正确的空区域。需要暂停线程，但是时间很短，借用进行Minor GC时同步完成。</li><li>并发标记：根据GC Root进行可达性分析，扫描对象图。完成扫描后，处理SATB记录下并发时有引用变动的对象。</li><li>最终标记：短暂暂停用户线程，处理并发阶段结束后，少量的SATB记录。</li><li>筛选回收：更新Region的统计数据，进行回收价值和成本的排序，根据用户期望的停顿时间来构建回收集合。回收集合的存活对象复制到空的Region，再清理旧的Region。涉及到对象移动，需要暂停用户线程，使用多线程并行完成移动。</li></ol><p>G1整体是基于标记-整理算法实现的收集器，但从局部优势基于标记-复制算法实现。在执行标记整理的时候，还进行了压缩的工作，这是之前的垃圾收集器都没有的。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1.jpg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-memory.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>收集过程：</p><ol><li>新生代GC</li><li>并发标记周期</li><li>混合收集</li><li>如果需要会进行Full GC</li></ol><p><strong>并发标记周期</strong></p><p>执行流程</p><ol><li>初始标记: 标记从根节点直接可达的对象。这个阶段会伴随一次新生代GC，产生全局停顿。</li><li>根区域扫描: 由于初始标记必然伴随一次新生代GC，存活对象均移入survivor区。将扫描由<strong>survivor区</strong>直接可达的老年代区域(根区域扫描依赖survivor区对象)。如果同时需要新生代GC，那么GC就需要等待根区域扫描结束后才能进行。</li><li>并发标记: 扫描并查找整个堆的存活对象，并发过程可被新生代GC打断。</li><li>重新标记: CMS一样，重新标记也是会产生应用程序停顿的由于在并发标记过程中，应用程序依然在运行，因此标记结果可能需要进行修正，所以在此对上一次的标记结果进行补充。在G1中，这个过程使用SATB(Snapshot At-The-Beginning)算法完成,G1会在标记之初为存活对象创建个快照，这个快照有助于加速重新标记的速度。</li><li>独占清理: 这个阶段是会引起停顿的，它将计算各个区域的存活对象和GC回收比例并进行排序，识别可供混合回收的区域 在这个阶段，还会更新记忆集(Remembered Set), 该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段，需要这些信息。</li><li>井发清理阶段: 这里会识别并清理完全空闲的区域 它是井发的清理，不会引起停顿。</li></ol><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png" alt="avatar"></a></p><p>由于并发标记周期包含一次新生代GC，故新生代会被整理。但由于并发标记周期执行时，应用程序依然在运行。因此，并发标记周期结束后，又会有新的Eden空间被使用。并发标记周期执行前后最大的不同是在该阶段后，系统增加了一些标记为G的区域。这些区域被标记，是因为它们内部的垃圾比例较高，因此希望在后续的混合GC中进行收集(注意在并发标记周期中并未正式收集这些区域〉。</p><p><strong>并发回收阶段前后的可能情况</strong> <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-alloc.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729043.png" alt="avatar"></a></p><p><strong>混合回收</strong></p><p>定义：在并发标记周期中，虽然有部分对象被回收，但是总体上说，回收的比例是相当低的。但是在并发标记周期后，己经明确知道哪些区域含有比较多的垃圾对象，在混合回收阶段，就可以专门针对这些区域进行回收。当然G1会优先回收垃圾比例较高的区域，因为回收这些区域的性价比也比较高。这个阶段叫作混合回收。</p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png" alt="avatar"></a></p><p>混合GC会执行多次，直到回收了足够多的内存空间，然后，它会触发一次新生代GC。新生代GC后，又可能会发生一次并发标记周期的处理。最后，又会起混合GC的执行。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png" alt="avatar"></a></p><p><strong>必要时的Full GC</strong></p><p>并发收集由于让应用程序和GC线程交替工作，因此总是不能完全避免在特别繁忙的场合会出现在回收过程中内存不充足的情况。当遇到这种情况时，G1会转入一个Full GC进行回收。</p><blockquote><p>如果在混合GC时发生空间不足或者在新生代GC时，survivor区和老年代无法容纳幸存对象，都会导致一次Full GC产生。</p></blockquote><p>记忆集是G1中维护的一个数据结构，简称RS(Remembered Set)。每一个G1区域都有一个RS与之关联。<br>作用：由G1回收时，是按照区域回收的，如在回收区域A的对象 ，很可能并不回收区域B的对象。为了避免在整个堆中进行对象的可达性扫描。因此，G1在区域RS中，记录了在区域A中被其他区域引用的对象，这样在回收区域A时，只要将RS视为区域A根集的一部分即可，从而可避免做整个堆的扫描。</p><p>G1日志的一些术语：</p><ul><li>CT(Card Table): RS 就是依靠 CardTab 来记录哪些是存活对象的：</li><li>CSet(Collection Sets): Collection Sets表示被选取的、将要被收集的区域的集合</li><li>Ref Proc(处理弱引用、软引用的时间)</li><li>RefEnq(弱引用、软引用入队时间)</li><li>Free CSet(释放被回收的CSet中区域的时间，包括它们的RS)。</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">1 .<span class="hljs-number"> 619 </span>: [GC pause (young) (init al-mark)<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 03848843 </span>secs] <br>[Parallel Time :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>ms] <br>[GC Worker Start (ms) : 1619.3<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Max :<span class="hljs-number"> 1619 </span>. 3, Diff : 0.0] <br>[Ext Root Scanning (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>0.3 0.2<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span>, Max :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Diff : 0.1] <br>[Update RS (ms) :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 7 </span>5 .<span class="hljs-number"> 4 </span>2<span class="hljs-number"> 8 </span>. O<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 11 </span>.<span class="hljs-number"> 1 </span>, Min :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span>, Max:<span class="hljs-number"> 28 </span>.<span class="hljs-number"> 0 </span>, Diff : 22.8] <br>[Processed Buffers :<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 1 </span>4 <br>Sum :<span class="hljs-number"> 14 </span>, Avg :<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1 </span>, Max : 5, Diff : 4] <br>[Scan RS (ms) :<span class="hljs-number"> 4 </span>.<span class="hljs-number"> 6 </span>5 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>5 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 3 </span>.<span class="hljs-number"> 7 </span>, Min : 0.0 , Max:<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 2 </span>, Diff :<span class="hljs-number"> 5 </span>. 2] <br>[Object Copy (ms): 27.4<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 3 </span>9 .<span class="hljs-number"> 6 </span>27 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 22 </span>.<span class="hljs-number"> 9 </span>, Min :<span class="hljs-number"> 9 </span>.<span class="hljs-number"> 6 </span>, Max :<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 4 </span>, Diff : 17.7) <br>[Term nat on (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 1 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Min: 0.0 , Max:<span class="hljs-number"> 0 </span>. 1, Diff : 0.1] <br>[Termination Attempts :<span class="hljs-number"> 3 </span>1<span class="hljs-number"> 10 </span>5 <br>Sum :<span class="hljs-number"> 19 </span>, Avg:<span class="hljs-number"> 4 </span>, Min :<span class="hljs-number"> 1 </span>, Max :<span class="hljs-number"> 10 </span>, Diff: 9] <br>[GC Worker End (ms): 1657.<span class="hljs-number"> 3 </span>1657.<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span><br>Avg : 1657.2, Min:<span class="hljs-number"> 1657 </span>. 2, Max : 1657.3, Diff:<span class="hljs-number"> 0 </span>. 0) <br>[GC Worker (ms) :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>38 .<span class="hljs-number"> 0 </span>38.0<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span><br>Avg :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Min :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Max :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Diff :<span class="hljs-number"> 0 </span>. 1] <br>[GC Worker Other (ms) : 0.0<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.1<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span><br>Avg : 0.1 , Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Max : 0.1 , Diff : 0.1) <br>[Clear CT : 0.0 ms] <br>[Other :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 4 </span>ms] <br>[Choose CSet : 0.<span class="hljs-number"> 0 </span>ms] <br>[Ref Proc :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Ref Enq:<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>ms] <br>[Free CSet :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Eden : 32M(35M) - &gt;0B(35M) Survivors : 5120K-&gt;5120K Heap : 147M(200M) - &gt;147M <br>(200M )) <br>[Times : user=0 .<span class="hljs-number"> 16 </span>sys=0 .<span class="hljs-number"> 00 </span>, real=0 .<span class="hljs-number"> 04 </span>secs]<br></code></pre></td></tr></table></figure><hr><p>特点:</p><ol><li>避免在整个Java堆进行全区域的垃圾回收，而是让G1跟踪每个Region的垃圾回收的价值及回收所需的时间，在后台维护一个优先级表。根据用户设定的允许收集停顿时间，优先回收价值收益最大的Region。(使用参数-XX:MaxGCPauseMills指定)</li><li>G1收集器每个Region都需要自己的记忆集，记录跨区域引用，因此比其他收集器要耗费内存，大约为java堆内存容量10%~20%。</li><li>通过在Region中划分空间(使用两TAMS指针，标记一块区域)用于并发回收的新对象分配，解决并发标记阶段与用户线程互不干扰。同样若内存分配速度大于内存回收速度，可能冻结用户线程进行Full GC。</li><li>CMS使用增量更新算法，而G1使用原始快照(SATB)算法来解决，用户线程改变对象的引用关系，不打破原有的对象图结构，防止标记错误。</li><li>通过可靠停顿预测模型的建立：根据每个Region的回收成本，分析出收集的平均值、标准偏差、置信度等统计信息。</li></ol><ul><li>缺点：内存占用过高，在小内存应用上CMS的表现大于G1。</li></ul><p>常用参数：</p><ul><li><code>-XX:+UseG1GC</code>：标记打开 GI 集器开关</li><li><code>-XX:G1HeapRegionSize</code>: 参数Region的大小可通过该参数设定，取值范围为1M~32M，为2的N次幂。</li><li><code>-XX:MaxGCPauseMills</code>：设置用户设定的允许收集停顿时间时，默认为200毫秒。调的调小会导致每次的回收集只占内存的很小一部分，收集的速度慢于分配的速度导致垃圾堆积，进而引发Full GC。正常设置为100~300毫秒之间。</li><li><code>-XX:ParallelGCThreads</code>：用于设置并行回收时，GC的工作线程数量。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值是45，即当整个堆占用率达到45%时，执行并发标记周期。</li></ul><h3 id="📚CMS-与-G1-对比"><a href="#📚CMS-与-G1-对比" class="headerlink" title="📚CMS 与 G1 对比"></a>📚CMS 与 G1 对比</h3><p>G1计划作为并发标记扫描收集器(CMS)的长期替代品。</p><ol><li>垃圾回收理念不同：CMS基于分代收集理念设计。G1基于分区收集理念设计。</li><li>整理：G1在GC的时候都会做垃圾的碎片整理，而CMS收集器只在Full GC STW时才会做内存压缩整理。</li><li>可停顿时间：G1是一种兼顾吞吐量和停顿时间的 GC 实现，其可靠停顿预测模型可以设定目标收集停顿时间，可以实现更短的GC停顿。</li><li>对象记录算法：对于对象记录CMS使用增量更新算法，而G1使用原始快照(SATB,snapshot-at-the-beginning)记录存活对象。</li><li>收集方式：G1使用混合收集的方式。G1可以扫描年轻代和一小部分老年代，但这意味着比简单地只扫描老年代、完全的快得多。</li><li>String重复数据删除。G1可以配置针对String的重复数据进行删除，而重复的数据将指向同一个char[] array。<code>-XX:+UseStringDeduplication</code></li></ol><ul><li>CMS对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用内存不超过25%。若核心数量小于4，则占用内存过大。</li><li>G1针对具有大内存的多处理器机器，因为其<code>Remembered Sets</code>的记忆集的设计，需要占用更多内存。</li></ul><h3 id="📚其他的垃圾收集器"><a href="#📚其他的垃圾收集器" class="headerlink" title="📚其他的垃圾收集器"></a>📚其他的垃圾收集器</h3><ul><li>Shenandoah 收集器：仅存在OpenJdk，区别G1的特点为支持并发整理，使用转发指针和读屏障实现。</li><li>ZGC 收集器：Region具有动态性，并分为大中小三个Region，使用染色指针技术实现并发整理算法。</li><li>Epsilon收集器：无操作收集器。</li></ul><h3 id="📚选用收集器的三个因素"><a href="#📚选用收集器的三个因素" class="headerlink" title="📚选用收集器的三个因素"></a>📚选用收集器的三个因素</h3><ol><li>如果是数据分析、科学计算类任务，目标是尽快可以算出结果，那么吞吐量为主要关注点。如果为SLA应用，停顿时间直接影响任务质量，严重甚至会导致事务超时，那么延迟是主要的关注点。</li><li>使用运行的基础设施的指标。</li><li>JDK对应的版本。</li></ol><h3 id="📚java虚拟机监控工具"><a href="#📚java虚拟机监控工具" class="headerlink" title="📚java虚拟机监控工具"></a>📚java虚拟机监控工具</h3><h4 id="📔jps"><a href="#📔jps" class="headerlink" title="📔jps"></a>📔jps</h4><p>jps (JVM Process Status): 类似 UNIX 的 ps 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -l<br><span class="hljs-number">3796</span> sun.tools.jps.Jps<br><span class="hljs-number">2903</span> org.apache.catalina.startup.Bootstrap<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -m<br><span class="hljs-number">3811</span> Jps -m<br><span class="hljs-number">2903</span> Bootstrap start<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -v<br><span class="hljs-number">3828</span> Jps -Dapplication.home=/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_221</span>-amd64 -Xms8m<br><span class="hljs-number">2903</span> Bootstrap -Djava.util.logging.config.file=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=<span class="hljs-number">2048</span> -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=<span class="hljs-number">0027</span> -Dignore.endorsed.dirs= -Dcatalina.base=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Dcatalina.home=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Djava.io.tmpdir=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/temp<br></code></pre></td></tr></table></figure><h4 id="📔jstat"><a href="#📔jstat" class="headerlink" title="📔jstat"></a>📔jstat</h4><p>jstat( JVM Statistics Monitoring Tool): 用于收集 HotSpot 虚拟机各方面的运行数据;</p><p>jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jstat -gc -h3 <span class="hljs-number">2903</span> <span class="hljs-number">1000</span> <span class="hljs-number">10</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br></code></pre></td></tr></table></figure><h4 id="📔jinfo"><a href="#📔jinfo" class="headerlink" title="📔jinfo"></a>📔jinfo</h4><p>jinfo (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Users\SnailClimb&gt;jinfo  -flag MaxHeapSize <span class="hljs-number">17340</span><br>-XX:MaxHeapSize=<span class="hljs-number">2124414976</span><br>C:\Users\SnailClimb&gt;jinfo  -flag PrintGC <span class="hljs-number">17340</span><br>-XX:-PrintGC<br></code></pre></td></tr></table></figure><h4 id="📔jmap-和-jhat"><a href="#📔jmap-和-jhat" class="headerlink" title="📔jmap 和 jhat"></a>📔jmap 和 jhat</h4><p>jmap (Memory Map for Java) :生成堆转储快照;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jmap -dump:format=b,file=elasticfoam.bin <span class="hljs-number">2903</span><br>Dumping heap to /usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/elasticfoam.bin ...<br>Heap dump file created<br></code></pre></td></tr></table></figure><p>jhat (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果;<br>与上面的jmap配合使用，分析heapdump的堆信息，会生成具体的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jhat elasticfoam.bin <br>Reading from elasticfoam.bin...<br>Dump file created Sat Nov <span class="hljs-number">07</span> <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">33</span> CST <span class="hljs-number">2020</span><br>Snapshot read, resolving...<br>Resolving <span class="hljs-number">131419</span> objects...<br>Chasing references, expect <span class="hljs-number">26</span> dots..........................<br>Eliminating duplicate references..........................<br>Snapshot resolved.<br>Started HTTP server on port <span class="hljs-number">7000</span><br>Server is ready.<br></code></pre></td></tr></table></figure><h4 id="📔jstack"><a href="#📔jstack" class="headerlink" title="📔jstack"></a>📔jstack</h4><p>jstack (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333e668</span> (object <span class="hljs-number">0x00000000d5efe1c0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 1&quot;</span><br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333be88</span> (object <span class="hljs-number">0x00000000d5efe1d0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 2&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">1</span>(DeadLockDemo.java:<span class="hljs-number">31</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">1078694789.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">0</span>(DeadLockDemo.java:<span class="hljs-number">16</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1324119927.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><p>一个linux的排除高CUP线程的排查案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">top -c <span class="hljs-comment">//查看所有进程</span><br>top -Hp <span class="hljs-title function_">xxx</span><span class="hljs-params">(PID)</span>  <span class="hljs-comment">// 查看进程具体的线程ID cup情况</span><br>jstack -l pid &gt; filename <span class="hljs-comment">// 输出当前快照</span><br>cat filename| grep <span class="hljs-string">&#x27;线程ID(16进制)&#x27;</span> -C <span class="hljs-number">8</span>     <span class="hljs-comment">// 查找匹配线程，-C 查看前后多少行数据</span><br></code></pre></td></tr></table></figure><h4 id="📔jconsole"><a href="#📔jconsole" class="headerlink" title="📔jconsole"></a>📔jconsole</h4><p>JConsole:Java 监视与管理控制台，很强大，可以检测死锁，查看堆的内存释放情况。</p><blockquote><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.rmi.server.hostname=外网访问 ip 地址 <br>-Dcom.sun.management.jmxremote.port=<span class="hljs-number">60001</span>   <span class="hljs-comment">//监控的端口号</span><br>-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>   <span class="hljs-comment">//关闭认证</span><br>-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="📓类文件"><a href="#📓类文件" class="headerlink" title="📓类文件"></a>📓类文件</h2><h3 id="📚类文件结构"><a href="#📚类文件结构" class="headerlink" title="📚类文件结构"></a>📚类文件结构</h3><p>方法体出现ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/synchronizeMethod.jpg" alt="avatar"></p><p>方法体对应的访问范围 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729362.jpeg" alt="avatar"></p><h3 id="📚双亲委派模型"><a href="#📚双亲委派模型" class="headerlink" title="📚双亲委派模型"></a>📚双亲委派模型</h3><p>站在虚拟机角度，只存在两种不同的类加载器：</p><ol><li>启动类加载器BootStrap ClassLoader，由虚拟机实现，是虚拟机自身一部分。</li><li>其他所有的类加载器，由Java语言实现，独立于虚拟机之外，都是继承自抽象类java.lang.ClassLoader。</li></ol><p>java相关的三层类加载器</p><ul><li>启动类加载器BootStrap ClassLoader：负责加载存放在<code>&lt;JAVA HOME&gt;\lib</code>目录，或者被<code>-Xbootclaspath</code>参数，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要交给引导类加载器去处理，那直接使用<code>null</code>替代即可。</li><li>扩展类加载器Extension ClassLoader：负责加载<code>&lt;JAVA HOME&gt;\lib\ext</code>目录，或者被<code>java.ext.dirs</code>系统变量所指定的目录中所有的类库。</li><li>应用程序类加载器Application ClassLoader：负责加载用户类路径ClassPath上所有的类库。</li></ul><p>双亲委派模型加载过程：</p><ol><li>如果一个类加载器接收到类加载请求，它首先不会自己尝试加载这个类，而是把请求委托到父类执行。</li><li>每一层次的类加载器都会委托其父类加载器去完成，最终传到最顶层的启动类加载器中。</li><li>只有当所有父加载器都无法自己完成这个类加载请求，子加载器才会进行加载。</li></ol><p><strong>作用</strong>：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器(Bootstrcp ClassLoader)加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729346.jpeg" alt="avatar"></p><p>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚双亲委派模型缺陷"><a href="#📚双亲委派模型缺陷" class="headerlink" title="📚双亲委派模型缺陷"></a>📚双亲委派模型缺陷</h3><p>双亲委派模型很好的解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的类加载器进行加载)<br>双亲委派模型检查类是否己经加载的委托过程是单向的，这种方式虽然从结构上说比较清楚，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。而且<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访应用类就会出现问题。</p></blockquote><p>解决方法：引入从线程上下文获取classLoader</p><h3 id="📚破坏双亲委派模型"><a href="#📚破坏双亲委派模型" class="headerlink" title="📚破坏双亲委派模型"></a>📚破坏双亲委派模型</h3><p>破坏双亲委派模型，就是要实现自己的ClassLoader重写loadClass，在方法中重写自己加载的逻辑。这样类加载过程中就不会通过委派父类加载的方式进行加载数据。</p><p>三次破坏双亲委派模型：</p><ol><li>第一次破坏。JDK1.2时期，双亲委派模型出现前，用户自定义了一些类加载器。在引入双亲委派模型，为了兼容用户自定义的类加载器，添加新的<code>findClass()</code>方法，并引导用户重写该方法，而不是重写<code>loadClass()</code>方法。</li><li>第二次破坏，为该模型的缺陷导致。父类加载器无法访问底层类加载器负责的类</li><li>第三次破坏，引入热部署的机制。违反双亲委派的类加载过程。</li></ol><h4 id="📔JDBC破坏双亲委派模型"><a href="#📔JDBC破坏双亲委派模型" class="headerlink" title="📔JDBC破坏双亲委派模型"></a>📔JDBC破坏双亲委派模型</h4><p>不破坏双亲委派模型的情况(不使用JNDI服务)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.加载数据访问驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">//2.连接到数据&quot;库&quot;上去</span><br>Connection conn= DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDBC需要破坏双亲委派模式：<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>原生的JDBC中的类是放在<strong>rt.jar包</strong>(对应由启用类加载器BootStrapClassLoader)的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。</p></blockquote><blockquote><p>在JDBC4.0以后，开始支持使用SPI(Service Provider Interface)的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF&#x2F;services&#x2F;java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用如下：<br><code>Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;, &quot;root&quot;, &quot;&quot;);</code></p></blockquote><p>如何解决父加载器无法加载子级类加载器路径中的类？</p><blockquote><p>引入线程上下文件类加载器(Thread Context ClassLoader).在mysql jdbc连接中获取当前的类加载器，这就破坏的双亲委派的类加载过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(</span><br><span class="hljs-params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * When callerCl is null, we should check the application&#x27;s</span><br><span class="hljs-comment">     * (which is invoking this class indirectly)</span><br><span class="hljs-comment">     * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="hljs-comment">     * can be loaded from here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//callerCL为空的时候，其实说明这个ClassLoader是启动类加载器，但是这个启动类加载并不能识别rt.jar之外的类，这个时候就把callerCL赋值为Thread.currentThread().getContextClassLoader();也就是应用程序启动类</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">callerCL</span> <span class="hljs-operator">=</span> caller != <span class="hljs-literal">null</span> ? caller.getClassLoader() : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span>(DriverManager.class) &#123;<br>        <span class="hljs-comment">// synchronize loading of the correct classloader.</span><br>        <span class="hljs-keyword">if</span> (callerCL == <span class="hljs-literal">null</span>) &#123;<br>            callerCL = Thread.currentThread().getContextClassLoader();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="📔自定义类加载器"><a href="#📔自定义类加载器" class="headerlink" title="📔自定义类加载器"></a>📔自定义类加载器</h4><ol><li>加载非classpath下的类，从非标准的来源加载代码</li><li>加载加密过的类文件，使用秘钥进行解密。</li><li>热部署，简单粗暴的方法是自定义类加载器，加载目录外的类对象。使用定时任务或者触发起的方法，每次创建新的类加载器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> String classPath;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(String classPath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.classPath = classPath;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>        name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(classPath + <span class="hljs-string">&quot;/&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> fis.available();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>        fis.read(data);<br>        fis.close();<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            data = loadByte(name);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚类初始化的时机"><a href="#📚类初始化的时机" class="headerlink" title="📚类初始化的时机"></a>📚类初始化的时机</h3><p>虚拟机严格规范了有且只有6种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code> 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li></ol><ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行<code>getstatic</code>指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行<code>putstatic</code>指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行<code>invokestatic</code>指令时会初始化类。即程序调用类的静态方法。</li></ul><ol><li>使用 java.lang.reflect 包的方法对类进行反射调用时如<code>Class.forname(&quot;...&quot;).newInstance()</code>等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用<code>findStaticVarHandle</code>来初始化要调用的类。</li><li>当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="📚类的生命周期"><a href="#📚类的生命周期" class="headerlink" title="📚类的生命周期"></a>📚类的生命周期</h3><p>类的生命周期： 加载、连接[验证、准备、解析]、初始化、使用、卸载。</p><h4 id="📔加载"><a href="#📔加载" class="headerlink" title="📔加载"></a>📔加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><h4 id="📔验证"><a href="#📔验证" class="headerlink" title="📔验证"></a>📔验证</h4><p>验证的范围：文件格式、元数据、字节码、符号引用验证</p><h4 id="📔准备"><a href="#📔准备" class="headerlink" title="📔准备"></a>📔准备</h4><p>准备阶段是正式为类变量(即静态变量)分配内存并设置类变量初始值的阶段，jdk8中这些内存都将在java堆中分配。对于该阶段有以下几点需要注意：</p><ul><li>进行内存分配的仅包括类变量(static)，而不包括实例变量</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值(如0、0L、null、false等)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器&lt;client&gt;方法之中</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080</span><br><br></code></pre></td></tr></table></figure><h4 id="📔解析"><a href="#📔解析" class="headerlink" title="📔解析"></a>📔解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>以方法解析为例：</p><ol><li>解析出方法表的class_index项中索引的方法所属的类或接口的符号引用。</li><li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果存在返回直接引用。</li><li>同上在类C的父类查找直接引用。</li><li>上述简述了类的查找，具体细节见书本。返回直接引用后，会验证方法的访问权限，即<code>private、protected、public</code>，如果发现不具备方法的访问级别，抛出<code>IllegalAccessError</code>异常。</li></ol><h4 id="📔初始化"><a href="#📔初始化" class="headerlink" title="📔初始化"></a>📔初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤，这个阶段Java虚拟机才开始真正执行类中编写的java程序，将主导权移交给应用程序。</p><p>在准备阶段已经赋初始化零值的变量，在初始化阶段，会根据程序去初始化类变量和其他资源。<br>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。该方法是由编译器收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。</p><h4 id="📔卸载"><a href="#📔卸载" class="headerlink" title="📔卸载"></a>📔卸载</h4><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ul><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ul><h2 id="📓对象创建及使用"><a href="#📓对象创建及使用" class="headerlink" title="📓对象创建及使用"></a>📓对象创建及使用</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/objcreate.jpg" alt="avatar"></p><p>对象的创建</p><ol><li>类加载检查：虚拟机遇到new命令，先检查是否能在常量池定位到一个类的引用，检查这个符号代表的类是否已被加载、解析和初始化过。</li><li>分配内存：检查通过，在java堆中分配对象内存，具体看对象的内存分配。</li><li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</li><li>设置对象头：进行对象的必要设置如那个类的示例、hashcode、GC分代年龄等信息，这些信息存放在对象头中。</li><li>上述工作完成之后，java开始调用对象的构造函数。</li></ol><h2 id="📓对象分配内存的方式"><a href="#📓对象分配内存的方式" class="headerlink" title="📓对象分配内存的方式"></a>📓对象分配内存的方式</h2><ul><li>规整空间：指针碰撞，整理过内存用一个指针标记内存使用过的范围，后序分配内存只需要移动指针，仅把指针向空闲空间移动一段与对象大小相等的距离。</li><li>碎片空间：空闲链表(free list)，通过额外的维护的列表存储记录空闲的地址，将随机IO变为顺序IO，但带来了额外的空间消耗。</li></ul><blockquote><p>使用Serial、ParNew等带压缩过程的垃圾回收器，使用指针分配算法。而CMS这种基于清除的算法理论上使用空闲链表的方式分配。</p></blockquote><p>对象分配内存并发控制(<strong>内存分配并发解决方案</strong>)：</p><ul><li>CAS+失败重试</li><li>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB) ，每个线程在Java堆中预先分配一小块内存，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li></ul><h2 id="📓对象内存分布"><a href="#📓对象内存分布" class="headerlink" title="📓对象内存分布"></a>📓对象内存分布</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729670.jpeg" alt="avatar"></p><p>对象在堆内存中的存储布局可以分为三部分：对象头、实例数据(对象有效信息)和对齐填充(仅起占位符作用)\</p><p>Hotspot的对象头包括两部分信息：</p><ol><li>第一部分：存储对象自身的运行数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。</li><li>第二部分：类型指针，即对象指向它的类型愿数据的指针。</li></ol><h2 id="📓对象的访问"><a href="#📓对象的访问" class="headerlink" title="📓对象的访问"></a>📓对象的访问</h2><p>定义：java程序会通过栈上的reference数据来操作堆上的具体对象。具体的对象访问方式由虚拟机决定，主要有两种使用句柄和直接指针两种。</p><ul><li>使用句柄访问的话，java堆会划分一块内存作为句柄池。引用会指向句柄，而句柄中分为两块指针，一个是指向对象实例的指针，一个是指向对象类型数据的指针(指向方法区)。好处为整理内存是只需要整理实例的指针。</li><li>直接指针访问，引用直接指向堆中的对象实例，而对象实例中包含数据的类型数据的指针(指向方法区)，好处为减少了指向实例的时间定为开销。</li></ul><blockquote><p>HotSpot虚拟机主要使用第二种方式进行访问。</p></blockquote><h2 id="📓对象引用"><a href="#📓对象引用" class="headerlink" title="📓对象引用"></a>📓对象引用</h2><ul><li>强引用(Strongly Reference): Object obj &#x3D; new Object()。关系存在虚拟机就不会回收。</li><li>软引用(Soft Reference)：用来描述一些还有用但非必须的对象。在系统要发生内存溢出会收集软引用对象，若回收完成仍内存不足，才抛出内存异常。软引用可用于实现内存敏感缓存，其中内存管理是一个非常重要的因素。</li><li>弱引用(Weak Reference)：弱引用关联的对象只能生存到下一次垃圾收集发生为止。</li><li>虚引用(Phantom Reference)：最弱的引用，意义为一个对象设置虚引用关联的唯一目的是为了在该对象被收集时得到一个通知。</li></ul><p>对象死亡的调用，任何一个对象都会被系统调用一次，如果对象下一次面临回收它的finalize()不会再执行。</p><ul><li>Soft References in Java</li><li>Weak References in Java</li><li>Phantom References in Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent);<br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent, referenceQueue);<br><br>        referent = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent2</span> <span class="hljs-operator">=</span> weakReference1.get();<br>        System.out.println(<span class="hljs-string">&quot;after gc, reference get result: &quot;</span> + referent2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        List&lt;LargeObjectFinalizer&gt; references = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Object&gt; largeObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">largeObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            largeObjects.add(largeObject);<br>            references.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LargeObjectFinalizer</span>(largeObject, referenceQueue));<br>        &#125;<br><br>        largeObjects = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        Reference&lt;?&gt; referenceFromQueue;<br>        <span class="hljs-keyword">for</span> (PhantomReference&lt;Object&gt; reference : references) &#123;<br>            System.out.println(reference.isEnqueued());<br>            <span class="hljs-comment">// 此处获取为空</span><br>            System.out.println(<span class="hljs-string">&quot;get result&quot;</span> + reference.get());<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> ((referenceFromQueue = referenceQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            ((LargeObjectFinalizer)referenceFromQueue).finalizeResources();<br>            referenceFromQueue.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObjectFinalizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LargeObjectFinalizer</span><span class="hljs-params">(</span><br><span class="hljs-params">            Object referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> Object&gt; q)</span> &#123;<br>        <span class="hljs-built_in">super</span>(referent, q);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalizeResources</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// free resources</span><br>        System.out.println(<span class="hljs-string">&quot;clearing ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓栈上分配"><a href="#📓栈上分配" class="headerlink" title="📓栈上分配"></a>📓栈上分配</h2><p>栈上分配是Java虚拟机的一项优化技术，基本思想是对于那些线程私有的对象(指不能被其他线程访问到的对象)，可以把他们打散分配在栈上，而不是分配在堆上。</p><blockquote><p>分配在对象上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能</p></blockquote><h3 id="📚逃逸分析"><a href="#📚逃逸分析" class="headerlink" title="📚逃逸分析"></a>📚逃逸分析</h3><p>逃逸分析是编译语言中的一种优化分析，而不是一种优化的手段。通过对象的作用范围的分析，为其他优化手段提供分析数据从而进行优化。</p><blockquote><p>目的是判断对象的作用域是否可能逃逸出函数体</p></blockquote><p>对象逃逸的三种类型：</p><ol><li><code>GlobalEscape</code>: 对象逃逸出方法或线程，如静态对象、对象作为方法的返回值、是已确认为逃逸对象的对象字段等</li><li><code>ArgEscape</code>: 对象作为方法调用的参数，传递引用给方法，但是在调用过程中不是全局逃逸对象。</li><li><code>NoEscape</code>: 可以标量替换的对象。</li></ol><blockquote><p>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量(如：int，long等基本数据类型以及reference类型等)</p></blockquote><h3 id="📚标量替换"><a href="#📚标量替换" class="headerlink" title="📚标量替换"></a>📚标量替换</h3><p>标量可以理解成一种不可分解的变量，如java内部的基本数据类型、引用类型等。 与之对应的聚合量是可以被拆解的，如对象。</p><p>当通过逃逸分析一个对象只会作用于方法内部，虚拟机可以通过使用标量替换来进行优化。</p><h3 id="📚应用"><a href="#📚应用" class="headerlink" title="📚应用"></a>📚应用</h3><ul><li><code>-XX:+DoEscapeAnalysis</code>：用于开启逃逸分析</li><li><code>-XX:+EliminateAllocations</code>：用于开启标量替换，允许将对象打散分配在栈上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnStackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        u.id = <span class="hljs-number">5</span>;<br>        u.name = <span class="hljs-string">&quot;geym&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(e-b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果关闭逃逸分析或者标量替换的任何一个，再次执行程序就会看到大量的GC日志，说明栈上分配依赖逃逸分析和标亮替换的实现。</p><h2 id="📓TLAB"><a href="#📓TLAB" class="headerlink" title="📓TLAB"></a>📓TLAB</h2><p>TLAB，全称Thread Local Allocation Buffer, 即：线程本地分配缓存。这是一块线程专用的内存分配区域。TLAB占用的是eden区的空间。在TLAB启用的情况下(默认开启)，JVM会为每一个线程分配一块TLAB区域。</p><p>为什么需要TLAB？ 这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须<strong>线程同步</strong>，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。</p><p>局限性： TLAB空间一般不会太大(占用eden区)，所以大对象无法进行TLAB分配，只能直接分配到堆上。</p><p>分配策略：<br>一个100KB的TLAB区域，如果已经使用了80KB，当需要分配一个30KB的对象时，TLAB是如何分配的呢？ 此时，虚拟机有两种选择：第一，废弃当前的TLAB(会浪费20KB的空间)；第二，将这个30KB的对象直接分配到堆上，保留当前TLAB(当有小于20KB的对象请求TLAB分配时可以直接使用该TLAB区域)。 JVM选择的策略是：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，若小于refill_waste值，则会废弃当前TLAB，新建TLAB来分配新对象。</p><blockquote><p>【默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使系统的运行状态达到最优。】</p></blockquote><table><thead><tr><th>参数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>-XX:+UseTLAB</td><td>启用TLAB</td><td>默认启用</td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>设置允许空间浪费的比例</td><td>默认值：64，即：使用1&#x2F;64的TLAB空间大小作为refill_waste值</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁止系统自动调整TLAB大小</td><td></td></tr><tr><td>-XX:TLABSize</td><td>指定TLAB大小</td><td>单位：B</td></tr></tbody></table><h2 id="📓对象内存分配流程"><a href="#📓对象内存分配流程" class="headerlink" title="📓对象内存分配流程"></a>📓对象内存分配流程</h2><p>java对象分配流程</p><ol><li>首先运行栈上分配。编译器通过逃逸分析及标量替换，决定对象应该分配在栈上还是堆中。如果逃逸分析及标量替换其中一个未启用，则直接分配在堆中。如果决定分配在堆中，那么执行步骤2</li><li>进行TLAB分配。如果TLAB的空间<code>TALB_TOP+SIZE &lt;= TLAB_END</code>，对象可以直接分配在TLAB中，那么<code>TLAB_TOP</code>加上对象<code>SIZE</code>进行位置移动。若不能执行步骤3</li><li>重新申请一块TALB，并尝试存储对象。若对象过大仍无法存储在TLAB中，执行步骤4</li><li>判断是否满足进入老年代的条件(<code>PretenureSizeThreshold</code>参数)，若满足直接进入老年代，不满足进行新声代分配</li><li>将对象存储在新声代<code>Eden</code>中，<code>EDEN_TOP</code>指针移位。若新声代无法存储对象，执行<code>Young GC</code>，并尝试重新分配对象。</li><li><code>Young GC</code> 后重新分配对象，若仍然无法分配。对象直接进入老年代。</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/object-alloc.png" alt="image"></p><h2 id="📓JDK编译期"><a href="#📓JDK编译期" class="headerlink" title="📓JDK编译期"></a>📓JDK编译期</h2><h3 id="📚编译期做的工作"><a href="#📚编译期做的工作" class="headerlink" title="📚编译期做的工作"></a>📚编译期做的工作</h3><ol><li>默认构造器： 经过编译的代码,可以看到在编译阶段，如果我们没有添加构造器。那么Java编译器会为我们添加一个无参构造方法。</li><li>自动拆装箱</li><li>泛型与类型擦除</li><li>foreach优化成Iterator</li><li><code>String... args</code> 可变参数优化</li><li>switch支持case使用字符串及枚举类型优化，优化成hashcode匹配。</li><li>枚举，优化成final class</li><li>try-with-resources 优化，自动在finally中加入close语句</li><li>重写的优化，子类重写方法中会新增一个桥接方法。</li><li>匿名内部类：生成final 修饰的类</li></ol><h2 id="📓堆内存的设置要点"><a href="#📓堆内存的设置要点" class="headerlink" title="📓堆内存的设置要点"></a>📓堆内存的设置要点</h2><ol><li>新生代的内存大小设置建议：Sun官方推荐配置为整个堆的3&#x2F;8。</li><li>服务器的内存需要预留一部分给永久代、线程栈及NIO</li></ol><p>内存分配问题: 省略比较小的区域，可以总结JVM占用的内存：</p><blockquote><p>JVM内存 ≈ Java永久代 ＋ Java堆(新生代和老年代) ＋ 线程栈＋ Java NIO</p></blockquote><p>假设原来的内存分配是：6G(java堆) ＋ 600M(监控) ＋ 800M(系统)，剩余大约600m内存未分配。</p><p>现在分析这600M内存的分配情况：</p><ol><li>Linux保留大约200M，这部分是Linux正常运行的需要，</li><li>Java服务的线程数量是160个，JVM默认的线程栈大小是1M，因此使用160M内存，</li><li>Java NIO buffer，通过JMX查到最多占用了200m，</li><li>Java服务使用NIO大量读写文件，需要使用PageCache，正如前面分析，这个暂时不好定量估算大小。 前三项加起来已经560M，因此可以断定Linux物理内存不够使用。</li></ol><p>以下是sun公司的性能优化白皮书中提到的几个例子： 1．对于吞吐量的调优。机器配置：4G的内存，32个线程并发能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> <br><br>-Xmx3800m -Xms3800m 配置了最大Java Heap来充分利用系统内存。 <br>-Xmn2g 创建足够大的青年代(可以并行被回收)充分利用系统内存，防止将短期对象复制到老年代。 <br>-Xss128 减少默认最大的线程栈大小，提供更多的处理虚拟内存地址空间被进程使用。 <br>-XX:+UseParallelGC 采用并行垃圾收集器对年青代的内存进行收集，提高效率。 <br>-XX:ParallelGCThreads=<span class="hljs-number">20</span> 减少垃圾收集线程，默认是和服务器可支持的线程最大并发数相同，往往不需要配置到最大值。 <br></code></pre></td></tr></table></figure><p>2．尝试采用对老年代并行收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseParallelOldGC <br><br>-Xmx3550m -Xms3550m 内存分配被减小，因为ParallelOldGC会增加对于Native Heap的需求，因此需要减小Java Heap来满足需求。 <br>-XX:+UseParallelOldGC 采用对于老年代并发收集的策略，可以提高收集效率。 <br></code></pre></td></tr></table></figure><p>3．提高吞吐量，减少应用停顿时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:TargetSurvivorRatio=<span class="hljs-number">90</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> <br><br>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC 选择了并发标记交换收集器，它可以并发执行收集操作，降低应用停止时间，同时它也是并行处理模式，可以有效地利用多处理器的系统的多进程处理。 <br>-XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> 表示在青年代中Eden和Survivor比例，设置增加了Survivor的大小，越大的survivor空间可以允许短期对象尽量在年青代消亡。 <br>-XX:TargetSurvivorRatio=<span class="hljs-number">90</span> 允许<span class="hljs-number">90</span>%的空间被占用，超过默认的<span class="hljs-number">50</span>%，提高对于survivor的使用率。<br></code></pre></td></tr></table></figure><h2 id="📓CMS-ParNew收集器的流程梳理"><a href="#📓CMS-ParNew收集器的流程梳理" class="headerlink" title="📓CMS + ParNew收集器的流程梳理"></a>📓CMS + ParNew收集器的流程梳理</h2><h3 id="📚young区域-年轻代"><a href="#📚young区域-年轻代" class="headerlink" title="📚young区域(年轻代)"></a>📚young区域(年轻代)</h3><ol><li>对象首先分配到Eden，分配满了触发Young Gc(Minor Gc)，基于复制交换算法，晋升对象年龄+1。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></a></li><li>年龄到达老年代门槛的晋升老年代。<ul><li>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</li><li>晋升失败触发FULL GC的两种场景：<ol><li>空间分配担保失败：在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。</li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</li></ol></li></ul></li></ol><p>特殊：</p><ol><li><p>大对象通过直接进入老年代。</p></li><li><p>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保：当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域(实际上大多数情况下就是老年代) 进行分配担保，survior区无法容纳的对象直接晋升到老年代。。</p><blockquote><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 - XX:HandlePromotionFailure 参数的设置值是否允许担保失败 (Handle Promotion Failure)；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次 Full GC。</p></blockquote></li></ol><h3 id="📚old区域-老年代"><a href="#📚old区域-老年代" class="headerlink" title="📚old区域(老年代)"></a>📚old区域(老年代)</h3><h4 id="📔CMS-GC原因"><a href="#📔CMS-GC原因" class="headerlink" title="📔CMS GC原因"></a>📔CMS GC原因</h4><p>触发 CMS GC有：</p><ol><li>Old 区达到回收阈值</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败</li><li>扩容缩容</li><li>显式调用System.gc</li><li>并发模式失败(浮动垃圾导致)</li></ol><h4 id="📔CMS-GC-垃圾回收模式"><a href="#📔CMS-GC-垃圾回收模式" class="headerlink" title="📔CMS GC 垃圾回收模式"></a>📔CMS GC 垃圾回收模式</h4><p>CMS GC 的垃圾回收共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>CMS 在Background回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><h4 id="📔其他老年代问题"><a href="#📔其他老年代问题" class="headerlink" title="📔其他老年代问题"></a>📔其他老年代问题</h4><p>CMS 无法处理浮动垃圾(Floating Garbage)。CMS 的并发清理阶段，应用还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p><h2 id="📓Java虚拟机内存调优"><a href="#📓Java虚拟机内存调优" class="headerlink" title="📓Java虚拟机内存调优"></a>📓Java虚拟机内存调优</h2><p>jdk1.8前的参数设置 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729631.jpeg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/jvmGCType.jpg" alt="avatar"></p><h3 id="📚基本概念重述"><a href="#📚基本概念重述" class="headerlink" title="📚基本概念重述"></a>📚基本概念重述</h3><p>跨代引用解决方案</p><p>Card Table：中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。</p><p>内存分配</p><ol><li><strong>TLAB</strong>：Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li><li>CAS+失败重试</li></ol><p>Mutator：生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。</p><h4 id="📔工具整理"><a href="#📔工具整理" class="headerlink" title="📔工具整理"></a>📔工具整理</h4><h5 id="🏷命令行终端"><a href="#🏷命令行终端" class="headerlink" title="🏷命令行终端"></a>🏷命令行终端</h5><p>标准终端类：jps、jinfo、jstat、jstack、jmap</p><p>功能整合类：jcmd、vjtools、arthas、greys</p><h5 id="🏷可视化界面"><a href="#🏷可视化界面" class="headerlink" title="🏷可视化界面"></a>🏷可视化界面</h5><p>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</p><p>进阶：MAT、JProfiler</p><p>命令行推荐 Arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy、heaphero、fastthread ，美团内部的 Scalpel(一款自研的 JVM 问题诊断工具，暂时未开源)也比较好用。</p><h3 id="📚GC-调优目的"><a href="#📚GC-调优目的" class="headerlink" title="📚GC 调优目的"></a>📚GC 调优目的</h3><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h3 id="📚GC-调优策略"><a href="#📚GC-调优策略" class="headerlink" title="📚GC 调优策略"></a>📚GC 调优策略</h3><p><strong>策略 1</strong>：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2</strong>：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代(当然短命的大对象对于垃圾回收来说简直就是噩梦)。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3</strong>：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><blockquote><p>为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区(年龄是可以调的，默认是15)hotspots的markword的图中，用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。</p></blockquote><p><strong>策略 4</strong>：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。</p><p><strong>策略5</strong>：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：</p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote><h3 id="📚调优指标"><a href="#📚调优指标" class="headerlink" title="📚调优指标"></a>📚调优指标</h3><ul><li>延迟(Latency)：也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li>吞吐量(Throughput)：应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><h3 id="📚问题排查思路"><a href="#📚问题排查思路" class="headerlink" title="📚问题排查思路"></a>📚问题排查思路</h3><p>四种分析思路</p><ul><li><strong>时序分析</strong>：先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高(要有足够的时间 Gap)，那么整个问题影响链就可能是：</li></ul><blockquote><p>CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程Block增多 -&gt; RT 上涨。</p></blockquote><ul><li><strong>概率分析</strong>：使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：</li></ul><blockquote><p>慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨。</p></blockquote><ul><li><strong>实验分析</strong>：通过故障演练等方式对问题现场进行模拟，触发其中部分条件(一个或多个)，观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨。</p></blockquote><ul><li><strong>反证分析</strong>：对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨。</p></blockquote><h3 id="📚案例"><a href="#📚案例" class="headerlink" title="📚案例"></a>📚案例</h3><h4 id="📔美团技术案例-基于CMS-JDK1-8"><a href="#📔美团技术案例-基于CMS-JDK1-8" class="headerlink" title="📔美团技术案例(基于CMS JDK1.8)"></a>📔美团技术案例(基于CMS JDK1.8)</h4><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/gcProcess.jpg"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729841.jpeg" alt="avatar"></a></p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/localIssue.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729263.png" alt="avatar"></a></p><p><strong>场景一：动态扩容引起的空间震荡</strong></p><p>服务刚刚启动时 GC 次数较多，最大空间剩余很多但是依然发生 GC， GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整。</p><p>解决：尽量将成对出现的空间大小配置参数设置成固定的，</p><blockquote><p>如 -Xms 和 -Xmx，-XX:MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 等。</p></blockquote><p>策略：保证 Java 虚拟机的堆是稳定的，避免弹性伸缩带来的额外 GC 消耗，确保 -Xms 和 -Xmx 设置的是一个值(即初始值和最大值一致)，获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题</p><blockquote><p>在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。</p></blockquote><hr><p><strong>场景二：显式 GC 的去与留 (System.gc)</strong></p><p>除了扩容缩容会触发 CMS GC 之外，还有</p><ol><li>Old 区达到回收阈值.</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败等几种触发条件</li></ol><p>如果以上均不是GC发生的原因，那么就是代码中调用了 <code>System.gc </code>方法。</p><p>增加 -XX:+DisableExplicitGC 参数后，<code>System.gc </code>这个方法变成了一个空方法</p><p>CMS GC 共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>保留 <code>System.gc</code>：在显示触发System.gc会使用Foreground模式对Old区域进行垃圾收集造成，长时间的STW。<br>去掉 <code>System.gc</code>：DirectByteBuffer直接内存在分配空间会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory。若禁用<code>System.gc</code>，会导致已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放，于是就有发生 Direct Memory 的 OOM。</p><blockquote><p>-XX:+DisableExplicitGC 可以用于禁用System.gc</p></blockquote><p><strong>策略</strong>: 因为DirectByteBuffer经常用于Netty 等各种 NIO 框架使用，所以不应该去除<code>System.gc</code>，可以使用参数改变System.gc的触发类型为Background，该模式也会触发old的DirectByteMemory 的清理工作。</p><blockquote><p>-XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background<br>不止 CMS，在 G1 或 ZGC中开启 ExplicitGCInvokesConcurrent 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。</p></blockquote><hr><p><strong>场景三：MetaSpace 区 OOM</strong></p><p>现象：JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p><p>MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p><ul><li><strong>Klass MetaSpace</strong>：就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构. 这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</li><li><strong>NoKlass MetaSpace</strong>：专门来存 Klass 相关的其他的内容，比如 Method，<strong>ConstantPool</strong> 常量池等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容。</li></ul><p>MetaSpace 内存管理：类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的<br>MetaSpace 弹性伸缩：由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize</p><p>问题原因：为了避免弹性伸缩带来的额外 GC 消耗，我们会将 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。</p><blockquote><p>经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。</p></blockquote><p>策略： 给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p><p><strong>场景四：过早晋升</strong></p><p>现象：</p><ol><li>分配速率接近于晋升速率，对象晋升年龄较小</li><li>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大。</li></ol><p>原因：</p><ol><li>Young&#x2F;Eden 区过小：过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升， copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间</li><li>分配速率过大：可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</li></ol><p>设定固定的 MaxTenuringThreshold 值作为晋升条件：</p><ul><li>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生。Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</li><li>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</li></ul><blockquote><p>未设置情况，Hotspot 会使用动态计算的方式来调整晋升的阈值：<br>Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值(TargetSurvivorRatio &#x2F; 100，TargetSurvivorRatio 默认值为 50)进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费。</p></blockquote><p>策略：</p><ol><li>Young&#x2F;Eden 区过小：调整堆分区内存，一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。 如何设置Survivor面积，可以自己推算。</li><li>分配速率过大：<ul><li>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</li><li>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</li></ul></li></ol><hr><p><strong>场景五：CMS Old GC 频繁</strong></p><p>现象：Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。</p><blockquote><p>描述过于抽象，见文章</p></blockquote><hr><p><strong>场景六：单次 CMS Old GC 耗时长</strong></p><p>CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table 遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>由上述过程可以推断，大部分出问题的耗时都是出现在最终标记中。处理思路如下：</p><ol><li><p>分析Reference 处理和元数据处理 real 耗时是否正常，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段。</p></li><li><p>需要通过</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintReferenceGC</span><br></code></pre></td></tr></table></figure><p>参数开启。基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注</p><ul><li>对 FinalReference 的分析: 经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。</li><li><code>scrub symbol table</code> 表示清理元数据符号引用耗时，观察 MetaSpace 区的历史使用峰值，看是否有使用动态类加载或者 DSL 处理等。 如果MateSpace 数据没啥变化，可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理。</li></ul></li></ol><hr><p><strong>场景七：内存碎片&amp;收集器退化</strong></p><p>现象： 并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><p>原因：</p><ol><li><p>晋升失败：</p><ol><li>在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。 <strong>发生的条件是很苛刻</strong></li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。<ul><li>碎片空间问题-空间分配效率较低：连续空间使用指针碰撞，而有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问</li><li>碎片空间问题-空间利用效率变低: Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象</li></ul></li></ol></li><li><p>增量收集担保失败: 分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小,，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之不安全，进行FULL GC。</p></li><li><p>显式 GC： System.gc</p></li><li><p>并发模式失败(Concurrent Mode Failure):在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p><blockquote><p>概率较高，主要是由于 CMS 无法处理浮动垃圾(Floating Garbage)引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p></blockquote></li></ol><p>策略</p><ul><li>内存碎片：通过配置 -XX:UseCMSCompactAtFullCollection&#x3D;true 来控制 Full GC的过程中是否进行空间的整理(默认开启，注意是Full GC，不是普通CMS GC)，以及 -XX: CMSFullGCsBeforeCompaction&#x3D;n 来控制多少次 Full GC 后进行一次压缩。</li><li>增量收集：降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</li><li>浮动垃圾：视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</li></ul><hr><p><strong>场景八：堆外内存 OOM</strong></p><p>现象： 内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java 进程的 RES 甚至超过了 -Xmx 的大小。</p><p>JVM 的堆外内存泄漏，主要有两种的原因：</p><ol><li>通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。</li><li>代码中有通过 JNI 调用 Native Code 申请的内存没有释放。</li></ol><p>策略：在项目中添加 -XX:NativeMemoryTracking&#x3D;detail JVM参数后重启项目(需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗)。使用命令 jcmd pid VM.native_memory detail 查看内存分布。</p><p><strong>场景九：JNI 引发的 GC 问题</strong></p><blockquote><p>太抽象了</p></blockquote><h4 id="📔不恰当的数据结构导致内存过大"><a href="#📔不恰当的数据结构导致内存过大" class="headerlink" title="📔不恰当的数据结构导致内存过大"></a>📔不恰当的数据结构导致内存过大</h4><p>场景：-Xms4g -Xmx8g -Xmn1g 使用ParNew + CMS组合。业务上需要10min加载80MB的数据到内存，会产生100W HashMap entry， Minor GC超过500ms，因为新生代使用了标记复制算法\</p><p>方案：不从修改程序，仅从GC调优，可以直接去掉SurvivorRatio，让新生代存活的对象一次Minor GC就进入到老年代<code> -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0</code>(或者-XX:+AlwaysTenure)</p><h4 id="📔堆外内存导致溢出错误"><a href="#📔堆外内存导致溢出错误" class="headerlink" title="📔堆外内存导致溢出错误"></a>📔堆外内存导致溢出错误</h4><p>NIO使用直接内存复制，而虚拟机中最大最小内存直接设值成系统内存大小了</p><h4 id="📔异步系统Socket连接"><a href="#📔异步系统Socket连接" class="headerlink" title="📔异步系统Socket连接"></a>📔异步系统Socket连接</h4><p>Socket 使用BIO连接异步处理，导致了系统连接数过多，进而虚拟机崩溃</p><h4 id="📔Evosuite-自动生成单元测试"><a href="#📔Evosuite-自动生成单元测试" class="headerlink" title="📔Evosuite 自动生成单元测试"></a>📔Evosuite 自动生成单元测试</h4><p>表现：maven build时候单元测试需要一个多小时。</p><p>排查：</p><ol><li><code>jstat -gc pid</code> 结合日志观察GC情况。</li><li><code>jstack -l pid</code> 刷具体的运行线程。</li><li><code>jmap -heap pid</code> 导出堆的分配情况</li></ol><p>原因为Evosuite自动生成的test中存在：</p><ol><li>StringUtils的expend测试，延长字符串到1610613374长度。jdk8，String内部使用char数组。</li><li>调用Util类分配694225808 长度的ArrayList 数组空间，并分配元素。</li><li>死循环线程</li></ol><p>java进程垃圾回收器使用ParallelGC，新生代使用标记复制算法，老年代标记整理。 <code>s0：1g s1：3g eden：3g old：10g</code></p><p>结果： YGC出现大量复制工作，很耗费时间。每次分配的空间过大，经常需要FGC来分配空间。</p><p>解决处理：死循环线程、修改自动生成的test分配合理内存。</p><h4 id="📔其他建议"><a href="#📔其他建议" class="headerlink" title="📔其他建议"></a>📔其他建议</h4><ol><li><p>禁用偏向锁：偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。</p><blockquote><p>在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。</p></blockquote></li><li><p>主动式 GC： 观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC。必要时引入，会影响系统健壮性。</p></li><li><p>虚拟内存：启动初期有些操作系统(例如 Linux)并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。</p><blockquote><p>这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。</p></blockquote></li></ol><h2 id="📓JVM工具"><a href="#📓JVM工具" class="headerlink" title="📓JVM工具"></a>📓JVM工具</h2><ul><li><p>javac.exe是编译.java文件</p></li><li><p>java.exe是执行编译好的.class文件</p></li><li><p>javadoc.exe是生成Java说明文档</p></li><li><p>jdb.exe是Java调试器</p></li><li><p>javaprof.exe是剖析工具</p></li></ul><h2 id="📓JVM参数"><a href="#📓JVM参数" class="headerlink" title="📓JVM参数"></a>📓JVM参数</h2><p>常见配置汇总</p><h3 id="📚堆设置"><a href="#📚堆设置" class="headerlink" title="📚堆设置"></a>📚堆设置</h3><ul><li>-Xms:初始堆大小</li><li>-Xmx:最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><h3 id="📚收集器设置"><a href="#📚收集器设置" class="headerlink" title="📚收集器设置"></a>📚收集器设置</h3><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><h3 id="📚垃圾回收统计信息"><a href="#📚垃圾回收统计信息" class="headerlink" title="📚垃圾回收统计信息"></a>📚垃圾回收统计信息</h3><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h3 id="📚并行收集器设置"><a href="#📚并行收集器设置" class="headerlink" title="📚并行收集器设置"></a>📚并行收集器设置</h3><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</li></ul><h3 id="📚并发收集器设置"><a href="#📚并发收集器设置" class="headerlink" title="📚并发收集器设置"></a>📚并发收集器设置</h3><ul><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP</title>
    <link href="/2022/09/04/AOP/"/>
    <url>/2022/09/04/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote><p>AOP(Aspect Oriented Programming,面向切面编程)通过提供一种思考程序结构的方式来补充OOP(Object Oriented Programming,面向对象编程)。OOP模块化的关键单元是类，而在AOP中，模块化的单元是切面。切面可以实现跨多个类型和对像之间的事务管理、日志等方面的模块化。</p></blockquote><p>Spring框架中使用AOP主要有以下优势：</p><ul><li>提供声明式企业服务，特别是作为 EJB声明式服务的替代品。重要的是，这种服务是声明式事务管理。</li><li>允许用户实现自定义切面。在某些不适合用OOP编程的场景中，采用AOP来补充。</li><li>可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高开发效率。</li></ul><p>要使用Spring AOP 需要添加spring-aop 模块。</p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205052246547.png" alt="image-20220402110359545"></p><ul><li>Aspect（切面）：将关注点进行模块化。在Spring AOP中，切面可以使用常规类（基于模式的方法）或@Aspect注解的常规类来实现。</li><li>Join Point（连接点）：在程序执行过程中的某个特定的点。如某方法调用时或处理异常时。在Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>Advice（通知）：在七日面的某个特定的连接点上执行的动作。通知有各种类型，包括around、before和after等。许多AOP框架都是以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。</li><li>Pointcut（切入点）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（如当执行某个特定的方法时）。切入点表达式如何和连接点匹配是AOP的核心。Spring默认使用AspectJ切入点语法。</li><li>Introduction（引入）：声明额外的方法或某个类型的字段。Spring允许引入新的接口（及一个对应的实现）到任何被通知的对象。例如，可以使用一个引入来使bean实现IsModified接口，以便简化缓存机制。</li><li>Target Object（目标对象）：被一个或多个切面通知的对象。也有人把它称为Adviced（被通知）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个Proxied（被代理）对象。</li><li>AOP Proxy（AOP代理）：AOP框架创建的对象用来实现Aspect Contract（切面契约），包括通知方法执行等功能。在Spring中，AOP代理可以JDK动态代理或CGLIB代理。</li><li>Weaving（织入）：把切面连接到其他的应用程序类型或对象上，并创建一个Adviced （被通知）的对象。这些可以在编译时（如使用AspectJ编译器）、类加载时和运行完成时。</li></ul><h2 id="Advice（通知）类型"><a href="#Advice（通知）类型" class="headerlink" title="Advice（通知）类型"></a>Advice（通知）类型</h2><ul><li>Before Advice（前置通知）：在某连接点之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>After Returning Advice（返回后通知）：在某连接点正常完成后执行的通知，如果一个方法没有抛出异常，就正常返回。</li><li>After Throwing Advice（抛出异常后通知）：在方法抛出异常退出时执行的通知。</li><li>After （finally) Advice（最后通知）：当某连接点退出时执行的通知（不论是正常返回还是异常退出）。</li><li>Around Advice（环绕通知）：包围一个连接点的通知。如方法调用。这是很强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为，它也会选择是否继续执行连接点，或者直接返回它自己的返回值或抛出异常来结束执行。Around Advice是常用的一种通知类型。与AspectJ一样，Spring提供所有的类型的通知，推荐使用尽量简单的通知类型来实现需要的功能。例如，如果只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情，但最好使用After Returning通知，而不是使用环绕通知。用合适的通知类型可以使编程模型变得简单，并且能够避免很多潜在的错误。</li></ul><h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><p>Spring AOP默认使用标准的JDK动态代理，这样任何接口（或接口的set方法）都可以被代理。</p><p>Spring AOP也支持CGLIB代理，当需要代理类（而不是代理接口）时，CGLIB代理是很有必要的。如果一个业务对象并没有实现一个接口，就会默认使用CGLIB、</p>]]></content>
    
    
    <categories>
      
      <category>Spring MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令大全</title>
    <link href="/2022/09/04/Git/"/>
    <url>/2022/09/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p> <strong>一、创建与合并分支</strong> </p><p><strong>1、 从master分支创建dev分支并切换到dev分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout mastergit checkout -b dev<br></code></pre></td></tr></table></figure><p>其中，git checkout -b dev 等价于:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch devgit checkout dev<br></code></pre></td></tr></table></figure><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</p><p>（2）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  branch  -a<br></code></pre></td></tr></table></figure><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</p><p><strong>2、修改代码、提交代码（当前的操作是在dev分支上进行）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add a.html<br>git commit -m <span class="hljs-string">&quot;提交文件a.html&quot;</span><br></code></pre></td></tr></table></figure><p><strong>3、分支合并(将dev合并到master)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge dev<br></code></pre></td></tr></table></figure><p><strong>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d dev<br></code></pre></td></tr></table></figure><p><strong>5、删除后，查看分支(此时看不到dev分支了)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>6、总结 ：工作中经常从master创建新的分支，具体操作如下:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">master创建新分支：<br>git checkout master<br>git checkout -b  issues1234  // 从master分支创建issues1234分支<br>git push origin issues1234<br>git add ..<br>git commit -m <span class="hljs-string">&quot;***&quot;</span><br>git push origin issues1234<br></code></pre></td></tr></table></figure><blockquote><p>注意：将本地分支branch1推到远端的branch2操作步骤：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin branch1:branch2<br></code></pre></td></tr></table></figure><p><strong>7、删除分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D   issues1234  // 本地强制删除分支issues1234<br>git push origin  :issues1234  // 推到远程<br></code></pre></td></tr></table></figure><hr><p> <strong>二、解决冲突</strong> </p><p><strong>1、发生冲突的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></code></pre></td></tr></table></figure><p>其中，git使用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记文件中自己和别人产生冲突的部分。</p><p>在 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======</code>之间为自己的代码；&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p><strong>2、冲突解决后提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br>git add ***<br>git commit -m <span class="hljs-string">&quot;fix conflict&quot;</span><br>git push origin 分支名<br></code></pre></td></tr></table></figure><hr><p> <strong>三、Bug分支</strong> </p><p><strong>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p><strong>2、恢复储藏的代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop // 恢复的同时把stash内容删掉<br></code></pre></td></tr></table></figure><p>或者<img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181623625.png" alt="图片"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：git stash apply stash@&#123;0&#125;<br>git stash apply  // 恢复stash，但是stash内容并不删除<br>git stash drop // 在上面操作的基础上，以此来删除stash<br>注： git stash list // 查看全部的stash列表<br></code></pre></td></tr></table></figure><p><strong>3、将stash空间清空</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash clear<br></code></pre></td></tr></table></figure><p><strong>4、git stash pop 和 git stash apply 区别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">原来git stash pop stash@&#123;<span class="hljs-built_in">id</span>&#125;命令会在执行后将对应的stash <span class="hljs-built_in">id</span> 从stash list里删除，而 git stash apply stash@&#123;<span class="hljs-built_in">id</span>&#125; 命令则会继续保存stash <span class="hljs-built_in">id</span>。<br></code></pre></td></tr></table></figure><hr><p> <strong>四、版本回退</strong> </p><p><strong>1、回退至上一个版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD<br></code></pre></td></tr></table></figure><p><strong>2、回退至指定版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard  版本号<br></code></pre></td></tr></table></figure><p><strong>3、查看以往版本号(本地的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><p><strong>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><hr><p> <strong>五、撤销修改</strong> </p><p><strong>1、撤销修改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  checkout -- a.html<br></code></pre></td></tr></table></figure><blockquote><p>分两种情况分析：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。<br>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态<br></code></pre></td></tr></table></figure><blockquote><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p></blockquote><p><strong>2、撤销新建文件</strong></p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f ../aa.html<br></code></pre></td></tr></table></figure><p><strong>3、撤销新建文件夹</strong></p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -<span class="hljs-built_in">df</span> ./demo<br></code></pre></td></tr></table></figure><hr><p> <strong>六、对已push版本进行回退</strong> </p><p><strong>1、第一步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 版本号 // 本地回退到指定的版本<br></code></pre></td></tr></table></figure><p><strong>2、第二步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push  -f origin dev    //将远程的也回退到指定版本<br></code></pre></td></tr></table></figure><hr><p> <strong>七、本地同步远程删除的分支</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin -p  // 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了<br></code></pre></td></tr></table></figure><hr><p> <strong>八、删掉未与远程分支对应的本地分支</strong> </p><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch -p<br></code></pre></td></tr></table></figure><hr><p> <strong>九、查看远程库与本地分支的信息</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote show origin<br></code></pre></td></tr></table></figure><hr><p> <strong>十、标签管理</strong> </p><p><strong>1、给当前分支最新commit打标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0<br></code></pre></td></tr></table></figure><p><strong>2、比如现在周五，要给周一某个commit打标签，应执行以下步骤：</strong></p><p>（1）、查看log日志，找到相应的commit版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline --abbrev-commit<br>// 显示如下commit，比如我想在 <span class="hljs-string">&quot;34372b05&quot;</span>这个commit打标签44d2e20b fix bug34372b05 fix bug29554931 fix bug<br></code></pre></td></tr></table></figure><p>（2）、给指定的commit打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0 34372b05<br></code></pre></td></tr></table></figure><p>（3）、创建的标签只存在本地，推至远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0.0<br></code></pre></td></tr></table></figure><p>（4）、一次性推送未推至远程的本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --tags<br></code></pre></td></tr></table></figure><p>（5）、查询所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br></code></pre></td></tr></table></figure><p>（6）、查询标签详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show v1.0.0<br></code></pre></td></tr></table></figure><p>（7）、删除本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d v1.0.0<br></code></pre></td></tr></table></figure><p>（8）、删除远程标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 先从本地删除git tag -d v1.0.0<br>// 然后从远程删除git push origin :refs/tags/v1.0.0<br>// 最后可以在gitlab上查看是否真正的删除了标签<br></code></pre></td></tr></table></figure><p><strong>3、创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// git  tag  -a  版本号  -m  说明信息  commit版本号git tag -a v1.0.0 -m <span class="hljs-string">&quot;version 1.0.0 released&quot;</span> 34372b05(commit版本号)     <br>// 查看标签详细信息git show v1.0.0    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo一键发布文章</title>
    <link href="/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"/>
    <url>/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo一键发布文章"><a href="#Hexo一键发布文章" class="headerlink" title="Hexo一键发布文章"></a>Hexo一键发布文章</h1><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>刚开始使用hexo的时候简直无法忍受繁杂的部署命令,不仅要输入以下命令来更新，并且还要在指定的目录下打开 git bash，这让怕麻烦的我十分难受…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure><h2 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h2><p>注意事项：下面的命令中 D:&#x2F;Myblog&#x2F;hexo&#x2F;liblog 是我博客的文件夹路径，请替换为你自己博客的路径</p><p>任意目录打开 git bash ，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.fuck <span class="hljs-string">&#x27;!cd D:/Myblog/hexo/liblog;hexo clean;hexo g -d&#x27;</span><br>git fuck<br></code></pre></td></tr></table></figure><p>以后就可以在任意目录下通过 git fuck 来一键更新了。</p><h2 id="三、如何取消别名"><a href="#三、如何取消别名" class="headerlink" title="三、如何取消别名"></a>三、如何取消别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> alias.fuck<br></code></pre></td></tr></table></figure><h2 id="四、再简单些"><a href="#四、再简单些" class="headerlink" title="四、再简单些"></a>四、再简单些</h2><p>每次都要打开git bush再输入git fuck 还是有些麻烦，通过windows的bat脚本一键实现发布文章，新建一个文件后缀命名为bat,输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> 开始提交到git....<br>git fuck<br><span class="hljs-built_in">echo</span> 推送到git成功<br>@<span class="hljs-built_in">echo</span> off<br>pause<br></code></pre></td></tr></table></figure><p><strong>完美！！！</strong></p><p>只需点击这个bat文件就能够一键发布文章了</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用的IDEA插件</title>
    <link href="/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><h2 id="1、Background-Image-Plus"><a href="#1、Background-Image-Plus" class="headerlink" title="1、Background Image Plus"></a>1、Background Image Plus</h2><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而<strong>Background Image Plus</strong>这个插件可以为IDEA设置<strong>自定义图片</strong>作为背景，而且还可以设置透明度，从此写代码乐趣十足!</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639600.jpeg" alt="图片"></p><p><strong>背景图设置效果如下：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639590.jpeg" alt="图片"></p><hr><h2 id="2、CodeGlance"><a href="#2、CodeGlance" class="headerlink" title="2、CodeGlance"></a>2、CodeGlance</h2><p><strong>CodeGlance</strong>是一款非常好用的<strong>代码地图</strong>插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639411.jpeg" alt="图片"></p><p><strong>放大镜效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639447.jpeg" alt="图片"></p><hr><h2 id="3、Translation"><a href="#3、Translation" class="headerlink" title="3、Translation"></a>3、Translation</h2><p>代码中经常遇到不认识的英文单词或者句子，很蒙蔽怎么办？</p><p><strong>Translation</strong>是一款非常好用的<strong>翻译插件</strong>，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639271.jpeg" alt="图片"></p><p><strong>翻译逐个单词：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639277.jpeg" alt="图片"></p><p><strong>翻译一段话：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639762.jpeg" alt="图片"></p><hr><h2 id="4、Rainbow-Brackets"><a href="#4、Rainbow-Brackets" class="headerlink" title="4、Rainbow Brackets"></a>4、Rainbow Brackets</h2><p>在代码非常复杂时，各种<strong>俄罗斯套娃式</strong>的括号简直让人心碎，<strong>Rainbow Brackets</strong>则是一款可以对<strong>成对括号</strong>进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639875.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639123.png" alt="图片"></p><hr><h2 id="5、Grep-Console"><a href="#5、Grep-Console" class="headerlink" title="5、Grep Console"></a>5、Grep Console</h2><p>默认情况下，IDEA控制台窗口在打印日志时都是一种颜色到底，比如各种<code>info</code>,<code>warn</code>,和<code>error</code>等类型的日志信息交织在一起，不好分辨。</p><p><strong>Grep Console</strong>插件则可以帮助我们自定义设置不用日志用不同的颜色进行标识，非常方便观看！</p><p><strong>设置自定义颜色：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639197.jpeg" alt="图片"></p><p><strong>着色后的日志打印效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639171.jpeg" alt="图片"></p><hr><h2 id="6、Statistic"><a href="#6、Statistic" class="headerlink" title="6、Statistic"></a>6、Statistic</h2><p>程序员天天闷头做项目、写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p><strong>Statistic</strong>则是一款可以做项目全局代码统计信息的小插件：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639241.jpeg" alt="图片"></p><hr><h2 id="7、Markdown-Navigator"><a href="#7、Markdown-Navigator" class="headerlink" title="7、Markdown Navigator"></a>7、Markdown Navigator</h2><p>很多人私信问说，你是用什么markdown编辑器写博客的呢？不瞒你说，用IDEA就可以很愉快的写博客了，装了一个<strong>Markdown Navigator</strong>插件即可方便的实现：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639787.jpeg" alt="图片"></p><hr><h2 id="8、RestfulToolkit"><a href="#8、RestfulToolkit" class="headerlink" title="8、RestfulToolkit"></a>8、RestfulToolkit</h2><ul><li>你知道你项目里到底写了多少个URL接口吗？</li><li>如何快速定位某个<code>URL</code>接口对应的<code>Controller</code>代码？</li><li>如何快速测试你的<code>Controller</code>接口？</li></ul><p><strong>RestfulToolkit</strong>则是一个可以解决上述问题的，非常方便的IDEA集成插件，从此<code>Postman</code>怕是要下岗了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639948.jpeg" alt="图片"></p><hr><h2 id="9、GsonFormat"><a href="#9、GsonFormat" class="headerlink" title="9、GsonFormat"></a>9、GsonFormat</h2><p>给你一段<code>Json</code>格式数据，除了手写之外，如何快速生成一个和该<code>Json</code>数据对应的<code>Java</code>对象？</p><p>比如一段<code>Json</code>格式数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;操作成功&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>GsonFormat</strong>则是一个<strong>JSON格式数据 → 对象</strong>的快速<strong>代码自动生成</strong>插件。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639900.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639827.png" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639896.jpeg" alt="图片"></p><hr><h2 id="10、MyBatis-Log-Plugin"><a href="#10、MyBatis-Log-Plugin" class="headerlink" title="10、MyBatis Log Plugin"></a>10、MyBatis Log Plugin</h2><p><code>Mybatis</code>的<code>xml</code>文件中的<code>SQL</code>语句都是拼装起来的，但有时候（比如在调试的时候）想把某个请求对应的后台具体<code>SQL</code>查询语句单独拿出来测试或验证，该怎么办呢？</p><p><strong>MyBatis Log Plugin</strong>这个插件既可以帮你完美地解决这个问题：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639995.jpeg" alt="图片"></p><hr><h2 id="11、Free-Mybatis-plugin"><a href="#11、Free-Mybatis-plugin" class="headerlink" title="11、Free Mybatis plugin"></a>11、Free Mybatis plugin</h2><p>除了全局搜索以外，如何方便地在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换？</p><p><strong>Free Mybatis plugin</strong>插件此时就可以大显身手了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639379.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639393.jpeg" alt="图片"></p><hr><h2 id="12、MyBatisX"><a href="#12、MyBatisX" class="headerlink" title="12、MyBatisX"></a>12、MyBatisX</h2><p>快速在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642594.png" alt="image-20220818164238523"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642440.png" alt="image-20220818164250365"></p><h2 id="13、Nyan-Progress-Bar"><a href="#13、Nyan-Progress-Bar" class="headerlink" title="13、Nyan Progress Bar"></a>13、Nyan Progress Bar</h2><p>让进度条变得好看，编程彩虹条</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181648858.png" alt="image-20220818164845828"></p><h2 id="14、SequenceDiagram"><a href="#14、SequenceDiagram" class="headerlink" title="14、SequenceDiagram"></a>14、SequenceDiagram</h2><p>查看代码执行时序图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181646385.png" alt="image-20220818164613306"></p><h2 id="15、Material-Theme-UI"><a href="#15、Material-Theme-UI" class="headerlink" title="15、Material Theme UI"></a>15、Material Theme UI</h2><p>代码主题切换，可以改变代码颜色搭配</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181647157.png" alt="image-20220818164727076"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSR303数据校验</title>
    <link href="/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <url>/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h1><blockquote><p>JSR 303 是Java为Bean数据合法校验提供的标准框架，已经包含在Java EE 6.0中。JSR是一个规范，它的核心接口时Validator，该接口根据目标对象类中所标注的校验注解进行数据校验，并得到校验结果。JSR303通过在Bean属性中标注类似@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p></blockquote><h2 id="JSR-303-包含注解"><a href="#JSR-303-包含注解" class="headerlink" title="JSR 303 包含注解"></a>JSR 303 包含注解</h2><table><thead><tr><th align="left">注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">@Null</td><td align="center">被注解的元素必须为null</td></tr><tr><td align="left">@NotNull</td><td align="center">被注解的元素必须不为null</td></tr><tr><td align="left">@AssertTrue</td><td align="center">被注解的元素必须为true</td></tr><tr><td align="left">@AssertFalse</td><td align="center">被注解的元素必须为false</td></tr><tr><td align="left">@Min(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@Max(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@DecimalMin(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@DecimalMax(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@Size</td><td align="center">被注解的元素的大小必须在指定的范围内</td></tr><tr><td align="left">@Digits(integer,fraction)</td><td align="center">被注解的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td align="left">@Past</td><td align="center">被注解的元素必须是一个过去的时间</td></tr><tr><td align="left">@Future</td><td align="center">被注解的元素必须是一个将来的时间</td></tr><tr><td align="left">@Pattern(regex&#x3D;,flag&#x3D;)</td><td align="center">被注解的元素必须符合指定的正则表达式</td></tr></tbody></table><h2 id="Hibernate-Vakudator"><a href="#Hibernate-Vakudator" class="headerlink" title="Hibernate Vakudator"></a>Hibernate Vakudator</h2><blockquote><p>Hibernate Vakudator是JSR303的一个参考实现，出来支持所有的标准注解外，还支持一些扩展注解</p></blockquote><table><thead><tr><th>注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td>@NotBlank(message&#x3D;)</td><td align="center">验证字符串非null,并且长度必须大于0</td></tr><tr><td>@Email</td><td align="center">被注解的元素必须是电子邮箱地址</td></tr><tr><td>@Length(min&#x3D;,max&#x3D;)</td><td align="center">被注解的字符串的大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td align="center">被注解的字符串必须非空</td></tr><tr><td>@Range(min&#x3D;,max&#x3D;,message&#x3D;)</td><td align="center">被注解的元素必须在合适的范围内</td></tr><tr><td>@URL</td><td align="center">被注解的元素必须是合法的URL</td></tr></tbody></table><h2 id="ValidationMessages-properties"><a href="#ValidationMessages-properties" class="headerlink" title="ValidationMessages.properties"></a>ValidationMessages.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">javax.validation.constraints.AssertFalse.message</span>     = <span class="hljs-string">必须为 false</span><br><span class="hljs-attr">javax.validation.constraints.AssertTrue.message</span>      = <span class="hljs-string">必须为 true</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMax.message</span>      = <span class="hljs-string">必须小于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMin.message</span>      = <span class="hljs-string">必须大于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Digits.message</span>          = <span class="hljs-string">数字值超出了边界（期望 &lt;&#123;integer&#125; digits&gt;.&lt;&#123;fraction&#125; digits&gt;）</span><br><span class="hljs-attr">javax.validation.constraints.Email.message</span>           = <span class="hljs-string">必须为格式规范的电子邮件地址</span><br><span class="hljs-attr">javax.validation.constraints.Future.message</span>          = <span class="hljs-string">必须是未来的日期</span><br><span class="hljs-attr">javax.validation.constraints.FutureOrPresent.message</span> = <span class="hljs-string">必须是现在或将来的日期</span><br><span class="hljs-attr">javax.validation.constraints.Max.message</span>             = <span class="hljs-string">必须小于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Min.message</span>             = <span class="hljs-string">必须大于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Negative.message</span>        = <span class="hljs-string">必须小于 0</span><br><span class="hljs-attr">javax.validation.constraints.NegativeOrZero.message</span>  = <span class="hljs-string">必须小于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.NotBlank.message</span>        = <span class="hljs-string">不得为空白</span><br><span class="hljs-attr">javax.validation.constraints.NotEmpty.message</span>        = <span class="hljs-string">不得为空</span><br><span class="hljs-attr">javax.validation.constraints.NotNull.message</span>         = <span class="hljs-string">不得为 null</span><br><span class="hljs-attr">javax.validation.constraints.Null.message</span>            = <span class="hljs-string">必须为 null</span><br><span class="hljs-attr">javax.validation.constraints.Past.message</span>            = <span class="hljs-string">必须是过去的日期</span><br><span class="hljs-attr">javax.validation.constraints.PastOrPresent.message</span>   = <span class="hljs-string">必须是过去或现在的日期</span><br><span class="hljs-attr">javax.validation.constraints.Pattern.message</span>         = <span class="hljs-string">必须与 &quot;&#123;regexp&#125;&quot; 匹配</span><br><span class="hljs-attr">javax.validation.constraints.Positive.message</span>        = <span class="hljs-string">必须大于 0</span><br><span class="hljs-attr">javax.validation.constraints.PositiveOrZero.message</span>  = <span class="hljs-string">必须大于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.Size.message</span>            = <span class="hljs-string">大小必须在 &#123;min&#125; 和 &#123;max&#125; 之间</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.CreditCardNumber.message</span>        = <span class="hljs-string">无效信用卡卡号</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Currency.message</span>                = <span class="hljs-string">无效货币（必须为 &#123;value&#125; 之一）</span><br><span class="hljs-attr">org.hibernate.validator.constraints.EAN.message</span>                     = <span class="hljs-string">无效 &#123;type&#125; 条形码</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Email.message</span>                   = <span class="hljs-string">电子邮件地址格式不规范</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ISBN.message</span>                    = <span class="hljs-string">无效 ISBN</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Length.message</span>                  = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.CodePointLength.message</span>         = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.LuhnCheck.message</span>               = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Luhn Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod10Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod11Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 11 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ModCheck.message</span>                = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，&#123;modType&#125; 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotBlank.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotEmpty.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ParametersScriptAssert.message</span>  = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Range.message</span>                   = <span class="hljs-string">必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.SafeHtml.message</span>                = <span class="hljs-string">可能具有不安全的 HTML 内容</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ScriptAssert.message</span>            = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.UniqueElements.message</span>          = <span class="hljs-string">必须仅包含唯一元素</span><br><span class="hljs-attr">org.hibernate.validator.constraints.URL.message</span>                     = <span class="hljs-string">必须为有效 URL</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CNPJ.message</span>                 = <span class="hljs-string">无效巴西企业纳税人登记号 (CNPJ)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CPF.message</span>                  = <span class="hljs-string">无效巴西个人纳税人登记号 (CPF)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.TituloEleitoral.message</span>      = <span class="hljs-string">无效巴西投票人身份证号</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.REGON.message</span>                = <span class="hljs-string">无效波兰纳税人识别号 (REGON)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.NIP.message</span>                  = <span class="hljs-string">无效 VAT 识别号 (NIP)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.PESEL.message</span>                = <span class="hljs-string">无效波兰身份证号 (PESEL)</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMax.message</span>        = <span class="hljs-string">必须短于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMin.message</span>        = <span class="hljs-string">必须长于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;<br>    &lt;version&gt;2.6.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-添加注解"><a href="#2-添加注解" class="headerlink" title="2.添加注解"></a>2.添加注解</h2><blockquote><p>在需要校验的字段上添加相应的注解进行校验，其中message是当校验不合法是提示的错误信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liziyuan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@email</span> liziyuan@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-07-08 08:58:02</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;pms_brand&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BrandEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@TableId</span><br>   <span class="hljs-keyword">private</span> Long brandId;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌名</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotBlank(message = &quot;品牌名称不能为空&quot;)</span><br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌logo地址</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@URL(message = &quot;logo必须是一个合法的URL地址&quot;)</span><br>   <span class="hljs-keyword">private</span> String logo;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 介绍</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String descript;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 显示状态[0-不显示；1-显示]</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Integer showStatus;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 检索首字母</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@Pattern(regexp = &quot;/~[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><br>   <span class="hljs-keyword">private</span> String firstLetter;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 排序</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-meta">@Min(value = 0,message = &quot;排序必须大于0&quot;)</span><br>   <span class="hljs-keyword">private</span> Integer sort;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Cotroller开启校验"><a href="#3-Cotroller开启校验" class="headerlink" title="3.Cotroller开启校验"></a>3.Cotroller开启校验</h2><blockquote><p>使用@Valid注解开启校验，其中参数BindingResult可以获取校验的结果。</p><ul><li>BindingResult：BindingResult扩展了Errors接口，同时可以获取数据绑定结果对象的信息。@Valid和BindingResult参数是成对出现的，并且在形参中出现的顺序是固定的，一前一后。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span>&#123;<br>        <span class="hljs-comment">//BindingResult 参数能够获取校验结果</span><br><span class="hljs-comment">//        获取校验的错误结果</span><br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            result.getFieldErrors().forEach((item)-&gt;&#123;<br><span class="hljs-comment">//                获取到错误提示</span><br>                String message=item.getDefaultMessage();<br>                 <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> item.getField();<span class="hljs-comment">//获取错误的属性的名字</span><br>                map.put(field,message);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-number">400</span>,<span class="hljs-string">&quot;提交数据不合法&quot;</span>).put(<span class="hljs-string">&quot;data&quot;</span>,map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>      brandService.save(brand);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h1><ol><li><p>编写一个自定义校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: liZiYuan</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Date: 2022/7/16  20:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Constraint(</span><br><span class="hljs-meta">        validatedBy = &#123;ListValueConstraintValidator.class&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ListValue &#123;<br>    String <span class="hljs-title function_">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&#123;com.zhang.common.valid.ListValue.message&#125;&quot;</span>;<br><br>    Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Payload</span>&gt;[] payload() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-type">int</span>[] vals()  <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>编写一个自定义的校验器 ConstrainValidator</p><p>实现ConstraintValidator&lt;Annotation, T&gt;接口,其中Annotation表示自定义的校验注解，T表示校验对象的类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListValueConstraintValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//初始化方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ListValue constraintAnnotation)</span> &#123;<br>        <span class="hljs-type">int</span>[] vals= constraintAnnotation.vals();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vals) &#123;<br>            set.add(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否校验成功</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 需要校验的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> constraintValidatorContext</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(Integer value, ConstraintValidatorContext constraintValidatorContext)</span> &#123;<br>        <span class="hljs-keyword">return</span> set.contains(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关联自定义的校验器和自定义的校验注解</p></li></ol><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><blockquote><p>@Validated是@Valid 的一次封装，是Spring提供的校验机制使用。@Valid不提供分组功能</p></blockquote><p><strong>@Valid和@Validated的区别</strong></p><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring的JSR-303规范，是标准JSR-303的一个变种），Javax提供了<code>@Valid</code>（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。</p><p><code>@Valid</code>属于Javax.validation包下，是jdk给提供的，是使用Hibernate validation的时候使用（java的JSR303声明了@Valid这类接口，而Hibernate-validator对其进行了实现）</p><p><code>@Validated</code>是org.springframework.validation.annotation包下的，是spring提供的，是只用Spring validator校验机制使用</p><p>在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p><p>1.分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Validated</span>：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制<br><span class="hljs-meta">@Valid</span>：作为标准的JSR-<span class="hljs-number">303</span>规范，还没有吸收分组的功能<br></code></pre></td></tr></table></figure><p><code>@Validated</code>会有分组的概念，后面默认是有一个Default.class,当你的@Validated后面没有加任何校验分组信息的时候默认会加Default分组,而对于被校验的对象的属性字段，如果你在属性的校验标签里面没有指定分组会添加到默认分组Default里面。所以如果你的对象里面的每个属性都指定了分组信息，而接口上面并没有添加分组信息会出现@Validated“失效的情况”，实际是因为它校验的是Default分组，而没有字段属于Default分组。上述校验不管加不加@ReqeustBody都能完成校验，但是都不能完成嵌套的校验。</p><p>特殊用法:</p><ul><li>分组: 当一个实体类需要多种验证方式时，例：对于一个实体类的id来说，新增的时候是不需要的，对于更新时是必须的, 可以通过groups对验证进行分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AllFiled</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">First</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Secend</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br><br>    <span class="hljs-meta">@NotBlank(message = &quot;姓名不能为空&quot;, groups = &#123;First.class, AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@NotEmpty(message = &quot;密码不能为空&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Length(min = 6, max = 10, message = &quot;密码长度只能在6-10之间&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@Min(value = 18, message = &quot;年龄最小为18&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Max(value = 60, message = &quot;年龄最大为60&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@AssertTrue(message = &quot;必须同意条款&quot;, groups = &#123;Secend.class, AllFiled.class&#125;)</span><br>    <span class="hljs-type">boolean</span> agree;<br>&#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;validate&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span>&#123;<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            List&lt;ObjectError&gt; list  = result.getAllErrors();<br>            <span class="hljs-keyword">for</span> (ObjectError error :<br>                    list) &#123;<br>                <span class="hljs-type">FieldError</span> <span class="hljs-variable">fieldError</span> <span class="hljs-operator">=</span> (FieldError)error;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">defaultMessage</span> <span class="hljs-operator">=</span> fieldError.getDefaultMessage();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldError.getField();<br>                map.put(field, defaultMessage);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当@Validated分组为空时, 只会验证没有分组的属性, 如上面的uid;</strong></p><p><strong>当@Validated{First.class}时, 只会验证分组为First.class的字段, 对于其他分组字段和未分组字段都为空</strong></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font style="color:red">注意</font></h1><p>添加全局异常处理时Controller层参数中不能加<code>BindingResult</code>参数，否则无法捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestControllerAdvice(basePackages = &quot;com.zhang.gulimall.product.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GulimallExceptionControllerAdvice</span> &#123;<br><br><span class="hljs-comment">//    @ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">handlerValidException</span><span class="hljs-params">(MethodArgumentNotValidException e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;校验异常处理&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;数据校验出现问题&#123;&#125;，异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());<br>         <span class="hljs-type">BindingResult</span> <span class="hljs-variable">bindingResult</span> <span class="hljs-operator">=</span> e.getBindingResult();<br>        Map&lt;String,String&gt; errorMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        bindingResult.getFieldErrors().forEach((filedError)-&gt;&#123;<br>            errorMap.put(filedError.getField(),filedError.getDefaultMessage());<br>        &#125;);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(<span class="hljs-string">&quot;data&quot;</span>,errorMap);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = RuntimeException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">hadleException</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.UNKNOW_EXCEPTION.getCode(),BizCodeEnum.UNKNOW_EXCEPTION.getMsg());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON序列化</title>
    <link href="/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h1><h2 id="Jackson序列化与反序列化"><a href="#Jackson序列化与反序列化" class="headerlink" title="Jackson序列化与反序列化"></a>Jackson序列化与反序列化</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json"><a href="#对象转json" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象"><a href="#json转对象" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>mapper.readValue(json字符串数据，类.Class)<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(mapper.readValue(json, Person[].class));<br></code></pre></td></tr></table></figure><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><p><code>@JsonIgnore</code> 此注解用于属性上，作用是进行JSON操作时忽略该属性。</p></li><li><p><code>@JsonFormat</code> 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH-mm-ss”)。</p></li><li><p><code>@JsonProperty</code> 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</p></li></ul><h2 id="Gson序列化与反序列化"><a href="#Gson序列化与反序列化" class="headerlink" title="Gson序列化与反序列化"></a>Gson序列化与反序列化</h2><h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-1"><a href="#对象转json-1" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> gson.toJson(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> gson.toJson(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-1"><a href="#json转对象-1" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">Person</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> gson.fromJson(json,对象.class);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(gson.fromJson(json, Person[].class));<span class="hljs-comment">//转为对象list</span><br></code></pre></td></tr></table></figure><p><strong>json转为List和Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Test&gt; o = gson.fromJson(json, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;转换为的对象&gt;&gt;() &#123; &#125;.getType());<br>HashMap&lt;String,Test&gt; o1 = gson.fromJson(jsonMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;HashMap&lt;String,Test&gt;&gt;()&#123;&#125;.getType());<br></code></pre></td></tr></table></figure><h3 id="常用注解：-1"><a href="#常用注解：-1" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@SerializedName(&quot;name&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</li><li><code>@Expose(serialize = false,deserialize = false)</code>serialize:是否参与序列化，deserialize是否参与反序列化</li></ul><h2 id="FastJson序列化与反序列化"><a href="#FastJson序列化与反序列化" class="headerlink" title="FastJson序列化与反序列化"></a>FastJson序列化与反序列化</h2><h3 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.79<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-2"><a href="#对象转json-2" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-2"><a href="#json转对象-2" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><h3 id="常用注解：-2"><a href="#常用注解：-2" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@JSONField(name = &quot;personName&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称,还能够日期匹配 <code>@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</code>等，基本都在此注解基础上进行的配置。</li></ul><p><strong>经典案例</strong></p><p>将map中的某个值转为指定类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getData</span><span class="hljs-params">(TypeReference&lt;T&gt; typeReference)</span>&#123;<br>   <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> get(<span class="hljs-string">&quot;data&quot;</span>);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> JSON.parseObject(s, typeReference);<br>   <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">R</span> <span class="hljs-variable">skuHasStock</span> <span class="hljs-operator">=</span> wareFeignService.getSkuHasStock(skuIdList);<br>TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;SkuHasStockVo&gt;&gt;()&#123;&#125;;<br>stockMap = skuHasStock.getData(data).stream().collect(Collectors.toMap(SkuHasStockVo::getHasStock, SkuHasStockVo::getHasStock));<br></code></pre></td></tr></table></figure><h2 id="Kryo序列化与反序列化"><a href="#Kryo序列化与反序列化" class="headerlink" title="Kryo序列化与反序列化"></a>Kryo序列化与反序列化</h2><h3 id="导包-3"><a href="#导包-3" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>作为一个灵活的序列化框架，Kryo 并不关心读写的数据，作为开发者，你可以随意使用 Kryo 提供的那些开箱即用的序列化器。</p></blockquote><h3 id="Kryo-的注册"><a href="#Kryo-的注册" class="headerlink" title="Kryo 的注册"></a>Kryo 的注册</h3><p>和很多其他的序列化框架一样，Kryo 为了提供性能和减小序列化结果体积，提供注册的序列化对象类的方式。在注册时，会为该序列化类生成 int ID，后续在序列化时使用 int ID 唯一标识该类型。注册的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>可以明确指定注册类的 int ID，但是该 ID 必须大于等于 0。如果不提供，内部将会使用 int++的方式维护一个有序的 int ID 生成。</p><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>Kryo 不是线程安全的。每个线程都应该有自己的 Kryo 对象、输入和输出实例。</p><p>因此在多线程环境中，可以考虑使用 ThreadLocal 或者对象池来保证线程安全性。</p><h4 id="ThreadLocal-Kryo-解决线程不安全"><a href="#ThreadLocal-Kryo-解决线程不安全" class="headerlink" title="ThreadLocal + Kryo 解决线程不安全"></a>ThreadLocal + Kryo 解决线程不安全</h4><p>ThreadLocal 是一种典型的牺牲空间来换取并发安全的方式，它会为每个线程都单独创建本线程专用的 kryo 对象。对于每条线程的每个 kryo 对象来说，都是顺序执行的，因此天然避免了并发安全问题。创建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Kryo&gt;() &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// 在此处配置kryo对象的使用示例，如循环引用等</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;;<br>&#125;;<br><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryos.get();<br></code></pre></td></tr></table></figure><p>之后，仅需要通过 <code>kryos.get()</code> 方法从线程上下文中取出对象即可使用。</p><h4 id="对象池-Kryo-解决线程不安全"><a href="#对象池-Kryo-解决线程不安全" class="headerlink" title="对象池 + Kryo 解决线程不安全"></a>对象池 + Kryo 解决线程不安全</h4><p><strong>「池」</strong>是一种非常重要的编程思想，连接池、线程池、对象池等都是<strong>「复用」</strong>思想的体现，通过将创建的“对象”保存在某一个“容器”中，以便后续反复使用，避免创建、销毁的产生的性能损耗，以此达到提升整体性能的作用。</p><p>Kryo 对象池原理也是如此。Kryo 框架自带了对象池的实现，整个使用过程不外乎<strong>创建池、从池中获取对象、归还对象</strong>三步，以下为代码实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pool constructor arguments: thread safe, soft references, maximum capacity</span><br>Pool&lt;Kryo&gt; kryoPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>&lt;Kryo&gt;(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">8</span>) &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">create</span> <span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// Kryo 配置</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;<br>&#125;;<br><br><span class="hljs-comment">// 获取池中的Kryo对象</span><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br><span class="hljs-comment">// 将kryo对象归还到池中</span><br>kryoPool.free(kryo);<br></code></pre></td></tr></table></figure><p>创建 Kryo 池时需要传入三个参数，其中第一个参数用于指定是否在 Pool 内部使用同步，如果指定为 true，则允许被多个线程并发访问。第三个参数适用于指定对象池的大小的，这两个参数较容易理解，因此重点来说一下第二个参数。</p><p>如果将第二个参数设置为 true，Kryo 池将会使用 java.lang.ref.SoftReference 来存储对象。这允许池中的对象在 JVM 的内存压力大时被垃圾回收。Pool clean 会删除所有对象已经被垃圾回收的软引用。当没有设置最大容量时，这可以减少池的大小。当池子有最大容量时，没有必要调用 clean，因为如果达到了最大容量，Pool free 会尝试删除一个空引用。</p><p>创建玩 Kryo 池后，使用 kryo 就变得异常简单了，只需调用 <code>kryoPool.obtain()</code> 方法即可，使用完毕后再调用 <code>kryoPool.free(kryo)</code> 归还对象，就完成了一次完整的租赁使用。</p><p>理论上，只要对象池大小评估得当，就能在占用极小内存空间的情况下完美解决并发安全问题。如果想要封装一个 Kryo 的序列化方法，可以参考如下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>    <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br>    <span class="hljs-comment">// 使用 Output 对象池会导致序列化重复的错误（getBuffer返回了Output对象的buffer引用）</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Output</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(<span class="hljs-number">1024</span>, -<span class="hljs-number">1</span>)) &#123;<br>        kryo.writeClassAndObject(opt, obj);<br>        opt.flush();<br>        <span class="hljs-keyword">return</span> opt.getBuffer();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        kryoPool.free(kryo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2022/09/04/Servlet/"/>
    <url>/2022/09/04/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Servlet是Server Applet的简称，称为服务器端小程序或服务连接器，主要功能在于交互式地浏览和修改数据，生成动态Web内容。</p><h2 id="Servlet架构"><a href="#Servlet架构" class="headerlink" title="Servlet架构"></a>Servlet架构</h2><p>Java Servlet是运行在Web服务器或应用服务器上的程序，作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。</p><p>使用Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205030850264.png" alt="image-20220503085026177"></p><p>Servlet主要执行以下任务：</p><ul><li>读取客户端（浏览器）发送的显式数据，包括网页上的HTML表单或自定义的HTTP客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式HTTP请求数据，包括Cookies，媒体类型和浏览器能理解的压缩格式等。</li><li>处理数据并生成结果、这个过程可能需要访问数据库、执行RMI等远程过程调用、调用Web服务或者直接计算得出对应的响应。</li><li>发送显式数据（文档）到客户端（浏览器），该文档的格式可以是多种多样的，包括文本文件（HMTL、XML或JSON文件）、二进制文件（GIF图像）、Excel等。</li><li>发送隐式HTTP响应到客户端（浏览器），包括告诉浏览器或其他客户端被返回的文档类型（例如HTML）、设置Cookies和缓存参数以及其他类似的任务。</li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet生命周期可被定义为从创建Servlet直到其销毁的整个过程。以下是Servlet遵循的过程：</p><ul><li>Servlet通过调用init方法进行初始化。</li><li>Servlet通过service方法来处理客户端的请求。</li><li>Servlet通过调用destroy方法终止。</li><li>最后，Servlet是由JVM的垃圾回收器进行垃圾回收的。</li></ul><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>init方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时不再调用。因此，它用于一次性初始化。</p><p>Servlet创建于用户第一次调用对应Servlet的URL时，但是也可以指定Servlet在服务器第一次启动时被调用。</p><p>用户调用一个Servlet就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候交给doGet或doPost方法。init方法简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。</p><p>init方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service方法"><a href="#Service方法" class="headerlink" title="Service方法"></a>Service方法</h3><p>service方法是执行实际任务的主要方法。Servlet容器调用service方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service方法检查HTTP请求类型（GET、POST、PUT、DELETE等），并在适当的时候调用doGet、doPost、doPut、doDelete等方法。</p><p>下面是该方法的特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service方法由容器调用，会在适当的时候调用doGet、doPost、doPut、doDelete等方法，所以不用对service方法做任何动作，只需要根据来自客户端的请求类型来重写doGet、doPost方法即可。</p><h3 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet()方法"></a>doGet()方法</h3><p>当Servlet容器接收到GET请求时，会将请求由doGet方法处理。处理逻辑写在重写的doGet方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doPost方法"><a href="#doPost方法" class="headerlink" title="doPost方法"></a>doPost方法</h3><p>当Servlet容器接收到POST请求时，会将请求由doPost方法处理。处理逻辑写在重写的doPost方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="destroy方法"><a href="#destroy方法" class="headerlink" title="destroy方法"></a>destroy方法</h3><p>当Servlet容器确定Servlet应该从服务器中移除时，将调用Servlet接口的destroy方法以允许Servlet释放它使用的任何资源和保存任何持久化的状态。例如，当想要借省内存资源或它被关闭时，容器可以执行destroy方法。</p><p>Servlet容器调用destroy方法之前，它必须让当前正在执行service方法的任何线程完成执行或超过服务器定义的事件限制。</p><p>一旦调用Servlet实例的destroy方法，容器就无法再路由其他请求到该Servlet实例。如果容器需要再次使用该Servlet，就必须用该Servlet类的一个新实例。在destroy方法完成后，Servlet容器必须释放Servlet实例以便垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>doGet处理 HTTP GET 请求</li><li>doPost处理 HTTP POST请求</li><li>doPut处理 HTTP PUT 请求</li><li>doDelete 处理 HTTP DELETE请求</li><li>doHead处理 HTTP HEAD 请求</li><li>doOptions处理 HTTP OPTIONS 请求</li><li>doTrace 处理 HTTP TRACE 请求</li></ul><h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><p>通俗点说，所谓容器，就是放东西的地方，Servlet容器自然就是方Servlet的地方。在Servlet开发中，我们需要按照Servlet的规范写代码，那么这样的代码就能在Servlet容器中运行。容器会按照规则加载类，并运行它。</p><p>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。</p><p>常见的Servlet容器有 Tomcat、Jetty、Oracle Application Server、Oracle Weblogic、JBoss Application Server等。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务哪些情况会失效？</title>
    <link href="/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
    <url>/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring事务失效"><a href="#Spring事务失效" class="headerlink" title="Spring事务失效"></a>Spring事务失效</h1><ol><li><h4 id="访问权限问题"><a href="#访问权限问题" class="headerlink" title="访问权限问题"></a>访问权限问题</h4><p>java的访问权限主要有4种：private、default、protected、public，如果事务方法的访问权限不是定义为public，这样会导致事务失效，因为spring要求被代理方法必须是public的。翻开源码，可以看到，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则返回null，即不支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> TransactionAttribute <span class="hljs-title function_">computeTransactionAttribute</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//........</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="方法用final修饰"><a href="#方法用final修饰" class="headerlink" title="方法用final修饰"></a>方法用final修饰</h4><p>如果事务方法用final修饰，会导致事务失效，因为spring事务底层原理使用了aop也就是通过jdk动态代理或者cglib，帮助我们生成了代理类，在代理类中实现的事务功能。但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p></li><li><h4 id="对象没有被spring管理"><a href="#对象没有被spring管理" class="headerlink" title="对象没有被spring管理"></a>对象没有被spring管理</h4><p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法就不会生成事务。</p></li><li><h4 id="表不支持事务"><a href="#表不支持事务" class="headerlink" title="表不支持事务"></a>表不支持事务</h4><p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的，因为myisam存储引擎不支持事务。</p></li><li><h4 id="方法内部调用"><a href="#方法内部调用" class="headerlink" title="方法内部调用"></a>方法内部调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-built_in">this</span>.updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，update方法上没有加@Transactional注解，调用有@Transactional注解的updateOrder方法，updateOrder方法上的事务会失效。因为发生了自身调用，调用该类自己的方法，而没有经过spring的代理类，只有在外部调用事务才会生效。</p><p><strong>解决：</strong></p><ul><li><p>再加一个serviece,将内部调用改为外部调用</p></li><li><p>使用编程式事务</p></li><li><p>使用AopContexct.currentProxy()获取代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        ((OrderService)AopContexct.currentProxy()).updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="未开启事务"><a href="#未开启事务" class="headerlink" title="未开启事务"></a>未开启事务</h4><p>如果是spring项目，则需要再配置文件中手动配置事务相关参数，如果忘记了配置，事务肯定是失效的。如果是spingboot项目，那么不需要手动配置。因为springboot已经在<code>DataSourceTransactionManagerAutoConfiguration</code>类中帮我们开启了事务。</p></li><li><h4 id="吞了异常"><a href="#吞了异常" class="headerlink" title="吞了异常"></a>吞了异常</h4><p>有时候事务不会回滚，有可能是在代码中手动catch了异常，因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况喜爱spring事务不会回滚。如果想要spring事务能够正常回滚必须抛出它能够处理的异常</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2022/09/04/Swagger/"/>
    <url>/2022/09/04/Swagger/</url>
    
    <content type="html"><![CDATA[<h1 id="SpingBoot整合swagger"><a href="#SpingBoot整合swagger" class="headerlink" title="SpingBoot整合swagger"></a>SpingBoot整合swagger</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-新建swagger配置类。"><a href="#2-新建swagger配置类。" class="headerlink" title="2.新建swagger配置类。"></a>2.新建swagger配置类。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/.*&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-给Controller加上注解"><a href="#3-给Controller加上注解" class="headerlink" title="3.给Controller加上注解"></a>3.给Controller加上注解</h2><p>首先要在整个类前面加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/&quot;,description = &quot;这是所有get方法&quot;)</span><br></code></pre></td></tr></table></figure><p>然后在每个接口前加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;通过这个方法可以获取到cookies&quot;,httpMethod = &quot;GET&quot;)</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/odl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/odl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OdlController</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取交换机信息 ++++++交换机+++++++++++</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 交换机信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;获取交换机信息&quot;,httpMethod = &quot;GET&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/getOvsTable&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;HostAndOvs&gt;&gt; <span class="hljs-title function_">getOvsTable</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">final</span> com.zhang.odl_sflow.entity.odlentity.tableflow.<span class="hljs-type">JsonRootBean</span> <span class="hljs-variable">flowInfo</span> <span class="hljs-operator">=</span> odlService.getFlowInfo(<span class="hljs-string">&quot;openflow:1&quot;</span>);<br>        <span class="hljs-keyword">final</span> List&lt;HostAndOvs&gt; hostInformation = RInfo.getHostInformation(odlService.getHostInfo());<br>        <span class="hljs-keyword">return</span> ResultUtils.success(hostInformation,<span class="hljs-string">&quot;获取流表信息成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4.常用注解"></a>4.常用注解</h2><p><strong>@Api</strong> 标识⼀个java类型是⽂档类，⽤controller类的类名上<br><strong>@ApiMode</strong>l 表⽰⼀个实体类&#x2F;模型⽂档，⽤在类名上；<br><strong>@ApiModelProperty</strong> 作⽤在属性上，添加属性描述；<br><strong>@ApiOperation</strong> 作⽤在接⼝类的⽅法上，控制⽅法的相关描述；<br><strong>@ApiImplicitParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，只能作⽤在⽅法上；<br><strong>@ApiImplicitParams</strong> 作⽤在接⼝⽅法上，@ApiImplicitParam参数组；<br><strong>@ApiParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，属性基本与@ApiImplicitParam⼀样，但可以作⽤在⽅法、参数、属性上；<br>下⾯分别对每个注解的常⽤参数作讲解。<br><strong>@Api</strong>：<br>value：字符串，对controller类的作⽤描述，代替原来的description(已过时)，⼀般⽤此属性；<br>tags：字符串数组，标签组，同样可以描述controller的作⽤；<br><strong>@ApiModel</strong><br>value：字符串，模型的简短别名，使得在⽂档的导航中便于识别；<br>description：字符串，模型的附加描述；<br><strong>@ApiOperation</strong><br>value：字符串，⽅法的功能描述；<br>tags：字符串数组，标签组，同样可以描述⽅法的作⽤；<br>response：ClassType，显⽰指出返回的对象类型；在响应⽰例中会显⽰出改对象的字段以及⽰例、描述；<br>code：响应代码，默认200，⼀般不改；<br><strong>@ApiModelProperty</strong><br>value：字符串，字段描述；<br>required：boolean；指定参数是否必须，默认false；<br>example：字符串，参数值的⽰例<br><strong>@ApiImplicitParam</strong><br>name：字符串，参数名；<br>value：字符串，参数描述；<br>defaultValue：字符串，参数默认值；<br>required：boolean，标识是否必须传值，默认false；<br>dataType：字符串，参数类型，可以是某个类名，也可以是基本数据类型的引⽤类名，如Integer；<br>example：字符串，参数值⽰例；<br><strong>@ApiImplicitParams</strong></p><p>value：@ApiImplicitParam类型数组，当⽅法有多个@ApiImplicitParam参数时，需要放到@ApiImplicitParams注解中</p><h2 id="5-访问端口："><a href="#5-访问端口：" class="headerlink" title="5.访问端口："></a>5.访问端口：</h2><p><code>http://IP:SpirngBoot工程端口/swagger-ui.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914031.png" alt="image-20220703093631903"></p><p>如果有强迫症不要basic-error-cotroller的话改下配置类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<span class="hljs-comment">// 对所有api进行监控</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.zhang.odl_sflow.controller&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问就没有了basic-error-cotroller了</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914990.png" alt="image-20220703093825196"></p><h2 id="高版本SpringBoot报错："><a href="#高版本SpringBoot报错：" class="headerlink" title="高版本SpringBoot报错："></a>高版本SpringBoot报错：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.context.ApplicationContextException: Failed to start bean <span class="hljs-string">&#x27;documentationPluginsBootstrapper&#x27;</span>; nested exception is java.lang.NullPointerException<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">181</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.access$<span class="hljs-number">200</span>(DefaultLifecycleProcessor.java:<span class="hljs-number">54</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:<span class="hljs-number">356</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at java.lang.Iterable.forEach(Iterable.java:<span class="hljs-number">75</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:<span class="hljs-number">155</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:<span class="hljs-number">123</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:<span class="hljs-number">935</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="hljs-number">586</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="hljs-number">147</span>) ~[spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="hljs-number">734</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="hljs-number">408</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">308</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1306</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1295</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at com.zhang.odl_sflow.OdlSFlowApplication.main(OdlSFlowApplication.java:<span class="hljs-number">11</span>) [classes/:na]<br>Caused by: java.lang.NullPointerException: <span class="hljs-literal">null</span><br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">112</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">109</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.ComparatorOrdering.compare(ComparatorOrdering.java:<span class="hljs-number">37</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at java.util.TimSort.countRunAndMakeAscending(TimSort.java:<span class="hljs-number">355</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.TimSort.sort(TimSort.java:<span class="hljs-number">220</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.Arrays.sort(Arrays.java:<span class="hljs-number">1438</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at com.google.common.collect.Ordering.sortedCopy(Ordering.java:<span class="hljs-number">855</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:<span class="hljs-number">57</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">138</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">135</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.Iterators$<span class="hljs-number">7.</span>transform(Iterators.java:<span class="hljs-number">750</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">52</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">50</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">249</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">209</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.FluentIterable.toList(FluentIterable.java:<span class="hljs-number">614</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.defaultContextBuilder(DocumentationPluginsBootstrapper.java:<span class="hljs-number">111</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.buildContext(DocumentationPluginsBootstrapper.java:<span class="hljs-number">96</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:<span class="hljs-number">167</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">178</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>... <span class="hljs-number">14</span> common frames omitted<br><br></code></pre></td></tr></table></figure><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>这个问题困扰了我很久，也在网上找了好多资料，也有些人说springboot版本升级的导致的问题。<br>找到的解决办法有两种：</p><ol><li>将springboot降级到2.5.7，但这也只是暂时解决问题的办法，不是长久之计；</li><li>从SpringFox迁移到SpringDoc，这种方式虽然可以处理问题，但对于已经上线的项目来说改动量还是有点大。<br>这上面两种解决方案都不是我最想要的，最近对Spring Boot 2.6.0的文档进行研究发现，2.6.0开始使用基于PathPatternParser的路径匹配，而Springfox版本一直没有更新还是使用的AntPathMatcher导致了这个问题，要处理问题也很简单，修改yaml文件，将SpringBoot路劲匹配模式修改为AntPathMatcher就可以了，配置如下：spring.mvc.pathmatch.matching-strategy&#x3D;ANT_PATH_MATCHER</li></ol><p>修改application.yml文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><h1 id="SpringBoot整合Kenife4j"><a href="#SpringBoot整合Kenife4j" class="headerlink" title="SpringBoot整合Kenife4j"></a>SpringBoot整合Kenife4j</h1><h2 id="1-导包-1"><a href="#1-导包-1" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;<br>   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;<br>   &lt;version&gt;3.0.3&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-新建配置类"><a href="#2-新建配置类" class="headerlink" title="2.新建配置类"></a>2.新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 必须启用swagger</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@EnableKnife4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">defaultApi2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2) <span class="hljs-comment">// 选择swagger2版本</span><br>                .useDefaultResponseMessages(<span class="hljs-literal">false</span>)<br>                <span class="hljs-comment">// 接口文档的基本信息</span><br>                .apiInfo(apiInfo())<br>                .select()<br>                <span class="hljs-comment">// 这里指定Controller扫描包路径(项目路径也行)</span><br>                <span class="hljs-comment">// 方式一：配置扫描：所有想要在swagger界面统一管理的接口，都必须在此包下</span><br>                <span class="hljs-comment">// .apis(RequestHandlerSelectors.basePackage(&quot;com.company.project.web.controller.entrance&quot;))</span><br>                <span class="hljs-comment">// 方式二：只有当方法上有@ApiOperation注解时，才能生成对应的接口文档</span><br>                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))<br>                <span class="hljs-comment">// 路径使用any风格（指定所有路径）</span><br>                .paths(PathSelectors.any())<br>                .build();<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置文档信息主页的内容说明</span><br><span class="hljs-comment">     * @param:</span><br><span class="hljs-comment">     * @return: springfox.documentation.service.ApiInfo 文档信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;接口项目 后台服务API接口文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;服务相关接口(knife4j)&quot;</span>)<br>                <span class="hljs-comment">// 服务Url（网站地址）</span><br>                .termsOfServiceUrl(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;liziyuan&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;mc1753343931&quot;</span>))<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-添加注解"><a href="#3-添加注解" class="headerlink" title="3.添加注解"></a>3.添加注解</h2><p>同Swagger</p><h2 id="4-访问端口"><a href="#4-访问端口" class="headerlink" title="4.访问端口"></a>4.访问端口</h2><p><code>http://IP:SpirngBoot工程端口/doc.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914933.png" alt="image-20220713093946919"></p><h2 id="5-报错解决方案"><a href="#5-报错解决方案" class="headerlink" title="5.报错解决方案"></a>5.报错解决方案</h2><p>同Swagger</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/"/>
    <url>/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务-Seata"><a href="#分布式事务-Seata" class="headerlink" title="分布式事务-Seata"></a>分布式事务-Seata</h1><h2 id="一、本地事务"><a href="#一、本地事务" class="headerlink" title="一、本地事务"></a>一、本地事务</h2><blockquote><p>在<code>JavaEE</code>企业级开发的应用领域，为了<strong>保证数据</strong>的<strong>完整性</strong>和<strong>一致性</strong>，必须引入数据库事务的概念，所以事务管理是企业级应用程序开发中必不可少的技术。</p><p>所谓<strong>本地事务</strong>，是指在单个数据源上进行数据的访问和更新，它<strong>仅在当前工程内有效</strong>。</p></blockquote><h3 id="1-1-ACID特性"><a href="#1-1-ACID特性" class="headerlink" title="1.1 ACID特性"></a>1.1 ACID特性</h3><ul><li>数据库事务的四大<strong>特性</strong>：原子性(<code>Atomicity</code> )、一致性( <code>Consistency</code> )、隔离性或独立性( <code>Isolation</code>) 和持久性(<code>Durabilily</code>)，简称就是 <code>ACID</code>。<ul><li><strong>原子性</strong>：一系列的操作整体不可拆分，要么同时成功，要么同时失败。</li><li><strong>一致性</strong>：数据在事务的前后，业务整体一致。</li><li><strong>隔离性</strong>：事务之间互相隔离。</li><li><strong>持久性</strong>：一旦事务成功，数据一定会落盘在数据库。</li></ul></li><li>在以往的单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易地整体回滚。就比如买东西业务，扣库存，下订单，账户扣款，是一个整体，<strong>必须同时成功或者失败</strong>。一个事务开始，代表以下的<strong>所有操作</strong>都在<strong>同一个连接</strong>里面。</li></ul><h3 id="1-2-隔离级别"><a href="#1-2-隔离级别" class="headerlink" title="1.2 隔离级别"></a>1.2 隔离级别</h3><ul><li><code>READ UNCOMMITTED</code>（<strong>脏读</strong>）：该隔离级别的事务会<strong>读到其它未提交事</strong>务的数据。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203395.webp" alt="image-20220709182208960"></p><ul><li><code>READ COMMITTED</code>（<strong>不可重复读</strong>）：一个事务可以读取另一个已提交的事务，<strong>多次读取会造成不一样的结果</strong>。<code>Oracle</code> 和 <code>SQL Server</code> 的默认隔离级别。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203393.webp" alt="image-20220709183324143"></p><ul><li><code>REPEATABLE READ</code>（<strong>虚读&#x2F;幻读</strong>）：该隔离级别是 <code>MySQL</code> 默认的隔离级别，一个事务可以<strong>读取另一个事务已提交的数据</strong>，<strong>读取的数据前后相比多了点或者少了点</strong>。<code>MySQL</code> 的 <code>InnoDB</code> 引擎可以通过<code>next-key locks</code> 机制来避免<strong>幻读</strong>。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709185135362"></p><ul><li><code>SERIALIZABLE</code>（<strong>序列化</strong>）：这是数据库<strong>最高的隔离级别</strong>，在该隔离级别下事务都是<strong>串行顺序执行</strong>的，<code>MySQL</code> 数据库的 <code>InnoDB</code> 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题，但是<strong>执行效率差</strong>，性能开销也最大，所以基本没人会用。</li></ul><h3 id="1-3-事务的传播行为"><a href="#1-3-事务的传播行为" class="headerlink" title="1.3 事务的传播行为"></a>1.3 事务的传播行为</h3><ul><li><strong>PROPAGATION_REQUIRED</strong>： ：如果当前<strong>没有</strong>事务，就<strong>创建</strong>一个新事务，如果当前<strong>存在</strong>事务，就<strong>加入</strong>该事务，该设置是<strong>最常用的设置</strong>。</li><li>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：：创建新事务，<strong>无论当前存不存在事务，都创建新事务</strong>。</li><li>PROPAGATION_NOT_SUPPORTED：：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： ：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED： ：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li><li>七种事务传播机制<strong>最常用</strong>的就<strong>两种</strong>：<ul><li>REQUIRED：一个事务，要么成功，要么失败。</li><li>REQUIRES_NEW：两个不同事务，彼此之间没有关系。一个事务失败了不影响另一个事务。</li></ul></li></ul><h3 id="1-4-本地事务在分布式下的问题"><a href="#1-4-本地事务在分布式下的问题" class="headerlink" title="1.4 本地事务在分布式下的问题"></a>1.4 本地事务在分布式下的问题</h3><p><strong>1.4.1 问题一：远程服务假失败</strong></p><ul><li>远程服务其实成功了，由于网络故障没有返回，导致订单回滚，库存却扣减。</li><li>假失败就是我们在订单服务调库存服务时， <strong>库存锁定成功</strong>，然后由于<strong>服务器</strong>慢、卡顿、等<strong>故障</strong>原因，本地事务提交了之后，<strong>一直没返回</strong>到订单服务。此时再看订单服务，因为调用库存服务时间太长了，库存服务迟迟没有返回结果，可能就会<strong>触发</strong> <code>feign</code> 的<strong>超时机制</strong>，在调用远程服务这里<strong>抛异常</strong>：<code>read time out</code> 读取超时，但是这个异常并不是我们手动抛的锁库存异常，而是 <code>feign</code> 的异常并且订单服务，设计的回滚机制，是只要<strong>一出现异常就会全部回滚</strong>，导致最终<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709064805120"></p><p><strong>1.4.2 问题二：调用新服务出现异常之后，已经执行的服务不会回滚</strong></p><ul><li>假设库存锁定成功，将结果返回到了订单服务，我们根据结果又调用了积分服务，让它扣减积分，结果<strong>积分服务</strong>内部出现<strong>异常</strong>，积分数据回滚此时再看订单服务，<strong>订单服务感知到</strong>我们手动抛的<strong>积分异常</strong>，订单数据回滚，但是<strong>库存服务</strong>，却<strong>不会有任何感知</strong>。其结果就是<strong>积分、订单数据全部回滚，库存给锁定了</strong>，也是<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203387.webp" alt="image-20220709064934354"></p><p><strong>1.4.3 总结</strong>：</p><ul><li><strong>本地事务</strong>，在分布式系统，<strong>只能控制住自己的回滚</strong>，控制不了其它服务的回滚。</li><li>产生<strong>分布式事务问题</strong>的最大原因，就是<strong>网络问题</strong> + <strong>分布式机器</strong>。</li></ul><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">假设我们有一个下单的事务场景，它会涉及调用库存、订单、会员功能。<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>在<strong>单体应用</strong>下，我们将三个功能的代码写到一个系统，而且都是连接同一数据库，这样的话很容易就能控制事务，若其中一个失败，则整个事务都会回滚。</li><li>而在<strong>分布式系统</strong>下，我们拆分了很多的微服务，它们都是独立部署且每个服务都有自己操作的数据库，那这样我们想要完成整个下单逻辑，我们就要远程调用这三个机器的各个方法。</li><li>但是，由于分布式系统会<strong>经常出现</strong>机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…等<strong>异常情况</strong>。所以，<strong>分布式事务</strong>是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是<strong>无法避免</strong>。</li></ul><h2 id="三、相关概述及理论"><a href="#三、相关概述及理论" class="headerlink" title="三、相关概述及理论"></a>三、相关概述及理论</h2><h3 id="3-1-CAP理论"><a href="#3-1-CAP理论" class="headerlink" title="3.1 CAP理论"></a>3.1 CAP理论</h3><blockquote><p><code>CAP</code> 指的是一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。</p><p><code>CAP</code> 原则指的是，这三个要素<strong>最多</strong>只能<strong>同时实现两点</strong>，<strong>不可能三者兼顾</strong>。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203402.webp" alt="image-20220709071207113"></p><ul><li><p>一致性</p><p>（Consistency）：</p><ul><li>在分布式系统中的<strong>所有数据备份</strong>，在<strong>同一时刻</strong>是否<strong>同样的值</strong>。（等同于所有节点访问同一份最新的数据副本）。</li><li>比如我们有三个节点，当我给节点1保存了值，那么我再请求节点2、3的数据时，响应的数据也应该是这个最新的值。</li></ul></li><li><p>可用性</p><p>（Availability） ：</p><ul><li>在集群中一<strong>部分节点故障</strong>后，集群<strong>整体是否还能响应</strong>客户端的读写请求。（对数据更新具备高可用性）。</li></ul></li><li><p>分区容错性</p><p>（Partition Tolerance） ：</p><ul><li>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是<strong>区间通信可能失败</strong>。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</li></ul></li></ul><h3 id="3-2-CAP为什么不能三者兼顾？"><a href="#3-2-CAP为什么不能三者兼顾？" class="headerlink" title="3.2 CAP为什么不能三者兼顾？"></a>3.2 CAP为什么不能三者兼顾？</h3><ul><li><strong>满足一致性</strong>：假设我们有三个节点，当客户端有一个请求进来，我们所有的节点完成数据备份，此时满足了我们的一致性<code>C</code>的需求。</li><li><strong>可用性与一致性冲突</strong>：再次假设，当节点1向节点2、3要求同步备份数据时，此时节点3发生了网络故障，也就是分区容错性。接下来我们就会考虑，能否<strong>满足可用性</strong>？若让其满足的话（允许客户端请求负载到节点3读取数据），但是由于上次发生故障导致节点3的数据没有更新，则此时<strong>读到的数据</strong>就出现了<strong>不一致</strong>。所以当你想要满足一致性，就必须让节点3不能被访问，既然不能被访问相当于又不可用。**<code>C</code>和<code>A</code>无法同时做到**。</li><li>在<strong>分布式系统</strong>里，因为我们这个<strong>网络肯定会出现问题</strong>，所以我们<strong>永远都要满足分区容错</strong>。则就需要在一致性与可用性做出选择。</li><li>选择可用性+分区容错性（<code>AP</code>）的情况下，我们不去在意读到的数据是否一致，这种场景实现相对简单。</li><li>若选择一致性+分区容错性（<code>CP</code>）的情况下，是如何保证它们之间一致的？我们在分布式系统里边一般会有一些<strong>一致性算法</strong>，典型的代表，比如说Google的Chubby分布式锁服务，采用了<code>Paxos</code>算法；etcd分布式键值数据库，采用了<code>Raft</code>算法；ZooKeeper分布式应用协调服务，Chubby的开源实现，采用<code>ZAB</code>算法。</li></ul><h3 id="3-3-Raft算法实现分布式系统一致性"><a href="#3-3-Raft算法实现分布式系统一致性" class="headerlink" title="3.3 Raft算法实现分布式系统一致性"></a>3.3 Raft算法实现分布式系统一致性</h3><ul><li>由于 <code>Paxos</code> 算法过于晦涩难懂且难以实现，后提出了一种更<strong>易于理解</strong>和实现并能等价于 <code>Paxos</code> 算法<strong>的共识算法</strong> - <code>Raft </code>算法。</li><li><code>Raft</code> 算法有<strong>两个核心概念</strong>：<ul><li><strong>领导选举</strong>（关注角色、心跳时间、自旋时间）-&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">Leader的选举过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">acehi.github.io&#x2F;thesecretli…</a></li><li><strong>日志复制</strong> -&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">日志复制过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">acehi.github.io&#x2F;thesecretli…</a></li></ul></li><li>通过它们来保证我们整个集群的一致性，即使有分区错误，我们也能保持一致性。</li></ul><h3 id="3-4-Base理论"><a href="#3-4-Base理论" class="headerlink" title="3.4 Base理论"></a>3.4 Base理论</h3><blockquote><p>是对 <code>CAP</code> 理论的延伸，思想是即使无法做到强一致性（<code>CAP</code> 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。</p></blockquote><ul><li>强一致与弱一致是<strong>对立</strong>概念。<strong>强一致性</strong>也叫做<strong>线性一致性</strong>，除此以外，所有其它的一致性都是弱一致性的特殊情况。所谓强一致性，即数据备份是<strong>同步</strong>的，<strong>弱一致性</strong>，即数据备份是<strong>异步</strong>的。</li><li><strong>基本可用</strong>（Basically Available）：指分布式系统在出现故障的时候，<strong>允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，基本可用绝<strong>不等价于系统不可用</strong>。就比如：<ul><li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒（查询故障节点不行，就换其它机器进行查询，允许查询速度慢一点）。</li><li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><strong>软状态</strong>（ Soft State） ：指允许系统存在<strong>中间状态</strong>，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的<strong>延时</strong>就是软状态的体现。<code>MySQL Replication</code> 的异步复制也是一种体现。</li><li><strong>最终一致性</strong>（ Eventual Consistency）：指系统中的所有数据副本<strong>经过一定时间</strong>后，最终能够<strong>达到一致</strong>的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h2 id="四、常见解决方案"><a href="#四、常见解决方案" class="headerlink" title="四、常见解决方案"></a>四、常见解决方案</h2><h3 id="4-1-2PC-模式"><a href="#4-1-2PC-模式" class="headerlink" title="4.1 2PC 模式"></a>4.1 2PC 模式</h3><blockquote><p><code>2PC</code> 就是我们说的<strong>二阶段提交</strong>，又叫做 <code>XA Transactions</code>。<code>MySQL</code> 从 5.5 版本开始支持，<code>SQL Server</code> 2005 开始支持，<code>Oracle</code> 7 开始支持。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203435.webp" alt="image-20220709074848470"></p><ul><li>假设我们这有一个本地资源管理器（相当于每个服务的事务管理器），一个事务管理器（相当于总的事务管理器）。</li><li>协调事务处理共为<strong>两个阶段</strong>：<ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交</strong>（<code>PreCommit</code>）此操作，并<strong>反映是否可以提交</strong>。</li><li>第二阶段：事务协调器<strong>要求</strong>每个数据库<strong>提交数据</strong>。</li><li>其中，如果有<strong>任何一个</strong>数据库<strong>否决</strong>此次提交，那么所有数据库都会被要求<strong>回滚</strong>它们在此事务中的那部分信息。</li></ul></li><li><strong>优点</strong>：<ul><li><code>XA 协议</code>比较<strong>简单</strong>，而且一旦商业数据库实现了 <code>XA 协议</code>，使用分布式事务的成本也比较低。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>性能不理想</strong>，特别是在交易下单链路，往往并发量很高，无法满足高并发场景。</li><li>目前在商业数据库支持的比较理想，在 <strong>mysql 数据库中支持的不太理想</strong>，<code>mysql</code> 的 <code>XA</code> 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</li><li>许多 <code>nosql</code> 也没有支持 <code>XA</code>，这让 <code>XA</code> 的<strong>应用场景</strong>变得<strong>非常狭隘</strong>。</li></ul></li><li><strong>总结</strong>：了解即可，使用场景非常少。</li></ul><h3 id="4-2-3PC-模式"><a href="#4-2-3PC-模式" class="headerlink" title="4.2 3PC 模式"></a>4.2 3PC 模式</h3><blockquote><p>三阶段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一个<strong>改良版本</strong>，引入了两个新的特性。</p></blockquote><ul><li>协调者和参与者均<strong>引入超时机制</strong>，通过超时机制来解决 <code>2PC</code> 的同步阻塞问题，<strong>避免事务</strong>资源<strong>被永久锁定</strong>。</li><li>把二阶段演变为三阶段，二阶段提交协议中的第一阶段”准备阶段”一分为二，形成了新的 <code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code> 三个阶段组成事务处理协议。</li><li><strong>优点</strong>：<code>3PC</code> 相比较于 <code>2PC</code> 最大的优点就是<strong>降低了参与者的阻塞范围</strong>，并且能够在协调者出现<strong>单点故障后继续达成一致</strong>。</li><li><strong>缺点</strong>：虽然通过超时机制解决了资源永久阻塞的问题，但是 <code>3PC</code> <strong>依然存在数据不一致的问题</strong>。当参与者接收到 <code>PreCommit</code> 消息后，如果网络出现分区，此时协调者与参与者无法进行正常通信，这种情况下，参与者依然会进行事务的提交。</li><li><strong>总结</strong>：通过了解 <code>2PC</code> 和 <code>3PC</code> 之后，我们可以知道这<strong>两种方案都无法彻底解决分布式下的数据一致性</strong>。</li></ul><h3 id="4-3-柔性事务-TCC-事务补偿方案"><a href="#4-3-柔性事务-TCC-事务补偿方案" class="headerlink" title="4.3 柔性事务-TCC 事务补偿方案"></a>4.3 柔性事务-TCC 事务补偿方案</h3><blockquote><p>补偿事务<code>TCC</code>，全称<code>Try-Confirm-Cancel</code>。</p></blockquote><ul><li><strong>什么是柔性事务</strong>？<ul><li>刚性事务：遵循 <code>ACID</code> 原则，强一致性。</li><li>柔性事务：遵循 <code>BASE</code> 理论，最终一致性。与刚性事务不同，柔性事务<strong>允许一定时间</strong>内，不同节点的数据<strong>不一致</strong>，<strong>但要求最终一致</strong>。</li></ul></li><li><strong>TCC核心思想</strong>：针对每个操作都要注册一个与其对应的确认（<code>Try</code>）和补偿（<code>Cancel</code>）。<ul><li><strong>Try阶段</strong>：做一些<strong>业务检查</strong>以及一些资源预留，它需要后续的<code>Confirm</code>一起才能构成一个完成的业务逻辑。</li><li><strong>Comfirm阶段</strong>：<strong>确认提交</strong>，<code>Try</code> 阶段所有分支事务执行成功后开始执行 <code>Confirm</code> 。</li><li><strong>Cancel阶段</strong>：业务执行出错需要<strong>回滚</strong>。</li></ul></li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203449.webp" alt="image-20220709082734127"></p><ul><li><p>总结</p><p>：</p><ul><li><code>2PC</code> 通常是在跨库<code>DB</code>里，而 <code>TCC</code> 是在<strong>应用层</strong>面。</li><li><code>TCC</code> 每个业务逻辑代码都要实现<code>Try</code>、<code>Confirm</code>、<code>Cacnel</code>接口，<strong>开发难度大</strong>，所以所对<strong>应用的倾入性非常强</strong>。</li></ul></li></ul><h3 id="4-4-柔性事务-最大努力通知方案"><a href="#4-4-柔性事务-最大努力通知方案" class="headerlink" title="4.4 柔性事务-最大努力通知方案"></a>4.4 柔性事务-最大努力通知方案</h3><blockquote><p>方案主要用在<strong>与第三方系统通讯</strong>时，比如：调用微信或支付宝支付后的支付结果通知。这种 方案也是结合 <code>MQ</code> 进行实现，例如：通过 <code>MQ</code> 发送 <code>http</code> 请求，<strong>设置最大通知次数</strong>，<strong>达到通知次数后即不再通知</strong>。</p></blockquote><ul><li><strong>应用场景</strong>：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对 账文件），支付宝的支付成功异步回调。</li><li><strong>案例说明</strong>：我们现在有一个大业务，调用了积分、库存和订单业务。当订单和库存都执行结束，但是在做用户积分扣减时<strong>失败</strong>了，然后订单模块就会<strong>发送一条消息</strong>给 <code>MQ</code>。接下来由订阅了消息队列的订单及库存服务接收消息，当它们都<strong>收到消息后</strong>，库存服务就会解锁库存，订单服务就会解锁订单，<strong>完成事务的回滚</strong>。既然是最大努力通知，期间就会<strong>不断发送</strong>业务处理失败的消息，<strong>直至</strong>对应业务<strong>返回处理成功</strong>的消息，<strong>就不再进行通知</strong>了。</li></ul><h3 id="4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul><li><strong>实现</strong>：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，<strong>实时消息服务只记录消息数据</strong>，而不是真正的发送。业务处理服务在<strong>业务事务提交之后</strong>，向实时消息服务<strong>确认发送</strong>。只有在得到确认发送指令后，实时消息服务<strong>才会真正发送</strong>。</li><li><strong>关键点</strong>（防止消息丢失）：<ul><li>做好消息确认机制 <code>Publisher</code>，<code>Consumer</code> 手动 <code>ack</code>。</li><li>每一个发送的消息都在数据库做好记录，定期将失败的消息再次发送一遍。</li></ul></li><li><strong>消息记录表</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mq_message` (<br>`message_id` <span class="hljs-type">CHAR</span> ( <span class="hljs-number">32</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br>`to_exchane` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`routing_key` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`class_type` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`message_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">1</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,<br>`create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `message_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="五、分布式事务框架-Seata"><a href="#五、分布式事务框架-Seata" class="headerlink" title="五、分布式事务框架-Seata"></a>五、分布式事务框架-Seata</h2><blockquote><p><code>Seata</code> 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。<code>Seata</code> 将为用户提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h3 id="5-1-核心概念及原理"><a href="#5-1-核心概念及原理" class="headerlink" title="5.1 核心概念及原理"></a>5.1 核心概念及原理</h3><ul><li>TC - 事务协调者：维护全局和分支事务的状态，<strong>驱动</strong>全局事务<strong>提交或回滚</strong>。</li><li>TM - 事务管理器：<strong>定义全局</strong>事务的<strong>范围</strong>（开始全局事务、提交或回滚全局事务）。</li><li>RM - 资源管理器：<strong>管理分支</strong>事务处理的<strong>资源</strong>，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li><li><strong>工作原理</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203454.webp" alt="image-20220709125044911"></p><ul><li><p>流程描述</p><p>：</p><ul><li>假设我们现在要执行一个大的下单业务 Business，<strong>大业务</strong>的 <code>TM</code>（事务管理器）先会告诉 <code>TC</code>（事务协调者）它要准备跨服<strong>开启</strong>一个<strong>全局事务</strong>。</li><li>开始全局事务后，接下来它调用第一个微服务的事务方法的时候，Storage 服务就会在 <code>TC</code>（事务协调者）<strong>注册</strong>一下，我们称为<strong>分支事务</strong>。相当于它的 <code>RM</code>（资源管理器）会告诉 <code>TC</code>（事务协调者），它有一个分支事务，并且它要实时<strong>汇报</strong>它的<strong>事务状态</strong>，它这个分支是提交成功还是失败回滚， <code>TC</code>（事务协调者）都能实时的知道。</li><li>接下来调我们第二个远程服务 Order，及第三个远程服务 Account也是同理注册分支事务，并且实时汇报状态。</li><li><strong>大事务只要一开启</strong>，每调一个小事务，<code>TC</code>（事务协调者）<strong>都知道</strong>这个<strong>小事务成了还是败了</strong>。</li><li>假设其中最后一个分支事务失败了，需要进行回滚。这个时候，<code>TC</code>（事务协调者）知道我们的大事务，已经调成功两个了，并且前两个事务都已经提交了，但是第三个事务给回滚了，<code>TC</code>（事务协调者）就会<strong>命令前两个事务也回滚</strong>。</li></ul></li></ul><h3 id="5-2-AT模式"><a href="#5-2-AT模式" class="headerlink" title="5.2 AT模式"></a>5.2 AT模式</h3><p><strong>5.2.1 相关概念</strong>：</p><ul><li><code>AT</code>模式（自动事务Auto Transaction）是<code>Seata</code>最<strong>主推的</strong>分布式事务解决方案，它是基于<code>XA</code>演进而来。</li><li><code>AT</code> 模式是一种<strong>无侵入</strong>的分布式事务解决方案，也就是说我们<strong>不需要再编写多余的代码来实现</strong>这个模式，<strong>只需要</strong>在方法中<strong>添加上指定的注解</strong>即可。</li><li>在 AT 模式下，用户只需关注自己的“业务 <code>SQL</code>”，用户的 “业务 <code>SQL</code>” 作为一阶段，<code>Seata</code> 框架会<strong>自动生成</strong>事务的<strong>二阶段提交和回滚</strong>操作。</li><li>AT模式支持的数据库有：<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>和 <code>TiDB</code>。</li></ul><p><strong>5.2.2 模式概述</strong>：</p><ul><li><p><strong>前提</strong>：我们如果要使用该模式，那么<strong>每一个</strong>要使用分布式事务的<strong>数据库</strong>都需要一个 <code>UNDO_LOG</code> 表（即回滚日志表）。</p></li><li><p><strong>效果</strong>：该模式下 <code>TC</code>（事务协调者） 只要调分支事务，<strong>成功</strong>之后就会<strong>提交事务</strong>，但是如果有一个分支事务<strong>失败</strong>了，失败的这个可以<strong>自己进行回滚</strong>。</p></li><li><p>处理逻辑</p><p>：</p><ul><li>某个服务除了它常规的业务表以外，我们会额外去创建一个回滚日志表。它是在<code>RM</code>（资源管理器）部分完成的，会在<strong>每一个数据库单元处理时</strong>均会生成一条<code>log</code>数据。</li><li>对于已提交的事务要进行回滚，它会利用<strong>魔改数据库进行反向补偿</strong>。比如：我们这有条加二的记录，原来它的值是八，加二以后变成十，结果被人给回滚了。</li><li>它先在 <code>UNDO_LOG</code> 里面记录了一下这条<strong>记录没改变之前的值</strong>。如果它失败回滚了，那它就回过头把我们数据库里边的这个十再改回去，改成八。所以，它相当于在我们事务执行之前，它先读取一下这个状态是几，最后再改回来。</li></ul></li></ul><h3 id="5-3-Seata-服务搭建"><a href="#5-3-Seata-服务搭建" class="headerlink" title="5.3 Seata 服务搭建"></a>5.3 Seata 服务搭建</h3><p><strong>5.3.1 组件版本关系</strong>：</p><blockquote><p>每个 <code>Spring Cloud Alibaba</code> 版本及其自身所适配的各组件对应版本如下表所示（<strong>避免版本不兼容</strong>带来未知问题）。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203640.webp" alt="image-20220708081609199"></p><p><strong>5.3.2 Docker下安装 Seata</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.下载镜像（注意：此处版本号请参考组件版本关系图！）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.启动容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name seata-server -p 8091:8091 seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.创建存放配置的文件夹。</span><br>mkdir -p /home/seata/config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.拷贝配置文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> seata-server:/seata-server/resources /home/seata/config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.编辑配置文件（参考下面截图）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home/seata/config/resources</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim registry.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在registry.conf指定seata配置的位置（config &#123;<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;nacos&quot;</span>&#125;）。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在file.conf中指定事务日志存储类型（store &#123;mode = <span class="hljs-string">&quot;db&quot;</span>&#125;），若使用mysql-8版本则需要额外修改以下两项配置，否则报错。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">driverClassName = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata?serverTimezone=UTC&quot;</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203629.webp" alt="image-20220708100915057"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">6.停止容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.移除旧容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">8.启动新容器并挂载配置。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d \</span><br><span class="language-bash">--name seata-server \</span><br><span class="language-bash">-p 8091:8091 \</span><br><span class="language-bash">-e SEATA_IP=yourIp（公网IP） \</span><br><span class="language-bash">-v /home/seata/config/resources:/seata-server/resources \</span><br><span class="language-bash">seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker update seata-server --restart=always</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.3.3 验证Seata服务启动成功</strong>：</p><ul><li>查看容器日志（Server started …）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs seata-server</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>访问注册中心后台（成功注册）：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">http://yourIp:8848/nacos<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203674.webp" alt="image-20220708101405016"></p><h3 id="5-4-项目整合"><a href="#5-4-项目整合" class="headerlink" title="5.4 项目整合"></a>5.4 项目整合</h3><p><strong>5.4.1 数据库添加 UNDO_LOG 表</strong>：</p><blockquote><p>每一个要使用分布式事务的数据库都需要一个 <code>UNDO_LOG</code> 表。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log` (<br>`id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`branch_id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`xid` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`context` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`rollback_info` LONGBLOB <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_created` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`ext` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br><span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` ( `xid`, `branch_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li><code>branch_id</code>：分支事务ID。</li><li><code>xid</code>：全局事务ID（<code>Seata</code> 服务端地址+ ID）。</li><li><code>context</code>：回滚信息序列化和压缩格式。</li><li><code>rollback_info</code>：回滚信息。</li><li><code>log_status</code>：日志状态（<code>0</code>表示正常，<code>1</code>表示全局已完成）。</li><li><code>log_created</code>：创建时间。</li><li><code>log_modified</code>：修改时间。</li></ul><p><strong>5.4.2 依赖引入</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">        <span class="hljs-comment">&lt;!--需要分布式事务的服务引入 seata-starter--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.3 配置代理数据源</strong>：</p><blockquote><p>配置代理数据源实现分支事务，如果没有注入，事务无法成功回滚。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySeataConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DataSourceProperties dataSourceProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要将 DataSourceProxy 设置为主数据源，否则事务无法回滚。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSourceProperties 数据源属性配置。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> DataSource&#125;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(DataSourceProperties dataSourceProperties)</span> &#123;<br><br>        <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> dataSourceProperties.initializeDataSourceBuilder()<br>                .type(HikariDataSource.class).build();<br><br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(dataSourceProperties.getName())) &#123;<br>            dataSource.setPoolName(dataSourceProperties.getName());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceProxy</span>(dataSource);<br>    &#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.4 微服务中添加配置文件</strong>：</p><blockquote><p><strong>方式一</strong>（此处使用）：<strong>每个</strong>要使用分布式事务的<strong>微服务</strong>服务中（<code>src/main/resources/</code>），都要添加这两个文件（<code>registry.conf</code>、<code>file.conf</code>）。</p><p><strong>方式二</strong>：也可以将 <code>Nacos</code> 作为统一配置中心，去配置 <code>Seata</code> 的 <code>file.conf</code> 各项参数，实现集群的配置共享，并结合 <code>application.properties/yml</code> + <code>registry.conf</code> 完成微服务整合。</p></blockquote><ul><li><code>registry.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---注册中心配置---</span><br><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="hljs-comment">  # 指定类型为nacos注册中心（根据项目所使用的注册中心进行选择），默认是&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">eureka</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serviceUrl</span> = <span class="hljs-string">&quot;http://localhost:1001/eureka&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">weight</span> = <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">redis</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:6379&quot;</span><br>    <span class="hljs-attr">db</span> = <span class="hljs-string">&quot;0&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">sofa</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:9603&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">region</span> = <span class="hljs-string">&quot;DEFAULT_ZONE&quot;</span><br>    <span class="hljs-attr">datacenter</span> = <span class="hljs-string">&quot;DefaultDataCenter&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">addressWaitTime</span> = <span class="hljs-string">&quot;3000&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---配置中心---</span><br><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="hljs-comment">  # 指定seata配置的位置，默认&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;file&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">apollo</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">app.id</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br>    <span class="hljs-attr">apollo.meta</span> = <span class="hljs-string">&quot;http://192.168.1.204:8801&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # 关联 `file.conf` 文件中配置的seata参数。</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><ul><li><code>file.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---网络传输配置---</span><br><span class="hljs-attr">transport</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # tcp udt unix-domain-socket</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;TCP&quot;</span><br><span class="hljs-comment">  #NIO NATIVE</span><br>  <span class="hljs-attr">server</span> = <span class="hljs-string">&quot;NIO&quot;</span><br><span class="hljs-comment">  #enable heartbeat</span><br>  <span class="hljs-attr">heartbeat</span> = <span class="hljs-string">true</span><br><span class="hljs-comment">  #thread factory for netty</span><br>  <span class="hljs-attr">thread-factory</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">boss-thread-prefix</span> = <span class="hljs-string">&quot;NettyBoss&quot;</span><br>    <span class="hljs-attr">worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerNIOWorker&quot;</span><br>    <span class="hljs-attr">server-executor-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerBizHandler&quot;</span><br>    <span class="hljs-attr">share-boss-worker</span> = <span class="hljs-string">false</span><br>    <span class="hljs-attr">client-selector-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientSelector&quot;</span><br>    <span class="hljs-attr">client-selector-thread-size</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">client-worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientWorkerThread&quot;</span><br><span class="hljs-comment">    # netty boss thread size,will not be used for UDT</span><br>    <span class="hljs-attr">boss-thread-size</span> = <span class="hljs-string">1</span><br><span class="hljs-comment">    #auto default pin or 8</span><br>    <span class="hljs-attr">worker-thread-size</span> = <span class="hljs-string">8</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">shutdown</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # when destroy server, wait seconds</span><br>    <span class="hljs-attr">wait</span> = <span class="hljs-string">3</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">serialization</span> = <span class="hljs-string">&quot;seata&quot;</span><br>  <span class="hljs-attr">compressor</span> = <span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---当前微服务在seata服务器中注册的信息配置---</span><br><span class="hljs-attr">service</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 事务分组，默认：$&#123;spring.applicaiton.name&#125;-fescar-service-group。</span><br>  <span class="hljs-attr">vgroup_mapping.applicaiton-name-fescar-service-group</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">  # 仅支持单节点，不要配置多地址，这里的default要和事务分组的值一致。</span><br>  <span class="hljs-attr">default.grouplist</span> = <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span><br><span class="hljs-comment">  # 降级，当前不支持。</span><br>  <span class="hljs-attr">enableDegrade</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  # 禁用全局事务。</span><br>  <span class="hljs-attr">disable</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br>  <span class="hljs-attr">max.commit.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br>  <span class="hljs-attr">max.rollback.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---客户端相关工作的机制---</span><br><span class="hljs-attr">client</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">async.commit.buffer.limit</span> = <span class="hljs-string">10000</span><br>  <span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">retry.internal</span> = <span class="hljs-string">10</span><br>    <span class="hljs-attr">retry.times</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">report.retry.count</span> = <span class="hljs-string">5</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---事务日志存储配置---</span><br><span class="hljs-comment"># 注意：该部分配置仅在seata-server中使用，如果选择db请配合seata.sql使用。</span><br><span class="hljs-comment">## transaction log store </span><br><span class="hljs-attr">store</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## store mode: file、db</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;file&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## file store</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br>    <span class="hljs-attr">max-branch-session-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # globe session size , if exceeded throws exceptions</span><br>    <span class="hljs-attr">max-global-session-size</span> = <span class="hljs-string">512</span><br><span class="hljs-comment">    # file buffer size , if exceeded allocate new buffer</span><br>    <span class="hljs-attr">file-write-buffer-cache-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # when recover batch read size</span><br>    <span class="hljs-attr">session.reload.read_size</span> = <span class="hljs-string">100</span><br><span class="hljs-comment">    # async, sync</span><br>    <span class="hljs-attr">flush-disk-mode</span> = <span class="hljs-string">async</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## database store</span><br>  <span class="hljs-attr">db</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br>    <span class="hljs-attr">datasource</span> = <span class="hljs-string">&quot;dbcp&quot;</span><br><span class="hljs-comment">    ## mysql/oracle/h2/oceanbase etc.</span><br>    <span class="hljs-attr">db-type</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br>    <span class="hljs-attr">user</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">min-conn</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">max-conn</span> = <span class="hljs-string">3</span><br>    <span class="hljs-attr">global.table</span> = <span class="hljs-string">&quot;global_table&quot;</span><br>    <span class="hljs-attr">branch.table</span> = <span class="hljs-string">&quot;branch_table&quot;</span><br>    <span class="hljs-attr">lock-table</span> = <span class="hljs-string">&quot;lock_table&quot;</span><br>    <span class="hljs-attr">query-limit</span> = <span class="hljs-string">100</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## the lock store mode: local、remote</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;remote&quot;</span><br><br>  <span class="hljs-attr">local</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in user&#x27;s database</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">remote</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in the seata&#x27;s server</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">recovery</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">asyn-committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">rollbacking-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">timeout-retry-delay</span> = <span class="hljs-string">30</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">transaction</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">undo.data.validation</span> = <span class="hljs-string">true</span><br>  <span class="hljs-attr">undo.log.serialization</span> = <span class="hljs-string">&quot;jackson&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## metrics settings</span><br><span class="hljs-attr">metrics</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">enabled</span> = <span class="hljs-string">false</span><br>  <span class="hljs-attr">registry-type</span> = <span class="hljs-string">&quot;compact&quot;</span><br><span class="hljs-comment">  # multi exporters use comma divided</span><br>  <span class="hljs-attr">exporter-list</span> = <span class="hljs-string">&quot;prometheus&quot;</span><br>  <span class="hljs-attr">exporter-prometheus-port</span> = <span class="hljs-string">9898</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><p><strong>5.4.5 添加全局事务注解</strong>：</p><ul><li><strong>主业务</strong>方法添加<strong>全局事务</strong>注解：<code>@GlobalTransactional</code></li><li><strong>分支业务</strong>方法添加<strong>本地事务</strong>注解：<code>@Transactional</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@GlobalTransactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String userId, String commodityCode, <span class="hljs-type">int</span> orderCount)</span> &#123;<br>        ......<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="5-5-更多官方示例"><a href="#5-5-更多官方示例" class="headerlink" title="5.5 更多官方示例"></a>5.5 更多官方示例</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 整合 nacos</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-nacos-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 jpa</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-jpa-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 dubbo</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-dubbo-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 ShardingSphere</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-shardingsphere-seata</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务是一种去中心化的应用架构方案。相对于单体式应用来说，微服务应用具有耦合性低、扩展性高、更灵活、能更高效交付的特点。</p><p>从名称上看。微服务的“微”涵盖了以下几层含义：</p><ul><li>服务按功能进行一定粒度的拆分，每一块都有独立的职责。</li><li>由于做了拆分，每一个微服务的开发都是独立进行的，因此这种架构的交付节奏可以更加灵活</li><li>微服务应用的部署及应用都是隔离的，这保证了整个应用架构可以按需进行扩展</li></ul><h2 id="微服务基础设施"><a href="#微服务基础设施" class="headerlink" title="微服务基础设施"></a>微服务基础设施</h2><p>微服务架构本质上是一种面向服务的分布式系统，为了解决分布式所带来的一系列管理问题，微服务通常需要依赖一些基础设施来保证架构的完整性。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在一个微服务集群中，由于服务的种类，实例数量由很多，仅通过人工配置的方式会加大工作量。而且这些服务实例的信息可能随时会发生变化，比如我们可能需要对某个服务做在线的扩容，或者因为故障处理而隔离某些节点。因此，需要由一个自动化的服务注册组件来完成这件事。服务注册通常需要记录当前可用的服务实例信息，并提供服务注册表API。服务的调用方可以通过API获得所需服务的实例信息，并实时订阅服务实例的变化。</p><p>通常服务注册的实现方式是心跳，即注册表于服务实例之间保持一个稳定的心跳检测，根据心跳的状态来判断服务实例是否存货。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>既然大量的微服务实例都记录到了服务注册表中，那么服务的调用方则应该通过服务发现组件来动态地可调用地服务实例信息。在微服务架构中，服务地发现有两种实现方式。</p><ol><li><p><strong>客户端发现</strong></p><p>客户端发现是指由调用方来完成目标服务实例信息地发现。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955546.png" alt="image-20220528195417255"></p></li><li><p><strong>服务端发现</strong></p><p>服务端发现是一种代理式地架构，即服务器间调用统一使用负载均衡器来实现。这与客户端发现的差别在于：服务实例的发现由负载均衡器来完成，并且所有的微服务接口调用都由该组件来代理</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955537.png" alt="image-20220528195428061"></p><p>这种方式的好处是可以屏蔽被调用服务的一些内部细节，并增加一些公共的能力，比如接口鉴权、流量控制、日志记录等。但是弊端也很明显，由于所有接口调用都需要经过该负载均衡器，所以该组件很容易形成瓶颈，一旦负载均衡器故障将会产生全局的影响</p><p>服务发现的实现方法无论是客户端发现还是服务器端发现，都离不开以下两点：</p><ul><li>依赖服务注册表组件来发现可用的服务</li><li>提供包括，目标实例的路由，如何在多个实例中挑选合适的节点取决于路由的算法，常见的包括随机路由、轮询路由、动态压力路由。</li></ul></li></ol><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>API网关是外部系统接入微服务集群的唯一入口。我们可以将微服务架构看作一个整体，其内部的微服务职责划分、服务间的交互调用对于外部来说是不可见的。那么为了对外提供体验一致的访问接口，微服务需要一个统一的API网关，所有外部系统对微服务的调用都经过API网关组件。</p><p>API网关组件通常具备的功能包括但不限于：</p><ul><li>接入鉴权</li><li>传输加密</li><li>请求路由</li><li>流量控制</li><li>灰度发布</li></ul><h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>在系统的节点实例变多后，实例故障的概率会增加。而且一旦故障发生，服务间的调用关系会导致故障大面积”传染“，通过人工进行实例故障隔离的方式效率较低，这就需要微服务能自动检测问题并自动做出应对。这种检测及应对能力通常由服务容错组件提供，一些手段如下：</p><ul><li>请求重试：在某些关键业务出现问题时，尝试进行请求的重试。</li><li>流量控制：这需要先对系统的容错做出明确的规划，然后对读物实例上的流量进行实时监控，一旦发现超过阈值则拒绝请求，这样就可以避免整个系统全面瘫痪。</li><li>服务熔断：根据一定的规则判断目标服务是否已经失效，规则的设计可以基于某个时间窗口的调用失败率进行计算，如果超过阈值则执行熔断（快速返回错误信息）</li></ul><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>对微服务实例保持足够的监控是非常重要的，而通常架构上需要对服务监控组件进行单独考虑。监控的目的是及时发现问题并采取一定的合理规避措施，以保证服务的SLA质量。通产在微服务监控服务中提供如下功能：</p><ul><li>业务日志采集：比如系统中用户注册、上下线等信息</li><li>运行指标采集：比如CPU、内存占用、JVM堆内存大小，或某些接口流量等</li><li>监控警告：对业务日志、运行指标信息进行分析、根据结果做出一定的判断和处理</li><li>调用链路跟踪：用于业务流程在分布式调用中出现问题时提供定位手段，调用链路需要借助一些特定的技术实现，比如服务埋点、跟踪树等。</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>传统的服务实例配置是通过本地文件(XML&#x2F;YAML&#x2F;PROPERTIES)实现的，比如数据库连接池的大小、接口请求流量的阈值等。对于配置的一些改动往往需要重新发布并重启服务，在存在实例时情况变得很不乐观。想象一下对于某个配置项的调整，你可能需要做几十次的发布动作。</p><p>通过将这些配置信息注册到统一的配置中心服务，微服务通过配置中心获取其所需要的配置，这样便免去了各种繁冗的发布工作。此外，如果服务实现了配置的动态感知及自动更新，则还可以实现各种平滑的动作。比如在数据库连接池的大小设置发生了变化时，实例可以自动感知而不需要重启。</p><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>微服务架构推崇采用轻量化的接口调用方式，比如使用HTTP&#x2F;REST。在项目实战中，我们还应该做出更统一的规范化定义，并形成公共的接口调用组件。这部分需要考虑的内容包括：</p><ul><li>数据的传输，比如HTTP还是TCP</li><li>数据的编码，比如JSON还是XML，或是二进制</li><li>数据的内容，比如是否采用固有的消息头定义</li><li>数据的安全，如是否使用TLS&#x2F;SSL实现加密，如何对接口权限进行校验等</li></ul><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>以Docker为代表的容器技术是微服务的最佳组合。通过使用容器作为基础设施，微服务能够实现快速部署、快速迭代的目。Kubernetes是当今容器标准化平台代表，其提供了强大的容器生命周期管理功能，可用于部署、扩展和管理所有的微服务容器。对微服务的自治、敏捷管理来说，容器的无状态、弹性伸缩能力无疑是最契合的。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282051685.png" alt="image-20220528205051510"></p><h2 id="CAP与BASE理论"><a href="#CAP与BASE理论" class="headerlink" title="CAP与BASE理论"></a>CAP与BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论又被称为CAP理论，指的是一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，三者不可兼得，而最多只能同时拥有两者</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282106926.png" alt="image-20220528210623871"></p><p>一致性（C）：分布式系统中节点的数据，在同一时刻拥有同样的值。对于每一次读操作都能够读到最新写入的数据</p><p>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求，即保持高可用</p><p>分区容忍性（P）：在出现网络分区（中断）后，系统是否还能继续保持运作。分区相当于对于通信条件的要求，如果出现了分区的情况，则势必会影响数据的一致性，即同步出现时延。此时系统就必须在一致性和可用性上做出选择。</p><p>实际上，CAP理论中忽略了网络时延对于系统的影响，在现实中网络时延一定是真实存在的，也就是P一定是存在的。因此分布式系统如果选择了高可用（AP），那么就会造成访问节点之间的数据不一致（牺牲一致性）。如果选择了一致性（CP），那么必须淘汰数据的备用点，而只访问主节点（牺牲高可用性）。CA的场景是无法存在的，因为网络通信失败的情况一定会存在。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论可被看作是CAP理论的一个补充，主要来源对大规模互联网系统分布式实践的总结。该理论由以下几个短语组成（BASE）。</p><ul><li>Basically Available（基本可用）</li><li>Soft State（软状态）</li><li>Eventually Consistent（最终一致性）</li></ul><p>实质上，BASE是对于一致性和可用性进行权衡的结果，其主要思想是在系统无法实现强一致性的情况下，根据应用的业务特点来做出一些权衡及补充，并使系统达到最终一致性。在达到最终一致性之前，系统会处于一个中间状态，具备以下特征：</p><ol><li>基本可用：即损失部分可用性，比如响应时间变长，或者部分服务被降级</li><li>软状态：数据会存在中间状态（不一致），但该状态不会影响系统的基本使用。</li></ol><p>在经过一段时间之后，系统应该能达到最终真正一致的状态，比如数据复制经过一段时间后真正完成同步。</p><p>相比CAP理论来说，BASE理论将一致性分成了强一致性和弱一致性，并在充分考虑网络时延、系统吞吐量的情况下选择了一种基本可用（弱一致性）的处理思路，这无疑更加适用于现有分布式系统。</p><h2 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h2><blockquote><p> <strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p></blockquote><p><strong>为什么需要RPC?</strong></p><p>两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。</p><p>通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。我们不需要了解底层网络编程的具体细节。</p><p>简单讲：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272135904.png" alt="image-20220527213236293"></p><p><strong>RPC相关概念：</strong></p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong>：代理类，把调用方法、类、方法参数传递到服务端</li><li><strong>服务端 Stub（桩）</strong>：接收到客户端执行方法的请求，返回给客户端的类</li><li><strong>网络传输</strong>：提供两端的数据传输服务<ol><li>实现方式：Socket、Netty</li></ol></li></ol><p><strong>原理如下：</strong></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: RpcRequest；</li><li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。</li></ol><hr><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><ul><li><p><strong>RMI（JDK自带）</strong></p><p>JDK自带的RPC，有很多局限性，不推荐使用。</p></li><li><p><strong>Dubbo</strong></p><p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</p></li><li><p><strong>gRPC</strong></p><p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</p></li><li><p><strong>Hessian</strong></p><p>Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送<strong>二进制数据</strong>。</p></li><li><p><strong>Thrift</strong></p><p>Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p></li></ul><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p><strong>服务调用关系</strong></p><ul><li>服务提供者：暴露接口给其他微服务调用</li><li>服务消费者：调用其他微服务的接口</li><li>提供者和消费者是<strong>相对</strong>的</li></ul><p><strong>eureka的作用</strong></p><ul><li>消费者该如何获取服务提供者信息？<ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者如何选择？<ul><li>服务消费者利用负载均衡算法，从列表中挑选一个</li></ul></li><li>消费者如何感知服务提供者健康状态？<ul><li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被踢除</li></ul></li></ul><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272158268.png" alt="image-20220527215852205"></p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><strong>Nacos服务分级存储模型</strong></p><ul><li>一级是服务，例如userService</li><li>二级是集群，例如杭州或上海</li><li>三级是实例：</li></ul><p><strong>NacosRule负载均衡策略</strong></p><ul><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其他集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ul><p>实例的权重控制</p><ul><li>Nacos控制台可以设置实例的权重值，0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ul><p><strong>Nacos环境隔离（namespace)</strong></p><ul><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见</li></ul><h2 id="Nacos与Eureka对比"><a href="#Nacos与Eureka对比" class="headerlink" title="Nacos与Eureka对比"></a>Nacos与Eureka对比</h2><p><strong>共同点：</strong></p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><p><strong>区别：</strong></p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><p>DataID命名规则：服务名称+环境.yaml(例如：userservice-dev.yaml)</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205280834487.png" alt="image-20220528083411388"></p><p><strong>将配置交给Nacos管理的步骤</strong></p><ul><li>在Nacos中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时nacos读取哪个文件</li></ul><p><strong>配置自动刷新</strong></p><ul><li>在需要注入配置文件中内容的类上添加注解@RefreshScope</li><li>也可以使用@ConfigurationProperties注解</li></ul><p>注：在nacos配置中，服务名.yaml文件是所有环境共享的环境</p><p>多种配置优先级如下：</p><p>服务名-profile.yaml &gt; 服务名称.yaml &gt; 本地配置</p><h2 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h2><p><strong>使用步骤：</strong></p><ul><li>引入依赖</li><li>添加@EnableFeignClients注解</li><li>编写FeignClient接口</li><li>使用FeignClient中定义的方法代替RestTemplate</li></ul><p><strong>Feign底层的客户端实现：</strong></p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>Feign性能优化主要为：</p><ul><li>使用连接池代替默认的URLConnection</li><li>日志级别最好采用basic或none</li></ul><h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><p><strong>网关功能</strong></p><ul><li>身份认证和权限校验</li><li>服务路由，将用户请求路由到微服务，并实现负载均衡</li><li>对用户请求做限流</li></ul><p>网关搭建步骤：</p><ul><li>创建项目，引入服务发现和gateway依赖</li><li>配置application.yml,包括服务基本信息、nacos地址、路由</li><li>路由配置包括：<ul><li>路由id：路由的唯一标识</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates):判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ul></li></ul><p><strong>路由过滤器GateWayFilter</strong></p><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281829903.png" alt="image-20220528182922800"></p><p>过滤器的作用：</p><ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由的请求生效</li><li>defaultFiler对所有的路由都生效</li></ul><p><strong>GlobalFIlter全局过滤器</strong></p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样，区别在于GatewayFilter通过配置定义，处理逻辑是固定的，而GlobalFilter的逻辑需要自己写代码实现。通过实现GlobalFilter接口实现。</p><p>实现全局过滤器步骤：</p><ul><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口(指定过滤器的执行顺序)</li><li>编写处理逻辑</li></ul><p><strong>过滤器执行顺序：</strong></p><p>请求进入网关会碰到三类过滤器：当前路由过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281900990.png" alt="image-20220528190022922"></p><ul><li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><strong>雪崩问题（微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况）</strong></p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>船壁模式：限定每个业务使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离</li><li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li><p>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也就是默认的模式</p></li><li><p>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>满足下面条件可以使用关联模式</p><ul><li>两个有竞争关系的资源</li><li>一个优先级高，一个优先级低</li></ul></li><li><p>链路：统计从指定链路访问到本资源的请求，触发阈值，对指定链路限流</p></li></ul><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。默认的处理方式</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</li></ul><blockquote><p>**热点参数限流:**分别统计参数值相同的请求，之后判断是否超过QPS阈值。</p></blockquote><h3 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h3><blockquote><p>虽然限流可以尽量避免因高并发引起的服务故障，但服务还会因为其他原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了</p></blockquote><p><strong>Feign整合Sentinel的步骤：</strong></p><ul><li>在application.yml中配置：feign.sentinel.enable&#x3D;true</li><li>在FeignClient编写FallbackFactory并注册为Bean(继承FallbackFactory并指定泛型为要降级的类)</li><li>将FallbackFactory配置到FeignClient中(在FeignClient中添加注解)</li></ul><p><strong>线程隔离</strong></p><ul><li><p>线程池隔离</p><p>优点：</p><ul><li>支持主动超时</li><li>支持异步调用</li></ul><p>缺点：</p><ul><li>线程的额外开销较大</li></ul><p>场景：</p><ul><li>低扇出</li></ul></li><li><p>信号量隔离(Sentinel默认采用)</p><p>优点：</p><ul><li>轻量级、无额外开销</li></ul><p>缺点：</p><ul><li>不支持主动超时</li><li>不支持异步调用</li></ul><p>场景：</p><ul><li>高频调用</li><li>高扇出</li></ul></li></ul><h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><p>断路器熔断策略有三种：满调用、异常比例、异常数</p><ul><li>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</li><li>异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</li><li>异常数：统计只当时间内的调用，如果调用次数超过指定请求数，并且出现异常的次数达到阈值则触发熔断。</li></ul><h3 id="授权规则及规则持久化"><a href="#授权规则及规则持久化" class="headerlink" title="授权规则及规则持久化"></a>授权规则及规则持久化</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li>白名单：来源（origin）在白名单内的调用者允许访问。</li><li>黑名单：来源（origin）在黑名单内的调用者不允许访问</li></ul><p><strong>自定义异常结果</strong></p><blockquote><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口</p><p><strong>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源</strong></p></blockquote><p><strong>Sentinel有三种配置管理模式</strong></p><ul><li>原始模式：保存在内存</li><li>pull模式：保存在本地文件或数据库，定时去读取</li><li>push模式：保存在nacos，监听变更实时更新</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>解决分布式事务的思想和模型</strong></p><ul><li>全局事务：整个分布式事务</li><li>分支事务：分布式事务中包含的每个子系统的事务</li><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚</li></ul><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata事务管理中的三个重要角色：</p><ul><li>TC（Transaction Coordinator）-事务协调者：维护全局和分支事务的状态，协调全局事务或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开启全局事务、提交或回滚事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205310925047.png" alt="image-20220531092538924"></p><p><strong>Seata提供了四种不同的分布式事务解决方案：</strong></p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致性的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><blockquote><p>XA模式原理：XA规范是X&#x2F;Open 组织定义的分布式事务处理（DTP，Distribute Transaction Processing）标准，XA规范描述了全局的TM与与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311015892.png" alt="image-20220531101529812"></p><p><strong>Seata的XA模式</strong></p><p>Seata的XA模式做了一些调整，但大体相似：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311025929.png" alt="image-20220531102528868"></p><p>RM一阶段的工作：</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<ul><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ul></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p>XA模式的优点：</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用的数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源，等二阶段结束才释放，性能差</li><li>依赖关系型数据库实现事务</li></ul><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><blockquote><p>AT模式同样是分阶段提交的事务模型，不够弥补了XA模式中资源锁定周期过长的缺陷</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311225992.png" alt="image-20220531122532913"></p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复到数更新前</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311231089.png" alt="image-20220531123104030"></p><p><strong>AT模式和XA模式的区别：</strong></p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚</li><li>XA模式强一致性；AT模式最终一致性</li></ul><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>Try：资源的检测和预留</li><li>Confirm:完成资源操作业务，要求Try成功Confirm一定能成功</li><li>Cancel：预留资源释放，可以理解为try的反向操作</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206011624351.png" alt="image-20220601162444229"></p><p><strong>TCC模式的各个阶段任务：</strong></p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p><strong>TCC的优点：</strong></p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模式，无需生成快照，无需使用全局锁，性能强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p><strong>TCC缺点：</strong></p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li></ul><p><strong>TCC的空回滚和业务悬挂</strong></p><ol><li>当某分支事务的try阶段阻塞，可能导致全局事务超时而触发二阶段的cancel操作。再未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚</li><li>对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止空回滚后的try操作，避免悬挂</li></ol><h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga模式时Seata提供的长事务解决方案。也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>而阶段：成功则什么都不做，失败则通过补偿业务来回滚</li></ul><p>Saga模式优点：</p><ul><li>事务参与者可以甚至时间驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不能编写TCC中的三个阶段，实现简单</li></ul><p>Saga缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>基本概念：</p><p>生产者（Publisher）：发布消息到 RabbitMQ 中的交换机（Exchange）上。</p><p>交换机（Exchange）：和生产者建立连接并接收生产者的消息。</p><p>消费者（Consumer）：监听 RabbitMQ 中的 Queue 中的消息。</p><p>队列（Queue）：Exchange 将消息分发到指定的 Queue，Queue 和消费者进行交互。</p><p>路由（Routes）：交换机转发消息到队列的规则。</p></blockquote><p><strong>同步调用的优点：</strong></p><ul><li>时效性较强，可以立即得到结果</li></ul><p><strong>同步调用的问题：</strong></p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><p><strong>异步通信的优点：</strong></p><ul><li>耦合度低</li><li>吞吐量提升</li><li>故障隔离</li><li>流量削峰</li></ul><p><strong>异步调用的缺点：</strong></p><ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂了，业务没有明显的流程线，不好追踪管理</li></ul><p><strong>RabbiMQ结构</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290841532.png" alt="image-20220529084151441"></p><ul><li>channel：操作MQ的工具</li><li>exchange：路由消息到队列中</li><li>queue：缓存消息</li><li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li></ul><p><strong>常见消息类型：</strong></p><ul><li><p>基本消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290846599.png" alt="image-20220529084644566"></p></li><li><p>工作消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849809.png" alt="image-20220529084907773"></p></li><li><p>发布订阅，又根据交换机类型不同分为三种：</p><ul><li><p>Fanout Exchange：广播</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848092.png" alt="image-20220529084855058"></p></li><li><p>Direct Exchange：路由</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848603.png" alt="image-20220529084840572"></p></li><li><p>Topic Exchange：主题</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849222.png" alt="image-20220529084938191"></p></li></ul></li></ul><h2 id="基本消息队列"><a href="#基本消息队列" class="headerlink" title="基本消息队列"></a>基本消息队列</h2><p>基本消息队列的消息发送流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ul><p>基本消息队列的消息接收流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消息行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ul><p><strong>如下代码实现：</strong></p><p>publisher如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.MessageProperties;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>       <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br><br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定对应的消息队列</span><br>        <span class="hljs-comment">//参数1：队列名称，如果队列不存在自动创建</span><br>        <span class="hljs-comment">//参数2：用来定义队列是否要持久化</span><br>        <span class="hljs-comment">//擦书3：exclusive是否独占队列</span><br>        <span class="hljs-comment">//参数4：autoDelete 是否在消费完成后自动删除队列</span><br>        <span class="hljs-comment">//参数5：额外附加参数</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//发布消息</span><br>        <span class="hljs-comment">//参数1：交换机名称，参数2队列名称，参数3：传递消息额外设置，参数4：消息的具体内容</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="hljs-string">&quot;hello rabbitmq&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        channel.close();<br>        connection.close()；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br><span class="hljs-comment">//    @Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>       <span class="hljs-comment">//参数1：消费哪个队列的消息，参数2：开启消息的自动确认机制，参数3：消费时的回调接口</span><br>        channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;new StringBody=&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>        channel.close();<br>        connection.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        Consumer consumer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br>        consumer.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本消息对列SpringAMQP使用</strong></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在配置文件中添加mq连接信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">rabbitmq-springboot</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">154.253</span><span class="hljs-number">.41</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/ems</span><br></code></pre></td></tr></table></figure></li><li><p>在publisher服务中添加一个测试类，编写发送消息的消息提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    String queueName=<span class="hljs-string">&quot;hello&quot;</span>;<br>    String message=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    rabbitTemplate.convertAndSend(queueName,message);<span class="hljs-comment">//发送到哪个队列以及发送什么消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><span class="hljs-comment">//监听哪个队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><span class="hljs-comment">//处理监听行为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receviel</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//参数是Publisher发送的消息类型</span><br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="工作消息队列"><a href="#工作消息队列" class="headerlink" title="工作消息队列"></a>工作消息队列</h2><blockquote><p>Work queue工作队列，可以提高消息处理速度，避免队列消息堆积</p></blockquote><p>util连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>publisher如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Provider &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>        <span class="hljs-keyword">assert</span> connection != null;<br>        Channel channel=connection.create<span class="hljs-constructor">Channel()</span>;<br>        channel.queue<span class="hljs-constructor">Declare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">true</span>,<span class="hljs-params">false</span>,<span class="hljs-params">false</span>,<span class="hljs-params">null</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;i++)<br>        channel.basic<span class="hljs-constructor">Publish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">null</span>,(<span class="hljs-params">i</span>+<span class="hljs-string">&quot;hello work quene&quot;</span>)</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>close<span class="hljs-constructor">ConnectionAndChannel(<span class="hljs-params">channel</span>,<span class="hljs-params">connection</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//每次只能消费一个消息</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<span class="hljs-comment">//参数1：确认队列中哪个具体消息，参数2：是否开启多个消息同时确认</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo.workquene;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;消费者-2：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工作消息队列SpringAMQP使用</strong></p><p>前三步同上面基础消息队列，也可以指定每次取多少条消息，处理完成才继续取消息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">listener:<br>  direct:<br>    prefetch: 1 #每次只能获取一条消息，处理完成后才能获取下一个消息<br></code></pre></td></tr></table></figure><ol><li><p>发送多条消息</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;work模型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者端添加多个消费者共同处理消息</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class WorkCumstomer &#123;<br><br>    <span class="hljs-variable">@RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    public void <span class="hljs-built_in">recevi1</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-1&quot;</span>+message);<br>    &#125;<br><br>    @<span class="hljs-selector-tag">RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">recevi2</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-2&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Fanout-Exchange-广播"><a href="#Fanout-Exchange-广播" class="headerlink" title="Fanout Exchange(广播)"></a>Fanout Exchange(广播)</h2><blockquote><p>Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的queue</p></blockquote><p>基本使用步骤：</p><p>连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span>  ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connectionFactory != <span class="hljs-literal">null</span>;<br>        Channel channel=connectionFactory.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//参数1：交换机名称，参数2：交换机类型  fanout 广播类型</span><br>        channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fanout type message&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fanout Exchange SpringAMQP使用：</strong></p><p>前两步同基础消息队列</p><p><strong>方式一注解：</strong></p><ol><li><p>定义pulisher发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanout</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;FanOut的模型发送的消息&quot;</span>);<span class="hljs-comment">//参数一是exchange，参数二是routingKey，参数三是消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>consumer消费端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>方式二配置类：</strong></p><p>也可以使用配置的方式声明消费者绑定的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//声明交换机</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue&quot;</span>);<span class="hljs-comment">//声明队列</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">fanoutBinfing</span><span class="hljs-params">(Queue fanoutQueue,FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue).to(fanoutExchange);<span class="hljs-comment">//绑定队列和交换机</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者使用直接指定队列即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(msg);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Direct-Exchange-路由"><a href="#Direct-Exchange-路由" class="headerlink" title="Direct Exchange(路由)"></a>Direct Exchange(路由)</h2><blockquote><p>DIrect Exchange会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）。</p></blockquote><ul><li>每一个Queue都与Exchange设置一个BindingKey（BindingKey可以指定多个）；</li><li>发布者发送消息时，指定消息的RoutingKey；</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列；</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291028289.png" alt="image-20220529102816194"></p><p>util连接工具类：</p><p>public class ConnectionRabbitMq {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//基于rout key 绑定队列和交换机</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费这-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;warning&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">//发送消息</span><br>        String routingKey=<span class="hljs-string">&quot;warning&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;log_direct&quot;</span>,routingKey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这是direct模型发布的基于rout key:[&quot;</span>+routingKey+<span class="hljs-string">&quot;]发送的消息&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Direct Exchange SpringAMQP使用：</strong></p><p>前两部同基础消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouteCumstomer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = &quot;direct&quot;),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者1</span><br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = ExchangeTypes.DIRECT),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者2</span><br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRoute</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;发送--info--key的信息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Topic-Exchange-主题"><a href="#Topic-Exchange-主题" class="headerlink" title="Topic Exchange(主题)"></a>Topic Exchange(主题)</h2><blockquote><p>Topic Exchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以 . 分割</p></blockquote><p>Queue与Exchange指定BindingKey时可以使用通配符：</p><ul><li>#：代表0个或多个单词</li><li>*：代表一个单词</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291044031.png" alt="image-20220529104430167"></p><p>基础使用步骤：</p><p>util连接工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String routekey=<span class="hljs-string">&quot;user.save.all&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routekey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这里是topic动态类型模型[&quot;</span>+routekey+<span class="hljs-string">&quot;]&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Topic Exchange SpringAMQP使用</strong></p><p>前面两部同基本消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;user.save&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;order.#&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopic</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;order&quot;</span>,<span class="hljs-string">&quot;user.save 路由消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>SpringAMQP中消息的序列化和反序列化是怎么实现的？</p><ul><li>利用MessageConverter实现的，默认是JDK的序列化</li><li>注意发送方与接收方必须使用相同的MessageConverter</li></ul><p><strong>RabbitMQ相关文章：</strong></p><p><a href="http://docs.javaboy.org/rabbitmq/message_push_pull/#_3-2-work-queues">江南一点雨</a></p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><blockquote><p>elasticsearch是一款非常强大的开源搜索引擎，可以帮我们从海量数据中快速找到需要的内容。</p><p>elasticsearch结合Kibana、logstash、Beats，也就是elastic stack(ELK)。被广泛应用在日志数据分析、实时监控等领域</p></blockquote><pre><code class="hljs"> ![image-20220529142245490](https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291422577.png)</code></pre><p><strong>文档和词条：</strong></p><ul><li>每一条数据就是一个文档</li><li>对文档中的内容分词，得到的词语就是词条</li></ul><p><strong>正向索引：</strong></p><ul><li>基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</li></ul><p><strong>倒排索引：</strong></p><ul><li>对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时先根据词条查询到文档id，而后获取文档。</li></ul><p><strong>索引</strong></p><ul><li>索引（index）：相同类型的文档的集合</li><li>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</li></ul><h2 id="Ik分词器安装使用"><a href="#Ik分词器安装使用" class="headerlink" title="Ik分词器安装使用"></a>Ik分词器安装使用</h2><p>下载与Elasticsearch版本相同的ik分词器</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>将下载的包解压后放到Elasticsearch中的plugins目录下，（踩坑日记–需要重新创建一个ik文件夹将解压后的ik分词器的内容复制到ik目录下才可以正常使用）</p><p><strong>Ik分词器的扩展与停用词</strong></p><p>在Ik分词器config目录下打开IKAnalyzer.cfg.xml进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br> <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291543388.png" alt="image-20220529154352092"></p><p>在字典中添加相关词语即可</p><p><strong>IK分词器有两种模式：</strong></p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2><p>安装同IK分词器，下载解压复制到plugins目录下，重启即可</p><p><strong>自定义分词器步骤：</strong></p><ul><li>创建索引库，在settings中配置，可以包含三部分</li><li>character filter</li><li>tokenizer</li><li>filter</li></ul><p><strong>例如：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;analysis&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;py&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;py&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;pinyin&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_joined_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_original&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;limit_first_letter_length&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">16</span><br>                    <span class="hljs-attr">&quot;remove_duplicated_term&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;none_chinese_pinyin_tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;standard&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单数据类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h2 id="索引库基本操作"><a href="#索引库基本操作" class="headerlink" title="索引库基本操作"></a>索引库基本操作</h2><ul><li>创建索引：PUT&#x2F;索引名称</li><li>查询索引：GET&#x2F;索引名称</li><li>删除索引：DELETE&#x2F;索引名称</li><li>添加字段：PUT&#x2F;索引库名&#x2F;_mapping</li></ul><p><strong>创建索引库</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>修改索引库</strong></p><p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br>如下示例：<br>PUT /heima/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;heima&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;aliases&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;properties&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;age&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;routing&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;allocation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;include&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;_tier_preference&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;data_content&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;provided_name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;creation_date&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1653818826936&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;uuid&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5dw1G0dkR1CbIV1CN6-MXA&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;created&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8010299&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;acknowledged&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="文档基本操作"><a href="#文档基本操作" class="headerlink" title="文档基本操作"></a>文档基本操作</h2><ul><li>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;索引库名&#x2F;文档id</li><li>修改文档:<ul><li>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>增量修改：POST &#x2F;索引库名&#x2F;update&#x2F;文档id {“doc”{字段}}</li></ul></li></ul><p><strong>新建文档的DSL语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值4&quot;</span><br>     <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ......<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ziyuan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;result&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;created&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima/_doc/<span class="hljs-number">1</span><br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;firstName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;lastName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ziyuan&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名/_doc/删除的文档id<br></code></pre></td></tr></table></figure><p><strong>修改文档</strong></p><ul><li><p>全量修改，会删除旧文档，添加新文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span>，<br>         ........<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>增量修改，修改指定字段值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;新的值&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="DSL查询分类"><a href="#DSL查询分类" class="headerlink" title="DSL查询分类"></a>DSL查询分类</h2><blockquote><p>Elasticsearch提供了基于JSON的DSL来定义查询，常见的查询类型包括如下：</p></blockquote><ul><li>查询所有：查询出所有数据，一般测试用。例如：match_all</li><li>全文检索（full text)查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>malti_match_query</li></ul></li><li>精确查询：根据精确词条查找数据，一般是查询keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li>地理(geo)查询：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li>复合(compound)查询：复合查询可以将上述各种查询条件组合起来，合并查询条件，例如：<ul><li>bool</li><li>boosting</li><li>constant_score</li><li>dis_max</li><li>function_score</li></ul></li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合可(aggregations)可以实现对文档数据的统计、分析、运算。常见的有三类：</p><ul><li>桶(Bucket)聚合：用来对文档做分组<ul><li>TermAggregation：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li>度量(Metric)聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小是</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li>管道(Pipeline)聚合：其他聚合的结果为基础的聚合</li></ul><h2 id="分词器组成"><a href="#分词器组成" class="headerlink" title="分词器组成"></a>分词器组成</h2><p>elasticsearch中分词（analyzer）的组成包括三部分：</p><ul><li>character filter：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换，同义词处理、拼音处理</li></ul><h2 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h2><p>elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配用户输入内容开头的词条并返回。为了提高补全查询效率，对于文档中字段的类型有一些约束：</p><ul><li>参数补全查询的字段必须是completion类型</li><li>字段的内容一般是用来补全的多个词条形成的数组</li></ul><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;completion&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Sony&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;WH-1000XM3&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>completion suggestion查询</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /test/_search<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;tittle_suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;s&quot;</span><span class="hljs-comment">//关键字,</span><br>            <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tittle&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//补全查询的字段</span><br>            <span class="hljs-attr">&quot;skip_duplicates&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//跳过重复的</span><br>            <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-comment">//获取10条结果</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零拷贝技术</title>
    <link href="/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><blockquote><p>零拷贝（zero-copy）是一种I&#x2F;O操作优化技术，可以快速高效地将数据从文件按系统移动到网络接口，而不需要将其从内核空间复制到用户空间，其在FTP或者HTTP等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用NIO和Epoll传输时才可使用该特性。需要注意，他不能用于实现了数据加密或者压缩的文件系统上，只能传输文件的原始内容。这类原始内同也包括加密了的文件内容。</p></blockquote><h2 id="传统I-x2F-O操作"><a href="#传统I-x2F-O操作" class="headerlink" title="传统I&#x2F;O操作"></a>传统I&#x2F;O操作</h2><ol><li><p>读操作</p><ol><li>应用程序发起读数据操作，触发read()系统调用。这时操作系统会进行一次上下文切换（把用户空间切换到内核空间）。</li><li>通过磁盘控制器把数据复制到内核缓冲区（页缓存）中，这里发生了一次DMA Copy。</li><li>然后内核将数据复制到用户空间的应用缓冲区中，发生了一次CPU Copy。</li><li>read调用返回后，会再进行一次上下文切换（把内核空间切换到用户空间）</li></ol><p>上述读过程，发生2次上下文切换和2次数据复制（一次是DMA Copy，一次是CPU Copy)。</p><p>DMA Copy是内核从磁盘上面读取数据，这是不消耗CPU时间的，是通过磁盘控制器完成的。</p></li><li><p>写操作</p><ol><li>应用程序发起写操作，触发write()系统调用，操作进行一次上下文切换（从用户空间到内核空间）</li><li>把数据复制到内核缓冲区Socket缓冲区，做了一次CPU Copy。</li><li>内核空间再把数据复制到磁盘或其他存储器（网卡，进行网络传输），进行了DMA Copy。</li><li>写入结束返回，又从内核空间切换到用户空间。</li></ol><p>上述写操作，也发生了2次上下文切换和2次数据复制（一次DMA Copy，一次CPU Copy）</p></li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082231556.png" alt="image-20220608223134442"></p><p><strong>总结：</strong></p><p>传统的I&#x2F;O读写操作，总共进行了4次上下文的切换，4次的数据复制动作。数据在内核空间和应用空间之间来回复制，其实并没有做任何有意义的逻辑，就是单纯的复制而已。所以这个机制太浪费时间，而且浪费CPU时间。</p><h2 id="零拷贝技术原理"><a href="#零拷贝技术原理" class="headerlink" title="零拷贝技术原理"></a>零拷贝技术原理</h2><p>零拷贝主要是用来解决操作系统在处理I&#x2F;O操作时，频繁复制数据的问题。零拷贝技术主要有mmap+write、sendfile、splice等几种方式。</p><ol><li><p><strong>虚拟内存</strong></p><p>所有的现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：</p><ul><li>多个虚拟内存可以指向同一个物理地址</li><li>虚拟内存空间可以远远大于物理内存空间</li></ul><p>利用上面的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在I&#x2F;O操作时 就不需要来回复制了。</p><p><strong>虚拟内存原理</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082245288.png" alt="image-20220608224540237"></p></li><li><p>mmap&#x2F;write方式</p><p>使用mmap&#x2F;write方式替代原来的传统I&#x2F;O方式，就是利用了虚拟内存的特性。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082252877.png" alt="image-20220608225254819"></p><p>整体流程的核心区别是，把数据读取到内核缓冲区后，应用程序进行数据写入操作时，直接把内核的Read Buffer的数据复制到Socket Buffer以便写入，这次内核之间的复制也是需要CPU参与的。</p><p>上述流程就少了一个CPU Copy，提升了I&#x2F;O的速度。不过发现上下文的切换还是4次并没有减少，这是因为还是要应用程序发起write操作。</p></li><li><p>sendfile方式</p><p>从linux2.1版本开始，Linux引入了sendfile来简化操作。sendfile方式可以替换上面的mmap&#x2F;write方式来进一步优化。</p><p>sendfile将以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mmap();<br>write();<br></code></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendfile()<br></code></pre></td></tr></table></figure><p>这样就减少了上下文切换，因为少了一个应用程序发起write操作，直接发起sendfile操作。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082305384.png" alt="image-20220608230549337"></p><p>sendfile方式只有3次数据复制（其中只有一次CPU copy）以及2次上下文切换。</p></li><li><p>带有scatter&#x2F;gather的sendfile方式</p><p>Linux2.4内核进行了优化，提供了带有scatter&#x2F;gather的sendfile操作，这个操作可以把最后一次CPU copy去除。其原理就是在内核空间Read Buffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到Socket Buffer中，这样就不需要复制，其本质和虚拟内存的解决方法思路一样，就是内存地址的记录。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082314110.png" alt="image-20220608231408062"></p><p>scatter&#x2F;gatter的sendfile只有2次数据复制（都是DMA Copy）以及2次上下文切换。CPU copy已经完全没有。不过这一种收集复制功能是需要硬件及驱动程序支持的。</p></li><li><p>splice方式</p><p>splice调用和sendfile非常类似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，另外一个表示输出设备。与sendfile不同的是，splice允许任意两个文件之间互相连接，而并不是文件到socket进行数据传输。对于一个文件描述符发送数据到socket这种特例来说，一直都是使用sendfile系统调用，而splice一直依赖只是一种机制，它并不仅是sendfile的功能，也就是说，sendfile只是splice的一个子集。</p></li></ol><p><strong>总结：</strong></p><p>无论是传统I&#x2F;O方式，还是引入了零拷贝之后，2次DMA Copy是都少不了的。因为两次DMA都是依赖硬件完成的。所以，所谓零拷贝，都是为了减少CPU copy及减少了上下文的切换。</p><table><thead><tr><th></th><th><strong>CPU拷贝</strong></th><th><strong>DMA拷贝</strong></th><th><strong>系统调用</strong></th><th><strong>上下文切换</strong></th></tr></thead><tbody><tr><td>传统方式</td><td>2</td><td>2</td><td>read&#x2F;write</td><td>4</td></tr><tr><td>内存映射</td><td>1</td><td>2</td><td>mmap&#x2F;write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile with dma<br> scatter&#x2F;gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单例模式的定义"><a href="#一、单例模式的定义" class="headerlink" title="一、单例模式的定义"></a>一、单例模式的定义</h1><p><strong>定义：</strong> 确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>这样做的好处是：有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。</p><h1 id="二、单例模式的设计要素"><a href="#二、单例模式的设计要素" class="headerlink" title="二、单例模式的设计要素"></a>二、单例模式的设计要素</h1><ul><li>一个私有构造函数 （确保只能单例类自己创建实例）</li><li>一个私有静态变量 （确保只有一个实例）</li><li>一个公有静态函数 （给使用者提供调用方法）</li></ul><p>简单来说就是，单例类的构造方法不让其他人修改和使用；并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一次实例。</p><h1 id="三、单例模式的6种实现及各实现的优缺点"><a href="#三、单例模式的6种实现及各实现的优缺点" class="headerlink" title="三、单例模式的6种实现及各实现的优缺点"></a>三、单例模式的6种实现及各实现的优缺点</h1><h2 id="（一）懒汉式（线程不安全）"><a href="#（一）懒汉式（线程不安全）" class="headerlink" title="（一）懒汉式（线程不安全）"></a>（一）懒汉式（线程不安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。</p><p><strong>优点：</strong> 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。</p><p><strong>缺点：</strong> 线程不安全，多线程环境下，如果多个线程同时进入了 if (uniqueInstance &#x3D;&#x3D; null) ，若此时还未实例化，也就是uniqueInstance &#x3D;&#x3D; null，那么就会有多个线程执行 uniqueInstance &#x3D; new Singleton(); ，就会实例化多个实例；</p><h2 id="（二）饿汉式（线程安全）"><a href="#（二）饿汉式（线程安全）" class="headerlink" title="（二）饿汉式（线程安全）"></a>（二）饿汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">uniqueInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。</p><p><strong>优点：</strong> 提前实例化好了一个实例，避免了线程不安全问题的出现。</p><p><strong>缺点：</strong> 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。</p><h2 id="（三）懒汉式（线程安全）"><a href="#（三）懒汉式（线程安全）" class="headerlink" title="（三）懒汉式（线程安全）"></a>（三）懒汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getUinqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 实现和 线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上 加了一把 锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。</p><p><strong>优点：</strong> 延迟实例化，节约了资源，并且是线程安全的。</p><p><strong>缺点：</strong> 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方***使线程阻塞，等待时间过长。</p><h2 id="（四）双重检查锁实现（线程安全）"><a href="#（四）双重检查锁实现（线程安全）" class="headerlink" title="（四）双重检查锁实现（线程安全）"></a>（四）双重检查锁实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明:</strong> 双重检查数相当于是改进了 线程安全的懒汉式。线程安全的懒汉式 的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。</p><p><strong>为什么使用 volatile 关键字修饰了 uniqueInstance 实例变量 ？</strong></p><p>uniqueInstance &#x3D; new Singleton(); 这段代码执行时分为三步：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>正常的执行顺序当然是 1&gt;2&gt;3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。<br>单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。<br>例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getUniqueInstance()，发现 uniqueInstance 不为空，便获取 uniqueInstance 实例，但是其实此时的 uniqueInstance 还没有初始化。</p><p>解决办法就是加一个 volatile 关键字修饰 uniqueInstance ，volatile 会禁止 JVM 的指令重排，就可以保证多线程环境下的安全运行。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。</p><p><strong>缺点：</strong> volatile 关键字，对性能也有一些影响。</p><h2 id="（五）静态内部类实现（线程安全）"><a href="#（五）静态内部类实现（线程安全）" class="headerlink" title="（五）静态内部类实现（线程安全）"></a>（五）静态内部类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getUniqueInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；且线程安全；性能也提高了。</p><h2 id="（六）枚举类实现（线程安全）"><a href="#（六）枚举类实现（线程安全）" class="headerlink" title="（六）枚举类实现（线程安全）"></a>（六）枚举类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-comment">//添加自己需要的操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeThing</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。</p><p><strong>优点：</strong> 写法简单，线程安全，天然防止反射和反序列化调用。</p><ul><li><strong>防止反序列化</strong><br><strong>序列化：</strong>把java对象转换为字节序列的过程；<br><strong>反序列化：</strong> 通过这些字节序列在内存中新建java对象的过程；<br><strong>说明：</strong> 反序列化 将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例。<br><strong>枚举类天然防止反序列化。</strong><br>其他单例模式 可以通过 重写 readResolve() 方法，从而防止反序列化，使实例唯一重写 readResolve() :</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException&#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、单例模式的应用场景"><a href="#四、单例模式的应用场景" class="headerlink" title="四、单例模式的应用场景"></a>四、单例模式的应用场景</h1><p><strong>应用场景举例：</strong></p><ul><li>网站计数器。</li><li>应用程序的日志应用。</li><li>Web项目中的配置对象的读取。</li><li>数据库连接池。</li><li>多线程池。</li><li>……</li></ul><p><strong>使用场景总结：</strong></p><ul><li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能。</li><li><strong>经常使用的对象，但实例化时耗费时间或者资源多</strong>，如数据库连接池，使用单例模式，可以提高性能，降低资源损坏。</li><li><strong>使用线程池之类的控制资源时</strong>，使用单例模式，可以方便资源之间的通信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为型设计模式</title>
    <link href="/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><h2 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h2><ol><li><p>定义：指定义一系列算法，并将每一种算法封装起来，让它们可以相互替换。策略模式能让算法独立于使用它地客户而变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172310354.png" alt="image-20220817230912880"></p></li></ol><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><ol><li><p>定义：指定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一种算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172316967.png" alt="image-20220817231640910"></p></li></ol><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ol><li><p>定义：指在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在以后将对象恢复到原先保存的状态，也叫Token模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172329323.png" alt="image-20220817232930270"></p></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol><li><p>定义：指定义对象之间的一种一对多的依赖关系，每当一个对象状态发生变化时，其相关依赖对象都能得到通知并被自动更新，又叫发布订阅模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172341700.png" alt="image-20220817234137646"></p></li></ol><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><ol><li><p>定义：指为了避免请求发送者与接收者耦合在一起，让多个对象都有可能接收到请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到所有对象处理为止。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172351970.png" alt="image-20220817235111917"></p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li><p>定义：指提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。迭代器模式又称为游标（Cursor），属于对象行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182049174.png" alt="image-20220818204949129"></p></li></ol><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ol><li><p>定义：指将一个请求封装为一个对象，从而使用不同的请求对客户进行参数化；对请求排队或记录日志，以及支持可撤销的操作。又称为动作模式或事务模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182042698.png" alt="image-20220818204238289"></p></li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ol><li><p>定义：允许一个对象在其内部状态发生变化的时改变其行为，使对象看起来似乎修改了它的类，状态模式又称为状态对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191851046.png" alt="image-20220819185056958"></p></li></ol><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><ol><li><p>定义：指用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立改变它们之间地交互，又称为调停者模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191930922.png" alt="image-20220819193014879"></p></li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><ol><li><p>定义：指一个作用于某对象结构中各元素地操作，它可以在不改变各元素地类地前提下，定义作用于这些元素的新操作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327947.png" alt="image-20220819232709871"></p></li></ol><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ol><li><p>定义：指定义语言的文法，并简历一个解释器来解释该语言中的句子，这里的”句子“是指使用规定格式和语法的代码，它是一宗类行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327119.png" alt="image-20220819232720065"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型设计模式</title>
    <link href="/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><strong>简单工厂模式</strong></h3><ol><li><p>定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p></li><li><p>结构图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171532554.png" alt="image-20220817153224447"></p></li></ol><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><ol><li><p>定义：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171542970.png" alt="image-20220817154249929"></p></li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a><strong>抽象工厂模式</strong></h3><ol><li><p>定义：提供一个创建一些列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171612449.png" alt="image-20220817161256362"></p></li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><strong>建造者模式</strong></h3><ol><li><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171621982.png" alt="image-20220817162143936"></p></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><strong>原型模式</strong></h3><ol><li><p>定义：使用原型实例指定待创建对象的类型，并通过复制这个原型来创建新的对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171628276.png" alt="image-20220817162807225"></p></li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><ol><li>定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</li><li>结构图：</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171634647.png" alt="image-20220817163425608"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构型设计模式</title>
    <link href="/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol><li><p>定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646024.png" alt="image-20220817164417326"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646005.png" alt="image-20220817164608352"></p></li></ol><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ol><li><p>定义：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171653072.png" alt="image-20220817165346023"></p></li></ol><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ol><li><p>定义：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171742358.png" alt="image-20220817174218295"></p></li></ol><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ol><li><p>定义：动态地给一个对象增加一些额外地职责。就扩展功能而言，装饰器模式提供了一种比使用子类更加灵活地替代方案。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171750349.png" alt="image-20220817175012294"></p></li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ol><li><p>定义：为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171754294.png" alt="image-20220817175427249"></p></li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ol><li><p>定义：运用共享技术有效地支持大量细粒度对象地复用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171802090.png" alt="image-20220817180248038"></p></li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li><p>定义：给某一个对象提供一个代理或占位符，并由代理对象来控制源对象地访问。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171809332.png" alt="image-20220817180918277"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种设计模式应用场景</title>
    <link href="/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/"/>
    <url>/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式应用场景"><a href="#设计模式应用场景" class="headerlink" title="设计模式应用场景"></a>设计模式应用场景</h1><ol><li>如何确保系统中一个类只有一个实例？单例模式</li><li>如何将对象的创建和对象的使用分离？简单工厂模式</li><li>如何通过不同的工厂来创建不同类型的对象？工厂方法模式</li><li>如何设计一个能够闯将一些列产品对象的工厂？抽象工厂模式</li><li>如何通过克隆来得到一个一模一样的对象？原型模式</li><li>如何一步步创建一个包含多个组成部分的复杂对象？建造者模式</li><li>如何在不修改现有系统的前提下重用没有源码的第三方类库？适配器模式</li><li>如何避免在多层继承结构中类的个数出现爆炸式增长？桥接模式</li><li>如何使用面向对象的方式来处理软件系统中的树形结构？组合模式</li><li>如何不通过继承的方式来扩展类的功能？装饰器模式</li><li>如何为复杂子系统提供一个统一的入口？外观模式</li><li>如何实现对象的多次复用以节省系统资源？享元模式</li><li>如何提供一种间接访问机制来实现对象的远程访问或受限访问？代理模式</li><li>如何让多个对象都有机会来处理同一个请求？责任链模式</li><li>如何将请求的发送者和请求的接收者完全解耦？命令模式</li><li>如何自定义一个简单的语言？解释器模式</li><li>如何遍历一个聚合对象中的元素？迭代器模式</li><li>如何协调多个对象之间复杂的相互调用？中介者模式</li><li>如何实现对象之间一对多的联动？观察者模式</li><li>如何设计和实现一个具有多个状态的对象？状态模式</li><li>如何在不修改现有代码的前提下更换一种算法？策略模式</li><li>如何为一个复杂算法的某些步骤提供多种实现方式？模板方法模式</li><li>如何操作一个包含多种类型对象的复杂结构？访问者模式</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计模式基础</title>
    <link href="/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h1><h2 id="软件设计模式定义"><a href="#软件设计模式定义" class="headerlink" title="软件设计模式定义"></a>软件设计模式定义</h2><p>软件设计模式是一套被反复使用，经过分类编目的代码设计经验的总结。使用软件设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。</p><p>软件设计模式定义有如下定义：</p><ol><li>软件设计模式是对代码设计经验的总结，且经过分类编目。</li><li>软件设计模式的根本目的是提高代码的重用性和可靠性。代码重用性是指相同功能的代码，不必多次编写。代码可靠性是指增加新功能时，对原来的功能没有影响。可靠性也体现了可扩展和可维护。</li><li>代码可读性是指编程的规范，便于其他程序员阅读和理解。</li></ol><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>软件设计模式的基本要素是指模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等。其中，软件设计模式的基本要素包括以下4个方面。</p><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ol><p>软件设计模式的基本结构由4部分构成，即问题描述、前提条件（环境或越苏条件）、解法（关联解法和其他相关设计模式）和效果（优&#x2F;缺点和已知应用），如下</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021813509.png" alt="image-20220502181256391"></p><h1 id="GoF设计模式及其分类"><a href="#GoF设计模式及其分类" class="headerlink" title="GoF设计模式及其分类"></a>GoF设计模式及其分类</h1><p>GoF的23中设计模式如下：</p><table>    <tbody style="text-align:center;vertical-align:middle;">        <tr >            <td colspan="2">创建型模式</td>            <td colspan="2">结构型模式</td>            <td colspan="2">行为型模式</td>        </tr>         <tr>            <td>类创建型模型</td>            <td>对象创建型模式</td>            <td>类结构型模式</td>            <td>对象结构型模式</td>            <td>类行为型模式</td>            <td>对象行为模式</td>        </tr>            <td>工厂方法模式</td>            <td></td>            <td>类适配器模式</td>            <td>对象适配模式</td>            <td></td>            <td>职责链模式</td>        </tr>        <tr>            <td></td>            <td>抽象工厂模式</td>            <td></td>            <td>桥接模式</td>            <td></td>            <td>命令模式</td>        </tr>        <tr>            <td></td>            <td>单例模式</td>            <td></td>            <td>代理模式</td>            <td></td>            <td>迭代器模式</td>        </tr>        <tr>            <td></td>            <td>建造者模式</td>            <td></td>            <td>组合模式</td>            <td></td>            <td>中介模式</td>        </tr>        <tr>            <td></td>            <td>原型模式</td>            <td></td>            <td>装饰模式</td>            <td></td>            <td>备忘录模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>享元模式</td>            <td></td>            <td>观察者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>外观模式</td>            <td></td>            <td>状态模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>策略模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>访问者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>模板方法模式</td>            <td></td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>解释器模式</td>            <td></td>        </tr>    </tbody></table><h2 id="创建型设计模式、结构型设计模式和行为型设计模式"><a href="#创建型设计模式、结构型设计模式和行为型设计模式" class="headerlink" title="创建型设计模式、结构型设计模式和行为型设计模式"></a>创建型设计模式、结构型设计模式和行为型设计模式</h2><p>软件设计模式有多种分类方法。根据模式目的（模式是用来做什么的）可分为创建型、结构型和行为型3种。</p><p>根据软件设计模式的处理范围，可以分为类模式和对象模式两种。</p><ul><li>类模式处理类和子类之间的关系是通过继承在编译时刻就被确定下来的，这些关系是属于静态的。</li><li>对象模式是处理对象之间的关系，这些关系是时刻变化运行的，具有动态性。</li></ul><p>根据软件设计模式的使用级别，可以分为基本设计模式、常用设计模式和高级设计模式3种。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>使用UML表示类间的4种基本关系：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021924361.png" alt="image-20220502191536437"></p><ol><li><p>关联关系：是类与类之间最常见的一种关系。他是一种结构化关系，用于表示一类对象与另一类对象之间的有（has a）联系。（通俗说是将一个类的对象作为另一个类的属性），在UML类图中，关联关系用实线（或实线带箭头–指向被关联类）连接有关联对象所对应的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013167.png" alt="image-20220502200907721"></p><ol><li><p>聚合关系（聚合关系是特殊的关联关系）具有如下特征：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象可以脱离整体而独立存在；</li><li>在代码实现时，成员对象可以通过构造器或setter方法注入；</li></ul><p>UMl类图表示聚合关系时，使用待空心菱形的实线表示（指向聚合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013175.png" alt="image-20220502201321550"></p></li><li><p>组合关系（组合关系表示类之间整体和部分的关系，其中整体类可控制成员类的声明周期，部分对象与整体对象之间具有同生共死的关系。）特征如下：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象与整体对象具有统一的生存期，当整体对象消亡时，成员对象也会消亡；</li><li>代码实现时，成员对象可在整体类声明或构造方法中实例化；</li></ul><p>在UML类图中，组合关系用待实心菱形的直线表示（指向组合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022015552.png" alt="image-20220502201549514"></p></li></ol></li><li><p>依赖关系：指两个事物之间的一种语义关系，表示一个事物发生变化时会影响另一个事物。依赖关系通常是一种使用关系，为临时性的关联。在代码中，依赖关系是通过定义被依赖类型的局部变量、方法参数及返回值类型等方式来体现。</p><p><font style="color:red;">注意：</font>关联关系使用成员变量（全局变量），而依赖关系使用局部变量。</p><p>在UML类图中依赖关系使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022017088.png" alt="image-20220502201724053"></p></li><li><p>泛化关系（即继承关系，也称”is a”关系。泛化关系用于描述父类与子类之间的关系，父类又称基类或超类，子类又称派生类。</p><p>在UML类图的泛化关系使用空心三角形的直线来表示（指向基类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022019078.png" alt="image-20220502201917032"></p></li><li><p>实现关系（指接口与实现类之间的实现，可实现接口中声明的所有抽象方法。</p><p>在UML类图中使用待空心三角形的虚线来表示实现关系（指向接口）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022021510.png" alt="image-20220502202141469"></p></li></ol><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。设计原则也是学习软件设计模式的基础，每种设计模式都会符合若干设计原则。</p><table><thead><tr><th align="center">名称</th><th align="center">简介</th><th align="center">重要性</th></tr></thead><tbody><tr><td align="center">开闭原则</td><td align="center">软件实体对扩展是开发的，但对修改是关闭的，即在不修改软件实体的基础上扩展其功能</td><td align="center">★★★★★</td></tr><tr><td align="center">里氏替换原则</td><td align="center">所有引用基类的地方必须透明地使用其子类对象。或者说，一个可以接收基类对象的地方必然可以接受一个子类对象</td><td align="center">★★★★★</td></tr><tr><td align="center">依赖倒置原则</td><td align="center">针对抽象层编程，而不应针对具体类编程</td><td align="center">★★★★★</td></tr><tr><td align="center">合成-聚合复用原则</td><td align="center">在关系中应尽量多地使用组合和聚合的关联关系，少使用甚至不使用继承关系</td><td align="center">★★★★</td></tr><tr><td align="center">单一职责原则</td><td align="center">类的职责要单一，不能将太多的职责放在一个类中</td><td align="center">★★★★</td></tr><tr><td align="center">迪米特法则</td><td align="center">一个软件实体对其他实体的引用应越少越好。或者说，如果两个类不必彼此直接通信，那么这两个类就不因该发生直接</br>的相互作用，而是通过引入一个第三方发生间接交互</td><td align="center">★★★</td></tr><tr><td align="center">接口隔离原则</td><td align="center">使用多个专门的接口来取代一个统一的接口</td><td align="center">★★</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
