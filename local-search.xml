<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/09/04/Java/"/>
    <url>/2022/09/04/Java/</url>
    
    <content type="html"><![CDATA[<h1 id="💠Java基础"><a href="#💠Java基础" class="headerlink" title="💠Java基础"></a>💠Java基础</h1><h2 id="📓java语言特点"><a href="#📓java语言特点" class="headerlink" title="📓java语言特点"></a>📓java语言特点</h2><ul><li>Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。</li><li>具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。</li><li>Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。</li><li>Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。</li><li>Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。</li></ul><h2 id="📓JDK-与-JRE-有什么区别？"><a href="#📓JDK-与-JRE-有什么区别？" class="headerlink" title="📓JDK 与 JRE 有什么区别？"></a>📓JDK 与 JRE 有什么区别？</h2><ul><li>JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。</li><li>JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。</li><li>JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK。</li></ul><h2 id="📓标识符"><a href="#📓标识符" class="headerlink" title="📓标识符"></a>📓标识符</h2><ul><li><strong>标识符的含义</strong>：在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</li><li><strong>命名规则</strong>：（<strong>硬性要求</strong>） 标识符可以包含英文字母，0-9的数字，$以及_ 标识符不能以数字开头 标 识符不是关键字</li><li><strong>命名规范</strong>：（<strong>非硬性要求</strong>） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量 名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。</li></ul><h2 id="📓关键字"><a href="#📓关键字" class="headerlink" title="📓关键字"></a>📓关键字</h2><table><thead><tr><th align="left"></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td align="left"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td align="left">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td align="left"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td align="left">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td align="left">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td align="left"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="📓数据类型"><a href="#📓数据类型" class="headerlink" title="📓数据类型"></a>📓数据类型</h2><blockquote><ul><li>Java中，如果对整数不指定类型，默认时int类型，对小数不指定类型，默认是double类型。</li><li>基本类型由小到大，可以自动转换，但是由大到小，则需要强制类型转换。</li></ul></blockquote><h3 id="📙基础数据类型"><a href="#📙基础数据类型" class="headerlink" title="📙基础数据类型"></a>📙基础数据类型</h3><table><thead><tr><th align="left">基本类型</th><th align="left">位数</th><th align="left">字节</th><th align="left">默认值</th><th>取值范围</th><th>封装类</th></tr></thead><tbody><tr><td align="left"><code>byte</code></td><td align="left">8</td><td align="left">1</td><td align="left">0</td><td>-128 ~ 127</td><td>Byte</td></tr><tr><td align="left"><code>short</code></td><td align="left">16</td><td align="left">2</td><td align="left">0</td><td>-32768 ~ 32767</td><td>Short</td></tr><tr><td align="left"><code>int</code></td><td align="left">32</td><td align="left">4</td><td align="left">0</td><td>-2147483648 ~ 2147483647</td><td>Integer</td></tr><tr><td align="left"><code>long</code></td><td align="left">64</td><td align="left">8</td><td align="left">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>Long</td></tr><tr><td align="left"><code>char</code></td><td align="left">16</td><td align="left">2</td><td align="left">‘\u0000’</td><td>0 ~ 65535</td><td>Float</td></tr><tr><td align="left"><code>float</code></td><td align="left">32</td><td align="left">4</td><td align="left">0f</td><td>1.4E-45 ~ 3.4028235E38</td><td>Double</td></tr><tr><td align="left"><code>double</code></td><td align="left">64</td><td align="left">8</td><td align="left">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td><td>Boolean</td></tr><tr><td align="left"><code>boolean</code></td><td align="left">1</td><td align="left"></td><td align="left">false</td><td>true、false</td><td>Character</td></tr></tbody></table><h3 id="📙基础类型的后缀："><a href="#📙基础类型的后缀：" class="headerlink" title="📙基础类型的后缀："></a>📙<strong>基础类型的后缀：</strong></h3><p>long ： l 或 L<br>float： f 或 F；<br>double： d 或 D</p><h3 id="📙隐式转换"><a href="#📙隐式转换" class="headerlink" title="📙隐式转换"></a>📙隐式转换</h3><h4 id="📚复合运算符的隐式转换"><a href="#📚复合运算符的隐式转换" class="headerlink" title="📚复合运算符的隐式转换"></a>📚复合运算符的隐式转换</h4><ul><li>复合运算符（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）是可以将右边表达式的类型自动强制转换成左边的类型</li></ul><h4 id="📚整形字面常量隐式转换的限制"><a href="#📚整形字面常量隐式转换的限制" class="headerlink" title="📚整形字面常量隐式转换的限制"></a>📚整形字面常量隐式转换的限制</h4><ul><li><p>整形字面常量的大小超出目标类型所能表示的范围时，要手动强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<span class="hljs-comment">//编译错误，128超出byte类型所能表示的范围</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)<span class="hljs-number">128</span>;<span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure></li><li><p>对于传参数时，必须要显式地进行强制类型转换，明确转换的类型(编译器之所以这样要求，其实为了避免 方法重载出现的隐式转换 与 小类型自动转大类型 发生冲突)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    shortMethod(<span class="hljs-number">8</span>);<span class="hljs-comment">//编译错误</span><br>    shortMethod((<span class="hljs-type">short</span>)<span class="hljs-number">8</span>); <span class="hljs-comment">//编译通过</span><br>    longMethod(<span class="hljs-number">8</span>);<span class="hljs-comment">//编译通过，因为这是小类型变成大类型，是不需要强制类型转换的</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shortMethod</span><span class="hljs-params">(<span class="hljs-type">short</span> c)</span>&#123;<br>    System.out.println(c);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longMethod</span><span class="hljs-params">(<span class="hljs-type">short</span> l)</span>&#123;<br>    System.out.println(l);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="📚特殊的char类型"><a href="#📚特殊的char类型" class="headerlink" title="📚特殊的char类型"></a>📚特殊的char类型</h4><blockquote><p>char类型是一个无符号类型，所以char类型与其他基本类型不是子集与父集间的关系（其他类型都是有符号的类型）。也就是说，char类型与byte、short之间的转换都需要显式的强制类型转换（小类型自动转换成大类型失败）。</p></blockquote><ul><li>char类型与byte、short的相互转换，都需要显式地强类型制转换。</li><li>对于数值是负数的，都需要进行显式地强制类型转换，特别是在整形字面常量的隐式转换中。</li><li>char类型转换成int、long类型是符合 小类型转大类型的规则，即无需要强制类型转换。</li></ul><h4 id="📚java的运算结果的类型有两个性质："><a href="#📚java的运算结果的类型有两个性质：" class="headerlink" title="📚java的运算结果的类型有两个性质："></a>📚java的运算结果的类型有两个性质：</h4><ul><li>运算结果的类型必须是int类型或int类型以上。</li><li>最高类型低于int类型的，运算结果都为int类型。否则，运算结果与表达式中最高类型一致。</li></ul><h3 id="📙包装类型"><a href="#📙包装类型" class="headerlink" title="📙包装类型"></a>📙包装类型</h3><blockquote><p>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。</p></blockquote><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><p>所谓包装类，就是能够直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类。</p><p>以下用途:</p><ol><li>作为基本数据类型对应的类类型，提供了一系列实用的对象操作，如类型转换，进制转换等</li><li>集合不允许存放基本数据类型，故常用包装类</li><li>包含了每种基本类型的相关属性，如最大值，最小值，所占位数等</li></ol><blockquote><p>包装类都为final 不可继承<br>包装类型都继承了Number抽象类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱 调用了 Integer.valueOf(2)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;         <span class="hljs-comment">// 拆箱 调用了 X.intValue()</span><br></code></pre></td></tr></table></figure><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><blockquote><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</p></blockquote><h3 id="📙自动拆装箱"><a href="#📙自动拆装箱" class="headerlink" title="📙自动拆装箱"></a>📙自动拆装箱</h3><blockquote><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的 valueOf(int) 方法<br>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的 intValue方法</p></blockquote><ol><li>基本型和基本型封装型进行“&#x3D;&#x3D;”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较</li><li>两个Integer类型进行“&#x3D;&#x3D;”比较，如果其值在-128至127，那么返回true，否则返回false,</li><li>两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li><li>基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行比较。</li></ol><h3 id="📙缓存池"><a href="#📙缓存池" class="headerlink" title="📙缓存池"></a>📙缓存池</h3><p>包装类型内存使用 private static class IntegerCache，声明一个内部使用的缓存池</p><blockquote><p>如Integer中有个静态内部类IntegerCache，里面有个cache[],也就是Integer常量池，常量池的大小为一个字节（-128~127）<br>为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。</p></blockquote><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小。</p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values: true and false</li><li>all byte values</li><li>short values: between -128 and 127</li><li>int values: between -128 and 127</li><li>char: in the range \u0000 to \u007F</li></ul><h2 id="📓BigDecimal"><a href="#📓BigDecimal" class="headerlink" title="📓BigDecimal"></a>📓BigDecimal</h2><p>BigDecimal 主要用于处理解决精度丢失问题</p><blockquote><p>float和double类型主要是为了科学计算和工程计算而设计的。执行二进制浮点运算，这是为了在广泛的数字范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0f</span> - <span class="hljs-number">0.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.9f</span> - <span class="hljs-number">0.8f</span>;<br>System.out.println(a);<span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);<span class="hljs-comment">// 0.099999964</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="📓字符串"><a href="#📓字符串" class="headerlink" title="📓字符串"></a>📓字符串</h2><h3 id="📙String"><a href="#📙String" class="headerlink" title="📙String"></a>📙String</h3><p>String 被声明为 final，因此它不可被继承</p><ul><li>Java 8 中，String 内部使用 char 数组存储数据。</li><li>Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</li></ul><p>:memo:<strong>String不可变原因：</strong></p><ol><li><p>保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供&#x2F;暴露修改这个字符 串的⽅法。</p></li><li><p>String 类被 final 修饰导致其不能被继承，进⽽避免了⼦类破坏 String 不可变</p></li></ol><blockquote><p>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</p></blockquote><p>:memo:<strong>不可变的好处</strong></p><ol><li>可以缓存 hash 值</li><li>String Pool 的需要。如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li><li>安全性。String 经常作为参数，String 不可变性可以保证参数不可变。如网络传输</li><li>线程安全</li></ol><p>:memo:<strong>关于String使用new创建的问题：</strong></p><blockquote><ul><li><p>String str1 &#x3D; “aaa”; 是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)，</p></li><li><p>String str2 &#x3D; new String(“aaa”) ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 “aaa” 字符串对象）。</p></li></ul></blockquote><h4 id="📚String类型常量池"><a href="#📚String类型常量池" class="headerlink" title="📚String类型常量池"></a>📚<strong>String</strong>类型常量池</h4><p>String类型的常量池比较<strong>特殊</strong>。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li><li>如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><h3 id="📙StringBuffer"><a href="#📙StringBuffer" class="headerlink" title="📙StringBuffer"></a>📙StringBuffer</h3><p><code>StringBuffer</code>是可变类，对应的字符串的改变不会产生新的对象。</p><p><code>StringBuffer</code>的读写方法都使用了synchronized修饰，同一时间只有一个线程进行操作，所以是线程安全的</p><h3 id="📙StringBuilder"><a href="#📙StringBuilder" class="headerlink" title="📙StringBuilder"></a>📙StringBuilder</h3><p><code>StringBuilder</code>是可变类，对应的字符串的改变不会产生新的对象（线程不安全）。</p><h3 id="📙三者比较"><a href="#📙三者比较" class="headerlink" title="📙三者比较"></a>📙三者比较</h3><p>String、<code>StringBuilder</code>、<code>StringBuffer</code>三者的执行效率：<br><code>StringBuilder </code>&gt; <code>StringBuffer</code> &gt; String。这个实验结果是相对而言的，不一定在所有情况下都是这样。</p><blockquote><p>比如String str &#x3D; “hello”+ “world”的效率就比 <code>StringBuilder st = new StringBuilder().append(&quot;hello&quot;).append(&quot;world&quot;)</code>要高。</p></blockquote><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ol><h2 id="📓数组"><a href="#📓数组" class="headerlink" title="📓数组"></a>📓数组</h2><p><strong>数组初始化的两种方式：</strong></p><ul><li><p><strong>静态初始化</strong>（声明并初始化，此时不能指定容量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>动态初始化</strong>（先声明再初始化，此时必须指定容量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓变量存储位置"><a href="#📓变量存储位置" class="headerlink" title="📓变量存储位置"></a>📓变量存储位置</h2><ul><li><p>常量池：未经 new 的常量</p></li><li><p>堆区：成员变量的引用，new 出来的变量</p></li><li><p>栈区：局部变量的引用</p></li><li><p>成员变量的引用在堆区，是因为成员变量的所属对象在堆区，所以它也在堆区</p></li><li><p>局部变量的引用在栈区，是因为局部变量不属于某一个对象，在被调用时才被加载，所以在栈区。</p></li></ul><h2 id="📓Java程序初始化顺序"><a href="#📓Java程序初始化顺序" class="headerlink" title="📓Java程序初始化顺序"></a>📓Java程序初始化顺序</h2><p>在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。</p><p><strong>初始化一般遵循3个原则：</strong></p><ul><li>静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；</li><li>父类优先于子类进行初始化；</li><li>按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；</li></ul><p>🔸<strong>加载顺序</strong></p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="📓continue、break-和-return-的区别"><a href="#📓continue、break-和-return-的区别" class="headerlink" title="📓continue、break 和 return 的区别"></a>📓continue、break 和 return 的区别</h2><ol><li><p><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</p></li><li><p><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</p></li><li><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ul><li><p><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</p></li><li><p><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</p></li></ul></li></ol><h2 id="📓instanceof-关键字的作用"><a href="#📓instanceof-关键字的作用" class="headerlink" title="📓instanceof 关键字的作用"></a>📓instanceof 关键字的作用</h2><p>instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。</p><p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><h2 id="📓final、finally和finalize的区别"><a href="#📓final、finally和finalize的区别" class="headerlink" title="📓final、finally和finalize的区别"></a>📓final、finally和finalize的区别</h2><h3 id="📙final-关键字"><a href="#📙final-关键字" class="headerlink" title="📙final 关键字"></a>📙final 关键字</h3><h4 id="📚final-类"><a href="#📚final-类" class="headerlink" title="📚final 类"></a>📚<strong>final 类</strong></h4><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><h4 id="📚final-方法"><a href="#📚final-方法" class="headerlink" title="📚final 方法"></a><strong>📚final 方法</strong></h4><p>类中的 final 方法可以被子类继承，但是不能被子类修改，声明 final 方法的主要目的是防止该方法的内容被修改。</p><h4 id="📚final-变量"><a href="#📚final-变量" class="headerlink" title="📚final 变量"></a>📚final 变量</h4><blockquote><p>final变量能被显式地初始化并且只能初始化一次。</p></blockquote><ul><li><strong>修饰引用类型</strong>：被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</li><li><strong>修饰基础数据类型</strong>：final 使数值不变；</li></ul><h3 id="📙finally-关键字"><a href="#📙finally-关键字" class="headerlink" title="📙finally 关键字"></a>📙finally 关键字</h3><p>在异常处理的时候，提供 finally 块来执行任何的清除操作。如果抛出一个异常，那么相匹配的 catch 字句就会执行，然后控制就会进入 finally 块，前提是有 finally 块。例如：数据库连接关闭操作上</p><p>　　finally 作为异常处理的一部分，它只能用在 try&#x2F;catch 语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。</p><h3 id="📙finalize-关键字"><a href="#📙finalize-关键字" class="headerlink" title="📙finalize 关键字"></a>📙finalize 关键字</h3><p>finalize() 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 finalize() 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。要明白这个问题，先看一下虚拟机是如何判断一个对象该死的。</p><p>　　可以覆盖此方法来实现对其他资源的回收，例如关闭文件。</p><h2 id="📓transient关键字"><a href="#📓transient关键字" class="headerlink" title="📓transient关键字"></a>📓transient关键字</h2><p>Java 的 transient 关键字，只需要实现 Serilizable 接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h2 id="📓native关键字"><a href="#📓native关键字" class="headerlink" title="📓native关键字"></a>📓native关键字</h2><p>native（即 JNI，Java Native Interface），凡是一种语言，都希望是纯。比如解决某一个方案都喜欢就单单这个语言来写即可。Java 平台有个用户和本地 C 代码进行互操作的 API，称为 Java Native Interface (Java本地接口)。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209021723033.png" alt="img"></p><h2 id="📓static关键字"><a href="#📓static关键字" class="headerlink" title="📓static关键字"></a>📓static关键字</h2><ul><li><p><strong>静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p></li><li><p><strong>静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</p></li><li><p><strong>静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p></li><li><p><strong>静态内部类</strong></p></li></ul><p>  内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><ul><li><p><strong>静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓super关键字"><a href="#📓super关键字" class="headerlink" title="📓super关键字"></a>📓super关键字</h2><ol><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li><li>泛型中用于约束泛型的下界。如<code>&lt; ? super Apple&gt;</code></li></ol><h1 id="💠面向对象"><a href="#💠面向对象" class="headerlink" title="💠面向对象"></a>💠面向对象</h1><h2 id="📓继承"><a href="#📓继承" class="headerlink" title="📓继承"></a>📓继承</h2><p>🏳‍🌈<strong>接口没有继承Object类</strong></p><p>:memo:<strong>继承规则：</strong></p><ol><li><p>类与类之间的关系为继承，只能单继承，但可以多层继承。</p></li><li><p>类与接口之间的关系为实现，既可以单实现，也可以多实现。 </p></li><li><p>接口与接口之间的关系为继承，既可以单继承，也可以多继承。</p></li></ol><p>:memo:<strong>关于继承的3个点</strong></p><ol><li><p>⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性和⽅ 法⼦类是⽆法访问，只是拥有。</p></li><li><p>⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。</p></li><li><ol start="3"><li>⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。（以后介绍）。</li></ol></li></ol><h2 id="📓封装"><a href="#📓封装" class="headerlink" title="📓封装"></a>📓封装</h2><blockquote><p>封装是指把⼀个对象的状态信息（也就是属性）<strong>隐藏在对象内部</strong>，不允许外部对象直接访问对象的内 部信息。但是可以提供⼀些可以被外界访问的⽅法来操作属性。</p></blockquote><p>Java 中有三个访问权限修饰符：private、protected 以及 public，</p><ul><li>如果不加访问修饰符，表示包级可见。</li><li>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</li><li>private 仅自己可见</li><li>public 所有均可见</li></ul><blockquote><p>private 和 protected 不能修饰类。</p></blockquote><table><thead><tr><th>访问修饰符</th><th>同一个类</th><th>同包</th><th>不同包，子类</th><th>不同包，非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="📓多态"><a href="#📓多态" class="headerlink" title="📓多态"></a>📓多态</h2><p>:memo:<strong>多态的理解(多态的实现方式)</strong></p><ul><li><strong>方法重载</strong>（overload）：实现的是<strong>编译时的多态性</strong>（也称为前绑定）。</li><li><strong>方法重写</strong>（override）：实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西。</li></ul><p><strong>:memo:面相对象开发方式优点（B65）</strong></p><ul><li>较高的<strong>开发效率</strong>：可以把事物进行抽象，映射为开发的对象。</li><li>保证软件的<strong>鲁棒性</strong>：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。</li><li>保证软件的<strong>高可维护性</strong>：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</li></ul><h2 id="📓重载和重写的区别"><a href="#📓重载和重写的区别" class="headerlink" title="📓重载和重写的区别"></a>📓重载和重写的区别</h2><ul><li><p><strong>方法重写（子类与父类之间）</strong></p><blockquote><p><strong>“两同两小一大”原则</strong>：</p><ol><li>两同：方法名和参数列表相同</li><li>两小：返回值或声明异常比父类小（或相同）  </li><li>一大：访问修饰符比父类的大（或相同）</li></ol><p>细节如下：</p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote></li><li><p><strong>方法重载（同一个类中）</strong></p><p>在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不 同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是 否相同来判断重载。</p><blockquote><ul><li><p>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</p></li><li><p>被重载的方法可以改变返回类型；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。无法以返回值类型作为重载函数的区分标准。</p></li></ul></blockquote></li></ul><h2 id="📓接⼝和抽象类"><a href="#📓接⼝和抽象类" class="headerlink" title="📓接⼝和抽象类"></a>📓接⼝和抽象类</h2><h3 id="📙抽象类"><a href="#📙抽象类" class="headerlink" title="📙抽象类"></a>📙抽象类</h3><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><h3 id="📙接口"><a href="#📙接口" class="headerlink" title="📙接口"></a>📙接口</h3><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><ul><li>从 Java 8 开始，接口也可以拥有默认的方法实现</li><li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</li><li>接口的字段默认都是 static 和 final 的。</li></ul><h3 id="📙两者比较"><a href="#📙两者比较" class="headerlink" title="📙两者比较"></a>📙两者比较</h3><p>从设计层面上看</p><ul><li>抽象类的实现目的，是代码复用，一种模板设计的方式，可以让这些类都派生于一个抽象类。</li><li>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。</li></ul><p>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</p><ul><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p>设计上对比：</p><ul><li>抽象类： 拓展继承该抽象类的模块的类的行为功能（开放闭合原则）</li><li>接口：约束继承该接口的类行为（依赖倒置原则）</li></ul><h2 id="📓内部类"><a href="#📓内部类" class="headerlink" title="📓内部类"></a>📓内部类</h2><h3 id="📙成员内部类"><a href="#📙成员内部类" class="headerlink" title="📙成员内部类"></a>📙成员内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Coco&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123; <span class="hljs-comment">//内部类</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jayden&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>System.out.println(Outer.<span class="hljs-built_in">this</span>.name);<br>System.out.println(name);<br>System.out.println(age);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInnerClass</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br><span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> o.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>in.show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 <strong>public</strong> 、 <strong>protected</strong> 、 <strong>private</strong> 等。</li><li>Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。</li><li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 &#x3D; 外部类对象.new 内部类( )。</li><li>编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}</li><li>成员内部类中不能存在任何 static 的变量和方法,可以定义常量：<ol><li>因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过，非静态内部类的作用域是实例级别。</li><li>常量是在编译器就确定的,放到所谓的常量池了。</li></ol></li></ol><p><strong>:diamonds:温馨提示</strong></p><ol><li>外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name。</li></ol><h3 id="📙静态内部类"><a href="#📙静态内部类" class="headerlink" title="📙静态内部类"></a>📙静态内部类</h3><blockquote><p> static 修饰的内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Coco&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//静态内部类</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Jayden&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>System.out.println(Outer.name);<br>System.out.println(name);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>i.show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；</li><li>如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 &#x3D; new 内部类();</li></ol><h3 id="📙方法内部类"><a href="#📙方法内部类" class="headerlink" title="📙方法内部类"></a>📙方法内部类</h3><blockquote><p>其作用域仅限于方法内，方法外部无法访问该内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Show</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//方法内部类</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;访问外部类:&quot;</span> + a);<br>System.out.println(<span class="hljs-string">&quot;访问内部类:&quot;</span> + c);<br>&#125;<br>&#125;<br><span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>i.print();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>o.show();<br>&#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><ol><li>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的</li><li>只能访问方法中定义的 final 类型的局部变量，因为：<ul><li>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。</li><li>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期，局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数，防止被篡改数据,而导致内部类得到的值不一致</li></ul></li></ol><h3 id="📙匿名内部类"><a href="#📙匿名内部类" class="headerlink" title="📙匿名内部类"></a>📙匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>            <span class="hljs-keyword">public</span> InnerClass <span class="hljs-title function_">getInnerClass</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span>   num,String str2)</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>()&#123; <span class="hljs-comment">//匿名内部类</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//实现抽象方法</span><br>                        <span class="hljs-keyword">return</span> number;<br>                    &#125;<br>                &#125;;        <span class="hljs-comment">/* 注意：分号不能省 */</span><br>            &#125;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>                <span class="hljs-type">OuterClass</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>();<br>                <span class="hljs-type">InnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> out.getInnerClass(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;chenssy&quot;</span>);<br>                System.out.println(inner.getNumber());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InnerClass</span> &#123; <span class="hljs-comment">//匿名内部类要实现的接口</span><br>            <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>;<br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</p></li><li><p>匿名内部类中是不能定义构造函数的。</p></li><li><p>匿名内部类中不能存在任何的静态成员变量和静态方法。</p></li><li><p>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</p></li><li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p></li></ol><h2 id="📓类关系"><a href="#📓类关系" class="headerlink" title="📓类关系"></a>📓类关系</h2><p>:books:类与类之间有三种关系：</p><p>（1）is-a 包括了继承（类）和实现（接口）关系；</p><p>（2）has-a包括了关联、聚合、组合关系；</p><p>（3）use-a包括了依赖关系；</p><p><em>注：依赖关系 &gt; 关联关系 &gt; 聚合关系 &gt; 组合关系</em></p><h2 id="📓equals与-x3D-x3D-的区别"><a href="#📓equals与-x3D-x3D-的区别" class="headerlink" title="📓equals与&#x3D;&#x3D;的区别"></a>📓equals与&#x3D;&#x3D;的区别</h2><ul><li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><p>细节：</p><blockquote><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是 否是指相同一个对象。比较的是真正意义上的指针操作。</p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object 中的equals方法返回的却是&#x3D;&#x3D;的判断。</p></blockquote><h2 id="📓Hashcode"><a href="#📓Hashcode" class="headerlink" title="📓Hashcode()"></a>📓Hashcode()</h2><h3 id="📙Hashcode-的作用"><a href="#📙Hashcode-的作用" class="headerlink" title="📙Hashcode()的作用"></a>📙Hashcode()的作用</h3><blockquote><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p></blockquote><p>**hashCode()**：hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值.</p><ul><li>对象按照自己不同的特征尽量的有不同的哈希码，作用是用于<strong>快速查找</strong></li><li>另一个应用就是hash集合的使用</li></ul><h3 id="📙为什么hashCode-和equals-方法要一起重写"><a href="#📙为什么hashCode-和equals-方法要一起重写" class="headerlink" title="📙为什么hashCode()和equals()方法要一起重写"></a>📙为什么hashCode()和equals()方法要一起重写</h3><p>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals ⽅法判断两个对象是相等 的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() ⽅法的话就可能会导致 equals ⽅法判断是相等的两个 对象， hashCode 值却不相等。</p><h2 id="📓java复制"><a href="#📓java复制" class="headerlink" title="📓java复制"></a>📓java复制</h2><p>对于基本类型，直接赋值复制，对于对象类型分为浅拷贝与深拷贝</p><ol><li>浅拷贝：对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><blockquote><p>深拷贝的另一种方式，使用序列化和反序列化，获取一个新对象。</p></blockquote><h2 id="📓序列化"><a href="#📓序列化" class="headerlink" title="📓序列化"></a>📓序列化</h2><blockquote><p>定义：🏷<strong>序列化</strong>：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是<strong>对象状态的保存与重建</strong>。</p><p><strong>🏷反序列化</strong>：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></blockquote><h2 id="📓枚举"><a href="#📓枚举" class="headerlink" title="📓枚举"></a>📓枚举</h2><p>枚举类比较使用&#x3D;&#x3D;，同样也可以使用equals方法，Enum类中重写了equals实际上还是调用&#x3D;&#x3D;方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns true if the specified object is equal to this</span><br><span class="hljs-comment">* enum constant.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> other the object to be compared for equality with this object.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span>  true if the specified object is equal to this</span><br><span class="hljs-comment">*          enum constant.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object other)</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>==other;<br>&#125;<br></code></pre></td></tr></table></figure><p>📚<strong>为什么使用&#x3D;&#x3D;比较？</strong></p><p>因为枚举类在jvm编译成class文件后，实际编译成使用final 修饰的class，final修饰就意味着实例化后不可修改，且都指向堆中的同一个对象</p><p>普通的一个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">t</span> &#123;<br>   SPRING,SUMMER,AUTUMN,WINTER;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">T</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(s, i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] values()<br>    &#123;<br>        T at[];<br>        <span class="hljs-type">int</span> i;<br>        T at1[];<br>        System.arraycopy(at = ENUM$VALUES, <span class="hljs-number">0</span>, at1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[i = at.length], <span class="hljs-number">0</span>, i);<br>        <span class="hljs-keyword">return</span> at1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title function_">valueOf</span><span class="hljs-params">(String s)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (T)Enum.valueOf(demo/T, s);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T SPRING;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T SUMMER;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T AUTUMN;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T WINTER;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> T ENUM$VALUES[];<br>    <span class="hljs-keyword">static</span><br>    &#123;<br>        SPRING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;SPRING&quot;</span>, <span class="hljs-number">0</span>);<br>        SUMMER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;SUMMER&quot;</span>, <span class="hljs-number">1</span>);<br>        AUTUMN = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;AUTUMN&quot;</span>, <span class="hljs-number">2</span>);<br>        WINTER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;WINTER&quot;</span>, <span class="hljs-number">3</span>);<br>        ENUM$VALUES = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[] &#123;<br>            SPRING, SUMMER, AUTUMN, WINTER<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓IO流"><a href="#📓IO流" class="headerlink" title="📓IO流"></a>📓IO流</h2><h3 id="📙分类"><a href="#📙分类" class="headerlink" title="📙分类"></a>📙分类</h3><p>📃Java 的 I&#x2F;O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入&#x2F;输出：NIO</li></ul><p>磁盘操作🌰</p><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。递归地输出一个目录下所有文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listAllFiles</span><span class="hljs-params">(File dir)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span> || !dir.exists()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dir.isFile()) &#123;<br>        System.out.println(dir.getName());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        listAllFiles(file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节操作🌰</p><p>使用字节流操作进行文件复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(String src, String dist)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dist);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">20</span> * <span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">// read() 最多读取 buffer.length 个字节</span><br>    <span class="hljs-comment">// 返回的是实际读取的个数</span><br>    <span class="hljs-comment">// 返回 -1 的时候表示读到 eof，即文件尾</span><br>    <span class="hljs-keyword">while</span> (in.read(buffer, <span class="hljs-number">0</span>, buffer.length) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer);<br>    &#125;<br>    in.close();<br>    out.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>字符操作🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFileContent</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);<br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(line);<br>    &#125;<br>    <span class="hljs-comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span><br>    <span class="hljs-comment">// 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法</span><br>    <span class="hljs-comment">// 因此只要一个 close() 调用即可</span><br>    bufferedReader.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/inputStreamStructure.jpg" alt="avatar"></p><p>Java I&#x2F;O 使用了装饰者模式来实现。以 InputStream 为例，</p><p>📖InputStream 是抽象组件；</p><ul><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了文件字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p>📖InputStream的作用是用来表示那些从不同数据源产生输入的类。</p><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道“，工作方式与实际管道类似，即一端输入另一端输出</li><li>其他数据源，如Internet连接等</li></ol><p>📖Reader 与 Writer</p><ul><li>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</li><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h3 id="📙编码与解码"><a href="#📙编码与解码" class="headerlink" title="📙编码与解码"></a>📙编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>String 编码转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中文&quot;</span>;<br><span class="hljs-type">byte</span>[] bytes = str1.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(str2);<br></code></pre></td></tr></table></figure><h2 id="📓操作系统中的IO"><a href="#📓操作系统中的IO" class="headerlink" title="📓操作系统中的IO"></a>📓操作系统中的IO</h2><h3 id="📙常见I-x2F-O模型对比"><a href="#📙常见I-x2F-O模型对比" class="headerlink" title="📙常见I&#x2F;O模型对比"></a>📙常见I&#x2F;O模型对比</h3><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/ioModel.jpg" alt="avatar"></p><p>所有的系统I&#x2F;O都分为两个阶段：等待就绪和操作。</p><p>举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>需要说明的是<strong>等待就绪的阻塞是不使用CPU的，是在“空等”</strong>； 而<strong>真正的读写操作的阻塞是使用CPU的</strong>，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB&#x2F;s级别以上，可以理解为基本不耗时。</p><h3 id="📙BIO"><a href="#📙BIO" class="headerlink" title="📙BIO"></a>📙BIO</h3><p>传统的BIO中，read去读取网络的数据时，是无法预知对方是否已经发送数据的。因此在收到数据之前，能做的只有等待，直到对方把数据发过来，或者等到网络超时。</p><h3 id="📙NIO"><a href="#📙NIO" class="headerlink" title="📙NIO"></a>📙NIO</h3><p>NIO模式下，系统调用read，如果发现没数据已经到达，就会立刻返回-1。使用轮询的方式，不断的尝试有没有数据到达。没有得到数据就等一小会再试继续轮询。</p><p>NIO解决了线程阻塞的问题 ，但是会带来两个新问题：</p><ol><li>如果有IO连接都要检查，那么就得一个一个的read。这会带来大量的线程上下文切换（read是系统调用，每调用一次就得在用户态和核心态切换一次）</li><li>轮询的休息等待时间无法确定。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。</li></ol><h3 id="📙IO复用模型"><a href="#📙IO复用模型" class="headerlink" title="📙IO复用模型"></a>📙IO复用模型</h3><p><strong>定义</strong>：多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互，告诉操作系统要监视这些IO是否有事件发生。阻塞读取操作系统epoll方法回调的通知消息。</p><p>特点及相关说明：</p><ul><li>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住，没有达到IO多路复用的通知请求到来的效果。</li><li>IO多路复用说的是多个Socket或IO连接，只不过操作系统是一起监听他们的事件而已。</li></ul><blockquote><p>多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。</p></blockquote><ul><li>IO多路复用的关键API调用(select，poll，epoll_wait）总是Block的</li><li><strong>IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费</strong>，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输）。</li></ul><h4 id="📚epoll"><a href="#📚epoll" class="headerlink" title="📚epoll"></a>📚epoll</h4><p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p><ul><li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li><li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li><li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。<ul><li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似<strong>callback的回调机制</strong>,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li></ul></li></ul><h4 id="📚水平触发与边缘触发"><a href="#📚水平触发与边缘触发" class="headerlink" title="📚水平触发与边缘触发"></a>📚水平触发与边缘触发</h4><p>epoll除了性能优势，还有一个优点——同时支持水平触发(Level Trigger)和边沿触发(Edge Trigger)。</p><ul><li>水平触发只关心文件描述符中是否还有没完成处理的数据，如果有，不管怎样epoll_wait，总是会被返回。简单说——水平触发代表了一种“状态”。</li><li>边沿触发只关心文件描述符是否有新的事件产生，如果有，则返回；如果返回过一次，不管程序是否处理了，只要没有新的事件产生，epoll_wait不会再认为这个fd被“触发”了。简单说——边沿触发代表了一个“事件”。</li></ul><p>边沿触发把如何处理数据的控制权完全交给了开发者，提供了巨大的灵活性。比如，读取一个http的请求，开发者可以决定只读取http中的headers数据就停下来。在边沿触发下，开发者有机会更精细的定制这里的控制逻辑。</p><h3 id="📙信号驱动IO"><a href="#📙信号驱动IO" class="headerlink" title="📙信号驱动IO"></a>📙信号驱动IO</h3><p>在通道中安装一个信号器：映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。</p><p>阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行的。</p><h4 id="📚AIO"><a href="#📚AIO" class="headerlink" title="📚AIO"></a>📚AIO</h4><p>用了AIO可以废弃select，poll，epoll。 linux的AIO的实现方式是内核和应用共享一片内存区域，应用通过检测这个内存区域（避免调用nonblocking的read、write函数来测试是否来数据，因为即便调用nonblocking的read和write由于进程要切换用户态和内核态，仍旧效率不高）来得知fd是否有数据，可是检测内存区域毕竟不是实时的，你需要在线程里构造一个监控内存的循环，设置sleep，总的效率不如epoll这样的实时通知。</p><h3 id="📙相关资料"><a href="#📙相关资料" class="headerlink" title="📙相关资料"></a>📙相关资料</h3><ul><li>操作系统层面理解IO：<a href="https://www.cnblogs.com/twoheads/p/10712094.html">https://www.cnblogs.com/twoheads/p/10712094.html</a></li><li>图解IO：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41#wechat_redirect</a></li><li>把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。<ul><li>烧水的报警器一响，整个烧水过程就完成了。水已经是开水了。</li><li>钓鱼的报警器一响，只能说明鱼儿已经咬钩了，但是还没有真正的钓上来。</li></ul></li></ul><h2 id="📓Java-中的网络支持"><a href="#📓Java-中的网络支持" class="headerlink" title="📓Java 中的网络支持"></a>📓Java 中的网络支持</h2><p>基本概念</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；f</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h2 id="📓java-BIO-Blocking-IO-阻塞"><a href="#📓java-BIO-Blocking-IO-阻塞" class="headerlink" title="📓java BIO(Blocking IO 阻塞)"></a>📓java BIO(Blocking IO 阻塞)</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/socket.png" alt="avatar"></p><ul><li>在不考虑多线程的情况下，BIO是无法处理多个客户端请求的。</li><li>BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。</li><li>多线程情况下对于服务端，服务端只能用线程开启多个线程与客户端建立连接。</li></ul><p>BIO多线程情况下的缺点：内存消耗、线程上下文切换</p><ol><li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li><li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU 使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li><li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li></ol><h2 id="📓java-NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#📓java-NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="📓java NIO(Non-blocking&#x2F;New I&#x2F;O)"></a>📓java NIO(Non-blocking&#x2F;New I&#x2F;O)</h2><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><ol><li>首先需要注册当这几个事件到来的时候所对应的处理器，事件处理完毕移除SelectKey，若未移除，selector不会检查这些key是否有事件到来。</li><li>然后在合适的时机告诉事件选择器：对这个事件感兴趣。</li><li>其次，用一个死循环选择就绪的事件，会执行系统调用，还会阻塞的等待新事件的到来。（系统调用指的是操作系统的函数调用，Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP）</li><li>新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</li><li>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。</li></ol><blockquote><p>select会进行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p></blockquote><ul><li>NIO由原来的阻塞读写（占用线程）变成了<strong>单线程轮询事件</strong>，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</li></ul><h3 id="📙零拷贝"><a href="#📙零拷贝" class="headerlink" title="📙零拷贝"></a>📙零拷贝</h3><p>IO的拷贝：</p><ol><li>硬件（网卡）拷贝内核缓冲区 （读）</li><li>内核缓冲区拷贝到用户缓冲区 （读）</li><li>用户空间再拷贝到内核空间中的Socket buffer&#x2F;Write buffer中。（写）</li><li>最后再从Socket buffer中拷贝到网卡缓冲区&#x2F;硬件资源中。（写）</li></ol><p>零拷贝的实现： 使用直接内存，在内核缓冲区中开辟一块用户空间和内核空间共享的直接内存区域，减少了用户缓冲区的复制操作。</p><h3 id="📙事件驱动模型"><a href="#📙事件驱动模型" class="headerlink" title="📙事件驱动模型"></a>📙事件驱动模型</h3><p>Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。</p><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I&#x2F;O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/NIORefactor.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/NIORefactor.png" alt="avatar"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelHandler</span>&#123;<br>      <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadable</span><span class="hljs-params">(Channel channel)</span>;<br>      <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelWritable</span><span class="hljs-params">(Channel channel)</span>;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>&#123;<br>     Socket socket;<br>     Event event;<span class="hljs-comment">//读，写或者连接</span><br>   &#125;<br><br>   <span class="hljs-comment">//IO线程主循环:</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">IoThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>   Channel channel;<br>   <span class="hljs-keyword">while</span>(channel=Selector.select())&#123;<span class="hljs-comment">//选择就绪的事件和对应的连接</span><br>      <span class="hljs-keyword">if</span>(channel.event==accept)&#123;<br>         registerNewChannelHandler(channel);<span class="hljs-comment">//如果是新连接，则注册一个新的读写处理器</span><br>      &#125;<br>      <span class="hljs-keyword">if</span>(channel.event==write)&#123;<br>         getChannelHandler(channel).channelWritable(channel);<span class="hljs-comment">//如果可以写，则执行写事件</span><br>      &#125;<br>      <span class="hljs-keyword">if</span>(channel.event==read)&#123;<br>          getChannelHandler(channel).channelReadable(channel);<span class="hljs-comment">//如果可以读，则执行读事件</span><br>      &#125;<br>    &#125;<br>   &#125;<br>   Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="hljs-comment">//所有channel的对应事件处理器</span><br></code></pre></td></tr></table></figure><p>相关资料：</p><ul><li>NIO selectKey原理：<a href="https://blog.csdn.net/qq_32331073/article/details/81132937">https://blog.csdn.net/qq_32331073/article/details/81132937</a></li><li>美团NIO浅析: <a href="https://tech.meituan.com/2016/11/04/nio.html">https://tech.meituan.com/2016/11/04/nio.html</a></li></ul><h3 id="📙NIO与BIO区别"><a href="#📙NIO与BIO区别" class="headerlink" title="📙NIO与BIO区别"></a>📙NIO与BIO区别</h3><ul><li>通讯方式：NIO 通过Channel（通道） 进行读写，通道是双向的，可读也可写。而BIO使用的流读写是单向的。</li><li>BIO流是阻塞的，NIO流是不阻塞的。</li><li>BIO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。<ol><li>在面向流的I&#x2F;O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</li><li>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</li></ol></li></ul><p>NIO 带来了什么</p><ul><li>避免多线程</li><li>非阻塞I&#x2F;O，I&#x2F;O读写不再阻塞，而是返回0</li><li>单线程处理多任务</li><li>基于block的传输，通常比基于流的传输更高效</li><li>更高级的IO函数，zero-copy</li><li>事件驱动模型</li><li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li></ul><h3 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h3><p>在Reactor中实现读</p><ol><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ol><p>在Proactor中实现读：</p><ol><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ol><ul><li>两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；</li><li>不同点在于，异步情况下（Proactor)，当回调handler时，表示I&#x2F;O操作已经完成；同步情况下（Reactor)，回调handler时，表示I&#x2F;O设备可以进行某个操作（can read 或 can write)。</li></ul><h3 id="📙RMI-远程方法调用"><a href="#📙RMI-远程方法调用" class="headerlink" title="📙RMI 远程方法调用"></a>📙RMI 远程方法调用</h3><p>java支持，最早的远程调用，使用Remote接口，同时实现类别需要继承UnicastRemoteObject</p><p>通过Registry，注册发现远程方法，并调用接口。</p><h3 id="📙netty"><a href="#📙netty" class="headerlink" title="📙netty"></a>📙netty</h3><p>Netty 是一个 基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</p><ul><li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li><li>支持多种协议 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li></ul><p>支持多个交互模型 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/netty.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/netty.jpg" alt="avatar"></a></p><ul><li>Reactor分成两部分，mainReactor负责监听server socket，accept新连接；并将建立的socket分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据，对业务处理功能，其扔给worker线程池完成。</li></ul><p>Netty中的事件分为Inbond事件和Outbound事件。</p><ul><li>Inbound事件通常由I&#x2F;O线程触发，如TCP链路建立事件、链路关闭事件、读事件、异常通知事件等。</li><li>Outbound事件通常是用户主动发起的网络I&#x2F;O操作，如用户发起的连接操作、绑定操作、消息发送等。</li></ul><p>相比NIO ：</p><ul><li>NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂。Netty的出现正是为了解决这些问题。</li><li>解决了JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li><li>通过代码封装，简化了服务端与客户端的代码交互。</li><li>数据直接复制到directBuffer的工作缓冲区</li></ul><h2 id="📓泛型"><a href="#📓泛型" class="headerlink" title="📓泛型"></a>📓泛型</h2><h3 id="📙简介"><a href="#📙简介" class="headerlink" title="📙简介"></a>📙简介</h3><blockquote><p>泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数。<br>在集合中存储对象并在使用前进行类型转换是不方便的。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p></blockquote><p>📚使用<code>T, E or K,V</code>等被广泛认可的类型占位符。</p><p>📖泛型有三种常用的使用方式：泛型类，泛型接口和泛型方法。</p><p>📄限定通配符和非限定通配符:</p><ol><li>非限定通配符：<code>&lt;?&gt;</code>表示了非限定通配符，因为<code>&lt;?&gt;</code>可以用任意类型来替代。</li><li>限定通配符：一种是<code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的上界 ，另一种是<code>&lt;? super T&gt;</code>它通过确保类型必须是T的父类来设定类型的下界</li><li>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</li></ol><h3 id="📙类型擦除"><a href="#📙类型擦除" class="headerlink" title="📙类型擦除"></a>📙类型擦除</h3><p>📚类型擦除: Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p><ul><li>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。</li><li>类型擦除后保留的原始类型，最后在字节码中的类型变量变成真正类型。无论何时定义一个泛型，相应的原始类型都会被自动提供，无限定的变量用Object替换。</li></ul><p>泛型擦除的例子： 本应该只能储存Integer，在通过反射调用方法时，却可以添加String数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>   list.add(<span class="hljs-number">1</span>);  <span class="hljs-comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br>   list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-string">&quot;asd&quot;</span>);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>      System.out.println(list.get(i));<br>   &#125;<br>&#125;<br><span class="hljs-comment">// output</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//asd</span><br></code></pre></td></tr></table></figure><p>📚<strong>类型擦除后保留的原始类型</strong>：在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，另一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，另一个是String，所以取同一父类的最小级，为Object  </span><br>  <br><span class="hljs-comment">//这是一个简单的泛型方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">add</span><span class="hljs-params">(T x,T y)</span>&#123;  <br>    <span class="hljs-keyword">return</span> y;  <br>&#125;    <br></code></pre></td></tr></table></figure><p>Java不能实现真正的泛型，只能使用<strong>类型擦除来实现伪泛型</strong>，这样虽然不会有类型膨胀问题，但是也引起来许多新问题</p><p>📚<strong>PECS原则</strong><br>如果要从集合中<strong>读取类型T的数据，并且不能写入</strong>，可以使用 ? extends 通配符；(Producer Extends)</p><p> 如果要从集合中<strong>写入类型T的数据，并且不需要读取</strong>，可以使用 ? super 通配符；</p><p>(Consumer Super) 如果<strong>既要存又要取</strong>，那么就不要使用任何通配符。</p><p>参考：</p><h2 id="📓反射"><a href="#📓反射" class="headerlink" title="📓反射"></a>📓反射</h2><p>:books:先看看知乎回答</p><p>　反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到 JVM，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><p>　　举个例子我们的项目底层有时是用 mysql，有时用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 Class tc &#x3D; Class.forName(“com.java.dbtest.TestConnection”); 通过类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle 则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出 Java 的特性了！</p><p>　　举多个例子，大家如果接触过 spring，会发现当你配置各种各样的 bean 时，是以配置文件的形式配置的，你需要用到哪些 bean 就配哪些，spring 容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><hr size=1 style="width:100%px;height:3px;border:none;border-top:3px double orange;"> <p>:memo:反射可以提供<strong>运行时</strong>的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><ol><li>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</li><li>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。</li><li>也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li></ol><p>:memo:Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><p>:memo:反射的<strong>优点</strong>：</p><ul><li><strong>可扩展性</strong>：应用程序可以利用全限定名创建可扩展对象的实例，如com.demo.Test。</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li><li>开发工具：如IDEA开发工具可以从反射中获取类的信息，帮助开发人员代码编写。</li></ul><p>:memo:反射的<strong>缺点</strong>：如果一个功能可以不用反射完成，那么最好就不用。</p><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。</li><li><strong>安全限制</strong>：使用反射技术要求程序必须在一个没有安全限制的环境中运行。</li><li>内部暴露：反射破坏了封装性，可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性</li></ul><p>:memo:反射的<strong>功能</strong>：</p><ul><li><p>在运行时判断任意一个对象所属的类</p></li><li><p>在运行时构造任意一个类的对象</p></li><li><p>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</p></li><li><p>在运行时调用任意一个对象的方法</p></li></ul><p><strong>重点</strong>：是运行时而不是编译时</p><p><strong>:memo:获得Class对象</strong></p><ul><li><p>调用运行时类本身的 <code>.class</code> 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Person.class;<br>System.out.println(clazz1.getName());<br></code></pre></td></tr></table></figure></li><li><p>通过运行时类的对象获取 <code>getClass()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> p.getClass();<br>System.out.println(clazz3.getName());<br></code></pre></td></tr></table></figure></li><li><p>使用 Class 类的 <code>forName</code> 静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br><span class="hljs-comment">// 在JDBC开发中常用此方法加载数据库驱动:</span><br>Class.forName(driver);<br></code></pre></td></tr></table></figure></li><li><p>（了解）通过类的加载器 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz5</span> <span class="hljs-operator">=</span> classLoader.loadClass(className);<br>System.out.println(clazz5.getName());<br></code></pre></td></tr></table></figure></li></ul><h2 id="📓异常与错误"><a href="#📓异常与错误" class="headerlink" title="📓异常与错误"></a>📓异常与错误</h2><p>📃Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。</p><blockquote><p>其中 Error 用来表示 JVM 无法处理的错误，</p></blockquote><p>📃Exception 分为两种：</p><ol><li>受检异常 ：要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li>非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复<ul><li>运行时异常（runtime exception）</li><li>错误（Error）</li></ul></li></ol><p>📃RuntimeException是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。一般来说，RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。</p><blockquote><p>常见RuntimeException异常：NullPointException、ClassCastException、IllegalArgumentException、IndexOutOfBoundException</p></blockquote><p>📃try语句return问题：<strong>如果try语句里有return，返回的是try语句块中变量值</strong>。详细执行过程如下：</p><ol><li>如果有返回值，就把返回值保存到局部变量中；</li><li>执行jsr指令跳到finally语句里执行；</li><li>执行完finally语句后，返回之前保存在局部变量表里的值。</li><li>针对对象引用的返回，如果finally中有修改值，返回的是引用的对象。 <strong>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</strong></li></ol><p>📃<strong>catch和finally语句不能同时省略！</strong></p><ul><li>用try-catch 捕获异常;</li><li>用try-finally 清除异常;</li><li>用try-catch-finally 处理所有的异常. 三者选一种即可</li></ul><p>📃Throwable 类常⽤⽅法</p><ul><li>String getMessage() : 返回异常发⽣时的简要描述 </li><li>String toString() : 返回异常发⽣时的详细信息</li><li>String getLocalizedMessage() : 返回异常对象的本地化信息。使⽤ Throwable 的⼦类覆盖这个⽅ 法，可以⽣成本地化信息。如果⼦类没有覆盖该⽅法，则该⽅法返回的信息与 getMessage() 返 回的结果相同</li><li>void printStackTrace() : 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h2 id="📓注解"><a href="#📓注解" class="headerlink" title="📓注解"></a>📓注解</h2><h3 id="📙什么是注解"><a href="#📙什么是注解" class="headerlink" title="📙什么是注解"></a>📙什么是注解</h3><p>　Annontation 是 Java5 开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来<strong>将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</strong>。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation 像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>　　Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <code>java.lang.annotation</code> 包中。</p><p>　　简单来说：注解其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。</p><h3 id="📙为什么要注解"><a href="#📙为什么要注解" class="headerlink" title="📙为什么要注解"></a>📙为什么要注解</h3><p>传统的方式，我们是通过配置文件 <code>.xml</code> 来告诉类是如何运行的。</p><p>有了注解技术以后，我们就可以通过注解告诉类如何运行</p><p>例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解…Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。</p><p>明显地可以看出，这样是非常直观的，并且 Servlet 规范是推崇这种配置方式的。</p><h3 id="📙内置注解"><a href="#📙内置注解" class="headerlink" title="📙内置注解"></a>📙内置注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p>🏷作用在代码的注解:</p><ul><li><code>@Override</code>: 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code>: 标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code>: 指示编译器去忽略注解中声明的警告。</li></ul><p>🏷作用在其他注解的注解(或者说<strong>元注解</strong>)是:</p><ul><li><code>@Retention</code> : 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code>: 标记这些注解是否包含在用户文档中。</li><li><code>@Target</code>: 标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code>: 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>🏷从 Java 7 开始，额外添加了 3 个注解:</p><ul><li><code>@SafeVarargs</code>: Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code>: Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li><code>@Repeatable</code>: Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h3 id="📙元注解"><a href="#📙元注解" class="headerlink" title="📙元注解"></a>📙元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><ol><li><p><code>@Documented</code>：注解是否将包含在JavaDoc中</p></li><li><p><code>@Retention</code>(什么时候使用该注解)</p><ul><li><code>RetentionPolicy.SOURCE</code> : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。<code>@Override</code>, <code>@SuppressWarnings</code>都属于这类注解。</li><li><code>RetentionPolicy.CLASS</code> : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li></ul></li><li><p>@Target（注解用于什么地方）</p><ul><li><code>ElementType.CONSTRUCTOR</code>: 用于描述构造器</li><li><code>ElementType.FIELD</code>: 成员变量、对象、属性（包括enum实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>: 用于描述局部变量</li><li><code>ElementType.METHOD</code>: 用于描述方法</li><li><code>ElementType.PACKAGE</code>: 用于描述包</li><li><code>ElementType.PARAMETER</code>: 用于描述参数</li><li><code>ElementType.TYPE</code>: 用于描述类、接口(包括注解类型) 或enum声明 常见的@Component、@Service</li></ul></li><li><p>@Inherited（是否允许子类继承该注解）</p><blockquote><p><code>@Inherited</code> 元注解是一个标记注解，<code>@Inherited</code> 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类</p></blockquote></li></ol><h3 id="📙自定义注解"><a href="#📙自定义注解" class="headerlink" title="📙自定义注解"></a>📙自定义注解</h3><ol><li>Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.</li><li>参数成员只能用 public 或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组</li><li>要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.ElementType.FIELD;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 水果名称注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(FIELD)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitName &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//属性写成类似方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="📓网络编程"><a href="#📓网络编程" class="headerlink" title="📓网络编程"></a>📓网络编程</h2><h3 id="📙网络编程基础"><a href="#📙网络编程基础" class="headerlink" title="📙网络编程基础"></a>📙网络编程基础</h3><ul><li>Java网络编程<code>API</code>建立在Socket基础之上</li><li>Java网络接口支持<code>IP</code>以上的所有高层协议</li></ul><p>📃java网络通信类：</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h3 id="📙Socket"><a href="#📙Socket" class="headerlink" title="📙Socket"></a>📙Socket</h3><blockquote><p>:books:Socket，又称套接字，是在不同的进程间进行网络通讯的一种协议、约定或者说是规范。</p><p>对于Socket编程，它更多的时候是基于TCP&#x2F;UDP等协议做的一层封装或者说抽象，是一套系统所提供的用于进行网络通信相关编程的接口。</p></blockquote><p>📃Socket通信伪代码：</p><ol><li>服务器绑定端口：server &#x3D; new ServerSocket(PORT)</li><li>服务器阻塞监听：socket &#x3D; server.accept()</li><li>服务器开启线程：new Thread(Handle handle)</li><li>服务器读写数据：BufferedReader PrintWriter</li><li>客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)</li><li>客户端传输接收数据：BufferedReader PrintWriter</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209022105074.png" alt="img"></p><p><strong>Socket的特点</strong></p><ol><li>Socket基于TCP链接，数据传输有保障</li><li>Socket适用于建立长时间链接</li><li>Socket编程通常应用于即时通讯</li></ol>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2022/09/04/Netty/"/>
    <url>/2022/09/04/Netty/</url>
    
    <content type="html"><![CDATA[<h1 id="💠Netty"><a href="#💠Netty" class="headerlink" title="💠Netty"></a>💠Netty</h1><h2 id="📓netty-是什么"><a href="#📓netty-是什么" class="headerlink" title="📓netty 是什么"></a>📓netty 是什么</h2><ul><li>基于 NIO 的 RPC 框架的网络通信框架</li><li>极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程</li><li>支持多种协议 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li><li>自带编解码器解决 TCP 粘包&#x2F;拆包问题。</li></ul><h2 id="📓Reactor-模式"><a href="#📓Reactor-模式" class="headerlink" title="📓Reactor 模式"></a>📓Reactor 模式</h2><p>Reactor模式基于事件驱动，特别适合处理海量的I&#x2F;O事件</p><p>Reactor线程模型分为单线程模型、多线程模型以及主从多线程模型。</p><h3 id="📙单线程Reactor"><a href="#📙单线程Reactor" class="headerlink" title="📙单线程Reactor"></a>📙单线程Reactor</h3><p>单线程 Reactor 的优点是对系统资源消耗特别小，但是，没办法支撑大量请求的应用场景并且处理请求的时间可能非常慢 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor.jpg" alt="avatar"></a></p><h3 id="📙多线程Reactor"><a href="#📙多线程Reactor" class="headerlink" title="📙多线程Reactor"></a>📙多线程Reactor</h3><p>一个线程负责接受请求,一组NIO线程处理IO操作。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.png" alt="avatar"></a></p><h3 id="📙主从多线程Reactor"><a href="#📙主从多线程Reactor" class="headerlink" title="📙主从多线程Reactor"></a>📙主从多线程Reactor</h3><p>一组NIO线程负责接受请求，一组NIO线程处理IO操作。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyRefactor2.jpg" alt="avatar"></a></p><h2 id="📓java-IO比较"><a href="#📓java-IO比较" class="headerlink" title="📓java IO比较"></a>📓java IO比较</h2><ul><li><strong>同步阻塞IO（BIO）</strong>：用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行（客户端和服务器连接需要三次握手，使用简单，但吞吐量小）；</li><li><strong>同步非阻塞IO（NIO）</strong>：用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费（客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性）；</li><li><strong>异步非阻塞IO（AIO）</strong>：用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式（NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法）。</li></ul><h2 id="📓I-x2F-O多路复用模型"><a href="#📓I-x2F-O多路复用模型" class="headerlink" title="📓I&#x2F;O多路复用模型"></a>📓I&#x2F;O多路复用模型</h2><ul><li><strong>I&#x2F;O</strong> ：网络 I&#x2F;O</li><li><strong>多路</strong>：多个 TCP 连接</li><li><strong>复用</strong>：共用一个线程或进程</li></ul><h2 id="📓Netty的核心组件"><a href="#📓Netty的核心组件" class="headerlink" title="📓Netty的核心组件"></a>📓Netty的核心组件</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/io/nettyAF.jpg" alt="avatar"></p><p>Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册到其上的Channel 处理 I&#x2F;O 操作，两者配合参与 I&#x2F;O 操作。</p><h3 id="📙Channel"><a href="#📙Channel" class="headerlink" title="📙Channel"></a>📙Channel</h3><p>Channel 接口是 Netty 对网络操作抽象类，它包括基本的 I&#x2F;O 操作，如 bind()、connect()、read()、write() 等。 比较常用的Channel接口实现类是NioServerSocketChannel（服务端）和NioSocketChannel（客户端），这两个 Channel 可以和 BIO 编程模型中的ServerSocket以及Socket两个概念对应上。</p><h3 id="📙EventLoop"><a href="#📙EventLoop" class="headerlink" title="📙EventLoop"></a>📙EventLoop</h3><p>EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。负责监听网络事件并调用事件处理器进行相关 I&#x2F;O 操作的处理。</p><p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程）,EventLoop 处理的 I&#x2F;O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p><p>客户端连接处理流程：</p><ol><li>当客户端通过 connect 方法连接服务端时，bossGroup 处理客户端连接请求。</li><li>当客户端处理完成后，会将这个连接提交给 workerGroup 来处理，然后 workerGroup 负责处理其 IO 相关操作。</li></ol><h3 id="📙ChannelHandler-和-ChannelPipeline"><a href="#📙ChannelHandler-和-ChannelPipeline" class="headerlink" title="📙ChannelHandler 和 ChannelPipeline"></a>📙ChannelHandler 和 ChannelPipeline</h3><p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p><p>ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">b.group(eventLoopGroup)<br>  .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyKryoDecoder</span>(kryoSerializer, RpcResponse.class));<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyKryoEncoder</span>(kryoSerializer, RpcRequest.class));<br>          ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KryoClientHandler</span>());<br>      &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="📙Bootstrap-和-ServerBootstrap-引导类"><a href="#📙Bootstrap-和-ServerBootstrap-引导类" class="headerlink" title="📙Bootstrap 和 ServerBootstrap 引导类"></a>📙Bootstrap 和 ServerBootstrap 引导类</h3><p>ServerBootstrap服务端启动： 1.首先你创建了两个 NioEventLoopGroup 对象实例：bossGroup 和 workerGroup。</p><ul><li>bossGroup : 用于处理客户端的 TCP 连接请求。</li><li>workerGroup ：负责每一条连接的具体读写数据的处理逻辑，真正负责 I&#x2F;O 读写操作，交由对应的 Handler 处理。</li><li>一般情况下我们会指定 bossGroup 的 线程数为 1（并发连接量不大的时候） ，workGroup 的线程数量为 CPU 核心数 *2 。另外，根据源码来看，使用 NioEventLoopGroup 类的无参构造函数设置线程数量的默认值就是 CPU 核心数 *2 。 2.接下来 我们创建了一个服务端启动引导&#x2F;辅助类：ServerBootstrap，这个类将引导我们进行服务端的启动工作。 3.通过 .group() 方法给引导类 ServerBootstrap 配置两大线程组，确定了<strong>线程模型</strong>。</li></ul><p>Bootstrap客户端启动： 1.创建一个 Bootstrap、NioEventLoopGroup 对象实例 2.通过 .group() 方法给引导类 Bootstrap 配置一个线程组 3.通过channel()方法给引导类 Bootstrap指定了 IO 模型为NIO 4.通过 .childHandler()给引导类创建一个ChannelInitializer ，然后指定了客户端消息的业务处理逻辑 ClientHandler 对象 5.调用 Bootstrap 类的 connect()方法进行连接，这个方法需要指定两个参数：IP、端口</p><h2 id="📓什么是-TCP-粘包-x2F-拆包"><a href="#📓什么是-TCP-粘包-x2F-拆包" class="headerlink" title="📓什么是 TCP 粘包&#x2F;拆包"></a>📓什么是 TCP 粘包&#x2F;拆包</h2><p>粘包与拆包：基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。</p><p>Netty 自带的解码器</p><ul><li>LineBasedFrameDecoder : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔。</li><li>DelimiterBasedFrameDecoder : 可以自定义分隔符解码器</li></ul><h2 id="📓其他"><a href="#📓其他" class="headerlink" title="📓其他"></a>📓其他</h2><p>Netty 长连接、心跳机制</p><ul><li>TCP连接三次握手、四次挥手耗费网络资源，且多次建立连接更消耗资源。因此使用长连接的方式，为了保证长连接的有效性，引入心跳机制，在空闲时刻也可以维持连接。</li></ul><p>Netty 的零拷贝</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java单元测试</title>
    <link href="/2022/09/04/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/04/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="💠java单元测试"><a href="#💠java单元测试" class="headerlink" title="💠java单元测试"></a>💠java单元测试</h1><h2 id="📓测试名词"><a href="#📓测试名词" class="headerlink" title="📓测试名词"></a>📓测试名词</h2><ul><li>单元测试：单元测试（模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。</li><li>集成测试：集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。</li><li>黑盒测试：被测程序看成是一个无法打开的黑盒，而工作人员在不考虑任何程序内部结构和特性的条件下，根据需求规格说明书设计测试实例，并检查程序的功能是否能够按照规范说明准确无误的运行。</li><li>白盒测试：借助程序内部的逻辑和相关信息，通过检测内部动作是否按照设计规格说明书的设定进行，检查每一条通路能否正常工作。白盒测试是从程序结构方面出发对测试用例进行设计。其主要用于检查各个逻辑结构是否合理，对应的模块独立路径是否正常以及内部结构是否有效。</li><li>冒烟测试：是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，并非对软件版本包的深入测试，是针对软件版本包进行详细测试之前的预测试，执行冒烟测试的主要目的是快速验证软件基本功能是否有缺陷。</li><li>回归测试：指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。</li><li>金丝雀测试：在金丝雀测试中，金丝雀是一小群体验最新软件更新的用户，他们的反馈可帮助开发团队决定是否应向所有用户提供新版本，或者更改应快速回滚，方法的名字来自过去在煤矿中用作有毒气体探测器的金丝雀鸟。 。金丝雀测试、金丝雀释放和金丝雀部署概念类似。</li></ul><h2 id="📓单元测试相关方法论"><a href="#📓单元测试相关方法论" class="headerlink" title="📓单元测试相关方法论"></a>📓单元测试相关方法论</h2><p>测试金字塔里的单元测试：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/unitTestTower.png" alt="avatar"></p><p>不同测试方法比较：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/UTCompare.png" alt="avatar"></p><h2 id="📓优缺点分析"><a href="#📓优缺点分析" class="headerlink" title="📓优缺点分析"></a>📓优缺点分析</h2><p>优点：</p><ol><li><p>开发人员：</p><ul><li>尽早发现缺陷，降低开发投入成本。开发人员可以快速验证他们所写代码，及早地发现代码中的问题。</li><li>新人融入。通过让新入职员工结合文档和运行单元测试，可以更快了解代码逻辑。</li><li>利于重构。通过单元测试，开发可以放心的修改重构代码，减少改代码时心理负担，提高重构的成功率。因为重构的代码通过单元测试，说明与原有逻辑一致。</li><li>改善设计。越是良好设计的代码，越容易编写单元测试，如果发现单测代码非常难写，一般表明被测试的代码包含了太多的依赖或职责，需要反思代码的合理性，进而推进代码设计的优化，形成正向循环。</li></ul></li><li><p>其他方面；</p><ul><li><p>单元测试触发快，每次项目构建可以触发run单元测试，保证每次发布修改不影响先前代码。</p></li><li><p>单元测试可以集成到代码合并流程里。在代码合并到发布分支之后，通过运行单元测试，保证分支代码的正确性再合并到master。</p><ul><li><blockquote><p>一般的流程是这样的：保护好“master”分支，不允许开发人员向该分支提交代码，而是让他们把代码提交到其他分支上。在将代码合并到 master 分支的时候，GitHub 要求先通过状态检查。Jenkins、CircleCI 和 TravisCI 都提供了状态检查钩子（hook），它们会从分支上获取代码并运行单元测试。如果通过了，就允许合并代码，否则就不允许。</p></blockquote></li></ul></li></ul></li></ol><p>缺点：</p><ol><li>开发的工作量变大。开发人员除了功能代码的开发外，还需要编写单元测试代码。</li><li>系统维护的工作量变大。随着项目复杂，代码量越来越大，单元测试的代码量也会越来越大。开发人员在维护系统代码的时候，也需要维护单元测试代码，加大开发人员的工作量。</li></ol><h2 id="📓TDD-测试驱动开发"><a href="#📓TDD-测试驱动开发" class="headerlink" title="📓TDD 测试驱动开发"></a>📓TDD 测试驱动开发</h2><p>TDD &#x3D; TFD + Refactoring (TFD – Test First Development)</p><p>TDD是测试驱动开发（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。</p><p>TDD的基本思路就是通过测试来推动整个开发的进行，要求开发人员在开发具体的功能代码之前，先编写方法对应的测试用例。</p><p>问题解释： TDD开发应该达到100%的单元测试覆盖率？</p><ol><li>TDD开发，首先就要保证单元测试的速度。如果单元测试包括了全部的数据库测试、redis缓存测试、ES等中间件功能的测试，那么在测试过程中就需要启动嵌入式的数据库等的中间件，导致整体的单元测试速度变慢。</li><li>单元测试代码应该着重于测试逻辑代码，对于DAO、外部接口使用mock的形式进行测试，才能保证单元测试的速度。</li><li>中间件功能的测试，不仅启动的时间慢，而且会耗费开发人员过多的精力到相关的测试中。 因此，TDD保证100%的单元测试覆盖率是不对的。满足<strong>逻辑代码</strong>100%覆盖即可，剩余的数据获取及中间件功能交互应留到集成测试中进行。</li></ol><h2 id="📓Junit测试"><a href="#📓Junit测试" class="headerlink" title="📓Junit测试"></a>📓Junit测试</h2><p>JUnit是一个Java编程语言编写的单元测试框架。需要区分的是Junit的版本，在Junit5中做了很多的改变。以下主要基于Junit4进行的说明。</p><h3 id="📙基本注解"><a href="#📙基本注解" class="headerlink" title="📙基本注解"></a>📙基本注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@BeforeClass 使用此注解的方法在测试类被调用之前执行</span><br><span class="hljs-comment">//@AfterClass 使用此注解的方法在测试类被调用结束退出之前执行</span><br><span class="hljs-comment">//一个类中有多少个@Test注解方法，以下对应注解方法就被调用多少次</span><br><span class="hljs-comment">//@Before 在每个@Test调用之前执行</span><br><span class="hljs-comment">//@After 在每个@Test调用之后执行</span><br><span class="hljs-comment">//@Test 使用此注解的方法为一个单元测试用例，一个测试类中可多次声明，每个注解为@Test只执行一次</span><br><span class="hljs-comment">//@Ignore 暂不执行的测试用例，会被JUnit4忽略执行</span><br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JunitDemo</span> &#123;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeClass</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeClass method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is before method&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDemo</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;hello junit world~&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test(expected = ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testException</span><span class="hljs-params">()</span> &#123;<br>        log.info(String.valueOf(<span class="hljs-number">123123</span>/<span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Test(timeout = 2000)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIgnore</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is ignore method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finish</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is after method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterClass</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is afterClass method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📙spring相关测试"><a href="#📙spring相关测试" class="headerlink" title="📙spring相关测试"></a>📙spring相关测试</h3><p>启动spring容器相关注解</p><p>@SpringBootTest注解: 告诉Spring Boot查找一个主要的配置类（例如，一个带有@SpringBootApplication的类），并使用该类来启动Spring应用程序上下文。</p><ul><li>webEnvironment&#x3D;RANDOM_PORT: 使用webEnvironment &#x3D; RANDOM_PORT可以使用随机端口启动服务器（用于避免测试环境中的冲突），并使用@LocalServerPort注入端口。</li></ul><p>@AutoConfigureMockMvc: 使用Spring的MockMvc，并通过在测试用例上使用@AutoConfigureMockMvc注释，要求为测试用力注入该代码MockMvc代码。</p><p>@WebMvcTest : 在测试中，Spring Boot仅实例化了Web层，而不是整个上下文。 在具有多个控制器的应用程序中，甚至可以使用例如@WebMvcTest（HomeController.class）来仅请求实例化一个。</p><blockquote><p>可以加快整个applicaiton的启动速度，因为该注解只指定扫描了部分annotation</p></blockquote><p>@Runwith(SpringRunner.class): 说明了改测试用例要在什么环境下进行测试，在Junit4中需要将@RunWith（SpringRunner.class）添加到测试中，否则注释将被忽略。如果使用的是JUnit 5，则无需添加等效的@ExtendWith（ SpringExtension.class）（如@SpringBootTest）和其他@…Test注释已使用它进行注释。</p><ul><li><blockquote><p>@ExtendWith（ SpringExtension.class） 暂时未研究，主要是@Runwith的拓展类提供能力的增强，应用于Junit5中。</p></blockquote></li></ul><p>@MockBean:可用于为ApplicationContext中的bean定义Mockito模拟</p><p>@DirtiesContext：Spring @DirtiesContext从与测试关联的上下文缓存中删除脏的ApplicationContext</p><p>测试用例demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JunitSpringTestDemo</span> &#123;<br><br>    <span class="hljs-meta">@LocalServerPort</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UnitTestService unitTestService;<br><br>    <span class="hljs-meta">@MockBean</span><br>    <span class="hljs-keyword">private</span> TransactionTemplate transactionTemplate;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestRestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greetingShouldReturnDefaultMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">forObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:&quot;</span> + port + <span class="hljs-string">&quot;/learning/unit/one&quot;</span>, String.class);<br>        System.out.println(forObject);<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldReturnDefaultMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.mockMvc.perform(get(<span class="hljs-string">&quot;/unit/one&quot;</span>))<br>                .andDo(print())<br>                .andExpect(status().isOk())<br>                .andExpect(content().string(containsString(<span class="hljs-string">&quot;one&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> unitTestService.testJdbcTemplate();<br>        Assert.assertEquals(<span class="hljs-string">&quot;return result should be bbb&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓testNG"><a href="#📓testNG" class="headerlink" title="📓testNG"></a>📓testNG</h2><h3 id="📙基本介绍"><a href="#📙基本介绍" class="headerlink" title="📙基本介绍"></a>📙基本介绍</h3><p>TestNG不是一个JUnit扩展。它的灵感来源于JUnit。它的目的是优于JUnit的，尤其是当测试集成的类 -<a href="http://www.testng.org.cn/1723.html">与UnitTest比较</a></p><p>使用套件，指定某几个test中的group 为一个套件。在IDEA中直接运行xml文件，可以执行套件的测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE suite SYSTEM <span class="hljs-string">&quot;https://testng.org/testng-1.0.dtd&quot;</span> &gt;<br>&lt;suite name=<span class="hljs-string">&quot;testng-demo&quot;</span>&gt;<br>    &lt;test name=<span class="hljs-string">&quot;testGroup1&quot;</span>&gt;<br>        &lt;parameter name=<span class="hljs-string">&quot;dbconfig&quot;</span> value=<span class="hljs-string">&quot;db.properties!~&quot;</span> /&gt;<br>        &lt;parameter name=<span class="hljs-string">&quot;poolsize&quot;</span> value=<span class="hljs-string">&quot;10&quot;</span> /&gt;<br>        &lt;groups&gt;<br>            &lt;run&gt;<br>                &lt;include name=<span class="hljs-string">&quot;group1&quot;</span>/&gt;<br>            &lt;/run&gt;<br>        &lt;/groups&gt;<br>        &lt;classes&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>=<span class="hljs-string">&quot;TestNGDemo&quot;</span>/&gt;<br>        &lt;/classes&gt;<br>    &lt;/test&gt;<br><br>    &lt;test name=<span class="hljs-string">&quot;testGroup2&quot;</span>&gt;<br>        &lt;groups&gt;<br>            &lt;run&gt;<br>                &lt;include name=<span class="hljs-string">&quot;group2&quot;</span>/&gt;<br>            &lt;/run&gt;<br>        &lt;/groups&gt;<br>        &lt;classes&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>=<span class="hljs-string">&quot;TestNGDemo&quot;</span>/&gt;<br>        &lt;/classes&gt;<br>    &lt;/test&gt;<br>&lt;/suite&gt;<br></code></pre></td></tr></table></figure><ul><li>基本注解使用的demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNGDemo</span> &#123;<br><br>    <span class="hljs-meta">@BeforeSuite(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBeforeSuite</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;testBeforeSuite()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterSuite(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAfterSuite</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;testAfterSuite()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeClass&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is AfterClass&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeMethod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBeforeMethod</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is beforeMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterMethod</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAfterMethod</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;this is afterMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeGroups(&quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupGroup1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;setupGroup1()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterGroups(&quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanGroup1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;cleanGroup1()&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is test1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;, expectedExceptions = ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testException</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is test2&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        log.info(<span class="hljs-string">&quot;After division the value of i is :&quot;</span>+ i);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(enabled = false)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIgnoreTestcase</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~ignore &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group2&quot;, timeOut = 5000)</span> <span class="hljs-comment">// time in mulliseconds</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testThisShouldPass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">4000</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;, dependsOnMethods = &quot;test1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDependOn</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is dependOnMethod~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group1&quot;)</span><br>    <span class="hljs-meta">@Parameters(&#123; &quot;dbconfig&quot;, &quot;poolsize&quot; &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createConnection</span><span class="hljs-params">(String dbconfig, <span class="hljs-type">int</span> poolsize)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is parameter Test, parameter is: &#123;&#125;, &#123;&#125;&quot;</span>, dbconfig, poolsize);<br>    &#125;<br><br>    <span class="hljs-meta">@Test(groups = &quot;group2&quot;, dataProvider = &quot;addDataProvider&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDataProvider</span><span class="hljs-params">( String data)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is testDataProvider, test data: &#123;&#125;&quot;</span>,data);<br>    &#125;<br><br>    <span class="hljs-meta">@DataProvider</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;Object&gt; <span class="hljs-title function_">addDataProvider</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Object&gt; list = Lists.newArrayList();<br>        list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>        list.add((<span class="hljs-string">&quot;123wesdf&quot;</span>));<br>        <span class="hljs-keyword">return</span> list.iterator();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📙spring相关的使用"><a href="#📙spring相关的使用" class="headerlink" title="📙spring相关的使用"></a>📙spring相关的使用</h3><p>通过<code>extends AbstractTestNGSpringContextTests</code>提供一个测试使用的spring 上下文，类似于Junit4中@RunWith(SpringExtend)</p><blockquote><p>AbstractTestNGSpringContextTests is an abstract base test class that integrates the Spring TestContext Framework with explicit ApplicationContext testing support in a TestNG environment. When you extend AbstractTestNGSpringContextTests, you can access a protected applicationContext instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.</p></blockquote><h2 id="📓Mockito"><a href="#📓Mockito" class="headerlink" title="📓Mockito"></a>📓Mockito</h2><p>Mockito 主要用来辅助编写测试用例的。比如在微服务中的跨服务调用，在单个服务的单元测试中跨服务调用是不可能成功的，因为另外一个服务未启动，这是用就要使用mock 的方式，模拟服务请求返回的情形。</p><ul><li>以下为一个demo，在Mockito最常用的都是spy一个实例，在该实例调用某种方法是Mock回预期的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockitoTestDemo</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UnitTestService unitTestService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UnitTestService</span> <span class="hljs-variable">spy</span> <span class="hljs-operator">=</span> Mockito.spy(unitTestService);<br>        Mockito.when(spy.testSql()).thenReturn(<span class="hljs-string">&quot;fadsfasdfasdf&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spy.testSql();<br>        log.info(result);   <span class="hljs-comment">// return fadsfasdfasdf</span><br><br>        Mockito.when(spy.testParameter(Mockito.anyInt(),<br>                        Mockito.anyString(),<br>                        Mockito.any(),<br>                        Mockito.anyList(),<br>                        Mockito.anyMap()))<br>                .thenReturn(<span class="hljs-string">&quot;mock success&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> spy.testParameter(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sddf&quot;</span>, BigDecimal.ZERO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br>        log.info(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓BDDMockito"><a href="#📓BDDMockito" class="headerlink" title="📓BDDMockito"></a>📓BDDMockito</h2><p>BDDMockito对比Mockito可以使用BDDMockito为各种Mockito方法提供BDD别名，代码看起来更易理解。</p><p>结合Testng的注解@BeforeClass，可以在一个测试用例类中直接把需要Mock的类方法及预期的返回值，设置好</p><ul><li><blockquote><p>Junit4中@BeforeClass，要求方法体内要为静态的。</p></blockquote></li><li><blockquote><p>BDDMockito 对于Mock类提供更为简便的表达</p></blockquote></li><li><blockquote><p>testng中对于@MockBean 需要配合使用 <code>@TestExecutionListeners(MockitoTestExecutionListener.class)</code></p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ActiveProfiles(profiles = &quot;test&quot;)</span><br><span class="hljs-meta">@SpringBootTest(classes = UnitTestApplication.class,</span><br><span class="hljs-meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@TestExecutionListeners(MockitoTestExecutionListener.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BDDMockitoTestDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTestNGSpringContextTests</span> &#123;<br><br>    <span class="hljs-meta">@MockBean</span><br>    UnitInterface unitInterface;<br><br>    <span class="hljs-meta">@BeforeClass</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>        given(unitInterface.register(anyString())).willReturn(<span class="hljs-string">&quot;register success&quot;</span>);<br>        given(unitInterface.calculate(anyDouble())).willThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Test(expectedExceptions = IllegalArgumentException.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">calculate</span> <span class="hljs-operator">=</span> unitInterface.calculate(<span class="hljs-number">123.112d</span>);<br>        log.info(String.valueOf(calculate));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/09/04/%F0%9F%92%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/09/04/%F0%9F%92%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="💠java虚拟机"><a href="#💠java虚拟机" class="headerlink" title="💠java虚拟机"></a>💠java虚拟机</h1><p>虚拟机是物理机器的软件实现。Java 的开发遵循 write once run anywhere（“一次编写到处乱跑”）理念，它运行在 VM（虚拟机）上。编译器将 Java 文件编译成 Java.class 文件，之后，将 .class 文件输入到 JVM 中，加载并执行该类文件。下图是 JVM 的体系结构</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/heap-detail.jpg" alt="avatar"></p><h2 id="📓虚拟机内存区域"><a href="#📓虚拟机内存区域" class="headerlink" title="📓虚拟机内存区域"></a>📓虚拟机内存区域</h2><h3 id="📚程序计数器"><a href="#📚程序计数器" class="headerlink" title="📚程序计数器"></a>📚程序计数器</h3><p>定义：可以看作是当前线程所执行的字节码的行号指示器，为线程隔离的数据区。<br>java多线程切换时，每个线程独立的程序计数器，各条线程之间的计数器互不影响，独立存储，保证了线程切换后能恢复到正确的位置。</p><blockquote><p>唯一一个无OOM的区域</p></blockquote><h3 id="📚Java虚拟机栈"><a href="#📚Java虚拟机栈" class="headerlink" title="📚Java虚拟机栈"></a>📚Java虚拟机栈</h3><p>定义：每个方法执行的时候，Java虚拟机都会同步的创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><blockquote><p>栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息</p></blockquote><ul><li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型(指向一条字节码指令的地址)、</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚本地方法栈"><a href="#📚本地方法栈" class="headerlink" title="📚本地方法栈"></a>📚本地方法栈</h3><p>定义：为虚拟机使用到的本地(Native)方法服务。</p><ul><li>HotSpot直接把本方法栈和虚拟机栈合二为一。</li><li>在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。</li></ul><h3 id="📚Java堆"><a href="#📚Java堆" class="headerlink" title="📚Java堆"></a>📚Java堆</h3><p>定义:是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><ul><li>参数-Xmx和-Xms 最大堆内存和最小堆内存</li></ul><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/hotstop-heap.jpg" alt="avatar"></p><h3 id="📚方法区"><a href="#📚方法区" class="headerlink" title="📚方法区"></a>📚方法区</h3><p>定义：是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息(类名、方法描述、字段描述)、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><blockquote><p>JDK8以前使用<strong>永久代来实现方法区</strong><br>方法区类似于接口，永久代类似于实现类的关系。使用永久代的时候，可以设置内存上限，而且不同的虚拟机的实现不一样，因此更容易遇到内存溢出的问题。</p></blockquote><p><code>-XX:MaxMetaspaceSize</code>:设置元空间最大值，默认-1，不限制或者说仅受限于机器内存。 <code>-XX:MetaspaceSize</code>: 指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会根据收集结果对该值进行动态调整。 </p><h3 id="📚运行时常量池"><a href="#📚运行时常量池" class="headerlink" title="📚运行时常量池"></a>📚运行时常量池</h3><ul><li>定义：运行时常量池是方法区的一部分。Class文件除类字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，在类加载后存放到运行时常量池中。</li><li>运行时常量池具备动态性，运行期间可以将新的常量放入池中，当无法申请到空间抛出OutOfMemoryError异常。</li></ul><blockquote><p>在 Java 7 之前，JVM 将 Java String Pool 放置在 永久代空间(java7方法区的实现)中，该空间具有固定大小——它不能在运行时扩展并且不符合垃圾收集条件。<br>在永久代(而不是堆)中使用字符串的风险是，如果我们创建太多字符串，我们可能会从 JVM 中得到 OutOfMemory 错误。<br>从 Java 7 开始，Java String Pool 存储在 <strong>Heap 空间</strong>中，由 JVM 进行垃圾回收。 这种方法的优点是降低了 OutOfMemory 错误的风险，因为未引用的字符串将从池中删除，从而释放内存。</p></blockquote><h2 id="📓HotSpot-的后台线程"><a href="#📓HotSpot-的后台线程" class="headerlink" title="📓HotSpot 的后台线程"></a>📓HotSpot 的后台线程</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/hotspotThread.jpg" alt="avatar"></p><h2 id="📓内存区域溢出分析"><a href="#📓内存区域溢出分析" class="headerlink" title="📓内存区域溢出分析"></a>📓内存区域溢出分析</h2><h3 id="📚Java堆溢出"><a href="#📚Java堆溢出" class="headerlink" title="📚Java堆溢出"></a>📚Java堆溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMObject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚虚拟机栈和本地方法栈溢出"><a href="#📚虚拟机栈和本地方法栈溢出" class="headerlink" title="📚虚拟机栈和本地方法栈溢出"></a>📚虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈的溢出有StackOverflowError和OutOfMemoryError</p><p>导致StackOverflowError的两种行为</p><ol><li><code>-Xss</code>参数减少栈内存容量，递归过程导致堆栈溢出</li><li>定义大量本地变量，导致堆栈溢出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss128k</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        stackLength++;<br>        stackLeak();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackSOF</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> unused1,unused2; <span class="hljs-comment">// .... unused199</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackSOF</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackSOF</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            oom.stackLeak();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;stack length:&quot;</span> + oom.stackLength);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内存溢出OutOfMemoryError的原因：因为创建一个线程的本地方法栈及虚拟机栈也是占用堆内存空间的，在内存有限的情况，创建一定数量的线程将导致内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Xss2M  设置每个线程的堆栈大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaVMStackOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dontStop</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stackLeakByThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    dontStop();<br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">JavaVMStackOOM</span> <span class="hljs-variable">oom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaVMStackOOM</span>();<br>        oom.stackLeakByThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚方法区和运行时常量池溢出"><a href="#📚方法区和运行时常量池溢出" class="headerlink" title="📚方法区和运行时常量池溢出"></a>📚方法区和运行时常量池溢出</h3><p>JDK1.7之前会产生永久代内存溢出的情况，而之后会产生内存溢出的情况，因为常量池移动到堆中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行时常量池溢出导致内存溢出 jdk7中</span><br><span class="hljs-comment">// 参数： -Xmx6M -XX:MaxMetaspaceSize=6M -XX:PermSize=6M</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">short</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            set.add(String.valueOf(i++).intern());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码增强生成大量的动态类导致的溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 借助CGlib 使方法区出现永久代内存溢出异常，在JDK7中导致内存空间溢出</span><br><span class="hljs-comment">// java 8 不会出现问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaMethodAreaOOM</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>            enhancer.setSuperclass(OOMObject.class);<br>            enhancer.setUseCache(<span class="hljs-literal">true</span>);<br>            enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                    <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);<br>                &#125;<br>            &#125;);<br>            enhancer.create();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMObject</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚本机直接内存溢出"><a href="#📚本机直接内存溢出" class="headerlink" title="📚本机直接内存溢出"></a>📚本机直接内存溢出</h3><p>特征是Heap dump很小，而程序中又间接使用了DirectMemory(如NIO)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//* 参数：-Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="hljs-comment">//* 本机直接内存溢出</span><br><span class="hljs-comment">//*</span><br><span class="hljs-comment">//*  -XX:MaxDirectMemorySize 用于指定直接内存大小</span><br><span class="hljs-comment">//* 真正申请内存分配的方法Unsafe::allocateMemory()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectMemoryOOM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredFields()[<span class="hljs-number">0</span>];<br>        unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)unsafeField.get(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            unsafe.allocateMemory(_1MB);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="hljs-comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="hljs-comment">     * at com.learning.jvm.memory.DirectMemoryOOM.main(DirectMemoryOOM.java:27)</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓四种引用类型"><a href="#📓四种引用类型" class="headerlink" title="📓四种引用类型"></a>📓四种引用类型</h2><blockquote><p>JDK1.2 之前，一个对象只有“已被引用”和”未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</p><p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p></blockquote><h3 id="📚强引用"><a href="#📚强引用" class="headerlink" title="📚强引用"></a>📚强引用</h3><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">//只要obj还指向Object对象，Object对象就不会被回收 obj = null; //手动置null</span><br></code></pre></td></tr></table></figure><h3 id="📚软引用"><a href="#📚软引用" class="headerlink" title="📚软引用"></a>📚软引用</h3><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="📚弱引用"><a href="#📚弱引用" class="headerlink" title="📚弱引用"></a>📚弱引用</h3><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="📚虚引用"><a href="#📚虚引用" class="headerlink" title="📚虚引用"></a>📚虚引用</h3><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h2 id="📓垃圾收集器与内存分配策略"><a href="#📓垃圾收集器与内存分配策略" class="headerlink" title="📓垃圾收集器与内存分配策略"></a>📓垃圾收集器与内存分配策略</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生而灭，因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收问题。</p><h3 id="📚判断对象是否已死的方法"><a href="#📚判断对象是否已死的方法" class="headerlink" title="📚判断对象是否已死的方法"></a>📚判断对象是否已死的方法</h3><h4 id="📔引用计数法"><a href="#📔引用计数法" class="headerlink" title="📔引用计数法"></a>📔引用计数法</h4><p>定义：在对象中添加一个引用计数器，有一个地方引用时，计数器值加一，引用失效时减一。</p><ul><li>优点：原理简单，判定效率也很高。</li><li>缺点：难以解决对象之间互相循环引用的问题。</li></ul><h4 id="📔可达性分析算法"><a href="#📔可达性分析算法" class="headerlink" title="📔可达性分析算法"></a>📔可达性分析算法</h4><p>定义：通过一系列成为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。若某对象到GC Roots间没有任何引用链相连，证明此对象是不可能再被使用的。</p><p>GC Roots的对象分为以下几种：</p><ol><li>虚拟机栈中的引用对象，入线程调用方法堆栈的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象。如Java类的引用类型静态变量。</li><li>在方法区中常量引用对象，如字符串常量池的引用。</li><li>在本地方法栈中的JNI(Native方法)引用的对象。</li><li>Java虚拟机内部的引用，如基本类型对应的Class对象，一些常驻异常对象(<code>NullPointException</code>)等，还有系统类加载器。</li><li>所有被同步锁(synchronize关键字)持有的对象。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地缓存代码等。</li></ol><h4 id="📔三色标记算法"><a href="#📔三色标记算法" class="headerlink" title="📔三色标记算法"></a>📔三色标记算法</h4><p>三色标记算法：GCRoot如果想查找到存活对象，会根据可达分析算法分析，遍历整个引用链 ,按照是否访问过该对象分成三种不同的颜色盒子(容器)：白色、灰色、黑色盒子。</p><blockquote><p>白色：本对象没有被访问过 (没有被GCRoot扫描过，有可能是为垃圾对象)；<br>灰色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性没有被GCRoot扫描，该对象就是为灰色对象；如果该对象的属性被扫描的情况下，从灰色变为黑色。<br>黑色：本对象已经被访问过(被GCRoot扫描过)，且本对象中的属性已经被GCRoot扫描过，该对象就是为黑色对象。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730951.png" alt="avatar"></p><p>三色标记算法缺陷：在并发标记阶段的时候，因为用户线程与GC线程同时运行，有可能会产生多标或者漏标；<br>多标–多标记(浮动垃圾)<br>漏标–漏标记</p><p><strong>浮动垃圾</strong></p><ol><li>并发标记：用户与GC线程同时运行，假设现在扫描到C对象，B对象变为黑色，用户线程执行C的属性E&#x3D;null,GC线程扫描C对象引用链，认为E对象是为可达对象，但是C对象根本没有引入到E对象，E对象应该是为垃圾对象，这种问题，可以在重新标记阶段(修正)修复。</li><li>并发清除阶段：用户与GC线程同时运行，会产生新的对象但是没有及时被GC清理。 只能在下一次GC清理垃圾的修复。</li></ol><p><strong>漏标问题</strong></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/mark-problem.png" alt="avatar"></p><ol><li>用户线程先执行C的E属性&#x3D;null；GC线程的GcRoot就扫描不到E。GC就认为E对象就是为垃圾对象，不可达对象。</li><li>用户线程执行B.E属性&#x3D;E；E对象就是应该是为可达对象。 因为GCRoot是从C开始，不会从黑色的B开始，就会导致漏标的情况发生。</li></ol><p>漏标的问题产生满足两个条件：</p><ol><li>至少有一个黑色对象指向了白色对象</li><li>在所有灰色对象扫描完整个链时，删除之前所有白色对象引用关系。</li></ol><p>CMS如何解决漏标问题—写屏障+增量更新方式</p><blockquote><p>满足一个条件(灰色对象与白色对象断开连接)，在并发标记阶段当我们黑色对象(B)引用关联白色对象(E)，记录下B黑色对象。<br>在重新标记阶段(所有用户线程暂停)，有将B对象变为灰色对象将整个引用链全部扫描。<br>缺点：遍历B整个链的效率非常低，有可能会导致用户线程等待的时间非常长。</p></blockquote><p>G1如何解决漏标问题—原始快照方式</p><blockquote><p>在C(灰色对象)断开E(白色)的时候，会记录原始快照，在重新标记阶段的时候以白色对象变为灰色为起始点扫描整个链，本次GC是不会被清理。<br>好处：如果假设B(黑色对象)引入该白色对象的时候，无需做任何遍历效率是非常高。<br>缺点：如果假设B(黑色对象) 没有引入该白色对象的时候，该白色对象在本次GC继续存活，只能放在下一次GC在做并发标记的时候清理。<br><strong>tips:以浮动垃圾(占内存空间)换让我们用户线程能够暂停的时间更加短。</strong></p></blockquote><p>总结： CMS收集器解决漏标问题：增量方式 如果现在B(黑色)对象引入白色对象，写屏障。</p><ul><li>好处：避免浮动垃圾</li><li>缺点扫描整个引用链效率比较低。</li></ul><p>G1收集器解决漏标问题：原始快照方式。</p><ul><li>好处：效率非常高，无需扫描整个引用链</li><li>缺点：可能会产生浮动垃圾。</li></ul><h2 id="📓回收方法区"><a href="#📓回收方法区" class="headerlink" title="📓回收方法区"></a>📓回收方法区</h2><p>方法区的回收主要是两部分内容：废弃的常量和不再使用的类型。</p><ul><li>废弃的常量的例子：字符串常量进入到常量池中，但当前系统有没有任何一个字符串对象的值为“java”，则该常量就会被系统清理出常量池。</li><li>不在使用的类，需同时满足一下三个条件：<ul><li>该类的所有实例已经被回收，也就是java对重不存在该类及其任何派生的子类实例。</li><li>加载该类的类加载器已经被回收。正常很难达成。如OSGi、JSP的重加载会产生。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h2 id="📓垃圾回收算法"><a href="#📓垃圾回收算法" class="headerlink" title="📓垃圾回收算法"></a>📓垃圾回收算法</h2><p>弱分代假说：绝大多数对象都是朝生夕灭。<br>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。<br>跨代引用假说：存在于新生代的对象可能会引用老年代的对象。因此该假说说明的是，存在互相引用关系的对象，是应该倾向于同时生存或者同时死亡。</p><blockquote><p>解决方案，在新生代上建立一个全局的数据结构(记忆集)，这个结构把老年代划分成若干小块，表示出老年代的哪一块内存会存在跨代引用。之后发生Minor GC时，只有包含跨代引用的小块内存才会加入到GC Root的扫描.</p></blockquote><h3 id="📚标记-清除算法"><a href="#📚标记-清除算法" class="headerlink" title="📚标记-清除算法"></a>📚标记-清除算法</h3><p><strong>算法实现</strong>：分为标记-清除两个阶段，首先根据上面的根搜索算法标记出所有需要回收的对象，在标记完成后，然后在统一回收掉所有被标记的对象。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730190.jpeg" alt="img"></p><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。</p><p><strong>不足：</strong></p><ul><li><strong>效率问题</strong>：标记和清除的效率都不高</li><li><strong>空间问题</strong>：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集。</li></ul><h3 id="📚复制算法"><a href="#📚复制算法" class="headerlink" title="📚复制算法"></a>📚<strong>复制算法</strong></h3><p><strong>算法实现</strong>：将可用内存按容量划分为大小相等的两块区域，每次只使用其中一块，当这一块的内存用完了，就将还活着的对象复制到另一块区域上，然后再把已使用过的内存空间一次性清理掉。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730608.jpeg" alt="img"></p><p><strong>优点</strong>：每次都是只对其中一块内存进行回收，不用考虑内存碎片的问题，而且分配内存时，只需要移动堆顶指针，按顺序进行分配即可，简单高效。</p><p><strong>缺点</strong>：将内存分为两块，但是每次只能使用一块，也就是说，机器的一半内存是闲置的，这资源浪费有点严重。并且如果对象存活率较高，每次都需要复制大量的对象，效率也会变得很低。</p><h3 id="📚标记-整理算法"><a href="#📚标记-整理算法" class="headerlink" title="📚标记-整理算法"></a>📚标记-整理算法</h3><p><strong>算法实现</strong>：首先标记出所有存活的对象，然后让所有存活对象向一端进行移动，最后直接清理到端边界以外的内存。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730009.jpeg" alt="img"></p><p>　<strong>局限性</strong>：只有对象存活率很高的情况下，使用该算法才会效率较高。</p><h3 id="📚分代收集算法"><a href="#📚分代收集算法" class="headerlink" title="📚分代收集算法"></a>📚分代收集算法</h3><p><strong>算法实现</strong>：根据对象的存活周期不同将内存分为几块，然后不同的区域采用不同的回收算法。</p><ol><li>对于存活周期较短，每次都有大批对象死亡，只有少量存活的区域，采用复制算法，因为只需要付出少量存活对象的复制成本即可完成收集；</li><li>对于存活周期较长，没有额外空间进行分配担保的区域，采用标记-整理算法，或者标记-清除算法。</li></ol><p>　比如，对于 HotSpot 虚拟机，它将堆空间分为如下两块区域：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730405.png" alt="image-20220902215350103"></p><p>堆有新生代和老年代两块区域组成，而新生代区域又分为三个部分，分别是 Eden,From Surivor,To Survivor ,比例是8:1:1。</p><p>　　新生代采用复制算法，每次使用一块Eden区和一块Survivor区，当进行垃圾回收时，将Eden和一块Survivor区域的所有存活对象复制到另一块Survivor区域，然后清理到刚存放对象的区域，依次循环。</p><p>​老年代采用标记-清除或者标记-整理算法，根据使用的垃圾回收器来进行判断。</p><h3 id="📚新生代垃圾回收"><a href="#📚新生代垃圾回收" class="headerlink" title="📚新生代垃圾回收"></a>📚新生代垃圾回收</h3><ol><li>eden、 survivor From 复制到 survivor To，年龄+1。</li></ol><blockquote><p>首先，把 Eden 和 survivor From 区域中存活的对象复制到 survivor To 区域(如果有对象的年龄以及达到了老年的标准，则赋值到老年代区)，同时把这些对象的年龄+1(如果 ServicorTo 不够位置了就放到老年区)；</p></blockquote><ol><li>清空 eden、 survivor From。</li></ol><blockquote><p>然后，清空 Eden 和 survivor From 中的对象；</p></blockquote><ol><li>survivor To 和 survivor From 互换</li></ol><blockquote><p>最后， survivor To 和 survivor From 互换，原 survivor To 成为下一次 GC 时的 survivor From区。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></p></blockquote><p><strong>相关问题</strong></p><p>为什么需要Survivor区域？</p><blockquote><p>防止对象过早进入Old，导致Old频繁Full GC。Survivor具有预筛选保证，只有对象到一定岁数才会送往老年代，Survivor区可以减少被送到老年代的对象，进而减少Full GC发生。</p></blockquote><p>为什么需要两个Survivor区域？</p><blockquote><p>如果只有一个Survivor，每次垃圾回收年龄+1，会有部分对象进入老年代，导致Survivor的空间变成碎片化空间，最后触发minor gc。使用两个Survivor并进行交换，就保证了两个Survivor区，一个为空，另一个是非空且无碎片保存的。</p></blockquote><h2 id="📓GC垃圾收集器"><a href="#📓GC垃圾收集器" class="headerlink" title="📓GC垃圾收集器"></a>📓GC垃圾收集器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；<br>年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/garbage-collector.jpg" alt="avatar"></p><h3 id="📚Serial收集器"><a href="#📚Serial收集器" class="headerlink" title="📚Serial收集器"></a>📚Serial收集器</h3><ul><li>定义:一个单线程的垃圾收集器，在垃圾收集时必须暂停其他所有工作线程，直到收集结束。</li><li>对于新生代采取复制算法暂停所有线程，对于老年代使用标记-整理算法同样暂停所有线程。</li><li>缺点：需要暂停用户线程。</li><li>优点：<ol><li>简单高效、对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。</li><li>单核处理器或者处理器核心较少的环境来说，Serial由于没有线程交互的开销，可以专心做垃圾回收自然可以获得最高的单线程收集效率。</li></ol></li></ul><h3 id="📚Serial-Old收集器"><a href="#📚Serial-Old收集器" class="headerlink" title="📚Serial Old收集器"></a>📚Serial Old收集器</h3><ul><li>定义：使用标记-整理算法。</li><li>用途：可以Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器发生失败的后背方案。<img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/serial-1.jpg" alt="avatar"></li></ul><h3 id="📚ParNew收集器"><a href="#📚ParNew收集器" class="headerlink" title="📚ParNew收集器"></a>📚ParNew收集器</h3><ul><li><p>定义：Serial收集器的多线程并行版本。</p></li><li><p>唯一的优点仅有ParNew和Serial可以和CMS收集器配合工作，以后ParNew将会合并入CMS，成为其处理新生代的组成部分。</p></li><li><p>随着可以被使用的处理核心增加，ParNew对于垃圾收集时系统可以高效利用，默认开启的收集线程数和处理器核心数量相同。</p></li><li><p>新生代：标记复制。老年代：标记-整理</p></li><li><p>常使用参数：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parNew-1.jpg" alt="avatar"></p></li></ul><h3 id="📚Parallel-Scavenge-收集器"><a href="#📚Parallel-Scavenge-收集器" class="headerlink" title="📚Parallel Scavenge 收集器"></a>📚Parallel Scavenge 收集器</h3><p>定义：新生代收集器，同样基于标记-复制算法，能够并行收集的多线程收集器。特点是达到一个可控制的吞吐量。 <code>吞吐量= 运行客户代码时间/(运行用户代码时间+运行垃圾收集时间)</code></p><p>虚拟机完成用户任务及垃圾收集用了100分钟，其中垃圾收集用了1分钟，吞吐量&#x3D;99%</p><ul><li>-XX:MaxGCPauseMills：控制最大垃圾收集时间参数</li></ul><blockquote><p>允许设置的是一个大于0的毫秒数，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换区的。调小新生代会缩短垃圾回收时间，若调的太小会导致垃圾收集变得频繁。</p></blockquote><ul><li>-XX:GCTimeRatio：设置吞吐量大小时间<ul><li>设置的值应当是大于0小于100的整数，也就是垃圾回收时间占总时间的比率为吞吐量的倒数。</li><li>设置成19，那允许垃圾回收时间为总时间的5%(1&#x2F;(1+19))，默认值为99,允许最大1%的时间进行垃圾回收。</li></ul></li><li>-XX:+UseAdaptiveSizePolicy: 开启自适应的调整策略。</li></ul><h3 id="📚Parallel-Old收集器"><a href="#📚Parallel-Old收集器" class="headerlink" title="📚Parallel Old收集器"></a>📚Parallel Old收集器</h3><p>定义：Parallel Scavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。</p><blockquote><p>与Parallel Scavenge搭配作为“吞吐量优先”的收集器搭配组合</p></blockquote><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/parallel.jpg" alt="avatar"></p><h3 id="📚CMS-Concurrent-Mark-Sweep-收集器"><a href="#📚CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="📚CMS(Concurrent Mark Sweep)收集器"></a>📚CMS(Concurrent Mark Sweep)收集器</h3><p>定义：一种以获取最短回收停顿时间为目标的收集器，工作于老年代。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行过程解析，基于标记-清除算法实现，具体大流程步骤如下：</p><ol><li>初始标记：仅仅标记一下GC Root对象能直接关联到的对象，速度很快，需要暂停所有线程。</li><li>并发标记：从GC Root关联对象开始遍历整个对象图的过程，可以与用户线程共同执行。</li><li>重新标记：因用户程序继续运行而导致标记产生变动的那部分对象的标记记录，通常比初始标记长远比并发标记段。</li><li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动对象，因此可以与用户线程共同执行。\</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/cms-1.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>主要流程:</p><ol><li>初始标记：STW，标记根对象。</li><li>并发标记：标记所有对象。</li><li>预清理：清理前准备以及控制停顿时间</li><li>重新标记：STW，修正并发标记数据</li><li>并发清理：清理垃圾</li><li>并发重置</li></ol><p>预清理：预清理是并发的，除了为正式清理做准备和检查以外，与清理还会尝试控制一次停顿时间。由于重新标记是独占CPU的，<strong>如果新声代GC后，立即触发一次重新标记，那么一次停顿时间可能很长</strong>。为了避免这种情况，预清理时，会可以等待一次新声代GC的发生，然后根据历史性能数据预测下一次新生代GC可能发生的时间，在当前时间和预测时间的中间时刻进行重新标记。最大程度上避免新生代GC和重新标记重合，尽可能减少一次停顿时间。</p><blockquote><p>开关<code>-XX:-CMSPrecleaningEnabled</code> 用来开关预清理</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041730258.png" alt="avatar"></p><p>特点：</p><ol><li>对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用CPU不超过25%。若核心数量小于4，则占用CPU过大。</li><li>无法处理“浮动垃圾”，有可能出现并发模式失败进而导致一次Full GC。浮动垃圾为出现在标记过程结束之后产生的对象。因为CMS要支持收集过程中与用户线程并存，因此不能在老年代几乎被填满时再运行，需要预留一部分空间供并发收集的程序运行。</li></ol><blockquote><p>JDK5中设置CMS在老年代使用了68%便会激活，JDK6默认的设置提高到92%。当运行预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”。后备预案为冻结用户线程，启用Serial Old进行老年代的垃圾收集。<br>并发收集失败：收集过程中，老年代被填满；收集完成后，收集的空间仍然无法满足被使用；浮动垃圾</p></blockquote><ul><li>参数-XX:CMSFullGCsBeforeCompaction：作用是要求CMS收集器在执行过若干次不整理的Full GC之后，下一次先进行碎片整理</li></ul><p>常用参数:</p><ul><li><code>-XX:+UseConcMarkSweepGC</code>: 启用 CMS 回收器</li><li><code>-XX:ConcGCThreads</code>和<code>-XX:ParallelCMSThreads</code>：用来指定GC并发线程数量</li><li><code>-XX:CMSinitiatingOccupancyFraction</code>：可以设置触发CMS收集的百分比。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>： 参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。(默认值为0，表示每次FullGC都进行碎片整理)</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：开关可以使CMS在垃圾收集完成后，进行一次内存碎片整理，内存碎片的整理不是并发进行的。</li><li><code>-XX:-CMSPrecleaningEnabled</code>：用来开关预清理</li></ul><h3 id="📚Garbage-First-收集器"><a href="#📚Garbage-First-收集器" class="headerlink" title="📚Garbage First 收集器"></a>📚Garbage First 收集器</h3><p>G1是一种兼顾吞吐量和停顿时间的GC实现。<br>定义：面向服务端应用的垃圾收集器，基于Region的堆内存布局进行垃圾收集，每一个Region都可以根据需要扮演新生代的Eden空间、Survivor空间和老年代空间。Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要超过了一个Region一半的对象即可认为是大对象。对于Humongous区域，正常当做老年代一部分。</p><p><strong>深入理解Java虚拟机中CMS流程说明：</strong></p><p>运行步骤：</p><ol><li>初始标记：标记GC Root对象能直接关联的对象并修改TAMS指针的值为正确的空区域。需要暂停线程，但是时间很短，借用进行Minor GC时同步完成。</li><li>并发标记：根据GC Root进行可达性分析，扫描对象图。完成扫描后，处理SATB记录下并发时有引用变动的对象。</li><li>最终标记：短暂暂停用户线程，处理并发阶段结束后，少量的SATB记录。</li><li>筛选回收：更新Region的统计数据，进行回收价值和成本的排序，根据用户期望的停顿时间来构建回收集合。回收集合的存活对象复制到空的Region，再清理旧的Region。涉及到对象移动，需要暂停用户线程，使用多线程并行完成移动。</li></ol><p>G1整体是基于标记-整理算法实现的收集器，但从局部优势基于标记-复制算法实现。在执行标记整理的时候，还进行了压缩的工作，这是之前的垃圾收集器都没有的。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1.jpg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-memory.jpg" alt="avatar"></p><p><strong>实战Java虚拟机中流程说明：</strong></p><p>收集过程：</p><ol><li>新生代GC</li><li>并发标记周期</li><li>混合收集</li><li>如果需要会进行Full GC</li></ol><p><strong>并发标记周期</strong></p><p>执行流程</p><ol><li>初始标记: 标记从根节点直接可达的对象。这个阶段会伴随一次新生代GC，产生全局停顿。</li><li>根区域扫描: 由于初始标记必然伴随一次新生代GC，存活对象均移入survivor区。将扫描由<strong>survivor区</strong>直接可达的老年代区域(根区域扫描依赖survivor区对象)。如果同时需要新生代GC，那么GC就需要等待根区域扫描结束后才能进行。</li><li>并发标记: 扫描并查找整个堆的存活对象，并发过程可被新生代GC打断。</li><li>重新标记: CMS一样，重新标记也是会产生应用程序停顿的由于在并发标记过程中，应用程序依然在运行，因此标记结果可能需要进行修正，所以在此对上一次的标记结果进行补充。在G1中，这个过程使用SATB(Snapshot At-The-Beginning)算法完成,G1会在标记之初为存活对象创建个快照，这个快照有助于加速重新标记的速度。</li><li>独占清理: 这个阶段是会引起停顿的，它将计算各个区域的存活对象和GC回收比例并进行排序，识别可供混合回收的区域 在这个阶段，还会更新记忆集(Remembered Set), 该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段，需要这些信息。</li><li>井发清理阶段: 这里会识别并清理完全空闲的区域 它是井发的清理，不会引起停顿。</li></ol><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-process.png" alt="avatar"></a></p><p>由于并发标记周期包含一次新生代GC，故新生代会被整理。但由于并发标记周期执行时，应用程序依然在运行。因此，并发标记周期结束后，又会有新的Eden空间被使用。并发标记周期执行前后最大的不同是在该阶段后，系统增加了一些标记为G的区域。这些区域被标记，是因为它们内部的垃圾比例较高，因此希望在后续的混合GC中进行收集(注意在并发标记周期中并未正式收集这些区域〉。</p><p><strong>并发回收阶段前后的可能情况</strong> <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-concurrent-alloc.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729043.png" alt="avatar"></a></p><p><strong>混合回收</strong></p><p>定义：在并发标记周期中，虽然有部分对象被回收，但是总体上说，回收的比例是相当低的。但是在并发标记周期后，己经明确知道哪些区域含有比较多的垃圾对象，在混合回收阶段，就可以专门针对这些区域进行回收。当然G1会优先回收垃圾比例较高的区域，因为回收这些区域的性价比也比较高。这个阶段叫作混合回收。</p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-alloc.png" alt="avatar"></a></p><p>混合GC会执行多次，直到回收了足够多的内存空间，然后，它会触发一次新生代GC。新生代GC后，又可能会发生一次并发标记周期的处理。最后，又会起混合GC的执行。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/g1-MixedGC.png" alt="avatar"></a></p><p><strong>必要时的Full GC</strong></p><p>并发收集由于让应用程序和GC线程交替工作，因此总是不能完全避免在特别繁忙的场合会出现在回收过程中内存不充足的情况。当遇到这种情况时，G1会转入一个Full GC进行回收。</p><blockquote><p>如果在混合GC时发生空间不足或者在新生代GC时，survivor区和老年代无法容纳幸存对象，都会导致一次Full GC产生。</p></blockquote><p>记忆集是G1中维护的一个数据结构，简称RS(Remembered Set)。每一个G1区域都有一个RS与之关联。<br>作用：由G1回收时，是按照区域回收的，如在回收区域A的对象 ，很可能并不回收区域B的对象。为了避免在整个堆中进行对象的可达性扫描。因此，G1在区域RS中，记录了在区域A中被其他区域引用的对象，这样在回收区域A时，只要将RS视为区域A根集的一部分即可，从而可避免做整个堆的扫描。</p><p>G1日志的一些术语：</p><ul><li>CT(Card Table): RS 就是依靠 CardTab 来记录哪些是存活对象的：</li><li>CSet(Collection Sets): Collection Sets表示被选取的、将要被收集的区域的集合</li><li>Ref Proc(处理弱引用、软引用的时间)</li><li>RefEnq(弱引用、软引用入队时间)</li><li>Free CSet(释放被回收的CSet中区域的时间，包括它们的RS)。</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">1 .<span class="hljs-number"> 619 </span>: [GC pause (young) (init al-mark)<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 03848843 </span>secs] <br>[Parallel Time :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>ms] <br>[GC Worker Start (ms) : 1619.3<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span>1619 .<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1619 </span>.<span class="hljs-number"> 3 </span>, Max :<span class="hljs-number"> 1619 </span>. 3, Diff : 0.0] <br>[Ext Root Scanning (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>0.3 0.2<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 2 </span>, Max :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 3 </span>, Diff : 0.1] <br>[Update RS (ms) :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 7 </span>5 .<span class="hljs-number"> 4 </span>2<span class="hljs-number"> 8 </span>. O<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span><br>Avg :<span class="hljs-number"> 11 </span>.<span class="hljs-number"> 1 </span>, Min :<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 3 </span>, Max:<span class="hljs-number"> 28 </span>.<span class="hljs-number"> 0 </span>, Diff : 22.8] <br>[Processed Buffers :<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 1 </span>4 <br>Sum :<span class="hljs-number"> 14 </span>, Avg :<span class="hljs-number"> 3 </span>, Min :<span class="hljs-number"> 1 </span>, Max : 5, Diff : 4] <br>[Scan RS (ms) :<span class="hljs-number"> 4 </span>.<span class="hljs-number"> 6 </span>5 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>5 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 3 </span>.<span class="hljs-number"> 7 </span>, Min : 0.0 , Max:<span class="hljs-number"> 5 </span>.<span class="hljs-number"> 2 </span>, Diff :<span class="hljs-number"> 5 </span>. 2] <br>[Object Copy (ms): 27.4<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 3 </span>9 .<span class="hljs-number"> 6 </span>27 .<span class="hljs-number"> 2 </span><br>Avg :<span class="hljs-number"> 22 </span>.<span class="hljs-number"> 9 </span>, Min :<span class="hljs-number"> 9 </span>.<span class="hljs-number"> 6 </span>, Max :<span class="hljs-number"> 27 </span>.<span class="hljs-number"> 4 </span>, Diff : 17.7) <br>[Term nat on (ms) :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 0 </span>0 .<span class="hljs-number"> 1 </span><br>Avg :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Min: 0.0 , Max:<span class="hljs-number"> 0 </span>. 1, Diff : 0.1] <br>[Termination Attempts :<span class="hljs-number"> 3 </span>1<span class="hljs-number"> 10 </span>5 <br>Sum :<span class="hljs-number"> 19 </span>, Avg:<span class="hljs-number"> 4 </span>, Min :<span class="hljs-number"> 1 </span>, Max :<span class="hljs-number"> 10 </span>, Diff: 9] <br>[GC Worker End (ms): 1657.<span class="hljs-number"> 3 </span>1657.<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span>1657 .<span class="hljs-number"> 2 </span><br>Avg : 1657.2, Min:<span class="hljs-number"> 1657 </span>. 2, Max : 1657.3, Diff:<span class="hljs-number"> 0 </span>. 0) <br>[GC Worker (ms) :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>38 .<span class="hljs-number"> 0 </span>38.0<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span><br>Avg :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Min :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Max :<span class="hljs-number"> 38 </span>.<span class="hljs-number"> 0 </span>, Diff :<span class="hljs-number"> 0 </span>. 1] <br>[GC Worker Other (ms) : 0.0<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>0.1<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span><br>Avg : 0.1 , Min :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>, Max : 0.1 , Diff : 0.1) <br>[Clear CT : 0.0 ms] <br>[Other :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 4 </span>ms] <br>[Choose CSet : 0.<span class="hljs-number"> 0 </span>ms] <br>[Ref Proc :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Ref Enq:<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 0 </span>ms] <br>[Free CSet :<span class="hljs-number"> 0 </span>.<span class="hljs-number"> 1 </span>ms] <br>[Eden : 32M(35M) - &gt;0B(35M) Survivors : 5120K-&gt;5120K Heap : 147M(200M) - &gt;147M <br>(200M )) <br>[Times : user=0 .<span class="hljs-number"> 16 </span>sys=0 .<span class="hljs-number"> 00 </span>, real=0 .<span class="hljs-number"> 04 </span>secs]<br></code></pre></td></tr></table></figure><hr><p>特点:</p><ol><li>避免在整个Java堆进行全区域的垃圾回收，而是让G1跟踪每个Region的垃圾回收的价值及回收所需的时间，在后台维护一个优先级表。根据用户设定的允许收集停顿时间，优先回收价值收益最大的Region。(使用参数-XX:MaxGCPauseMills指定)</li><li>G1收集器每个Region都需要自己的记忆集，记录跨区域引用，因此比其他收集器要耗费内存，大约为java堆内存容量10%~20%。</li><li>通过在Region中划分空间(使用两TAMS指针，标记一块区域)用于并发回收的新对象分配，解决并发标记阶段与用户线程互不干扰。同样若内存分配速度大于内存回收速度，可能冻结用户线程进行Full GC。</li><li>CMS使用增量更新算法，而G1使用原始快照(SATB)算法来解决，用户线程改变对象的引用关系，不打破原有的对象图结构，防止标记错误。</li><li>通过可靠停顿预测模型的建立：根据每个Region的回收成本，分析出收集的平均值、标准偏差、置信度等统计信息。</li></ol><ul><li>缺点：内存占用过高，在小内存应用上CMS的表现大于G1。</li></ul><p>常用参数：</p><ul><li><code>-XX:+UseG1GC</code>：标记打开 GI 集器开关</li><li><code>-XX:G1HeapRegionSize</code>: 参数Region的大小可通过该参数设定，取值范围为1M~32M，为2的N次幂。</li><li><code>-XX:MaxGCPauseMills</code>：设置用户设定的允许收集停顿时间时，默认为200毫秒。调的调小会导致每次的回收集只占内存的很小一部分，收集的速度慢于分配的速度导致垃圾堆积，进而引发Full GC。正常设置为100~300毫秒之间。</li><li><code>-XX:ParallelGCThreads</code>：用于设置并行回收时，GC的工作线程数量。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值是45，即当整个堆占用率达到45%时，执行并发标记周期。</li></ul><h3 id="📚CMS-与-G1-对比"><a href="#📚CMS-与-G1-对比" class="headerlink" title="📚CMS 与 G1 对比"></a>📚CMS 与 G1 对比</h3><p>G1计划作为并发标记扫描收集器(CMS)的长期替代品。</p><ol><li>垃圾回收理念不同：CMS基于分代收集理念设计。G1基于分区收集理念设计。</li><li>整理：G1在GC的时候都会做垃圾的碎片整理，而CMS收集器只在Full GC STW时才会做内存压缩整理。</li><li>可停顿时间：G1是一种兼顾吞吐量和停顿时间的 GC 实现，其可靠停顿预测模型可以设定目标收集停顿时间，可以实现更短的GC停顿。</li><li>对象记录算法：对于对象记录CMS使用增量更新算法，而G1使用原始快照(SATB,snapshot-at-the-beginning)记录存活对象。</li><li>收集方式：G1使用混合收集的方式。G1可以扫描年轻代和一小部分老年代，但这意味着比简单地只扫描老年代、完全的快得多。</li><li>String重复数据删除。G1可以配置针对String的重复数据进行删除，而重复的数据将指向同一个char[] array。<code>-XX:+UseStringDeduplication</code></li></ol><ul><li>CMS对处理器资源非常敏感。CMS默认启动的回收线程数是(处理器数量+3)&#x2F;4，因此若核心数量在4个以上，占用内存不超过25%。若核心数量小于4，则占用内存过大。</li><li>G1针对具有大内存的多处理器机器，因为其<code>Remembered Sets</code>的记忆集的设计，需要占用更多内存。</li></ul><h3 id="📚其他的垃圾收集器"><a href="#📚其他的垃圾收集器" class="headerlink" title="📚其他的垃圾收集器"></a>📚其他的垃圾收集器</h3><ul><li>Shenandoah 收集器：仅存在OpenJdk，区别G1的特点为支持并发整理，使用转发指针和读屏障实现。</li><li>ZGC 收集器：Region具有动态性，并分为大中小三个Region，使用染色指针技术实现并发整理算法。</li><li>Epsilon收集器：无操作收集器。</li></ul><h3 id="📚选用收集器的三个因素"><a href="#📚选用收集器的三个因素" class="headerlink" title="📚选用收集器的三个因素"></a>📚选用收集器的三个因素</h3><ol><li>如果是数据分析、科学计算类任务，目标是尽快可以算出结果，那么吞吐量为主要关注点。如果为SLA应用，停顿时间直接影响任务质量，严重甚至会导致事务超时，那么延迟是主要的关注点。</li><li>使用运行的基础设施的指标。</li><li>JDK对应的版本。</li></ol><h3 id="📚java虚拟机监控工具"><a href="#📚java虚拟机监控工具" class="headerlink" title="📚java虚拟机监控工具"></a>📚java虚拟机监控工具</h3><h4 id="📔jps"><a href="#📔jps" class="headerlink" title="📔jps"></a>📔jps</h4><p>jps (JVM Process Status): 类似 UNIX 的 ps 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -l<br><span class="hljs-number">3796</span> sun.tools.jps.Jps<br><span class="hljs-number">2903</span> org.apache.catalina.startup.Bootstrap<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -m<br><span class="hljs-number">3811</span> Jps -m<br><span class="hljs-number">2903</span> Bootstrap start<br>[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jps -v<br><span class="hljs-number">3828</span> Jps -Dapplication.home=/usr/java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_221</span>-amd64 -Xms8m<br><span class="hljs-number">2903</span> Bootstrap -Djava.util.logging.config.file=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=<span class="hljs-number">2048</span> -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=<span class="hljs-number">0027</span> -Dignore.endorsed.dirs= -Dcatalina.base=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Dcatalina.home=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span> -Djava.io.tmpdir=/usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/temp<br></code></pre></td></tr></table></figure><h4 id="📔jstat"><a href="#📔jstat" class="headerlink" title="📔jstat"></a>📔jstat</h4><p>jstat( JVM Statistics Monitoring Tool): 用于收集 HotSpot 虚拟机各方面的运行数据;</p><p>jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jstat -gc -h3 <span class="hljs-number">2903</span> <span class="hljs-number">1000</span> <span class="hljs-number">10</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   <br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br><span class="hljs-number">4160.0</span> <span class="hljs-number">4160.0</span> <span class="hljs-number">2589.7</span>  <span class="hljs-number">0.0</span>   <span class="hljs-number">33792.0</span>   <span class="hljs-number">8242.5</span>   <span class="hljs-number">84096.0</span>    <span class="hljs-number">55749.8</span>   <span class="hljs-number">61440.0</span> <span class="hljs-number">60173.8</span> <span class="hljs-number">7424.0</span> <span class="hljs-number">7132.2</span>    <span class="hljs-number">306</span>    <span class="hljs-number">1.047</span>   <span class="hljs-number">7</span>      <span class="hljs-number">0.345</span>    <span class="hljs-number">1.393</span><br></code></pre></td></tr></table></figure><h4 id="📔jinfo"><a href="#📔jinfo" class="headerlink" title="📔jinfo"></a>📔jinfo</h4><p>jinfo (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Users\SnailClimb&gt;jinfo  -flag MaxHeapSize <span class="hljs-number">17340</span><br>-XX:MaxHeapSize=<span class="hljs-number">2124414976</span><br>C:\Users\SnailClimb&gt;jinfo  -flag PrintGC <span class="hljs-number">17340</span><br>-XX:-PrintGC<br></code></pre></td></tr></table></figure><h4 id="📔jmap-和-jhat"><a href="#📔jmap-和-jhat" class="headerlink" title="📔jmap 和 jhat"></a>📔jmap 和 jhat</h4><p>jmap (Memory Map for Java) :生成堆转储快照;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jmap -dump:format=b,file=elasticfoam.bin <span class="hljs-number">2903</span><br>Dumping heap to /usr/local/apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>/elasticfoam.bin ...<br>Heap dump file created<br></code></pre></td></tr></table></figure><p>jhat (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果;<br>与上面的jmap配合使用，分析heapdump的堆信息，会生成具体的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[root<span class="hljs-meta">@iZuf6ee30yhz3x9bqf63clZ</span> apache-tomcat-<span class="hljs-number">8.5</span><span class="hljs-number">.31</span>]# jhat elasticfoam.bin <br>Reading from elasticfoam.bin...<br>Dump file created Sat Nov <span class="hljs-number">07</span> <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">33</span> CST <span class="hljs-number">2020</span><br>Snapshot read, resolving...<br>Resolving <span class="hljs-number">131419</span> objects...<br>Chasing references, expect <span class="hljs-number">26</span> dots..........................<br>Eliminating duplicate references..........................<br>Snapshot resolved.<br>Started HTTP server on port <span class="hljs-number">7000</span><br>Server is ready.<br></code></pre></td></tr></table></figure><h4 id="📔jstack"><a href="#📔jstack" class="headerlink" title="📔jstack"></a>📔jstack</h4><p>jstack (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333e668</span> (object <span class="hljs-number">0x00000000d5efe1c0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 1&quot;</span><br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000000333be88</span> (object <span class="hljs-number">0x00000000d5efe1d0</span>, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;线程 2&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;线程 2&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">1</span>(DeadLockDemo.java:<span class="hljs-number">31</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">1078694789.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;线程 1&quot;</span>:<br>        at DeadLockDemo.lambda$main$<span class="hljs-number">0</span>(DeadLockDemo.java:<span class="hljs-number">16</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)<br>        at DeadLockDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1324119927.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><p>一个linux的排除高CUP线程的排查案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">top -c <span class="hljs-comment">//查看所有进程</span><br>top -Hp <span class="hljs-title function_">xxx</span><span class="hljs-params">(PID)</span>  <span class="hljs-comment">// 查看进程具体的线程ID cup情况</span><br>jstack -l pid &gt; filename <span class="hljs-comment">// 输出当前快照</span><br>cat filename| grep <span class="hljs-string">&#x27;线程ID(16进制)&#x27;</span> -C <span class="hljs-number">8</span>     <span class="hljs-comment">// 查找匹配线程，-C 查看前后多少行数据</span><br></code></pre></td></tr></table></figure><h4 id="📔jconsole"><a href="#📔jconsole" class="headerlink" title="📔jconsole"></a>📔jconsole</h4><p>JConsole:Java 监视与管理控制台，很强大，可以检测死锁，查看堆的内存释放情况。</p><blockquote><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.rmi.server.hostname=外网访问 ip 地址 <br>-Dcom.sun.management.jmxremote.port=<span class="hljs-number">60001</span>   <span class="hljs-comment">//监控的端口号</span><br>-Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>   <span class="hljs-comment">//关闭认证</span><br>-Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="📓类文件"><a href="#📓类文件" class="headerlink" title="📓类文件"></a>📓类文件</h2><h3 id="📚类文件结构"><a href="#📚类文件结构" class="headerlink" title="📚类文件结构"></a>📚类文件结构</h3><p>方法体出现ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/synchronizeMethod.jpg" alt="avatar"></p><p>方法体对应的访问范围 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729362.jpeg" alt="avatar"></p><h3 id="📚双亲委派模型"><a href="#📚双亲委派模型" class="headerlink" title="📚双亲委派模型"></a>📚双亲委派模型</h3><p>站在虚拟机角度，只存在两种不同的类加载器：</p><ol><li>启动类加载器BootStrap ClassLoader，由虚拟机实现，是虚拟机自身一部分。</li><li>其他所有的类加载器，由Java语言实现，独立于虚拟机之外，都是继承自抽象类java.lang.ClassLoader。</li></ol><p>java相关的三层类加载器</p><ul><li>启动类加载器BootStrap ClassLoader：负责加载存放在<code>&lt;JAVA HOME&gt;\lib</code>目录，或者被<code>-Xbootclaspath</code>参数，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要交给引导类加载器去处理，那直接使用<code>null</code>替代即可。</li><li>扩展类加载器Extension ClassLoader：负责加载<code>&lt;JAVA HOME&gt;\lib\ext</code>目录，或者被<code>java.ext.dirs</code>系统变量所指定的目录中所有的类库。</li><li>应用程序类加载器Application ClassLoader：负责加载用户类路径ClassPath上所有的类库。</li></ul><p>双亲委派模型加载过程：</p><ol><li>如果一个类加载器接收到类加载请求，它首先不会自己尝试加载这个类，而是把请求委托到父类执行。</li><li>每一层次的类加载器都会委托其父类加载器去完成，最终传到最顶层的启动类加载器中。</li><li>只有当所有父加载器都无法自己完成这个类加载请求，子加载器才会进行加载。</li></ol><p><strong>作用</strong>：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器(Bootstrcp ClassLoader)加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729346.jpeg" alt="avatar"></p><p>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚双亲委派模型缺陷"><a href="#📚双亲委派模型缺陷" class="headerlink" title="📚双亲委派模型缺陷"></a>📚双亲委派模型缺陷</h3><p>双亲委派模型很好的解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的类加载器进行加载)<br>双亲委派模型检查类是否己经加载的委托过程是单向的，这种方式虽然从结构上说比较清楚，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。而且<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访应用类就会出现问题。</p></blockquote><p>解决方法：引入从线程上下文获取classLoader</p><h3 id="📚破坏双亲委派模型"><a href="#📚破坏双亲委派模型" class="headerlink" title="📚破坏双亲委派模型"></a>📚破坏双亲委派模型</h3><p>破坏双亲委派模型，就是要实现自己的ClassLoader重写loadClass，在方法中重写自己加载的逻辑。这样类加载过程中就不会通过委派父类加载的方式进行加载数据。</p><p>三次破坏双亲委派模型：</p><ol><li>第一次破坏。JDK1.2时期，双亲委派模型出现前，用户自定义了一些类加载器。在引入双亲委派模型，为了兼容用户自定义的类加载器，添加新的<code>findClass()</code>方法，并引导用户重写该方法，而不是重写<code>loadClass()</code>方法。</li><li>第二次破坏，为该模型的缺陷导致。父类加载器无法访问底层类加载器负责的类</li><li>第三次破坏，引入热部署的机制。违反双亲委派的类加载过程。</li></ol><h4 id="📔JDBC破坏双亲委派模型"><a href="#📔JDBC破坏双亲委派模型" class="headerlink" title="📔JDBC破坏双亲委派模型"></a>📔JDBC破坏双亲委派模型</h4><p>不破坏双亲委派模型的情况(不使用JNDI服务)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.加载数据访问驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">//2.连接到数据&quot;库&quot;上去</span><br>Connection conn= DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDBC需要破坏双亲委派模式：<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong></p><blockquote><p>原生的JDBC中的类是放在<strong>rt.jar包</strong>(对应由启用类加载器BootStrapClassLoader)的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。</p></blockquote><blockquote><p>在JDBC4.0以后，开始支持使用SPI(Service Provider Interface)的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF&#x2F;services&#x2F;java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用如下：<br><code>Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test?characterEncoding=GBK&quot;, &quot;root&quot;, &quot;&quot;);</code></p></blockquote><p>如何解决父加载器无法加载子级类加载器路径中的类？</p><blockquote><p>引入线程上下文件类加载器(Thread Context ClassLoader).在mysql jdbc连接中获取当前的类加载器，这就破坏的双亲委派的类加载过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(</span><br><span class="hljs-params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * When callerCl is null, we should check the application&#x27;s</span><br><span class="hljs-comment">     * (which is invoking this class indirectly)</span><br><span class="hljs-comment">     * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="hljs-comment">     * can be loaded from here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//callerCL为空的时候，其实说明这个ClassLoader是启动类加载器，但是这个启动类加载并不能识别rt.jar之外的类，这个时候就把callerCL赋值为Thread.currentThread().getContextClassLoader();也就是应用程序启动类</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">callerCL</span> <span class="hljs-operator">=</span> caller != <span class="hljs-literal">null</span> ? caller.getClassLoader() : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span>(DriverManager.class) &#123;<br>        <span class="hljs-comment">// synchronize loading of the correct classloader.</span><br>        <span class="hljs-keyword">if</span> (callerCL == <span class="hljs-literal">null</span>) &#123;<br>            callerCL = Thread.currentThread().getContextClassLoader();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="📔自定义类加载器"><a href="#📔自定义类加载器" class="headerlink" title="📔自定义类加载器"></a>📔自定义类加载器</h4><ol><li>加载非classpath下的类，从非标准的来源加载代码</li><li>加载加密过的类文件，使用秘钥进行解密。</li><li>热部署，简单粗暴的方法是自定义类加载器，加载目录外的类对象。使用定时任务或者触发起的方法，每次创建新的类加载器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> String classPath;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClassLoader</span><span class="hljs-params">(String classPath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.classPath = classPath;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>        name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(classPath + <span class="hljs-string">&quot;/&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> fis.available();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>        fis.read(data);<br>        fis.close();<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            data = loadByte(name);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="📚类初始化的时机"><a href="#📚类初始化的时机" class="headerlink" title="📚类初始化的时机"></a>📚类初始化的时机</h3><p>虚拟机严格规范了有且只有6种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code> 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li></ol><ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行<code>getstatic</code>指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行<code>putstatic</code>指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行<code>invokestatic</code>指令时会初始化类。即程序调用类的静态方法。</li></ul><ol><li>使用 java.lang.reflect 包的方法对类进行反射调用时如<code>Class.forname(&quot;...&quot;).newInstance()</code>等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用<code>findStaticVarHandle</code>来初始化要调用的类。</li><li>当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="📚类的生命周期"><a href="#📚类的生命周期" class="headerlink" title="📚类的生命周期"></a>📚类的生命周期</h3><p>类的生命周期： 加载、连接[验证、准备、解析]、初始化、使用、卸载。</p><h4 id="📔加载"><a href="#📔加载" class="headerlink" title="📔加载"></a>📔加载</h4><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><h4 id="📔验证"><a href="#📔验证" class="headerlink" title="📔验证"></a>📔验证</h4><p>验证的范围：文件格式、元数据、字节码、符号引用验证</p><h4 id="📔准备"><a href="#📔准备" class="headerlink" title="📔准备"></a>📔准备</h4><p>准备阶段是正式为类变量(即静态变量)分配内存并设置类变量初始值的阶段，jdk8中这些内存都将在java堆中分配。对于该阶段有以下几点需要注意：</p><ul><li>进行内存分配的仅包括类变量(static)，而不包括实例变量</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值(如0、0L、null、false等)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器&lt;client&gt;方法之中</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080</span><br><br></code></pre></td></tr></table></figure><h4 id="📔解析"><a href="#📔解析" class="headerlink" title="📔解析"></a>📔解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>以方法解析为例：</p><ol><li>解析出方法表的class_index项中索引的方法所属的类或接口的符号引用。</li><li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果存在返回直接引用。</li><li>同上在类C的父类查找直接引用。</li><li>上述简述了类的查找，具体细节见书本。返回直接引用后，会验证方法的访问权限，即<code>private、protected、public</code>，如果发现不具备方法的访问级别，抛出<code>IllegalAccessError</code>异常。</li></ol><h4 id="📔初始化"><a href="#📔初始化" class="headerlink" title="📔初始化"></a>📔初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤，这个阶段Java虚拟机才开始真正执行类中编写的java程序，将主导权移交给应用程序。</p><p>在准备阶段已经赋初始化零值的变量，在初始化阶段，会根据程序去初始化类变量和其他资源。<br>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。该方法是由编译器收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。</p><h4 id="📔卸载"><a href="#📔卸载" class="headerlink" title="📔卸载"></a>📔卸载</h4><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ul><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ul><h2 id="📓对象创建及使用"><a href="#📓对象创建及使用" class="headerlink" title="📓对象创建及使用"></a>📓对象创建及使用</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/objcreate.jpg" alt="avatar"></p><p>对象的创建</p><ol><li>类加载检查：虚拟机遇到new命令，先检查是否能在常量池定位到一个类的引用，检查这个符号代表的类是否已被加载、解析和初始化过。</li><li>分配内存：检查通过，在java堆中分配对象内存，具体看对象的内存分配。</li><li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</li><li>设置对象头：进行对象的必要设置如那个类的示例、hashcode、GC分代年龄等信息，这些信息存放在对象头中。</li><li>上述工作完成之后，java开始调用对象的构造函数。</li></ol><h2 id="📓对象分配内存的方式"><a href="#📓对象分配内存的方式" class="headerlink" title="📓对象分配内存的方式"></a>📓对象分配内存的方式</h2><ul><li>规整空间：指针碰撞，整理过内存用一个指针标记内存使用过的范围，后序分配内存只需要移动指针，仅把指针向空闲空间移动一段与对象大小相等的距离。</li><li>碎片空间：空闲链表(free list)，通过额外的维护的列表存储记录空闲的地址，将随机IO变为顺序IO，但带来了额外的空间消耗。</li></ul><blockquote><p>使用Serial、ParNew等带压缩过程的垃圾回收器，使用指针分配算法。而CMS这种基于清除的算法理论上使用空闲链表的方式分配。</p></blockquote><p>对象分配内存并发控制(<strong>内存分配并发解决方案</strong>)：</p><ul><li>CAS+失败重试</li><li>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB) ，每个线程在Java堆中预先分配一小块内存，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li></ul><h2 id="📓对象内存分布"><a href="#📓对象内存分布" class="headerlink" title="📓对象内存分布"></a>📓对象内存分布</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729670.jpeg" alt="avatar"></p><p>对象在堆内存中的存储布局可以分为三部分：对象头、实例数据(对象有效信息)和对齐填充(仅起占位符作用)\</p><p>Hotspot的对象头包括两部分信息：</p><ol><li>第一部分：存储对象自身的运行数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。</li><li>第二部分：类型指针，即对象指向它的类型愿数据的指针。</li></ol><h2 id="📓对象的访问"><a href="#📓对象的访问" class="headerlink" title="📓对象的访问"></a>📓对象的访问</h2><p>定义：java程序会通过栈上的reference数据来操作堆上的具体对象。具体的对象访问方式由虚拟机决定，主要有两种使用句柄和直接指针两种。</p><ul><li>使用句柄访问的话，java堆会划分一块内存作为句柄池。引用会指向句柄，而句柄中分为两块指针，一个是指向对象实例的指针，一个是指向对象类型数据的指针(指向方法区)。好处为整理内存是只需要整理实例的指针。</li><li>直接指针访问，引用直接指向堆中的对象实例，而对象实例中包含数据的类型数据的指针(指向方法区)，好处为减少了指向实例的时间定为开销。</li></ul><blockquote><p>HotSpot虚拟机主要使用第二种方式进行访问。</p></blockquote><h2 id="📓对象引用"><a href="#📓对象引用" class="headerlink" title="📓对象引用"></a>📓对象引用</h2><ul><li>强引用(Strongly Reference): Object obj &#x3D; new Object()。关系存在虚拟机就不会回收。</li><li>软引用(Soft Reference)：用来描述一些还有用但非必须的对象。在系统要发生内存溢出会收集软引用对象，若回收完成仍内存不足，才抛出内存异常。软引用可用于实现内存敏感缓存，其中内存管理是一个非常重要的因素。</li><li>弱引用(Weak Reference)：弱引用关联的对象只能生存到下一次垃圾收集发生为止。</li><li>虚引用(Phantom Reference)：最弱的引用，意义为一个对象设置虚引用关联的唯一目的是为了在该对象被收集时得到一个通知。</li></ul><p>对象死亡的调用，任何一个对象都会被系统调用一次，如果对象下一次面临回收它的finalize()不会再执行。</p><ul><li>Soft References in Java</li><li>Weak References in Java</li><li>Phantom References in Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent);<br>        <span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(referent, referenceQueue);<br><br>        referent = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">referent2</span> <span class="hljs-operator">=</span> weakReference1.get();<br>        System.out.println(<span class="hljs-string">&quot;after gc, reference get result: &quot;</span> + referent2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        List&lt;LargeObjectFinalizer&gt; references = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Object&gt; largeObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">largeObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            largeObjects.add(largeObject);<br>            references.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LargeObjectFinalizer</span>(largeObject, referenceQueue));<br>        &#125;<br><br>        largeObjects = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        Reference&lt;?&gt; referenceFromQueue;<br>        <span class="hljs-keyword">for</span> (PhantomReference&lt;Object&gt; reference : references) &#123;<br>            System.out.println(reference.isEnqueued());<br>            <span class="hljs-comment">// 此处获取为空</span><br>            System.out.println(<span class="hljs-string">&quot;get result&quot;</span> + reference.get());<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> ((referenceFromQueue = referenceQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            ((LargeObjectFinalizer)referenceFromQueue).finalizeResources();<br>            referenceFromQueue.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObjectFinalizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LargeObjectFinalizer</span><span class="hljs-params">(</span><br><span class="hljs-params">            Object referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> Object&gt; q)</span> &#123;<br>        <span class="hljs-built_in">super</span>(referent, q);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalizeResources</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// free resources</span><br>        System.out.println(<span class="hljs-string">&quot;clearing ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📓栈上分配"><a href="#📓栈上分配" class="headerlink" title="📓栈上分配"></a>📓栈上分配</h2><p>栈上分配是Java虚拟机的一项优化技术，基本思想是对于那些线程私有的对象(指不能被其他线程访问到的对象)，可以把他们打散分配在栈上，而不是分配在堆上。</p><blockquote><p>分配在对象上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能</p></blockquote><h3 id="📚逃逸分析"><a href="#📚逃逸分析" class="headerlink" title="📚逃逸分析"></a>📚逃逸分析</h3><p>逃逸分析是编译语言中的一种优化分析，而不是一种优化的手段。通过对象的作用范围的分析，为其他优化手段提供分析数据从而进行优化。</p><blockquote><p>目的是判断对象的作用域是否可能逃逸出函数体</p></blockquote><p>对象逃逸的三种类型：</p><ol><li><code>GlobalEscape</code>: 对象逃逸出方法或线程，如静态对象、对象作为方法的返回值、是已确认为逃逸对象的对象字段等</li><li><code>ArgEscape</code>: 对象作为方法调用的参数，传递引用给方法，但是在调用过程中不是全局逃逸对象。</li><li><code>NoEscape</code>: 可以标量替换的对象。</li></ol><blockquote><p>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量(如：int，long等基本数据类型以及reference类型等)</p></blockquote><h3 id="📚标量替换"><a href="#📚标量替换" class="headerlink" title="📚标量替换"></a>📚标量替换</h3><p>标量可以理解成一种不可分解的变量，如java内部的基本数据类型、引用类型等。 与之对应的聚合量是可以被拆解的，如对象。</p><p>当通过逃逸分析一个对象只会作用于方法内部，虚拟机可以通过使用标量替换来进行优化。</p><h3 id="📚应用"><a href="#📚应用" class="headerlink" title="📚应用"></a>📚应用</h3><ul><li><code>-XX:+DoEscapeAnalysis</code>：用于开启逃逸分析</li><li><code>-XX:+EliminateAllocations</code>：用于开启标量替换，允许将对象打散分配在栈上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnStackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        u.id = <span class="hljs-number">5</span>;<br>        u.name = <span class="hljs-string">&quot;geym&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(e-b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果关闭逃逸分析或者标量替换的任何一个，再次执行程序就会看到大量的GC日志，说明栈上分配依赖逃逸分析和标亮替换的实现。</p><h2 id="📓TLAB"><a href="#📓TLAB" class="headerlink" title="📓TLAB"></a>📓TLAB</h2><p>TLAB，全称Thread Local Allocation Buffer, 即：线程本地分配缓存。这是一块线程专用的内存分配区域。TLAB占用的是eden区的空间。在TLAB启用的情况下(默认开启)，JVM会为每一个线程分配一块TLAB区域。</p><p>为什么需要TLAB？ 这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须<strong>线程同步</strong>，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。</p><p>局限性： TLAB空间一般不会太大(占用eden区)，所以大对象无法进行TLAB分配，只能直接分配到堆上。</p><p>分配策略：<br>一个100KB的TLAB区域，如果已经使用了80KB，当需要分配一个30KB的对象时，TLAB是如何分配的呢？ 此时，虚拟机有两种选择：第一，废弃当前的TLAB(会浪费20KB的空间)；第二，将这个30KB的对象直接分配到堆上，保留当前TLAB(当有小于20KB的对象请求TLAB分配时可以直接使用该TLAB区域)。 JVM选择的策略是：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，若小于refill_waste值，则会废弃当前TLAB，新建TLAB来分配新对象。</p><blockquote><p>【默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使系统的运行状态达到最优。】</p></blockquote><table><thead><tr><th>参数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>-XX:+UseTLAB</td><td>启用TLAB</td><td>默认启用</td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>设置允许空间浪费的比例</td><td>默认值：64，即：使用1&#x2F;64的TLAB空间大小作为refill_waste值</td></tr><tr><td>-XX:-ResizeTLAB</td><td>禁止系统自动调整TLAB大小</td><td></td></tr><tr><td>-XX:TLABSize</td><td>指定TLAB大小</td><td>单位：B</td></tr></tbody></table><h2 id="📓对象内存分配流程"><a href="#📓对象内存分配流程" class="headerlink" title="📓对象内存分配流程"></a>📓对象内存分配流程</h2><p>java对象分配流程</p><ol><li>首先运行栈上分配。编译器通过逃逸分析及标量替换，决定对象应该分配在栈上还是堆中。如果逃逸分析及标量替换其中一个未启用，则直接分配在堆中。如果决定分配在堆中，那么执行步骤2</li><li>进行TLAB分配。如果TLAB的空间<code>TALB_TOP+SIZE &lt;= TLAB_END</code>，对象可以直接分配在TLAB中，那么<code>TLAB_TOP</code>加上对象<code>SIZE</code>进行位置移动。若不能执行步骤3</li><li>重新申请一块TALB，并尝试存储对象。若对象过大仍无法存储在TLAB中，执行步骤4</li><li>判断是否满足进入老年代的条件(<code>PretenureSizeThreshold</code>参数)，若满足直接进入老年代，不满足进行新声代分配</li><li>将对象存储在新声代<code>Eden</code>中，<code>EDEN_TOP</code>指针移位。若新声代无法存储对象，执行<code>Young GC</code>，并尝试重新分配对象。</li><li><code>Young GC</code> 后重新分配对象，若仍然无法分配。对象直接进入老年代。</li></ol><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/jvm/object-alloc.png" alt="image"></p><h2 id="📓JDK编译期"><a href="#📓JDK编译期" class="headerlink" title="📓JDK编译期"></a>📓JDK编译期</h2><h3 id="📚编译期做的工作"><a href="#📚编译期做的工作" class="headerlink" title="📚编译期做的工作"></a>📚编译期做的工作</h3><ol><li>默认构造器： 经过编译的代码,可以看到在编译阶段，如果我们没有添加构造器。那么Java编译器会为我们添加一个无参构造方法。</li><li>自动拆装箱</li><li>泛型与类型擦除</li><li>foreach优化成Iterator</li><li><code>String... args</code> 可变参数优化</li><li>switch支持case使用字符串及枚举类型优化，优化成hashcode匹配。</li><li>枚举，优化成final class</li><li>try-with-resources 优化，自动在finally中加入close语句</li><li>重写的优化，子类重写方法中会新增一个桥接方法。</li><li>匿名内部类：生成final 修饰的类</li></ol><h2 id="📓堆内存的设置要点"><a href="#📓堆内存的设置要点" class="headerlink" title="📓堆内存的设置要点"></a>📓堆内存的设置要点</h2><ol><li>新生代的内存大小设置建议：Sun官方推荐配置为整个堆的3&#x2F;8。</li><li>服务器的内存需要预留一部分给永久代、线程栈及NIO</li></ol><p>内存分配问题: 省略比较小的区域，可以总结JVM占用的内存：</p><blockquote><p>JVM内存 ≈ Java永久代 ＋ Java堆(新生代和老年代) ＋ 线程栈＋ Java NIO</p></blockquote><p>假设原来的内存分配是：6G(java堆) ＋ 600M(监控) ＋ 800M(系统)，剩余大约600m内存未分配。</p><p>现在分析这600M内存的分配情况：</p><ol><li>Linux保留大约200M，这部分是Linux正常运行的需要，</li><li>Java服务的线程数量是160个，JVM默认的线程栈大小是1M，因此使用160M内存，</li><li>Java NIO buffer，通过JMX查到最多占用了200m，</li><li>Java服务使用NIO大量读写文件，需要使用PageCache，正如前面分析，这个暂时不好定量估算大小。 前三项加起来已经560M，因此可以断定Linux物理内存不够使用。</li></ol><p>以下是sun公司的性能优化白皮书中提到的几个例子： 1．对于吞吐量的调优。机器配置：4G的内存，32个线程并发能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> <br><br>-Xmx3800m -Xms3800m 配置了最大Java Heap来充分利用系统内存。 <br>-Xmn2g 创建足够大的青年代(可以并行被回收)充分利用系统内存，防止将短期对象复制到老年代。 <br>-Xss128 减少默认最大的线程栈大小，提供更多的处理虚拟内存地址空间被进程使用。 <br>-XX:+UseParallelGC 采用并行垃圾收集器对年青代的内存进行收集，提高效率。 <br>-XX:ParallelGCThreads=<span class="hljs-number">20</span> 减少垃圾收集线程，默认是和服务器可支持的线程最大并发数相同，往往不需要配置到最大值。 <br></code></pre></td></tr></table></figure><p>2．尝试采用对老年代并行收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseParallelOldGC <br><br>-Xmx3550m -Xms3550m 内存分配被减小，因为ParallelOldGC会增加对于Native Heap的需求，因此需要减小Java Heap来满足需求。 <br>-XX:+UseParallelOldGC 采用对于老年代并发收集的策略，可以提高收集效率。 <br></code></pre></td></tr></table></figure><p>3．提高吞吐量，减少应用停顿时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=<span class="hljs-number">20</span> -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:TargetSurvivorRatio=<span class="hljs-number">90</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> <br><br>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC 选择了并发标记交换收集器，它可以并发执行收集操作，降低应用停止时间，同时它也是并行处理模式，可以有效地利用多处理器的系统的多进程处理。 <br>-XX:SurvivorRatio=<span class="hljs-number">8</span> -XX:MaxTenuringThreshold=<span class="hljs-number">31</span> 表示在青年代中Eden和Survivor比例，设置增加了Survivor的大小，越大的survivor空间可以允许短期对象尽量在年青代消亡。 <br>-XX:TargetSurvivorRatio=<span class="hljs-number">90</span> 允许<span class="hljs-number">90</span>%的空间被占用，超过默认的<span class="hljs-number">50</span>%，提高对于survivor的使用率。<br></code></pre></td></tr></table></figure><h2 id="📓CMS-ParNew收集器的流程梳理"><a href="#📓CMS-ParNew收集器的流程梳理" class="headerlink" title="📓CMS + ParNew收集器的流程梳理"></a>📓CMS + ParNew收集器的流程梳理</h2><h3 id="📚young区域-年轻代"><a href="#📚young区域-年轻代" class="headerlink" title="📚young区域(年轻代)"></a>📚young区域(年轻代)</h3><ol><li>对象首先分配到Eden，分配满了触发Young Gc(Minor Gc)，基于复制交换算法，晋升对象年龄+1。 <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/edenGc.jpg" alt="avatar"></a></li><li>年龄到达老年代门槛的晋升老年代。<ul><li>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</li><li>晋升失败触发FULL GC的两种场景：<ol><li>空间分配担保失败：在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。</li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</li></ol></li></ul></li></ol><p>特殊：</p><ol><li><p>大对象通过直接进入老年代。</p></li><li><p>动态对象年龄判断：如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保：当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域(实际上大多数情况下就是老年代) 进行分配担保，survior区无法容纳的对象直接晋升到老年代。。</p><blockquote><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 - XX:HandlePromotionFailure 参数的设置值是否允许担保失败 (Handle Promotion Failure)；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次 Full GC。</p></blockquote></li></ol><h3 id="📚old区域-老年代"><a href="#📚old区域-老年代" class="headerlink" title="📚old区域(老年代)"></a>📚old区域(老年代)</h3><h4 id="📔CMS-GC原因"><a href="#📔CMS-GC原因" class="headerlink" title="📔CMS GC原因"></a>📔CMS GC原因</h4><p>触发 CMS GC有：</p><ol><li>Old 区达到回收阈值</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败</li><li>扩容缩容</li><li>显式调用System.gc</li><li>并发模式失败(浮动垃圾导致)</li></ol><h4 id="📔CMS-GC-垃圾回收模式"><a href="#📔CMS-GC-垃圾回收模式" class="headerlink" title="📔CMS GC 垃圾回收模式"></a>📔CMS GC 垃圾回收模式</h4><p>CMS GC 的垃圾回收共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>CMS 在Background回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><h4 id="📔其他老年代问题"><a href="#📔其他老年代问题" class="headerlink" title="📔其他老年代问题"></a>📔其他老年代问题</h4><p>CMS 无法处理浮动垃圾(Floating Garbage)。CMS 的并发清理阶段，应用还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p><h2 id="📓Java虚拟机内存调优"><a href="#📓Java虚拟机内存调优" class="headerlink" title="📓Java虚拟机内存调优"></a>📓Java虚拟机内存调优</h2><p>jdk1.8前的参数设置 </p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729631.jpeg" alt="avatar"></p><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/jvmGCType.jpg" alt="avatar"></p><h3 id="📚基本概念重述"><a href="#📚基本概念重述" class="headerlink" title="📚基本概念重述"></a>📚基本概念重述</h3><p>跨代引用解决方案</p><p>Card Table：中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。</p><p>内存分配</p><ol><li><strong>TLAB</strong>：Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程(Mutator Threads)可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。</li><li>CAS+失败重试</li></ol><p>Mutator：生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。</p><h4 id="📔工具整理"><a href="#📔工具整理" class="headerlink" title="📔工具整理"></a>📔工具整理</h4><h5 id="🏷命令行终端"><a href="#🏷命令行终端" class="headerlink" title="🏷命令行终端"></a>🏷命令行终端</h5><p>标准终端类：jps、jinfo、jstat、jstack、jmap</p><p>功能整合类：jcmd、vjtools、arthas、greys</p><h5 id="🏷可视化界面"><a href="#🏷可视化界面" class="headerlink" title="🏷可视化界面"></a>🏷可视化界面</h5><p>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</p><p>进阶：MAT、JProfiler</p><p>命令行推荐 Arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy、heaphero、fastthread ，美团内部的 Scalpel(一款自研的 JVM 问题诊断工具，暂时未开源)也比较好用。</p><h3 id="📚GC-调优目的"><a href="#📚GC-调优目的" class="headerlink" title="📚GC 调优目的"></a>📚GC 调优目的</h3><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h3 id="📚GC-调优策略"><a href="#📚GC-调优策略" class="headerlink" title="📚GC 调优策略"></a>📚GC 调优策略</h3><p><strong>策略 1</strong>：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2</strong>：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代(当然短命的大对象对于垃圾回收来说简直就是噩梦)。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3</strong>：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><blockquote><p>为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区(年龄是可以调的，默认是15)hotspots的markword的图中，用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。</p></blockquote><p><strong>策略 4</strong>：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。</p><p><strong>策略5</strong>：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：</p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote><h3 id="📚调优指标"><a href="#📚调优指标" class="headerlink" title="📚调优指标"></a>📚调优指标</h3><ul><li>延迟(Latency)：也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li>吞吐量(Throughput)：应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><h3 id="📚问题排查思路"><a href="#📚问题排查思路" class="headerlink" title="📚问题排查思路"></a>📚问题排查思路</h3><p>四种分析思路</p><ul><li><strong>时序分析</strong>：先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高(要有足够的时间 Gap)，那么整个问题影响链就可能是：</li></ul><blockquote><p>CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程Block增多 -&gt; RT 上涨。</p></blockquote><ul><li><strong>概率分析</strong>：使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：</li></ul><blockquote><p>慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨。</p></blockquote><ul><li><strong>实验分析</strong>：通过故障演练等方式对问题现场进行模拟，触发其中部分条件(一个或多个)，观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨。</p></blockquote><ul><li><strong>反证分析</strong>：对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：</li></ul><blockquote><p>GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨。</p></blockquote><h3 id="📚案例"><a href="#📚案例" class="headerlink" title="📚案例"></a>📚案例</h3><h4 id="📔美团技术案例-基于CMS-JDK1-8"><a href="#📔美团技术案例-基于CMS-JDK1-8" class="headerlink" title="📔美团技术案例(基于CMS JDK1.8)"></a>📔美团技术案例(基于CMS JDK1.8)</h4><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/gcProcess.jpg"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729841.jpeg" alt="avatar"></a></p><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/localIssue.png"><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209041729263.png" alt="avatar"></a></p><p><strong>场景一：动态扩容引起的空间震荡</strong></p><p>服务刚刚启动时 GC 次数较多，最大空间剩余很多但是依然发生 GC， GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整。</p><p>解决：尽量将成对出现的空间大小配置参数设置成固定的，</p><blockquote><p>如 -Xms 和 -Xmx，-XX:MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 等。</p></blockquote><p>策略：保证 Java 虚拟机的堆是稳定的，避免弹性伸缩带来的额外 GC 消耗，确保 -Xms 和 -Xmx 设置的是一个值(即初始值和最大值一致)，获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题</p><blockquote><p>在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。</p></blockquote><hr><p><strong>场景二：显式 GC 的去与留 (System.gc)</strong></p><p>除了扩容缩容会触发 CMS GC 之外，还有</p><ol><li>Old 区达到回收阈值.</li><li>MetaSpace 空间不足</li><li>Young 区晋升失败</li><li>大对象担保失败等几种触发条件</li></ol><p>如果以上均不是GC发生的原因，那么就是代码中调用了 <code>System.gc </code>方法。</p><p>增加 -XX:+DisableExplicitGC 参数后，<code>System.gc </code>这个方法变成了一个空方法</p><p>CMS GC 共分为 Background 和 Foreground 两种模式，</p><ul><li>Background： 正常的CMS收集过程，初始标记、并发标记、重新标记、标记清除</li><li>Foreground： 会进行一次压缩式 GC，使用 MSC(Mark-Sweep-Compact)做 Full GC。收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace，会带来非常长的 STW。</li></ul><p>保留 <code>System.gc</code>：在显示触发System.gc会使用Foreground模式对Old区域进行垃圾收集造成，长时间的STW。<br>去掉 <code>System.gc</code>：DirectByteBuffer直接内存在分配空间会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory。若禁用<code>System.gc</code>，会导致已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放，于是就有发生 Direct Memory 的 OOM。</p><blockquote><p>-XX:+DisableExplicitGC 可以用于禁用System.gc</p></blockquote><p><strong>策略</strong>: 因为DirectByteBuffer经常用于Netty 等各种 NIO 框架使用，所以不应该去除<code>System.gc</code>，可以使用参数改变System.gc的触发类型为Background，该模式也会触发old的DirectByteMemory 的清理工作。</p><blockquote><p>-XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background<br>不止 CMS，在 G1 或 ZGC中开启 ExplicitGCInvokesConcurrent 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。</p></blockquote><hr><p><strong>场景三：MetaSpace 区 OOM</strong></p><p>现象：JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p><p>MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p><ul><li><strong>Klass MetaSpace</strong>：就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构. 这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</li><li><strong>NoKlass MetaSpace</strong>：专门来存 Klass 相关的其他的内容，比如 Method，<strong>ConstantPool</strong> 常量池等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容。</li></ul><p>MetaSpace 内存管理：类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的<br>MetaSpace 弹性伸缩：由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize</p><p>问题原因：为了避免弹性伸缩带来的额外 GC 消耗，我们会将 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。</p><blockquote><p>经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。</p></blockquote><p>策略： 给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p><p><strong>场景四：过早晋升</strong></p><p>现象：</p><ol><li>分配速率接近于晋升速率，对象晋升年龄较小</li><li>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大。</li></ol><p>原因：</p><ol><li>Young&#x2F;Eden 区过小：过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升， copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间</li><li>分配速率过大：可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</li></ol><p>设定固定的 MaxTenuringThreshold 值作为晋升条件：</p><ul><li>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生。Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</li><li>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</li></ul><blockquote><p>未设置情况，Hotspot 会使用动态计算的方式来调整晋升的阈值：<br>Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值(TargetSurvivorRatio &#x2F; 100，TargetSurvivorRatio 默认值为 50)进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费。</p></blockquote><p>策略：</p><ol><li>Young&#x2F;Eden 区过小：调整堆分区内存，一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。 如何设置Survivor面积，可以自己推算。</li><li>分配速率过大：<ul><li>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</li><li>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</li></ul></li></ol><hr><p><strong>场景五：CMS Old GC 频繁</strong></p><p>现象：Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。</p><blockquote><p>描述过于抽象，见文章</p></blockquote><hr><p><strong>场景六：单次 CMS Old GC 耗时长</strong></p><p>CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段</p><ul><li>初始标记 Init Mark ： 整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li><li>最终标记 Final Remark ：Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 <strong>Card Table 遍历</strong>、<strong>Reference 实例的清理</strong>并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源</li></ul><blockquote><p>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行,如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。</p></blockquote><p>由上述过程可以推断，大部分出问题的耗时都是出现在最终标记中。处理思路如下：</p><ol><li><p>分析Reference 处理和元数据处理 real 耗时是否正常，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段。</p></li><li><p>需要通过</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintReferenceGC</span><br></code></pre></td></tr></table></figure><p>参数开启。基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注</p><ul><li>对 FinalReference 的分析: 经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。</li><li><code>scrub symbol table</code> 表示清理元数据符号引用耗时，观察 MetaSpace 区的历史使用峰值，看是否有使用动态类加载或者 DSL 处理等。 如果MateSpace 数据没啥变化，可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理。</li></ul></li></ol><hr><p><strong>场景七：内存碎片&amp;收集器退化</strong></p><p>现象： 并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><p>原因：</p><ol><li><p>晋升失败：</p><ol><li>在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。 <strong>发生的条件是很苛刻</strong></li><li>内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。<ul><li>碎片空间问题-空间分配效率较低：连续空间使用指针碰撞，而有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问</li><li>碎片空间问题-空间利用效率变低: Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象</li></ul></li></ol></li><li><p>增量收集担保失败: 分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小,，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之不安全，进行FULL GC。</p></li><li><p>显式 GC： System.gc</p></li><li><p>并发模式失败(Concurrent Mode Failure):在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p><blockquote><p>概率较高，主要是由于 CMS 无法处理浮动垃圾(Floating Garbage)引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。</p></blockquote></li></ol><p>策略</p><ul><li>内存碎片：通过配置 -XX:UseCMSCompactAtFullCollection&#x3D;true 来控制 Full GC的过程中是否进行空间的整理(默认开启，注意是Full GC，不是普通CMS GC)，以及 -XX: CMSFullGCsBeforeCompaction&#x3D;n 来控制多少次 Full GC 后进行一次压缩。</li><li>增量收集：降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</li><li>浮动垃圾：视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</li></ul><hr><p><strong>场景八：堆外内存 OOM</strong></p><p>现象： 内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java 进程的 RES 甚至超过了 -Xmx 的大小。</p><p>JVM 的堆外内存泄漏，主要有两种的原因：</p><ol><li>通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。</li><li>代码中有通过 JNI 调用 Native Code 申请的内存没有释放。</li></ol><p>策略：在项目中添加 -XX:NativeMemoryTracking&#x3D;detail JVM参数后重启项目(需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗)。使用命令 jcmd pid VM.native_memory detail 查看内存分布。</p><p><strong>场景九：JNI 引发的 GC 问题</strong></p><blockquote><p>太抽象了</p></blockquote><h4 id="📔不恰当的数据结构导致内存过大"><a href="#📔不恰当的数据结构导致内存过大" class="headerlink" title="📔不恰当的数据结构导致内存过大"></a>📔不恰当的数据结构导致内存过大</h4><p>场景：-Xms4g -Xmx8g -Xmn1g 使用ParNew + CMS组合。业务上需要10min加载80MB的数据到内存，会产生100W HashMap entry， Minor GC超过500ms，因为新生代使用了标记复制算法\</p><p>方案：不从修改程序，仅从GC调优，可以直接去掉SurvivorRatio，让新生代存活的对象一次Minor GC就进入到老年代<code> -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0</code>(或者-XX:+AlwaysTenure)</p><h4 id="📔堆外内存导致溢出错误"><a href="#📔堆外内存导致溢出错误" class="headerlink" title="📔堆外内存导致溢出错误"></a>📔堆外内存导致溢出错误</h4><p>NIO使用直接内存复制，而虚拟机中最大最小内存直接设值成系统内存大小了</p><h4 id="📔异步系统Socket连接"><a href="#📔异步系统Socket连接" class="headerlink" title="📔异步系统Socket连接"></a>📔异步系统Socket连接</h4><p>Socket 使用BIO连接异步处理，导致了系统连接数过多，进而虚拟机崩溃</p><h4 id="📔Evosuite-自动生成单元测试"><a href="#📔Evosuite-自动生成单元测试" class="headerlink" title="📔Evosuite 自动生成单元测试"></a>📔Evosuite 自动生成单元测试</h4><p>表现：maven build时候单元测试需要一个多小时。</p><p>排查：</p><ol><li><code>jstat -gc pid</code> 结合日志观察GC情况。</li><li><code>jstack -l pid</code> 刷具体的运行线程。</li><li><code>jmap -heap pid</code> 导出堆的分配情况</li></ol><p>原因为Evosuite自动生成的test中存在：</p><ol><li>StringUtils的expend测试，延长字符串到1610613374长度。jdk8，String内部使用char数组。</li><li>调用Util类分配694225808 长度的ArrayList 数组空间，并分配元素。</li><li>死循环线程</li></ol><p>java进程垃圾回收器使用ParallelGC，新生代使用标记复制算法，老年代标记整理。 <code>s0：1g s1：3g eden：3g old：10g</code></p><p>结果： YGC出现大量复制工作，很耗费时间。每次分配的空间过大，经常需要FGC来分配空间。</p><p>解决处理：死循环线程、修改自动生成的test分配合理内存。</p><h4 id="📔其他建议"><a href="#📔其他建议" class="headerlink" title="📔其他建议"></a>📔其他建议</h4><ol><li><p>禁用偏向锁：偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。</p><blockquote><p>在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。</p></blockquote></li><li><p>主动式 GC： 观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC。必要时引入，会影响系统健壮性。</p></li><li><p>虚拟内存：启动初期有些操作系统(例如 Linux)并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。</p><blockquote><p>这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。</p></blockquote></li></ol><h2 id="📓JVM工具"><a href="#📓JVM工具" class="headerlink" title="📓JVM工具"></a>📓JVM工具</h2><ul><li><p>javac.exe是编译.java文件</p></li><li><p>java.exe是执行编译好的.class文件</p></li><li><p>javadoc.exe是生成Java说明文档</p></li><li><p>jdb.exe是Java调试器</p></li><li><p>javaprof.exe是剖析工具</p></li></ul><h2 id="📓JVM参数"><a href="#📓JVM参数" class="headerlink" title="📓JVM参数"></a>📓JVM参数</h2><p>常见配置汇总</p><h3 id="📚堆设置"><a href="#📚堆设置" class="headerlink" title="📚堆设置"></a>📚堆设置</h3><ul><li>-Xms:初始堆大小</li><li>-Xmx:最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><h3 id="📚收集器设置"><a href="#📚收集器设置" class="headerlink" title="📚收集器设置"></a>📚收集器设置</h3><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><h3 id="📚垃圾回收统计信息"><a href="#📚垃圾回收统计信息" class="headerlink" title="📚垃圾回收统计信息"></a>📚垃圾回收统计信息</h3><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h3 id="📚并行收集器设置"><a href="#📚并行收集器设置" class="headerlink" title="📚并行收集器设置"></a>📚并行收集器设置</h3><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</li></ul><h3 id="📚并发收集器设置"><a href="#📚并发收集器设置" class="headerlink" title="📚并发收集器设置"></a>📚并发收集器设置</h3><ul><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP</title>
    <link href="/2022/09/04/AOP/"/>
    <url>/2022/09/04/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><blockquote><p>AOP(Aspect Oriented Programming,面向切面编程)通过提供一种思考程序结构的方式来补充OOP(Object Oriented Programming,面向对象编程)。OOP模块化的关键单元是类，而在AOP中，模块化的单元是切面。切面可以实现跨多个类型和对像之间的事务管理、日志等方面的模块化。</p></blockquote><p>Spring框架中使用AOP主要有以下优势：</p><ul><li>提供声明式企业服务，特别是作为 EJB声明式服务的替代品。重要的是，这种服务是声明式事务管理。</li><li>允许用户实现自定义切面。在某些不适合用OOP编程的场景中，采用AOP来补充。</li><li>可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高开发效率。</li></ul><p>要使用Spring AOP 需要添加spring-aop 模块。</p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205052246547.png" alt="image-20220402110359545"></p><ul><li>Aspect（切面）：将关注点进行模块化。在Spring AOP中，切面可以使用常规类（基于模式的方法）或@Aspect注解的常规类来实现。</li><li>Join Point（连接点）：在程序执行过程中的某个特定的点。如某方法调用时或处理异常时。在Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>Advice（通知）：在七日面的某个特定的连接点上执行的动作。通知有各种类型，包括around、before和after等。许多AOP框架都是以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。</li><li>Pointcut（切入点）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（如当执行某个特定的方法时）。切入点表达式如何和连接点匹配是AOP的核心。Spring默认使用AspectJ切入点语法。</li><li>Introduction（引入）：声明额外的方法或某个类型的字段。Spring允许引入新的接口（及一个对应的实现）到任何被通知的对象。例如，可以使用一个引入来使bean实现IsModified接口，以便简化缓存机制。</li><li>Target Object（目标对象）：被一个或多个切面通知的对象。也有人把它称为Adviced（被通知）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个Proxied（被代理）对象。</li><li>AOP Proxy（AOP代理）：AOP框架创建的对象用来实现Aspect Contract（切面契约），包括通知方法执行等功能。在Spring中，AOP代理可以JDK动态代理或CGLIB代理。</li><li>Weaving（织入）：把切面连接到其他的应用程序类型或对象上，并创建一个Adviced （被通知）的对象。这些可以在编译时（如使用AspectJ编译器）、类加载时和运行完成时。</li></ul><h2 id="Advice（通知）类型"><a href="#Advice（通知）类型" class="headerlink" title="Advice（通知）类型"></a>Advice（通知）类型</h2><ul><li>Before Advice（前置通知）：在某连接点之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>After Returning Advice（返回后通知）：在某连接点正常完成后执行的通知，如果一个方法没有抛出异常，就正常返回。</li><li>After Throwing Advice（抛出异常后通知）：在方法抛出异常退出时执行的通知。</li><li>After （finally) Advice（最后通知）：当某连接点退出时执行的通知（不论是正常返回还是异常退出）。</li><li>Around Advice（环绕通知）：包围一个连接点的通知。如方法调用。这是很强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为，它也会选择是否继续执行连接点，或者直接返回它自己的返回值或抛出异常来结束执行。Around Advice是常用的一种通知类型。与AspectJ一样，Spring提供所有的类型的通知，推荐使用尽量简单的通知类型来实现需要的功能。例如，如果只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情，但最好使用After Returning通知，而不是使用环绕通知。用合适的通知类型可以使编程模型变得简单，并且能够避免很多潜在的错误。</li></ul><h2 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h2><p>Spring AOP默认使用标准的JDK动态代理，这样任何接口（或接口的set方法）都可以被代理。</p><p>Spring AOP也支持CGLIB代理，当需要代理类（而不是代理接口）时，CGLIB代理是很有必要的。如果一个业务对象并没有实现一个接口，就会默认使用CGLIB、</p>]]></content>
    
    
    <categories>
      
      <category>Spring MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令大全</title>
    <link href="/2022/09/04/Git/"/>
    <url>/2022/09/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p> <strong>一、创建与合并分支</strong> </p><p><strong>1、 从master分支创建dev分支并切换到dev分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout mastergit checkout -b dev<br></code></pre></td></tr></table></figure><p>其中，git checkout -b dev 等价于:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch devgit checkout dev<br></code></pre></td></tr></table></figure><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</p><p>（2）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  branch  -a<br></code></pre></td></tr></table></figure><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</p><p><strong>2、修改代码、提交代码（当前的操作是在dev分支上进行）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add a.html<br>git commit -m <span class="hljs-string">&quot;提交文件a.html&quot;</span><br></code></pre></td></tr></table></figure><p><strong>3、分支合并(将dev合并到master)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge dev<br></code></pre></td></tr></table></figure><p><strong>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d dev<br></code></pre></td></tr></table></figure><p><strong>5、删除后，查看分支(此时看不到dev分支了)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p><strong>6、总结 ：工作中经常从master创建新的分支，具体操作如下:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">master创建新分支：<br>git checkout master<br>git checkout -b  issues1234  // 从master分支创建issues1234分支<br>git push origin issues1234<br>git add ..<br>git commit -m <span class="hljs-string">&quot;***&quot;</span><br>git push origin issues1234<br></code></pre></td></tr></table></figure><blockquote><p>注意：将本地分支branch1推到远端的branch2操作步骤：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin branch1:branch2<br></code></pre></td></tr></table></figure><p><strong>7、删除分支：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D   issues1234  // 本地强制删除分支issues1234<br>git push origin  :issues1234  // 推到远程<br></code></pre></td></tr></table></figure><hr><p> <strong>二、解决冲突</strong> </p><p><strong>1、发生冲突的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></code></pre></td></tr></table></figure><p>其中，git使用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记文件中自己和别人产生冲突的部分。</p><p>在 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======</code>之间为自己的代码；&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p><strong>2、冲突解决后提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br>git add ***<br>git commit -m <span class="hljs-string">&quot;fix conflict&quot;</span><br>git push origin 分支名<br></code></pre></td></tr></table></figure><hr><p> <strong>三、Bug分支</strong> </p><p><strong>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p><strong>2、恢复储藏的代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop // 恢复的同时把stash内容删掉<br></code></pre></td></tr></table></figure><p>或者<img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181623625.png" alt="图片"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 通过 git stash list，查看本地所有的stash,如果我要恢复第一个就执行：git stash apply stash@&#123;0&#125;<br>git stash apply  // 恢复stash，但是stash内容并不删除<br>git stash drop // 在上面操作的基础上，以此来删除stash<br>注： git stash list // 查看全部的stash列表<br></code></pre></td></tr></table></figure><p><strong>3、将stash空间清空</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash clear<br></code></pre></td></tr></table></figure><p><strong>4、git stash pop 和 git stash apply 区别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">原来git stash pop stash@&#123;<span class="hljs-built_in">id</span>&#125;命令会在执行后将对应的stash <span class="hljs-built_in">id</span> 从stash list里删除，而 git stash apply stash@&#123;<span class="hljs-built_in">id</span>&#125; 命令则会继续保存stash <span class="hljs-built_in">id</span>。<br></code></pre></td></tr></table></figure><hr><p> <strong>四、版本回退</strong> </p><p><strong>1、回退至上一个版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD<br></code></pre></td></tr></table></figure><p><strong>2、回退至指定版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard  版本号<br></code></pre></td></tr></table></figure><p><strong>3、查看以往版本号(本地的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure><p><strong>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><hr><p> <strong>五、撤销修改</strong> </p><p><strong>1、撤销修改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git  checkout -- a.html<br></code></pre></td></tr></table></figure><blockquote><p>分两种情况分析：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。<br>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态<br></code></pre></td></tr></table></figure><blockquote><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p></blockquote><p><strong>2、撤销新建文件</strong></p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -f ../aa.html<br></code></pre></td></tr></table></figure><p><strong>3、撤销新建文件夹</strong></p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -<span class="hljs-built_in">df</span> ./demo<br></code></pre></td></tr></table></figure><hr><p> <strong>六、对已push版本进行回退</strong> </p><p><strong>1、第一步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 版本号 // 本地回退到指定的版本<br></code></pre></td></tr></table></figure><p><strong>2、第二步：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push  -f origin dev    //将远程的也回退到指定版本<br></code></pre></td></tr></table></figure><hr><p> <strong>七、本地同步远程删除的分支</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin -p  // 用来清除已经没有远程信息的分支，这样git branch -a 就不会拉取远程已经删除的分支了<br></code></pre></td></tr></table></figure><hr><p> <strong>八、删掉未与远程分支对应的本地分支</strong> </p><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch -p<br></code></pre></td></tr></table></figure><hr><p> <strong>九、查看远程库与本地分支的信息</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote show origin<br></code></pre></td></tr></table></figure><hr><p> <strong>十、标签管理</strong> </p><p><strong>1、给当前分支最新commit打标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0<br></code></pre></td></tr></table></figure><p><strong>2、比如现在周五，要给周一某个commit打标签，应执行以下步骤：</strong></p><p>（1）、查看log日志，找到相应的commit版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline --abbrev-commit<br>// 显示如下commit，比如我想在 <span class="hljs-string">&quot;34372b05&quot;</span>这个commit打标签44d2e20b fix bug34372b05 fix bug29554931 fix bug<br></code></pre></td></tr></table></figure><p>（2）、给指定的commit打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag v1.0.0 34372b05<br></code></pre></td></tr></table></figure><p>（3）、创建的标签只存在本地，推至远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0.0<br></code></pre></td></tr></table></figure><p>（4）、一次性推送未推至远程的本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin --tags<br></code></pre></td></tr></table></figure><p>（5）、查询所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br></code></pre></td></tr></table></figure><p>（6）、查询标签详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show v1.0.0<br></code></pre></td></tr></table></figure><p>（7）、删除本地标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d v1.0.0<br></code></pre></td></tr></table></figure><p>（8）、删除远程标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 先从本地删除git tag -d v1.0.0<br>// 然后从远程删除git push origin :refs/tags/v1.0.0<br>// 最后可以在gitlab上查看是否真正的删除了标签<br></code></pre></td></tr></table></figure><p><strong>3、创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// git  tag  -a  版本号  -m  说明信息  commit版本号git tag -a v1.0.0 -m <span class="hljs-string">&quot;version 1.0.0 released&quot;</span> 34372b05(commit版本号)     <br>// 查看标签详细信息git show v1.0.0    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo一键发布文章</title>
    <link href="/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"/>
    <url>/2022/09/04/Hexo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo一键发布文章"><a href="#Hexo一键发布文章" class="headerlink" title="Hexo一键发布文章"></a>Hexo一键发布文章</h1><h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>刚开始使用hexo的时候简直无法忍受繁杂的部署命令,不仅要输入以下命令来更新，并且还要在指定的目录下打开 git bash，这让怕麻烦的我十分难受…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure><h2 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h2><p>注意事项：下面的命令中 D:&#x2F;Myblog&#x2F;hexo&#x2F;liblog 是我博客的文件夹路径，请替换为你自己博客的路径</p><p>任意目录打开 git bash ，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.fuck <span class="hljs-string">&#x27;!cd D:/Myblog/hexo/liblog;hexo clean;hexo g -d&#x27;</span><br>git fuck<br></code></pre></td></tr></table></figure><p>以后就可以在任意目录下通过 git fuck 来一键更新了。</p><h2 id="三、如何取消别名"><a href="#三、如何取消别名" class="headerlink" title="三、如何取消别名"></a>三、如何取消别名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> alias.fuck<br></code></pre></td></tr></table></figure><h2 id="四、再简单些"><a href="#四、再简单些" class="headerlink" title="四、再简单些"></a>四、再简单些</h2><p>每次都要打开git bush再输入git fuck 还是有些麻烦，通过windows的bat脚本一键实现发布文章，新建一个文件后缀命名为bat,输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> 开始提交到git....<br>git fuck<br><span class="hljs-built_in">echo</span> 推送到git成功<br>@<span class="hljs-built_in">echo</span> off<br>pause<br></code></pre></td></tr></table></figure><p><strong>完美！！！</strong></p><p>只需点击这个bat文件就能够一键发布文章了</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用的IDEA插件</title>
    <link href="/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/09/04/IDEA%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><h2 id="1、Background-Image-Plus"><a href="#1、Background-Image-Plus" class="headerlink" title="1、Background Image Plus"></a>1、Background Image Plus</h2><p>默认IDEA的背景一般都比较单调，要么白乎乎，要么褐乎乎，而<strong>Background Image Plus</strong>这个插件可以为IDEA设置<strong>自定义图片</strong>作为背景，而且还可以设置透明度，从此写代码乐趣十足!</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639600.jpeg" alt="图片"></p><p><strong>背景图设置效果如下：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639590.jpeg" alt="图片"></p><hr><h2 id="2、CodeGlance"><a href="#2、CodeGlance" class="headerlink" title="2、CodeGlance"></a>2、CodeGlance</h2><p><strong>CodeGlance</strong>是一款非常好用的<strong>代码地图</strong>插件，可以在代码编辑区的右侧生成一个竖向可拖动的代码缩略区，可以快速定位代码的同时，并且提供放大镜功能</p><p><strong>右侧代码缩略图效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639411.jpeg" alt="图片"></p><p><strong>放大镜效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639447.jpeg" alt="图片"></p><hr><h2 id="3、Translation"><a href="#3、Translation" class="headerlink" title="3、Translation"></a>3、Translation</h2><p>代码中经常遇到不认识的英文单词或者句子，很蒙蔽怎么办？</p><p><strong>Translation</strong>是一款非常好用的<strong>翻译插件</strong>，可以随时随地翻译单词、甚至一段话，从此不再需要额外打开浏览器搜索翻译网站了！</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639271.jpeg" alt="图片"></p><p><strong>翻译逐个单词：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639277.jpeg" alt="图片"></p><p><strong>翻译一段话：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639762.jpeg" alt="图片"></p><hr><h2 id="4、Rainbow-Brackets"><a href="#4、Rainbow-Brackets" class="headerlink" title="4、Rainbow Brackets"></a>4、Rainbow Brackets</h2><p>在代码非常复杂时，各种<strong>俄罗斯套娃式</strong>的括号简直让人心碎，<strong>Rainbow Brackets</strong>则是一款可以对<strong>成对括号</strong>进行着色的插件，顾名思义“彩虹色的括号”，从此复杂代码一眼即可看穿！</p><p>装完插件，括号都被染上了彩虹的颜色：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639875.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639123.png" alt="图片"></p><hr><h2 id="5、Grep-Console"><a href="#5、Grep-Console" class="headerlink" title="5、Grep Console"></a>5、Grep Console</h2><p>默认情况下，IDEA控制台窗口在打印日志时都是一种颜色到底，比如各种<code>info</code>,<code>warn</code>,和<code>error</code>等类型的日志信息交织在一起，不好分辨。</p><p><strong>Grep Console</strong>插件则可以帮助我们自定义设置不用日志用不同的颜色进行标识，非常方便观看！</p><p><strong>设置自定义颜色：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639197.jpeg" alt="图片"></p><p><strong>着色后的日志打印效果：</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639171.jpeg" alt="图片"></p><hr><h2 id="6、Statistic"><a href="#6、Statistic" class="headerlink" title="6、Statistic"></a>6、Statistic</h2><p>程序员天天闷头做项目、写代码！</p><ul><li>你知道你项目到底有多少行代码吗？</li><li>你知道项目代码里有多少是实际代码？</li><li>有多少是空行？</li><li>有多少是注释吗？</li><li>. . .</li></ul><p><strong>Statistic</strong>则是一款可以做项目全局代码统计信息的小插件：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639241.jpeg" alt="图片"></p><hr><h2 id="7、Markdown-Navigator"><a href="#7、Markdown-Navigator" class="headerlink" title="7、Markdown Navigator"></a>7、Markdown Navigator</h2><p>很多人私信问说，你是用什么markdown编辑器写博客的呢？不瞒你说，用IDEA就可以很愉快的写博客了，装了一个<strong>Markdown Navigator</strong>插件即可方便的实现：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639787.jpeg" alt="图片"></p><hr><h2 id="8、RestfulToolkit"><a href="#8、RestfulToolkit" class="headerlink" title="8、RestfulToolkit"></a>8、RestfulToolkit</h2><ul><li>你知道你项目里到底写了多少个URL接口吗？</li><li>如何快速定位某个<code>URL</code>接口对应的<code>Controller</code>代码？</li><li>如何快速测试你的<code>Controller</code>接口？</li></ul><p><strong>RestfulToolkit</strong>则是一个可以解决上述问题的，非常方便的IDEA集成插件，从此<code>Postman</code>怕是要下岗了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639948.jpeg" alt="图片"></p><hr><h2 id="9、GsonFormat"><a href="#9、GsonFormat" class="headerlink" title="9、GsonFormat"></a>9、GsonFormat</h2><p>给你一段<code>Json</code>格式数据，除了手写之外，如何快速生成一个和该<code>Json</code>数据对应的<code>Java</code>对象？</p><p>比如一段<code>Json</code>格式数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;操作成功&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>GsonFormat</strong>则是一个<strong>JSON格式数据 → 对象</strong>的快速<strong>代码自动生成</strong>插件。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639900.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639827.png" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639896.jpeg" alt="图片"></p><hr><h2 id="10、MyBatis-Log-Plugin"><a href="#10、MyBatis-Log-Plugin" class="headerlink" title="10、MyBatis Log Plugin"></a>10、MyBatis Log Plugin</h2><p><code>Mybatis</code>的<code>xml</code>文件中的<code>SQL</code>语句都是拼装起来的，但有时候（比如在调试的时候）想把某个请求对应的后台具体<code>SQL</code>查询语句单独拿出来测试或验证，该怎么办呢？</p><p><strong>MyBatis Log Plugin</strong>这个插件既可以帮你完美地解决这个问题：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639995.jpeg" alt="图片"></p><hr><h2 id="11、Free-Mybatis-plugin"><a href="#11、Free-Mybatis-plugin" class="headerlink" title="11、Free Mybatis plugin"></a>11、Free Mybatis plugin</h2><p>除了全局搜索以外，如何方便地在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换？</p><p><strong>Free Mybatis plugin</strong>插件此时就可以大显身手了：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639379.jpeg" alt="图片"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181639393.jpeg" alt="图片"></p><hr><h2 id="12、MyBatisX"><a href="#12、MyBatisX" class="headerlink" title="12、MyBatisX"></a>12、MyBatisX</h2><p>快速在<code>Mybatis</code>的<code>mapper Java</code>接口方法和<code>mapper XML</code>文件之间来回切换</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642594.png" alt="image-20220818164238523"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181642440.png" alt="image-20220818164250365"></p><h2 id="13、Nyan-Progress-Bar"><a href="#13、Nyan-Progress-Bar" class="headerlink" title="13、Nyan Progress Bar"></a>13、Nyan Progress Bar</h2><p>让进度条变得好看，编程彩虹条</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181648858.png" alt="image-20220818164845828"></p><h2 id="14、SequenceDiagram"><a href="#14、SequenceDiagram" class="headerlink" title="14、SequenceDiagram"></a>14、SequenceDiagram</h2><p>查看代码执行时序图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181646385.png" alt="image-20220818164613306"></p><h2 id="15、Material-Theme-UI"><a href="#15、Material-Theme-UI" class="headerlink" title="15、Material Theme UI"></a>15、Material Theme UI</h2><p>代码主题切换，可以改变代码颜色搭配</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208181647157.png" alt="image-20220818164727076"></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSR303数据校验</title>
    <link href="/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <url>/2022/09/04/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h1><blockquote><p>JSR 303 是Java为Bean数据合法校验提供的标准框架，已经包含在Java EE 6.0中。JSR是一个规范，它的核心接口时Validator，该接口根据目标对象类中所标注的校验注解进行数据校验，并得到校验结果。JSR303通过在Bean属性中标注类似@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p></blockquote><h2 id="JSR-303-包含注解"><a href="#JSR-303-包含注解" class="headerlink" title="JSR 303 包含注解"></a>JSR 303 包含注解</h2><table><thead><tr><th align="left">注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">@Null</td><td align="center">被注解的元素必须为null</td></tr><tr><td align="left">@NotNull</td><td align="center">被注解的元素必须不为null</td></tr><tr><td align="left">@AssertTrue</td><td align="center">被注解的元素必须为true</td></tr><tr><td align="left">@AssertFalse</td><td align="center">被注解的元素必须为false</td></tr><tr><td align="left">@Min(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@Max(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@DecimalMin(value)</td><td align="center">被注解的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@DecimalMax(value)</td><td align="center">被注解的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@Size</td><td align="center">被注解的元素的大小必须在指定的范围内</td></tr><tr><td align="left">@Digits(integer,fraction)</td><td align="center">被注解的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td align="left">@Past</td><td align="center">被注解的元素必须是一个过去的时间</td></tr><tr><td align="left">@Future</td><td align="center">被注解的元素必须是一个将来的时间</td></tr><tr><td align="left">@Pattern(regex&#x3D;,flag&#x3D;)</td><td align="center">被注解的元素必须符合指定的正则表达式</td></tr></tbody></table><h2 id="Hibernate-Vakudator"><a href="#Hibernate-Vakudator" class="headerlink" title="Hibernate Vakudator"></a>Hibernate Vakudator</h2><blockquote><p>Hibernate Vakudator是JSR303的一个参考实现，出来支持所有的标准注解外，还支持一些扩展注解</p></blockquote><table><thead><tr><th>注解名称</th><th align="center">描述</th></tr></thead><tbody><tr><td>@NotBlank(message&#x3D;)</td><td align="center">验证字符串非null,并且长度必须大于0</td></tr><tr><td>@Email</td><td align="center">被注解的元素必须是电子邮箱地址</td></tr><tr><td>@Length(min&#x3D;,max&#x3D;)</td><td align="center">被注解的字符串的大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td align="center">被注解的字符串必须非空</td></tr><tr><td>@Range(min&#x3D;,max&#x3D;,message&#x3D;)</td><td align="center">被注解的元素必须在合适的范围内</td></tr><tr><td>@URL</td><td align="center">被注解的元素必须是合法的URL</td></tr></tbody></table><h2 id="ValidationMessages-properties"><a href="#ValidationMessages-properties" class="headerlink" title="ValidationMessages.properties"></a>ValidationMessages.properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">javax.validation.constraints.AssertFalse.message</span>     = <span class="hljs-string">必须为 false</span><br><span class="hljs-attr">javax.validation.constraints.AssertTrue.message</span>      = <span class="hljs-string">必须为 true</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMax.message</span>      = <span class="hljs-string">必须小于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.DecimalMin.message</span>      = <span class="hljs-string">必须大于 $&#123;inclusive == true ? &#x27;or equal to &#x27; : &#x27;&#x27;&#125;&#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Digits.message</span>          = <span class="hljs-string">数字值超出了边界（期望 &lt;&#123;integer&#125; digits&gt;.&lt;&#123;fraction&#125; digits&gt;）</span><br><span class="hljs-attr">javax.validation.constraints.Email.message</span>           = <span class="hljs-string">必须为格式规范的电子邮件地址</span><br><span class="hljs-attr">javax.validation.constraints.Future.message</span>          = <span class="hljs-string">必须是未来的日期</span><br><span class="hljs-attr">javax.validation.constraints.FutureOrPresent.message</span> = <span class="hljs-string">必须是现在或将来的日期</span><br><span class="hljs-attr">javax.validation.constraints.Max.message</span>             = <span class="hljs-string">必须小于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Min.message</span>             = <span class="hljs-string">必须大于或等于 &#123;value&#125;</span><br><span class="hljs-attr">javax.validation.constraints.Negative.message</span>        = <span class="hljs-string">必须小于 0</span><br><span class="hljs-attr">javax.validation.constraints.NegativeOrZero.message</span>  = <span class="hljs-string">必须小于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.NotBlank.message</span>        = <span class="hljs-string">不得为空白</span><br><span class="hljs-attr">javax.validation.constraints.NotEmpty.message</span>        = <span class="hljs-string">不得为空</span><br><span class="hljs-attr">javax.validation.constraints.NotNull.message</span>         = <span class="hljs-string">不得为 null</span><br><span class="hljs-attr">javax.validation.constraints.Null.message</span>            = <span class="hljs-string">必须为 null</span><br><span class="hljs-attr">javax.validation.constraints.Past.message</span>            = <span class="hljs-string">必须是过去的日期</span><br><span class="hljs-attr">javax.validation.constraints.PastOrPresent.message</span>   = <span class="hljs-string">必须是过去或现在的日期</span><br><span class="hljs-attr">javax.validation.constraints.Pattern.message</span>         = <span class="hljs-string">必须与 &quot;&#123;regexp&#125;&quot; 匹配</span><br><span class="hljs-attr">javax.validation.constraints.Positive.message</span>        = <span class="hljs-string">必须大于 0</span><br><span class="hljs-attr">javax.validation.constraints.PositiveOrZero.message</span>  = <span class="hljs-string">必须大于或等于 0</span><br><span class="hljs-attr">javax.validation.constraints.Size.message</span>            = <span class="hljs-string">大小必须在 &#123;min&#125; 和 &#123;max&#125; 之间</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.CreditCardNumber.message</span>        = <span class="hljs-string">无效信用卡卡号</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Currency.message</span>                = <span class="hljs-string">无效货币（必须为 &#123;value&#125; 之一）</span><br><span class="hljs-attr">org.hibernate.validator.constraints.EAN.message</span>                     = <span class="hljs-string">无效 &#123;type&#125; 条形码</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Email.message</span>                   = <span class="hljs-string">电子邮件地址格式不规范</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ISBN.message</span>                    = <span class="hljs-string">无效 ISBN</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Length.message</span>                  = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.CodePointLength.message</span>         = <span class="hljs-string">长度必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.LuhnCheck.message</span>               = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Luhn Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod10Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 10 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Mod11Check.message</span>              = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，Modulo 11 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ModCheck.message</span>                = <span class="hljs-string">$&#123;validatedValue&#125; 的校验位无效，&#123;modType&#125; 校验和失败</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotBlank.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.NotEmpty.message</span>                = <span class="hljs-string">可能不为空</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ParametersScriptAssert.message</span>  = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.Range.message</span>                   = <span class="hljs-string">必须介于 &#123;min&#125; 与 &#123;max&#125; 之间</span><br><span class="hljs-attr">org.hibernate.validator.constraints.SafeHtml.message</span>                = <span class="hljs-string">可能具有不安全的 HTML 内容</span><br><span class="hljs-attr">org.hibernate.validator.constraints.ScriptAssert.message</span>            = <span class="hljs-string">脚本表达式 &quot;&#123;script&#125;&quot; 未求值为 true</span><br><span class="hljs-attr">org.hibernate.validator.constraints.UniqueElements.message</span>          = <span class="hljs-string">必须仅包含唯一元素</span><br><span class="hljs-attr">org.hibernate.validator.constraints.URL.message</span>                     = <span class="hljs-string">必须为有效 URL</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CNPJ.message</span>                 = <span class="hljs-string">无效巴西企业纳税人登记号 (CNPJ)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.CPF.message</span>                  = <span class="hljs-string">无效巴西个人纳税人登记号 (CPF)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.br.TituloEleitoral.message</span>      = <span class="hljs-string">无效巴西投票人身份证号</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.REGON.message</span>                = <span class="hljs-string">无效波兰纳税人识别号 (REGON)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.NIP.message</span>                  = <span class="hljs-string">无效 VAT 识别号 (NIP)</span><br><span class="hljs-attr">org.hibernate.validator.constraints.pl.PESEL.message</span>                = <span class="hljs-string">无效波兰身份证号 (PESEL)</span><br><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMax.message</span>        = <span class="hljs-string">必须短于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><span class="hljs-attr">org.hibernate.validator.constraints.time.DurationMin.message</span>        = <span class="hljs-string">必须长于 $&#123;inclusive == true ? &#x27; or equal to&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days == 1 ? &#x27; 1 day&#x27; : &#x27; &#x27; += days += &#x27; days&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours == 1 ? &#x27; 1 hour&#x27; : &#x27; &#x27; += hours += &#x27; hours&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes == 1 ? &#x27; 1 minute&#x27; : &#x27; &#x27; += minutes += &#x27; minutes&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds == 1 ? &#x27; 1 second&#x27; : &#x27; &#x27; += seconds += &#x27; seconds&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis == 1 ? &#x27; 1 milli&#x27; : &#x27; &#x27; += millis += &#x27; millis&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos == 1 ? &#x27; 1 nano&#x27; : &#x27; &#x27; += nanos += &#x27; nanos&#x27;&#125;</span><br><br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;<br>    &lt;version&gt;2.6.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-添加注解"><a href="#2-添加注解" class="headerlink" title="2.添加注解"></a>2.添加注解</h2><blockquote><p>在需要校验的字段上添加相应的注解进行校验，其中message是当校验不合法是提示的错误信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> liziyuan</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@email</span> liziyuan@gmail.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-07-08 08:58:02</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;pms_brand&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BrandEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@TableId</span><br>   <span class="hljs-keyword">private</span> Long brandId;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌名</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotBlank(message = &quot;品牌名称不能为空&quot;)</span><br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 品牌logo地址</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@URL(message = &quot;logo必须是一个合法的URL地址&quot;)</span><br>   <span class="hljs-keyword">private</span> String logo;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 介绍</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> String descript;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 显示状态[0-不显示；1-显示]</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Integer showStatus;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 检索首字母</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotEmpty</span><br>   <span class="hljs-meta">@Pattern(regexp = &quot;/~[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><br>   <span class="hljs-keyword">private</span> String firstLetter;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 排序</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-meta">@Min(value = 0,message = &quot;排序必须大于0&quot;)</span><br>   <span class="hljs-keyword">private</span> Integer sort;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Cotroller开启校验"><a href="#3-Cotroller开启校验" class="headerlink" title="3.Cotroller开启校验"></a>3.Cotroller开启校验</h2><blockquote><p>使用@Valid注解开启校验，其中参数BindingResult可以获取校验的结果。</p><ul><li>BindingResult：BindingResult扩展了Errors接口，同时可以获取数据绑定结果对象的信息。@Valid和BindingResult参数是成对出现的，并且在形参中出现的顺序是固定的，一前一后。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span>&#123;<br>        <span class="hljs-comment">//BindingResult 参数能够获取校验结果</span><br><span class="hljs-comment">//        获取校验的错误结果</span><br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            result.getFieldErrors().forEach((item)-&gt;&#123;<br><span class="hljs-comment">//                获取到错误提示</span><br>                String message=item.getDefaultMessage();<br>                 <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> item.getField();<span class="hljs-comment">//获取错误的属性的名字</span><br>                map.put(field,message);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-number">400</span>,<span class="hljs-string">&quot;提交数据不合法&quot;</span>).put(<span class="hljs-string">&quot;data&quot;</span>,map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>      brandService.save(brand);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h1><ol><li><p>编写一个自定义校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: liZiYuan</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Date: 2022/7/16  20:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Constraint(</span><br><span class="hljs-meta">        validatedBy = &#123;ListValueConstraintValidator.class&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ListValue &#123;<br>    String <span class="hljs-title function_">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&#123;com.zhang.common.valid.ListValue.message&#125;&quot;</span>;<br><br>    Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Payload</span>&gt;[] payload() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-type">int</span>[] vals()  <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>编写一个自定义的校验器 ConstrainValidator</p><p>实现ConstraintValidator&lt;Annotation, T&gt;接口,其中Annotation表示自定义的校验注解，T表示校验对象的类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListValueConstraintValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//初始化方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ListValue constraintAnnotation)</span> &#123;<br>        <span class="hljs-type">int</span>[] vals= constraintAnnotation.vals();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vals) &#123;<br>            set.add(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否校验成功</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 需要校验的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> constraintValidatorContext</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(Integer value, ConstraintValidatorContext constraintValidatorContext)</span> &#123;<br>        <span class="hljs-keyword">return</span> set.contains(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关联自定义的校验器和自定义的校验注解</p></li></ol><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><blockquote><p>@Validated是@Valid 的一次封装，是Spring提供的校验机制使用。@Valid不提供分组功能</p></blockquote><p><strong>@Valid和@Validated的区别</strong></p><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring的JSR-303规范，是标准JSR-303的一个变种），Javax提供了<code>@Valid</code>（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。</p><p><code>@Valid</code>属于Javax.validation包下，是jdk给提供的，是使用Hibernate validation的时候使用（java的JSR303声明了@Valid这类接口，而Hibernate-validator对其进行了实现）</p><p><code>@Validated</code>是org.springframework.validation.annotation包下的，是spring提供的，是只用Spring validator校验机制使用</p><p>在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p><p>1.分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Validated</span>：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制<br><span class="hljs-meta">@Valid</span>：作为标准的JSR-<span class="hljs-number">303</span>规范，还没有吸收分组的功能<br></code></pre></td></tr></table></figure><p><code>@Validated</code>会有分组的概念，后面默认是有一个Default.class,当你的@Validated后面没有加任何校验分组信息的时候默认会加Default分组,而对于被校验的对象的属性字段，如果你在属性的校验标签里面没有指定分组会添加到默认分组Default里面。所以如果你的对象里面的每个属性都指定了分组信息，而接口上面并没有添加分组信息会出现@Validated“失效的情况”，实际是因为它校验的是Default分组，而没有字段属于Default分组。上述校验不管加不加@ReqeustBody都能完成校验，但是都不能完成嵌套的校验。</p><p>特殊用法:</p><ul><li>分组: 当一个实体类需要多种验证方式时，例：对于一个实体类的id来说，新增的时候是不需要的，对于更新时是必须的, 可以通过groups对验证进行分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AllFiled</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">First</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Secend</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br><br>    <span class="hljs-meta">@NotBlank(message = &quot;姓名不能为空&quot;, groups = &#123;First.class, AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@NotEmpty(message = &quot;密码不能为空&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Length(min = 6, max = 10, message = &quot;密码长度只能在6-10之间&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@Min(value = 18, message = &quot;年龄最小为18&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-meta">@Max(value = 60, message = &quot;年龄最大为60&quot;, groups = &#123;AllFiled.class&#125;)</span><br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//临时加的字段</span><br>    <span class="hljs-meta">@AssertTrue(message = &quot;必须同意条款&quot;, groups = &#123;Secend.class, AllFiled.class&#125;)</span><br>    <span class="hljs-type">boolean</span> agree;<br>&#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;validate&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span>&#123;<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            List&lt;ObjectError&gt; list  = result.getAllErrors();<br>            <span class="hljs-keyword">for</span> (ObjectError error :<br>                    list) &#123;<br>                <span class="hljs-type">FieldError</span> <span class="hljs-variable">fieldError</span> <span class="hljs-operator">=</span> (FieldError)error;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">defaultMessage</span> <span class="hljs-operator">=</span> fieldError.getDefaultMessage();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldError.getField();<br>                map.put(field, defaultMessage);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当@Validated分组为空时, 只会验证没有分组的属性, 如上面的uid;</strong></p><p><strong>当@Validated{First.class}时, 只会验证分组为First.class的字段, 对于其他分组字段和未分组字段都为空</strong></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font style="color:red">注意</font></h1><p>添加全局异常处理时Controller层参数中不能加<code>BindingResult</code>参数，否则无法捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestControllerAdvice(basePackages = &quot;com.zhang.gulimall.product.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GulimallExceptionControllerAdvice</span> &#123;<br><br><span class="hljs-comment">//    @ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">handlerValidException</span><span class="hljs-params">(MethodArgumentNotValidException e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;校验异常处理&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;数据校验出现问题&#123;&#125;，异常类型&#123;&#125;&quot;</span>,e.getMessage(),e.getClass());<br>         <span class="hljs-type">BindingResult</span> <span class="hljs-variable">bindingResult</span> <span class="hljs-operator">=</span> e.getBindingResult();<br>        Map&lt;String,String&gt; errorMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        bindingResult.getFieldErrors().forEach((filedError)-&gt;&#123;<br>            errorMap.put(filedError.getField(),filedError.getDefaultMessage());<br>        &#125;);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(<span class="hljs-string">&quot;data&quot;</span>,errorMap);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = RuntimeException.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">hadleException</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> R.error(BizCodeEnum.UNKNOW_EXCEPTION.getCode(),BizCodeEnum.UNKNOW_EXCEPTION.getMsg());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON序列化</title>
    <link href="/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/09/04/Json%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h1><h2 id="Jackson序列化与反序列化"><a href="#Jackson序列化与反序列化" class="headerlink" title="Jackson序列化与反序列化"></a>Jackson序列化与反序列化</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json"><a href="#对象转json" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMapper mapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象"><a href="#json转对象" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>mapper.readValue(json字符串数据，类.Class)<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(mapper.readValue(json, Person[].class));<br></code></pre></td></tr></table></figure><h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><p><code>@JsonIgnore</code> 此注解用于属性上，作用是进行JSON操作时忽略该属性。</p></li><li><p><code>@JsonFormat</code> 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH-mm-ss”)。</p></li><li><p><code>@JsonProperty</code> 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</p></li></ul><h2 id="Gson序列化与反序列化"><a href="#Gson序列化与反序列化" class="headerlink" title="Gson序列化与反序列化"></a>Gson序列化与反序列化</h2><h3 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-1"><a href="#对象转json-1" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> gson.toJson(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> gson.toJson(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-1"><a href="#json转对象-1" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> <span class="hljs-type">Person</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> gson.fromJson(json,对象.class);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-keyword">final</span> List&lt;Person&gt; people = Arrays.asList(gson.fromJson(json, Person[].class));<span class="hljs-comment">//转为对象list</span><br></code></pre></td></tr></table></figure><p><strong>json转为List和Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Test&gt; o = gson.fromJson(json, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;转换为的对象&gt;&gt;() &#123; &#125;.getType());<br>HashMap&lt;String,Test&gt; o1 = gson.fromJson(jsonMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;HashMap&lt;String,Test&gt;&gt;()&#123;&#125;.getType());<br></code></pre></td></tr></table></figure><h3 id="常用注解：-1"><a href="#常用注解：-1" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@SerializedName(&quot;name&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称</li><li><code>@Expose(serialize = false,deserialize = false)</code>serialize:是否参与序列化，deserialize是否参与反序列化</li></ul><h2 id="FastJson序列化与反序列化"><a href="#FastJson序列化与反序列化" class="headerlink" title="FastJson序列化与反序列化"></a>FastJson序列化与反序列化</h2><h3 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.79<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对象转json-2"><a href="#对象转json-2" class="headerlink" title="对象转json"></a>对象转json</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(对象);<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(PersonList);<br></code></pre></td></tr></table></figure><h3 id="json转对象-2"><a href="#json转对象-2" class="headerlink" title="json转对象"></a>json转对象</h3><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;Object&gt; people = Arrays.asList(JSON.parse(json));<br></code></pre></td></tr></table></figure><h3 id="常用注解：-2"><a href="#常用注解：-2" class="headerlink" title="常用注解："></a>常用注解：</h3><ul><li><code>@JSONField(name = &quot;personName&quot;)</code>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称,还能够日期匹配 <code>@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</code>等，基本都在此注解基础上进行的配置。</li></ul><p><strong>经典案例</strong></p><p>将map中的某个值转为指定类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getData</span><span class="hljs-params">(TypeReference&lt;T&gt; typeReference)</span>&#123;<br>   <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> get(<span class="hljs-string">&quot;data&quot;</span>);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> JSON.parseObject(s, typeReference);<br>   <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">R</span> <span class="hljs-variable">skuHasStock</span> <span class="hljs-operator">=</span> wareFeignService.getSkuHasStock(skuIdList);<br>TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;SkuHasStockVo&gt;&gt;()&#123;&#125;;<br>stockMap = skuHasStock.getData(data).stream().collect(Collectors.toMap(SkuHasStockVo::getHasStock, SkuHasStockVo::getHasStock));<br></code></pre></td></tr></table></figure><h2 id="Kryo序列化与反序列化"><a href="#Kryo序列化与反序列化" class="headerlink" title="Kryo序列化与反序列化"></a>Kryo序列化与反序列化</h2><h3 id="导包-3"><a href="#导包-3" class="headerlink" title="导包"></a>导包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>作为一个灵活的序列化框架，Kryo 并不关心读写的数据，作为开发者，你可以随意使用 Kryo 提供的那些开箱即用的序列化器。</p></blockquote><h3 id="Kryo-的注册"><a href="#Kryo-的注册" class="headerlink" title="Kryo 的注册"></a>Kryo 的注册</h3><p>和很多其他的序列化框架一样，Kryo 为了提供性能和减小序列化结果体积，提供注册的序列化对象类的方式。在注册时，会为该序列化类生成 int ID，后续在序列化时使用 int ID 唯一标识该类型。注册的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">kryo.register(SomeClass.class, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>可以明确指定注册类的 int ID，但是该 ID 必须大于等于 0。如果不提供，内部将会使用 int++的方式维护一个有序的 int ID 生成。</p><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>Kryo 不是线程安全的。每个线程都应该有自己的 Kryo 对象、输入和输出实例。</p><p>因此在多线程环境中，可以考虑使用 ThreadLocal 或者对象池来保证线程安全性。</p><h4 id="ThreadLocal-Kryo-解决线程不安全"><a href="#ThreadLocal-Kryo-解决线程不安全" class="headerlink" title="ThreadLocal + Kryo 解决线程不安全"></a>ThreadLocal + Kryo 解决线程不安全</h4><p>ThreadLocal 是一种典型的牺牲空间来换取并发安全的方式，它会为每个线程都单独创建本线程专用的 kryo 对象。对于每条线程的每个 kryo 对象来说，都是顺序执行的，因此天然避免了并发安全问题。创建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Kryo&gt;() &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// 在此处配置kryo对象的使用示例，如循环引用等</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;;<br>&#125;;<br><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryos.get();<br></code></pre></td></tr></table></figure><p>之后，仅需要通过 <code>kryos.get()</code> 方法从线程上下文中取出对象即可使用。</p><h4 id="对象池-Kryo-解决线程不安全"><a href="#对象池-Kryo-解决线程不安全" class="headerlink" title="对象池 + Kryo 解决线程不安全"></a>对象池 + Kryo 解决线程不安全</h4><p><strong>「池」</strong>是一种非常重要的编程思想，连接池、线程池、对象池等都是<strong>「复用」</strong>思想的体现，通过将创建的“对象”保存在某一个“容器”中，以便后续反复使用，避免创建、销毁的产生的性能损耗，以此达到提升整体性能的作用。</p><p>Kryo 对象池原理也是如此。Kryo 框架自带了对象池的实现，整个使用过程不外乎<strong>创建池、从池中获取对象、归还对象</strong>三步，以下为代码实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pool constructor arguments: thread safe, soft references, maximum capacity</span><br>Pool&lt;Kryo&gt; kryoPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>&lt;Kryo&gt;(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">8</span>) &#123;<br>   <span class="hljs-keyword">protected</span> Kryo <span class="hljs-title function_">create</span> <span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>      <span class="hljs-comment">// Kryo 配置</span><br>      <span class="hljs-keyword">return</span> kryo;<br>   &#125;<br>&#125;;<br><br><span class="hljs-comment">// 获取池中的Kryo对象</span><br><span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br><span class="hljs-comment">// 将kryo对象归还到池中</span><br>kryoPool.free(kryo);<br></code></pre></td></tr></table></figure><p>创建 Kryo 池时需要传入三个参数，其中第一个参数用于指定是否在 Pool 内部使用同步，如果指定为 true，则允许被多个线程并发访问。第三个参数适用于指定对象池的大小的，这两个参数较容易理解，因此重点来说一下第二个参数。</p><p>如果将第二个参数设置为 true，Kryo 池将会使用 java.lang.ref.SoftReference 来存储对象。这允许池中的对象在 JVM 的内存压力大时被垃圾回收。Pool clean 会删除所有对象已经被垃圾回收的软引用。当没有设置最大容量时，这可以减少池的大小。当池子有最大容量时，没有必要调用 clean，因为如果达到了最大容量，Pool free 会尝试删除一个空引用。</p><p>创建玩 Kryo 池后，使用 kryo 就变得异常简单了，只需调用 <code>kryoPool.obtain()</code> 方法即可，使用完毕后再调用 <code>kryoPool.free(kryo)</code> 归还对象，就完成了一次完整的租赁使用。</p><p>理论上，只要对象池大小评估得当，就能在占用极小内存空间的情况下完美解决并发安全问题。如果想要封装一个 Kryo 的序列化方法，可以参考如下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>    <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoPool.obtain();<br>    <span class="hljs-comment">// 使用 Output 对象池会导致序列化重复的错误（getBuffer返回了Output对象的buffer引用）</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Output</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(<span class="hljs-number">1024</span>, -<span class="hljs-number">1</span>)) &#123;<br>        kryo.writeClassAndObject(opt, obj);<br>        opt.flush();<br>        <span class="hljs-keyword">return</span> opt.getBuffer();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        kryoPool.free(kryo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2022/09/04/MyBatis/"/>
    <url>/2022/09/04/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="💠MyBatis"><a href="#💠MyBatis" class="headerlink" title="💠MyBatis"></a>💠MyBatis</h1><p>一个🌰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;resultMap id=&quot;ExtListBaseResultMap&quot; type=&quot;com.xy.tms.tran.entity.vo.TranSeaPlanListVo&quot;<br>           extends=&quot;com.xy.tms.tran.dao.TranSeaPlanMapper.BaseResultMap&quot;&gt;<br>    &lt;result column=&quot;sea_plan_detail_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;seaPlanDetailId&quot;/&gt;<br>    &lt;result column=&quot;ship_company_order_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;shipCompanyOrderNo&quot;/&gt;<br>    &lt;result column=&quot;materiel_code&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;materielCode&quot;/&gt;<br>    &lt;result column=&quot;materiel_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;materielName&quot;/&gt;<br>    &lt;result column=&quot;materiel_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;materielId&quot;/&gt;<br>    &lt;result column=&quot;status&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;status&quot;/&gt;<br>    &lt;result column=&quot;create_by&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;createBy&quot; /&gt;<br>    &lt;result column=&quot;create_by_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;createByName&quot; /&gt;<br>    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;<br>    &lt;result column=&quot;update_by&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;updateBy&quot; /&gt;<br>    &lt;result column=&quot;update_by_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;updateByName&quot; /&gt;<br>    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;<br>    &lt;collection property=&quot;sysRoleIdList&quot; javaType=&quot;java.util.ArrayList&quot; ofType=&quot;java.lang.String&quot; resultMap=&quot;itemResultId&quot;/&gt;<br>&lt;/resultMap&gt;<br><br>&lt;resultMap id=&quot;itemResult&quot; type=&quot;java.lang.String&quot;&gt;<br>    &lt;id column=&quot;role_name&quot; javaType=&quot;java.lang.String&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;role_name&quot;/&gt;<br>&lt;/resultMap&gt;<br><br>&lt;sql id=&quot;Base_Column_List&quot;&gt;<br>    tran_main_plan_id, organization_id, tran_order_id, tran_main_plan_no, plan_sort,<br>    tran_type, tran_type_desc, tran_method, tran_method_desc, start_station_id, end_station_id,<br>    audit_status, audit_status_desc, audit_time, audit_user, allot_status, allot_status_desc,<br>    delivery_status, delivery_status_desc, remark, create_by, create_by_name, create_time,<br>    update_by, update_by_name, update_time, version<br> &lt;/sql&gt;<br><br>&lt;select id=&quot;querySeaPlan&quot; parameterType=&quot;com.xy.tms.tran.entity.vo.TranSeaPlanQueryVo&quot;<br>        resultMap=&quot;ExtListBaseResultMap&quot;&gt;<br>    SELECT<br>    &lt;include refid=&quot;Base_Column_List&quot; /&gt;<br>    tsp.sea_plan_id sea_plan_id,<br>    tsp.status_desc status_desc, -- 状态,<br>    tsp.sea_plan_no sea_plan_no, -- 海运计划号,<br>    tsp.ship_company_order_no ship_company_order_no, -- 船公司订舱单号<br>    tsp.book_space_success_flag_desc book_space_success_flag_desc, -- 是否订舱成功,<br>    tsp.plan_date plan_date, -- 计划日期,<br>    tspd.materiel_code materiel_code, -- 物料编码,<br>    tspd.materiel_name materiel_name, -- 物料名称,<br>    CONCAT(ifnull(mm.materiel_spec,&#x27;&#x27;)<br>    ,ifnull(mm.packing_weight_unit_desc,&#x27;&#x27;),&#x27;/&#x27;,ifnull(mm.packing_pieces_unit_desc,&#x27;&#x27;)) as packing_spec_full_desc,<br>    -- 规格,<br>    pg.product_grade_name product_grade_name, -- 等级,<br>    mm.base_unit_desc base_unit_desc, -- 单位<br>    tspd.product_grade_id<br>    FROM tran_sea_plan tsp<br>    LEFT JOIN tran_sea_plan_detail tspd ON tsp.sea_plan_id = tspd.sea_plan_id<br>    LEFT JOIN mst_warehouse start_mw ON start_ml.location_id = start_mw.location_id<br>    AND start_mw.organization_id = tsp.organization_id<br>    LEFT JOIN mst_carrier mc ON tsp.ship_company_id = mc.carrier_id<br>    &lt;where&gt;<br>        &lt;trim prefixOverrides=&quot;and&quot;&gt;<br>       &lt;!-- &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt;  与上面等价 --&gt;<br>            &lt;if test=&quot;queryVo.seaPlanNo != null and queryVo.seaPlanNo != &#x27;&#x27;&quot;&gt;<br>                AND tsp.sea_plan_no LIKE concat(&#x27;%&#x27;,#&#123;queryVo.seaPlanNo&#125;, &#x27;%&#x27;)<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.organizationId != null and queryVo.organizationId != &#x27;&#x27;&quot;&gt;<br>                AND tsp.organization_id = #&#123;queryVo.organizationId&#125;<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.status != null and queryVo.status.size() &gt;0&quot;&gt;<br>                AND tsp.status IN<br>                &lt;foreach collection=&quot;queryVo.status&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;<br>                    #&#123;item&#125;<br>                &lt;/foreach&gt;<br>            &lt;/if&gt;<br>            &lt;if test=&quot;queryVo.createTimeList != null and queryVo.createTimeList.size() == 2&quot;&gt;<br>                AND tsp.create_time<br>                BETWEEN #&#123;queryVo.createTimeList[0] &#125; AND #&#123;queryVo.createTimeList[1]  &#125;<br>            &lt;/if&gt;<br>            &lt;choose&gt;<br>                &lt;when test=&quot;isUpdate !=null &quot;&gt;<br>                    AND tsp.create_time = #&#123;isUpdate, jdbcType=INTEGER&#125;<br>                &lt;/when&gt;<br>                &lt;when test=&quot;isDelete != null&quot;&gt;<br>                    AND tsp.create_time  = #&#123;isDelete, jdbcType=INTEGER&#125;<br>                &lt;/when&gt;<br>                &lt;otherwise&gt;<br>                    AND tsp.create_time NOT NULL<br>                &lt;/otherwise&gt;<br>            &lt;/choose&gt;<br>            &lt;if test=&quot; userName != null and userName !=&quot;&quot; &quot;&gt; <br>            　　&lt;bind name= &quot; userNameLike &quot; value ＝ &quot;&#x27;%&#x27;＋ userName ＋ &#x27;%&#x27;&quot;/&gt;<br>            　　and username like #&#123;userNameLike&#125; <br>            &lt;/if&gt;　　<br>        &lt;/trim&gt;<br>    &lt;/where&gt;<br>    ORDER BY<br>    tsp.sea_plan_no DESC<br>&lt;/select&gt;<br><br>&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;<br>  update Author<br>    &lt;set&gt;<br>      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;<br>      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;<br>    &lt;/set&gt;<br>  where id=#&#123;id&#125;<br>&lt;/update&gt;<br><br>&lt;update id=&quot;updateAuthorIfNecessary2&quot;&gt;<br>  update Author<br>    &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;<br>        &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;<br>            &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;<br>    &lt;/trim&gt;<br>  where id=#&#123;id&#125;<br>&lt;/update&gt;<br></code></pre></td></tr></table></figure><h2 id="📓执行流程"><a href="#📓执行流程" class="headerlink" title="📓执行流程"></a>📓执行流程</h2><p><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisgo.png" alt="avatar"></p><ol><li>mapper.xml中的配置⽂件⾥的每条sql语句，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为带有Id信息的一个个MappedStatement对象，再通过⼀个HashMap集合保存起来。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement。</li><li>执⾏getMapper()⽅法，判断是否注册过mapper接⼝，注册了就会使⽤mapperProxyFactory去⽣成代理类MapperProxy执⾏⽬标⽅法时，会调⽤MapperProxy代理类的invoke()⽅法</li><li>此时会使用boundSql和对应的mapperStatement构造cacheKey,先进行缓存查询，命中直接返回。缓存<code>Map&lt;Method, MapperMethodInvoker&gt; methodCache =</code></li><li>缓存无命中,则创建connect连接，通过statement对象执行execute方法。</li><li>执⾏execute()⽅法返回结果使用resultSetHandler进行结果集的封装，添加到缓存中，最后返回结果。</li></ol><p><a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisProcess.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/learning/basic/mybatisProcess.jpg" alt="avatar"></a></p><ul><li>四大组件:StatementHandler、Executor、ParameterHandler、ResultSetHandler</li></ul><p>下面的执行流程简要描述，只是为了辅助理解，相关初始化方法：</p><ol><li>Configuration中保存了，解析完xml的MapperStatement的HashMap<ul><li>Mybatis将Mapper接口注册到Spring的时候，将Mapper接口生成的BeanDefinition的beanClass设置为MapperFactoryBean</li></ul></li><li>Mapper接口初始化的时候通过MapperFactoryBean，进而调用MapperProxyFactory方法初始化及调用。</li><li>MapperProxy代理调用时，通过匹配权限名+ID 获取MapperStatement对象</li><li>MapperProxy进而MapperMethod的execute方法。</li><li>SqlSession 执行的时候会获取Configuration中的四大组件进行sql执行。</li><li>Configuration返回的四大组件是经过Interceptor代理封装过返回的代理对象。</li></ol><h2 id="📓Interceptor的实现原理"><a href="#📓Interceptor的实现原理" class="headerlink" title="📓Interceptor的实现原理"></a>📓Interceptor的实现原理</h2><p>Executor、ResultSetHandler、StatementHandler、ParameterHandler，这是Mybatis中的四大对象，也是拦截器的切入点。我们可以基于这四大对象的方法进行增强。因为这四个都是接口，我们可以利用动态代理进行方法的增强。</p><p>org.apache.ibatis.session.Configuration类，在新建接口对象的时候，通过调用interceptorChain：拦截器执行链的plugin方法，返回被拦截器包装后的代理对象。 因此对象调用的时候，会判断方法是否拦截进而进入拦截器的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">wrap</span><span class="hljs-params">(Object target, Interceptor interceptor)</span> &#123;<br>        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);<br>        Class&lt;?&gt; type = target.getClass();<br>        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);<br>        <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                    type.getClassLoader(),<br>                    interfaces,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(target, interceptor, signatureMap));<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());<br>            <span class="hljs-keyword">if</span> (methods != <span class="hljs-literal">null</span> &amp;&amp; methods.contains(method)) &#123;<br>                <span class="hljs-keyword">return</span> interceptor.intercept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Invocation</span>(target, method, args));<br>            &#125;<br>            <span class="hljs-keyword">return</span> method.invoke(target, args);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul><li><code>$&#123;&#125;</code>是文件中的变量占位符，它可以用于标签属性值和内部，属于静态文本替换，比如是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如<code>$&#123;driver&#125;</code>会被静态替换为com.mysql.jdbc.Driver。</li><li>#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue).</li><li>不转义字符串，有风险，同时存在sql注入.</li></ul><h2 id="📓Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？"><a href="#📓Xml-映射文件中，除了常见的-select-insert-updae-delete-标签之外，还有哪些标签？" class="headerlink" title="📓Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？"></a>📓Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？</h2><p><code>&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为 sql 片段标签，通过标签引入 sql 片段</p><h2 id="📓通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#📓通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="📓通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>📓通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h2><ul><li>在 MyBatis 中，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为带有Id信息的一个个MappedStatement对象。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement。举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。</li><li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li><li>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。</li></ul><h2 id="📓MyBatis的分页"><a href="#📓MyBatis的分页" class="headerlink" title="📓MyBatis的分页"></a>📓MyBatis的分页</h2><p>MyBatis的分页有两种，一种是使用 RowBounds 对象进行分页，另一种是使用PageHelper进行分页</p><ul><li>使用 RowBounds 对象分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，对于数据量大的情况，使用这种分页方式会浪费内存</li><li>使用PageHelper 进行分页，它是在StatementHandler之前进行拦截，对MappedStatement进行分页sql的拼接操作，PageHelper只对紧跟着的第一个SQL语句起作用.</li><li>另外可以使用mybatis插件，声明拦截器进行sql的处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;</span><br><span class="hljs-meta">      @Signature(type = Executor.class,</span><br><span class="hljs-meta">              method = &quot;query&quot;,</span><br><span class="hljs-meta">              args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class,</span><br><span class="hljs-meta">                      CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">      @Signature(type = Executor.class,</span><br><span class="hljs-meta">              method = &quot;query&quot;,</span><br><span class="hljs-meta">              args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataPermissionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span>  &#123;&#125;  <br></code></pre></td></tr></table></figure><h2 id="📓MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#📓MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="📓MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>📓MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写</p><h2 id="📓MyBatis-的关联查询"><a href="#📓MyBatis-的关联查询" class="headerlink" title="📓MyBatis 的关联查询"></a>📓MyBatis 的关联查询</h2><p>关联对象查询，有两种实现方式：</p><ol><li>一种是使用嵌套查询，在resultMap中使用association标签关联嵌套查询的sql语句。<ul><li><code>&lt;association property=&quot;way&quot; column=&quot;wayId&quot; javaType=&quot;com.whx.bus.entity.Way&quot; select=&quot;selectWayById&quot;&gt;</code></li></ul></li><li>另一种是使用 标签指定resultMapId，将关联查询的记录映射到集合List中 - 去重复的原理是标签内的子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，可以有多个，代表了联合主键的语意。</li></ol><h2 id="📓MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#📓MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="📓MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>📓MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h2><p>不同的 Xml 映射文件，如果配置了 namespace,那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复</p><h2 id="📓MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#📓MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="📓MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>📓MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>MyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li><strong>ReuseExecutor</strong>：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li><strong>BatchExecutor</strong>：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</li><li>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</li><li>Mybatis的默认执行器是SimpleExecutor，需要配置在创建SqlSession对象的时候指定执行器的类型即可。</li></ul><h2 id="📓MyBatis-xml文件与内部数据结构之间的关系？"><a href="#📓MyBatis-xml文件与内部数据结构之间的关系？" class="headerlink" title="📓MyBatis xml文件与内部数据结构之间的关系？"></a>📓MyBatis xml文件与内部数据结构之间的关系？</h2><p><code>&lt;resultMap&gt;</code>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</p><p>每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 MappedStatement 对象。</p><p>标签内的 sql 会被解析为 BoundSql 对象。</p><h2 id="📓为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#📓为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="📓为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>📓为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h2><p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取</p><p>而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p><h2 id="📓mybatis与Hibernate区别"><a href="#📓mybatis与Hibernate区别" class="headerlink" title="📓mybatis与Hibernate区别"></a>📓mybatis与Hibernate区别</h2><ol><li>编写sql方面：hibernate不需要自己写sql语句，只需要写hql语句。而mybatis需要自己在配置文件中写sql语句，对开发人员的sql要求较高。</li><li>sql优化方面：由于hibernate自动生成sql语句，生成的语句开发人员不易优化。而mybatis的sql完全体现在配置文件中，就便于优化。</li><li>数据库迁移方面：由于hibernate的sql是自动生成的，会根据不同的数据库生成对应的语法，迁移性较高。而mybatis的因为都是写在配置文件，迁移数据库，就可能造成语法不支持的情况。</li><li>日志方面：hibernate拥有完整的日志系统，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等。而mybatis仅有基本的记录功能。</li><li>缓存方面：hibernate有更好的二级缓存机制，可以使用第三方缓存。而mybatis支持两级缓存，实际应用中应用性不高。<ul><li>mybatis一级缓存sqlSession级的缓存。二级缓存Mapper级别的缓存。</li><li>hibernate一级缓存session级别的。Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存</li></ul></li></ol><h2 id="📓mybatis的一二级缓存"><a href="#📓mybatis的一二级缓存" class="headerlink" title="📓mybatis的一二级缓存"></a>📓mybatis的一二级缓存</h2><p>一级缓存的作用域是SQlSession, Mabits默认开启一级缓存。 在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空。</p><ul><li>Mybatis的内部缓存使用一个HashMap，key为Statement Id + Offset + Limit + Sql + Params语句。Value为查询出来的结果集映射成的java对象。 SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。<ul><li>① select * from table limit 2,1; &#x2F;&#x2F;含义是跳过2条取出1条数据</li><li>② select * from table limit 2 offset 1; &#x2F;&#x2F;含义是从第1条数据开始取出2条数据,limit后面跟的是2条数据,offset后面是从第1条开始读取,即读取第2,3条。</li></ul></li><li>一级缓存脏读：对于不同的sqlsession A与B, A做update操作，只能刷新A自己的一级缓存，无法刷新B的一级缓存。所以，如果A与B操作同一条记录，就会有脏读。<ul><li>一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li></ul></li></ul><p>二级缓存作用域是Mapper级别的，默认是没有开启。MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别。</p><ul><li><p>二级缓存脏读：在两个不同的mapper中都涉及到</p><p>同一个表</p><p>的增删改查操作，当其中一个mapper对这张表进行查询操作，此时另一个mapper进行了更新操作刷新缓存，然后第一个mapper又查询了一次，那么这次查询出的数据是脏数据。</p><ul><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li></ul></li><li><p>mybatis：查询时，先进行二级缓存执行流程后，就会进入一级缓存的执行流程。（mapper级别的缓存可能是其他旧的sqlsession更新的，自己的sqlsession若存在缓存，则为较新的缓存。）</p></li></ul><p>总结：在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据</p><ul><li>美团技术团队mybatis缓存分析：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a></li></ul><h2 id="📓千万级数据查询方案—-流式查询"><a href="#📓千万级数据查询方案—-流式查询" class="headerlink" title="📓千万级数据查询方案—- 流式查询"></a>📓千万级数据查询方案—- 流式查询</h2><ul><li>流式查询指的是查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器取一条查询结果。流式查询的好处是能够降低内存使用。</li><li>流式查询的过程当中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架（mybatis）就不负责关闭数据库连接了，需要应用在取完数据后自己关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cursor 还提供了三个方法：</span><br><br><span class="hljs-comment">// 1. isOpen()：用于在取数据之前判断 Cursor 对象是否是打开状态。只有当打开时 Cursor 才能取数据；</span><br><span class="hljs-comment">// 2. isConsumed()：用于判断查询结果是否全部取完。</span><br><span class="hljs-comment">// 3. getCurrentIndex()：返回已经获取了多少条数据</span><br><br><span class="hljs-comment">// 正常使用方案1 , 使用sql session</span><br><span class="hljs-keyword">try</span> (<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();  <span class="hljs-comment">// 1</span><br>        Cursor&lt;Foo&gt; cursor = <br>              sqlSession.getMapper(FooMapper.class).scan(limit)   <span class="hljs-comment">// 2</span><br>    ) &#123;<br>        cursor.forEach(foo -&gt; &#123; &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 方案2，使用编程式事务 TransactionTemplate</span><br><span class="hljs-comment">// 方案3，使用声明式事务 @Transaction</span><br></code></pre></td></tr></table></figure><h2 id="📓MyBatis的设计模式"><a href="#📓MyBatis的设计模式" class="headerlink" title="📓MyBatis的设计模式"></a>📓MyBatis的设计模式</h2><ul><li><p>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</p><ul><li><blockquote><p>SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p></blockquote></li></ul></li><li><p>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</p></li><li><p>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</p></li><li><p>单例模式，例如ErrorContext和LogFactory；</p></li><li><p>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</p></li><li><p>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</p></li><li><p>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</p></li><li><p>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</p></li><li><p>迭代器模式，例如迭代器模式PropertyTokenizer；</p></li></ul><h2 id="📓-Param的作用"><a href="#📓-Param的作用" class="headerlink" title="📓@Param的作用"></a>📓@Param的作用</h2><p>用来指定xml中<code>#&#123;&#125;</code> 指定的参数名。</p><ul><li>对于常规的参数映射，参数解析直接按照名称解析对应的K-V对应关系。</li><li>对于对象类型传递，对于单个对象参数传递，则直接解析成class，xml文件需要直接指定class中的字段<code>demoId</code>，不能用参数前缀名<code>demo.demoId</code></li><li>对于多对象参数的传递，参数可以使用别名代替。</li><li>参数解析方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperMethod</span>&#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">convertArgsToSqlCommandParam</span><span class="hljs-params">(Object[] args)</span> &#123;<br>      <span class="hljs-keyword">return</span> paramNameResolver.getNamedParams(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数获取方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaObject</span>&#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">PropertyTokenizer</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyTokenizer</span>(name);<br>        <span class="hljs-keyword">if</span> (prop.hasNext()) &#123;<br>              <span class="hljs-type">MetaObject</span> <span class="hljs-variable">metaValue</span> <span class="hljs-operator">=</span> metaObjectForProperty(prop.getIndexedName());<br>              <span class="hljs-keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> metaValue.getValue(prop.getChildren());<br>              &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> objectWrapper.get(prop);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="💠Drools规则引擎"><a href="#💠Drools规则引擎" class="headerlink" title="💠Drools规则引擎"></a>💠Drools规则引擎</h1><h2 id="📓使用场景"><a href="#📓使用场景" class="headerlink" title="📓使用场景"></a>📓使用场景</h2><p>对于多分支的if else，可以使用策略模式进行优化。但是对于过多分支的情况，会使得策略过多，难以维护。</p><p>在该种情况下，需求点为以下四点：</p><ul><li>第一，我们要简化if else结构,让业务逻辑和数据分离！</li><li>第二，分离出的业务逻辑必须要易于编写，至少单独编写这些业务逻辑，要比写代码快！</li><li>第三，分离出的业务逻辑必须要比原来的代码更容易读懂！</li><li>第四，分离出的业务逻辑必须比原来的易于维护，至少改动这些逻辑，应用程序不用重启！</li></ul><p>规则引擎满足以上的需求点，具体体现在如下： <a href="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/other/ruleEnginExample.jpg"><img src="https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/other/ruleEnginExample.jpg" alt="image"></a></p><p>参考资料：<a href="https://www.cnblogs.com/rjzheng/p/10996186.html">规则引擎的使用场景</a></p><p>使用规则引擎可以给系统带来如下优势：</p><ul><li>高灵活性：在规则保存在知识库中，可以在规则变动轻易做出修改。</li><li>容易掌控：规则比过程代码更易于理解，因此可以有效地来弥补业务分析师和开发人员之间的沟通问题。</li><li>降低复杂度：在程序中编写大量的判断条件，很可能是会造成一场噩梦。使用规则引擎却能够通过一致的表示形式，更好的处理日益复杂的业务逻辑。</li><li>可重用性：规则集中管理，可提高业务的规则的可重用性。而且，传统的代码程序通常会添加不必要的变数，很然进行重复利用。</li></ul><blockquote><p>需要留意的是，在业务规则没有太多变动，业务规则比较简单的情况下，是没有必要使用规则引擎的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2022/09/04/Servlet/"/>
    <url>/2022/09/04/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Servlet是Server Applet的简称，称为服务器端小程序或服务连接器，主要功能在于交互式地浏览和修改数据，生成动态Web内容。</p><h2 id="Servlet架构"><a href="#Servlet架构" class="headerlink" title="Servlet架构"></a>Servlet架构</h2><p>Java Servlet是运行在Web服务器或应用服务器上的程序，作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。</p><p>使用Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205030850264.png" alt="image-20220503085026177"></p><p>Servlet主要执行以下任务：</p><ul><li>读取客户端（浏览器）发送的显式数据，包括网页上的HTML表单或自定义的HTTP客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式HTTP请求数据，包括Cookies，媒体类型和浏览器能理解的压缩格式等。</li><li>处理数据并生成结果、这个过程可能需要访问数据库、执行RMI等远程过程调用、调用Web服务或者直接计算得出对应的响应。</li><li>发送显式数据（文档）到客户端（浏览器），该文档的格式可以是多种多样的，包括文本文件（HMTL、XML或JSON文件）、二进制文件（GIF图像）、Excel等。</li><li>发送隐式HTTP响应到客户端（浏览器），包括告诉浏览器或其他客户端被返回的文档类型（例如HTML）、设置Cookies和缓存参数以及其他类似的任务。</li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet生命周期可被定义为从创建Servlet直到其销毁的整个过程。以下是Servlet遵循的过程：</p><ul><li>Servlet通过调用init方法进行初始化。</li><li>Servlet通过service方法来处理客户端的请求。</li><li>Servlet通过调用destroy方法终止。</li><li>最后，Servlet是由JVM的垃圾回收器进行垃圾回收的。</li></ul><h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>init方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时不再调用。因此，它用于一次性初始化。</p><p>Servlet创建于用户第一次调用对应Servlet的URL时，但是也可以指定Servlet在服务器第一次启动时被调用。</p><p>用户调用一个Servlet就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候交给doGet或doPost方法。init方法简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。</p><p>init方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service方法"><a href="#Service方法" class="headerlink" title="Service方法"></a>Service方法</h3><p>service方法是执行实际任务的主要方法。Servlet容器调用service方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service方法检查HTTP请求类型（GET、POST、PUT、DELETE等），并在适当的时候调用doGet、doPost、doPut、doDelete等方法。</p><p>下面是该方法的特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>   <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>service方法由容器调用，会在适当的时候调用doGet、doPost、doPut、doDelete等方法，所以不用对service方法做任何动作，只需要根据来自客户端的请求类型来重写doGet、doPost方法即可。</p><h3 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet()方法"></a>doGet()方法</h3><p>当Servlet容器接收到GET请求时，会将请求由doGet方法处理。处理逻辑写在重写的doGet方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//逻辑代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doPost方法"><a href="#doPost方法" class="headerlink" title="doPost方法"></a>doPost方法</h3><p>当Servlet容器接收到POST请求时，会将请求由doPost方法处理。处理逻辑写在重写的doPost方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="destroy方法"><a href="#destroy方法" class="headerlink" title="destroy方法"></a>destroy方法</h3><p>当Servlet容器确定Servlet应该从服务器中移除时，将调用Servlet接口的destroy方法以允许Servlet释放它使用的任何资源和保存任何持久化的状态。例如，当想要借省内存资源或它被关闭时，容器可以执行destroy方法。</p><p>Servlet容器调用destroy方法之前，它必须让当前正在执行service方法的任何线程完成执行或超过服务器定义的事件限制。</p><p>一旦调用Servlet实例的destroy方法，容器就无法再路由其他请求到该Servlet实例。如果容器需要再次使用该Servlet，就必须用该Servlet类的一个新实例。在destroy方法完成后，Servlet容器必须释放Servlet实例以便垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>doGet处理 HTTP GET 请求</li><li>doPost处理 HTTP POST请求</li><li>doPut处理 HTTP PUT 请求</li><li>doDelete 处理 HTTP DELETE请求</li><li>doHead处理 HTTP HEAD 请求</li><li>doOptions处理 HTTP OPTIONS 请求</li><li>doTrace 处理 HTTP TRACE 请求</li></ul><h2 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h2><p>通俗点说，所谓容器，就是放东西的地方，Servlet容器自然就是方Servlet的地方。在Servlet开发中，我们需要按照Servlet的规范写代码，那么这样的代码就能在Servlet容器中运行。容器会按照规则加载类，并运行它。</p><p>Servlet容器的作用是负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。</p><p>常见的Servlet容器有 Tomcat、Jetty、Oracle Application Server、Oracle Weblogic、JBoss Application Server等。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务哪些情况会失效？</title>
    <link href="/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
    <url>/2022/09/04/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring事务失效"><a href="#Spring事务失效" class="headerlink" title="Spring事务失效"></a>Spring事务失效</h1><ol><li><h4 id="访问权限问题"><a href="#访问权限问题" class="headerlink" title="访问权限问题"></a>访问权限问题</h4><p>java的访问权限主要有4种：private、default、protected、public，如果事务方法的访问权限不是定义为public，这样会导致事务失效，因为spring要求被代理方法必须是public的。翻开源码，可以看到，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则返回null，即不支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> TransactionAttribute <span class="hljs-title function_">computeTransactionAttribute</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//........</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="方法用final修饰"><a href="#方法用final修饰" class="headerlink" title="方法用final修饰"></a>方法用final修饰</h4><p>如果事务方法用final修饰，会导致事务失效，因为spring事务底层原理使用了aop也就是通过jdk动态代理或者cglib，帮助我们生成了代理类，在代理类中实现的事务功能。但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p></li><li><h4 id="对象没有被spring管理"><a href="#对象没有被spring管理" class="headerlink" title="对象没有被spring管理"></a>对象没有被spring管理</h4><p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法就不会生成事务。</p></li><li><h4 id="表不支持事务"><a href="#表不支持事务" class="headerlink" title="表不支持事务"></a>表不支持事务</h4><p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的，因为myisam存储引擎不支持事务。</p></li><li><h4 id="方法内部调用"><a href="#方法内部调用" class="headerlink" title="方法内部调用"></a>方法内部调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-built_in">this</span>.updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，update方法上没有加@Transactional注解，调用有@Transactional注解的updateOrder方法，updateOrder方法上的事务会失效。因为发生了自身调用，调用该类自己的方法，而没有经过spring的代理类，只有在外部调用事务才会生效。</p><p><strong>解决：</strong></p><ul><li><p>再加一个serviece,将内部调用改为外部调用</p></li><li><p>使用编程式事务</p></li><li><p>使用AopContexct.currentProxy()获取代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Order order)</span>&#123;<br>        ((OrderService)AopContexct.currentProxy()).updateOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>&#123;<br>        <span class="hljs-comment">//更新操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="未开启事务"><a href="#未开启事务" class="headerlink" title="未开启事务"></a>未开启事务</h4><p>如果是spring项目，则需要再配置文件中手动配置事务相关参数，如果忘记了配置，事务肯定是失效的。如果是spingboot项目，那么不需要手动配置。因为springboot已经在<code>DataSourceTransactionManagerAutoConfiguration</code>类中帮我们开启了事务。</p></li><li><h4 id="吞了异常"><a href="#吞了异常" class="headerlink" title="吞了异常"></a>吞了异常</h4><p>有时候事务不会回滚，有可能是在代码中手动catch了异常，因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况喜爱spring事务不会回滚。如果想要spring事务能够正常回滚必须抛出它能够处理的异常</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2022/09/04/Swagger/"/>
    <url>/2022/09/04/Swagger/</url>
    
    <content type="html"><![CDATA[<h1 id="SpingBoot整合swagger"><a href="#SpingBoot整合swagger" class="headerlink" title="SpingBoot整合swagger"></a>SpingBoot整合swagger</h1><h2 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-新建swagger配置类。"><a href="#2-新建swagger配置类。" class="headerlink" title="2.新建swagger配置类。"></a>2.新建swagger配置类。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/.*&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-给Controller加上注解"><a href="#3-给Controller加上注解" class="headerlink" title="3.给Controller加上注解"></a>3.给Controller加上注解</h2><p>首先要在整个类前面加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/&quot;,description = &quot;这是所有get方法&quot;)</span><br></code></pre></td></tr></table></figure><p>然后在每个接口前加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;通过这个方法可以获取到cookies&quot;,httpMethod = &quot;GET&quot;)</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;/odl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/odl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OdlController</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取交换机信息 ++++++交换机+++++++++++</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 交换机信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;获取交换机信息&quot;,httpMethod = &quot;GET&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/getOvsTable&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;HostAndOvs&gt;&gt; <span class="hljs-title function_">getOvsTable</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">final</span> com.zhang.odl_sflow.entity.odlentity.tableflow.<span class="hljs-type">JsonRootBean</span> <span class="hljs-variable">flowInfo</span> <span class="hljs-operator">=</span> odlService.getFlowInfo(<span class="hljs-string">&quot;openflow:1&quot;</span>);<br>        <span class="hljs-keyword">final</span> List&lt;HostAndOvs&gt; hostInformation = RInfo.getHostInformation(odlService.getHostInfo());<br>        <span class="hljs-keyword">return</span> ResultUtils.success(hostInformation,<span class="hljs-string">&quot;获取流表信息成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4.常用注解"></a>4.常用注解</h2><p><strong>@Api</strong> 标识⼀个java类型是⽂档类，⽤controller类的类名上<br><strong>@ApiMode</strong>l 表⽰⼀个实体类&#x2F;模型⽂档，⽤在类名上；<br><strong>@ApiModelProperty</strong> 作⽤在属性上，添加属性描述；<br><strong>@ApiOperation</strong> 作⽤在接⼝类的⽅法上，控制⽅法的相关描述；<br><strong>@ApiImplicitParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，只能作⽤在⽅法上；<br><strong>@ApiImplicitParams</strong> 作⽤在接⼝⽅法上，@ApiImplicitParam参数组；<br><strong>@ApiParam</strong> 作⽤在接⼝⽅法上，描述单个参数信息，属性基本与@ApiImplicitParam⼀样，但可以作⽤在⽅法、参数、属性上；<br>下⾯分别对每个注解的常⽤参数作讲解。<br><strong>@Api</strong>：<br>value：字符串，对controller类的作⽤描述，代替原来的description(已过时)，⼀般⽤此属性；<br>tags：字符串数组，标签组，同样可以描述controller的作⽤；<br><strong>@ApiModel</strong><br>value：字符串，模型的简短别名，使得在⽂档的导航中便于识别；<br>description：字符串，模型的附加描述；<br><strong>@ApiOperation</strong><br>value：字符串，⽅法的功能描述；<br>tags：字符串数组，标签组，同样可以描述⽅法的作⽤；<br>response：ClassType，显⽰指出返回的对象类型；在响应⽰例中会显⽰出改对象的字段以及⽰例、描述；<br>code：响应代码，默认200，⼀般不改；<br><strong>@ApiModelProperty</strong><br>value：字符串，字段描述；<br>required：boolean；指定参数是否必须，默认false；<br>example：字符串，参数值的⽰例<br><strong>@ApiImplicitParam</strong><br>name：字符串，参数名；<br>value：字符串，参数描述；<br>defaultValue：字符串，参数默认值；<br>required：boolean，标识是否必须传值，默认false；<br>dataType：字符串，参数类型，可以是某个类名，也可以是基本数据类型的引⽤类名，如Integer；<br>example：字符串，参数值⽰例；<br><strong>@ApiImplicitParams</strong></p><p>value：@ApiImplicitParam类型数组，当⽅法有多个@ApiImplicitParam参数时，需要放到@ApiImplicitParams注解中</p><h2 id="5-访问端口："><a href="#5-访问端口：" class="headerlink" title="5.访问端口："></a>5.访问端口：</h2><p><code>http://IP:SpirngBoot工程端口/swagger-ui.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914031.png" alt="image-20220703093631903"></p><p>如果有强迫症不要basic-error-cotroller的话改下配置类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:liZiYuan Date: 2022/7/3  8:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<span class="hljs-comment">// 对所有api进行监控</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.zhang.odl_sflow.controller&quot;</span>))<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;SDN流量监控与防御系统接口文档&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;李子园&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;mc1753343931@gmail.com&quot;</span>))<br>                .description(<span class="hljs-string">&quot;C4项目接口文档&quot;</span>)<br>                .build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问就没有了basic-error-cotroller了</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914990.png" alt="image-20220703093825196"></p><h2 id="高版本SpringBoot报错："><a href="#高版本SpringBoot报错：" class="headerlink" title="高版本SpringBoot报错："></a>高版本SpringBoot报错：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.context.ApplicationContextException: Failed to start bean <span class="hljs-string">&#x27;documentationPluginsBootstrapper&#x27;</span>; nested exception is java.lang.NullPointerException<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">181</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.access$<span class="hljs-number">200</span>(DefaultLifecycleProcessor.java:<span class="hljs-number">54</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:<span class="hljs-number">356</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at java.lang.Iterable.forEach(Iterable.java:<span class="hljs-number">75</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:<span class="hljs-number">155</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:<span class="hljs-number">123</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:<span class="hljs-number">935</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="hljs-number">586</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="hljs-number">147</span>) ~[spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="hljs-number">734</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="hljs-number">408</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">308</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1306</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="hljs-number">1295</span>) [spring-boot-<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>.jar:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span>]<br>at com.zhang.odl_sflow.OdlSFlowApplication.main(OdlSFlowApplication.java:<span class="hljs-number">11</span>) [classes/:na]<br>Caused by: java.lang.NullPointerException: <span class="hljs-literal">null</span><br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">112</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spi.service.contexts.Orderings$<span class="hljs-number">8.</span>compare(Orderings.java:<span class="hljs-number">109</span>) ~[springfox-spi-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.ComparatorOrdering.compare(ComparatorOrdering.java:<span class="hljs-number">37</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at java.util.TimSort.countRunAndMakeAscending(TimSort.java:<span class="hljs-number">355</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.TimSort.sort(TimSort.java:<span class="hljs-number">220</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at java.util.Arrays.sort(Arrays.java:<span class="hljs-number">1438</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_333</span>]<br>at com.google.common.collect.Ordering.sortedCopy(Ordering.java:<span class="hljs-number">855</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:<span class="hljs-number">57</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">138</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper$<span class="hljs-number">2.</span>apply(DocumentationPluginsBootstrapper.java:<span class="hljs-number">135</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at com.google.common.collect.Iterators$<span class="hljs-number">7.</span>transform(Iterators.java:<span class="hljs-number">750</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.TransformedIterator.next(TransformedIterator.java:<span class="hljs-number">47</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">52</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.MultitransformedIterator.hasNext(MultitransformedIterator.java:<span class="hljs-number">50</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">249</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.ImmutableList.copyOf(ImmutableList.java:<span class="hljs-number">209</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at com.google.common.collect.FluentIterable.toList(FluentIterable.java:<span class="hljs-number">614</span>) ~[guava-<span class="hljs-number">20.0</span>.jar:na]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.defaultContextBuilder(DocumentationPluginsBootstrapper.java:<span class="hljs-number">111</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.buildContext(DocumentationPluginsBootstrapper.java:<span class="hljs-number">96</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:<span class="hljs-number">167</span>) ~[springfox-spring-web-<span class="hljs-number">2.9</span><span class="hljs-number">.2</span>.jar:<span class="hljs-literal">null</span>]<br>at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:<span class="hljs-number">178</span>) ~[spring-context-<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>.jar:<span class="hljs-number">5.3</span><span class="hljs-number">.21</span>]<br>... <span class="hljs-number">14</span> common frames omitted<br><br></code></pre></td></tr></table></figure><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>这个问题困扰了我很久，也在网上找了好多资料，也有些人说springboot版本升级的导致的问题。<br>找到的解决办法有两种：</p><ol><li>将springboot降级到2.5.7，但这也只是暂时解决问题的办法，不是长久之计；</li><li>从SpringFox迁移到SpringDoc，这种方式虽然可以处理问题，但对于已经上线的项目来说改动量还是有点大。<br>这上面两种解决方案都不是我最想要的，最近对Spring Boot 2.6.0的文档进行研究发现，2.6.0开始使用基于PathPatternParser的路径匹配，而Springfox版本一直没有更新还是使用的AntPathMatcher导致了这个问题，要处理问题也很简单，修改yaml文件，将SpringBoot路劲匹配模式修改为AntPathMatcher就可以了，配置如下：spring.mvc.pathmatch.matching-strategy&#x3D;ANT_PATH_MATCHER</li></ol><p>修改application.yml文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><h1 id="SpringBoot整合Kenife4j"><a href="#SpringBoot整合Kenife4j" class="headerlink" title="SpringBoot整合Kenife4j"></a>SpringBoot整合Kenife4j</h1><h2 id="1-导包-1"><a href="#1-导包-1" class="headerlink" title="1.导包"></a>1.导包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml-dtd">&lt;dependency&gt;<br>   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;<br>   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;<br>   &lt;version&gt;3.0.3&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="2-新建配置类"><a href="#2-新建配置类" class="headerlink" title="2.新建配置类"></a>2.新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 必须启用swagger</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@EnableKnife4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">defaultApi2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2) <span class="hljs-comment">// 选择swagger2版本</span><br>                .useDefaultResponseMessages(<span class="hljs-literal">false</span>)<br>                <span class="hljs-comment">// 接口文档的基本信息</span><br>                .apiInfo(apiInfo())<br>                .select()<br>                <span class="hljs-comment">// 这里指定Controller扫描包路径(项目路径也行)</span><br>                <span class="hljs-comment">// 方式一：配置扫描：所有想要在swagger界面统一管理的接口，都必须在此包下</span><br>                <span class="hljs-comment">// .apis(RequestHandlerSelectors.basePackage(&quot;com.company.project.web.controller.entrance&quot;))</span><br>                <span class="hljs-comment">// 方式二：只有当方法上有@ApiOperation注解时，才能生成对应的接口文档</span><br>                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))<br>                <span class="hljs-comment">// 路径使用any风格（指定所有路径）</span><br>                .paths(PathSelectors.any())<br>                .build();<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置文档信息主页的内容说明</span><br><span class="hljs-comment">     * @param:</span><br><span class="hljs-comment">     * @return: springfox.documentation.service.ApiInfo 文档信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;接口项目 后台服务API接口文档&quot;</span>)<br>                .description(<span class="hljs-string">&quot;服务相关接口(knife4j)&quot;</span>)<br>                <span class="hljs-comment">// 服务Url（网站地址）</span><br>                .termsOfServiceUrl(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span>)<br>                .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;liziyuan&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;mc1753343931&quot;</span>))<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-添加注解"><a href="#3-添加注解" class="headerlink" title="3.添加注解"></a>3.添加注解</h2><p>同Swagger</p><h2 id="4-访问端口"><a href="#4-访问端口" class="headerlink" title="4.访问端口"></a>4.访问端口</h2><p><code>http://IP:SpirngBoot工程端口/doc.html</code></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202209040914933.png" alt="image-20220713093946919"></p><h2 id="5-报错解决方案"><a href="#5-报错解决方案" class="headerlink" title="5.报错解决方案"></a>5.报错解决方案</h2><p>同Swagger</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/"/>
    <url>/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务-Seata"><a href="#分布式事务-Seata" class="headerlink" title="分布式事务-Seata"></a>分布式事务-Seata</h1><h2 id="一、本地事务"><a href="#一、本地事务" class="headerlink" title="一、本地事务"></a>一、本地事务</h2><blockquote><p>在<code>JavaEE</code>企业级开发的应用领域，为了<strong>保证数据</strong>的<strong>完整性</strong>和<strong>一致性</strong>，必须引入数据库事务的概念，所以事务管理是企业级应用程序开发中必不可少的技术。</p><p>所谓<strong>本地事务</strong>，是指在单个数据源上进行数据的访问和更新，它<strong>仅在当前工程内有效</strong>。</p></blockquote><h3 id="1-1-ACID特性"><a href="#1-1-ACID特性" class="headerlink" title="1.1 ACID特性"></a>1.1 ACID特性</h3><ul><li>数据库事务的四大<strong>特性</strong>：原子性(<code>Atomicity</code> )、一致性( <code>Consistency</code> )、隔离性或独立性( <code>Isolation</code>) 和持久性(<code>Durabilily</code>)，简称就是 <code>ACID</code>。<ul><li><strong>原子性</strong>：一系列的操作整体不可拆分，要么同时成功，要么同时失败。</li><li><strong>一致性</strong>：数据在事务的前后，业务整体一致。</li><li><strong>隔离性</strong>：事务之间互相隔离。</li><li><strong>持久性</strong>：一旦事务成功，数据一定会落盘在数据库。</li></ul></li><li>在以往的单体应用中，我们多个业务操作使用同一条连接操作不同的数据表，一旦有异常，我们可以很容易地整体回滚。就比如买东西业务，扣库存，下订单，账户扣款，是一个整体，<strong>必须同时成功或者失败</strong>。一个事务开始，代表以下的<strong>所有操作</strong>都在<strong>同一个连接</strong>里面。</li></ul><h3 id="1-2-隔离级别"><a href="#1-2-隔离级别" class="headerlink" title="1.2 隔离级别"></a>1.2 隔离级别</h3><ul><li><code>READ UNCOMMITTED</code>（<strong>脏读</strong>）：该隔离级别的事务会<strong>读到其它未提交事</strong>务的数据。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203395.webp" alt="image-20220709182208960"></p><ul><li><code>READ COMMITTED</code>（<strong>不可重复读</strong>）：一个事务可以读取另一个已提交的事务，<strong>多次读取会造成不一样的结果</strong>。<code>Oracle</code> 和 <code>SQL Server</code> 的默认隔离级别。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203393.webp" alt="image-20220709183324143"></p><ul><li><code>REPEATABLE READ</code>（<strong>虚读&#x2F;幻读</strong>）：该隔离级别是 <code>MySQL</code> 默认的隔离级别，一个事务可以<strong>读取另一个事务已提交的数据</strong>，<strong>读取的数据前后相比多了点或者少了点</strong>。<code>MySQL</code> 的 <code>InnoDB</code> 引擎可以通过<code>next-key locks</code> 机制来避免<strong>幻读</strong>。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709185135362"></p><ul><li><code>SERIALIZABLE</code>（<strong>序列化</strong>）：这是数据库<strong>最高的隔离级别</strong>，在该隔离级别下事务都是<strong>串行顺序执行</strong>的，<code>MySQL</code> 数据库的 <code>InnoDB</code> 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题，但是<strong>执行效率差</strong>，性能开销也最大，所以基本没人会用。</li></ul><h3 id="1-3-事务的传播行为"><a href="#1-3-事务的传播行为" class="headerlink" title="1.3 事务的传播行为"></a>1.3 事务的传播行为</h3><ul><li><strong>PROPAGATION_REQUIRED</strong>： ：如果当前<strong>没有</strong>事务，就<strong>创建</strong>一个新事务，如果当前<strong>存在</strong>事务，就<strong>加入</strong>该事务，该设置是<strong>最常用的设置</strong>。</li><li>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：：创建新事务，<strong>无论当前存不存在事务，都创建新事务</strong>。</li><li>PROPAGATION_NOT_SUPPORTED：：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： ：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED： ：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li><li>七种事务传播机制<strong>最常用</strong>的就<strong>两种</strong>：<ul><li>REQUIRED：一个事务，要么成功，要么失败。</li><li>REQUIRES_NEW：两个不同事务，彼此之间没有关系。一个事务失败了不影响另一个事务。</li></ul></li></ul><h3 id="1-4-本地事务在分布式下的问题"><a href="#1-4-本地事务在分布式下的问题" class="headerlink" title="1.4 本地事务在分布式下的问题"></a>1.4 本地事务在分布式下的问题</h3><p><strong>1.4.1 问题一：远程服务假失败</strong></p><ul><li>远程服务其实成功了，由于网络故障没有返回，导致订单回滚，库存却扣减。</li><li>假失败就是我们在订单服务调库存服务时， <strong>库存锁定成功</strong>，然后由于<strong>服务器</strong>慢、卡顿、等<strong>故障</strong>原因，本地事务提交了之后，<strong>一直没返回</strong>到订单服务。此时再看订单服务，因为调用库存服务时间太长了，库存服务迟迟没有返回结果，可能就会<strong>触发</strong> <code>feign</code> 的<strong>超时机制</strong>，在调用远程服务这里<strong>抛异常</strong>：<code>read time out</code> 读取超时，但是这个异常并不是我们手动抛的锁库存异常，而是 <code>feign</code> 的异常并且订单服务，设计的回滚机制，是只要<strong>一出现异常就会全部回滚</strong>，导致最终<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203380.webp" alt="image-20220709064805120"></p><p><strong>1.4.2 问题二：调用新服务出现异常之后，已经执行的服务不会回滚</strong></p><ul><li>假设库存锁定成功，将结果返回到了订单服务，我们根据结果又调用了积分服务，让它扣减积分，结果<strong>积分服务</strong>内部出现<strong>异常</strong>，积分数据回滚此时再看订单服务，<strong>订单服务感知到</strong>我们手动抛的<strong>积分异常</strong>，订单数据回滚，但是<strong>库存服务</strong>，却<strong>不会有任何感知</strong>。其结果就是<strong>积分、订单数据全部回滚，库存给锁定了</strong>，也是<strong>数据不一致</strong>。</li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203387.webp" alt="image-20220709064934354"></p><p><strong>1.4.3 总结</strong>：</p><ul><li><strong>本地事务</strong>，在分布式系统，<strong>只能控制住自己的回滚</strong>，控制不了其它服务的回滚。</li><li>产生<strong>分布式事务问题</strong>的最大原因，就是<strong>网络问题</strong> + <strong>分布式机器</strong>。</li></ul><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">假设我们有一个下单的事务场景，它会涉及调用库存、订单、会员功能。<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>在<strong>单体应用</strong>下，我们将三个功能的代码写到一个系统，而且都是连接同一数据库，这样的话很容易就能控制事务，若其中一个失败，则整个事务都会回滚。</li><li>而在<strong>分布式系统</strong>下，我们拆分了很多的微服务，它们都是独立部署且每个服务都有自己操作的数据库，那这样我们想要完成整个下单逻辑，我们就要远程调用这三个机器的各个方法。</li><li>但是，由于分布式系统会<strong>经常出现</strong>机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…等<strong>异常情况</strong>。所以，<strong>分布式事务</strong>是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是<strong>无法避免</strong>。</li></ul><h2 id="三、相关概述及理论"><a href="#三、相关概述及理论" class="headerlink" title="三、相关概述及理论"></a>三、相关概述及理论</h2><h3 id="3-1-CAP理论"><a href="#3-1-CAP理论" class="headerlink" title="3.1 CAP理论"></a>3.1 CAP理论</h3><blockquote><p><code>CAP</code> 指的是一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。</p><p><code>CAP</code> 原则指的是，这三个要素<strong>最多</strong>只能<strong>同时实现两点</strong>，<strong>不可能三者兼顾</strong>。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203402.webp" alt="image-20220709071207113"></p><ul><li><p>一致性</p><p>（Consistency）：</p><ul><li>在分布式系统中的<strong>所有数据备份</strong>，在<strong>同一时刻</strong>是否<strong>同样的值</strong>。（等同于所有节点访问同一份最新的数据副本）。</li><li>比如我们有三个节点，当我给节点1保存了值，那么我再请求节点2、3的数据时，响应的数据也应该是这个最新的值。</li></ul></li><li><p>可用性</p><p>（Availability） ：</p><ul><li>在集群中一<strong>部分节点故障</strong>后，集群<strong>整体是否还能响应</strong>客户端的读写请求。（对数据更新具备高可用性）。</li></ul></li><li><p>分区容错性</p><p>（Partition Tolerance） ：</p><ul><li>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是<strong>区间通信可能失败</strong>。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</li></ul></li></ul><h3 id="3-2-CAP为什么不能三者兼顾？"><a href="#3-2-CAP为什么不能三者兼顾？" class="headerlink" title="3.2 CAP为什么不能三者兼顾？"></a>3.2 CAP为什么不能三者兼顾？</h3><ul><li><strong>满足一致性</strong>：假设我们有三个节点，当客户端有一个请求进来，我们所有的节点完成数据备份，此时满足了我们的一致性<code>C</code>的需求。</li><li><strong>可用性与一致性冲突</strong>：再次假设，当节点1向节点2、3要求同步备份数据时，此时节点3发生了网络故障，也就是分区容错性。接下来我们就会考虑，能否<strong>满足可用性</strong>？若让其满足的话（允许客户端请求负载到节点3读取数据），但是由于上次发生故障导致节点3的数据没有更新，则此时<strong>读到的数据</strong>就出现了<strong>不一致</strong>。所以当你想要满足一致性，就必须让节点3不能被访问，既然不能被访问相当于又不可用。**<code>C</code>和<code>A</code>无法同时做到**。</li><li>在<strong>分布式系统</strong>里，因为我们这个<strong>网络肯定会出现问题</strong>，所以我们<strong>永远都要满足分区容错</strong>。则就需要在一致性与可用性做出选择。</li><li>选择可用性+分区容错性（<code>AP</code>）的情况下，我们不去在意读到的数据是否一致，这种场景实现相对简单。</li><li>若选择一致性+分区容错性（<code>CP</code>）的情况下，是如何保证它们之间一致的？我们在分布式系统里边一般会有一些<strong>一致性算法</strong>，典型的代表，比如说Google的Chubby分布式锁服务，采用了<code>Paxos</code>算法；etcd分布式键值数据库，采用了<code>Raft</code>算法；ZooKeeper分布式应用协调服务，Chubby的开源实现，采用<code>ZAB</code>算法。</li></ul><h3 id="3-3-Raft算法实现分布式系统一致性"><a href="#3-3-Raft算法实现分布式系统一致性" class="headerlink" title="3.3 Raft算法实现分布式系统一致性"></a>3.3 Raft算法实现分布式系统一致性</h3><ul><li>由于 <code>Paxos</code> 算法过于晦涩难懂且难以实现，后提出了一种更<strong>易于理解</strong>和实现并能等价于 <code>Paxos</code> 算法<strong>的共识算法</strong> - <code>Raft </code>算法。</li><li><code>Raft</code> 算法有<strong>两个核心概念</strong>：<ul><li><strong>领导选举</strong>（关注角色、心跳时间、自旋时间）-&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">Leader的选举过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23election">acehi.github.io&#x2F;thesecretli…</a></li><li><strong>日志复制</strong> -&gt; <a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">日志复制过程-演示动画</a>：<a href="https://link.juejin.cn/?target=https://acehi.github.io/thesecretlivesofdata-cn/raft/%23replication">acehi.github.io&#x2F;thesecretli…</a></li></ul></li><li>通过它们来保证我们整个集群的一致性，即使有分区错误，我们也能保持一致性。</li></ul><h3 id="3-4-Base理论"><a href="#3-4-Base理论" class="headerlink" title="3.4 Base理论"></a>3.4 Base理论</h3><blockquote><p>是对 <code>CAP</code> 理论的延伸，思想是即使无法做到强一致性（<code>CAP</code> 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。</p></blockquote><ul><li>强一致与弱一致是<strong>对立</strong>概念。<strong>强一致性</strong>也叫做<strong>线性一致性</strong>，除此以外，所有其它的一致性都是弱一致性的特殊情况。所谓强一致性，即数据备份是<strong>同步</strong>的，<strong>弱一致性</strong>，即数据备份是<strong>异步</strong>的。</li><li><strong>基本可用</strong>（Basically Available）：指分布式系统在出现故障的时候，<strong>允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，基本可用绝<strong>不等价于系统不可用</strong>。就比如：<ul><li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒（查询故障节点不行，就换其它机器进行查询，允许查询速度慢一点）。</li><li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><strong>软状态</strong>（ Soft State） ：指允许系统存在<strong>中间状态</strong>，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的<strong>延时</strong>就是软状态的体现。<code>MySQL Replication</code> 的异步复制也是一种体现。</li><li><strong>最终一致性</strong>（ Eventual Consistency）：指系统中的所有数据副本<strong>经过一定时间</strong>后，最终能够<strong>达到一致</strong>的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h2 id="四、常见解决方案"><a href="#四、常见解决方案" class="headerlink" title="四、常见解决方案"></a>四、常见解决方案</h2><h3 id="4-1-2PC-模式"><a href="#4-1-2PC-模式" class="headerlink" title="4.1 2PC 模式"></a>4.1 2PC 模式</h3><blockquote><p><code>2PC</code> 就是我们说的<strong>二阶段提交</strong>，又叫做 <code>XA Transactions</code>。<code>MySQL</code> 从 5.5 版本开始支持，<code>SQL Server</code> 2005 开始支持，<code>Oracle</code> 7 开始支持。</p></blockquote><ul><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203435.webp" alt="image-20220709074848470"></p><ul><li>假设我们这有一个本地资源管理器（相当于每个服务的事务管理器），一个事务管理器（相当于总的事务管理器）。</li><li>协调事务处理共为<strong>两个阶段</strong>：<ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交</strong>（<code>PreCommit</code>）此操作，并<strong>反映是否可以提交</strong>。</li><li>第二阶段：事务协调器<strong>要求</strong>每个数据库<strong>提交数据</strong>。</li><li>其中，如果有<strong>任何一个</strong>数据库<strong>否决</strong>此次提交，那么所有数据库都会被要求<strong>回滚</strong>它们在此事务中的那部分信息。</li></ul></li><li><strong>优点</strong>：<ul><li><code>XA 协议</code>比较<strong>简单</strong>，而且一旦商业数据库实现了 <code>XA 协议</code>，使用分布式事务的成本也比较低。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>性能不理想</strong>，特别是在交易下单链路，往往并发量很高，无法满足高并发场景。</li><li>目前在商业数据库支持的比较理想，在 <strong>mysql 数据库中支持的不太理想</strong>，<code>mysql</code> 的 <code>XA</code> 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</li><li>许多 <code>nosql</code> 也没有支持 <code>XA</code>，这让 <code>XA</code> 的<strong>应用场景</strong>变得<strong>非常狭隘</strong>。</li></ul></li><li><strong>总结</strong>：了解即可，使用场景非常少。</li></ul><h3 id="4-2-3PC-模式"><a href="#4-2-3PC-模式" class="headerlink" title="4.2 3PC 模式"></a>4.2 3PC 模式</h3><blockquote><p>三阶段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一个<strong>改良版本</strong>，引入了两个新的特性。</p></blockquote><ul><li>协调者和参与者均<strong>引入超时机制</strong>，通过超时机制来解决 <code>2PC</code> 的同步阻塞问题，<strong>避免事务</strong>资源<strong>被永久锁定</strong>。</li><li>把二阶段演变为三阶段，二阶段提交协议中的第一阶段”准备阶段”一分为二，形成了新的 <code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code> 三个阶段组成事务处理协议。</li><li><strong>优点</strong>：<code>3PC</code> 相比较于 <code>2PC</code> 最大的优点就是<strong>降低了参与者的阻塞范围</strong>，并且能够在协调者出现<strong>单点故障后继续达成一致</strong>。</li><li><strong>缺点</strong>：虽然通过超时机制解决了资源永久阻塞的问题，但是 <code>3PC</code> <strong>依然存在数据不一致的问题</strong>。当参与者接收到 <code>PreCommit</code> 消息后，如果网络出现分区，此时协调者与参与者无法进行正常通信，这种情况下，参与者依然会进行事务的提交。</li><li><strong>总结</strong>：通过了解 <code>2PC</code> 和 <code>3PC</code> 之后，我们可以知道这<strong>两种方案都无法彻底解决分布式下的数据一致性</strong>。</li></ul><h3 id="4-3-柔性事务-TCC-事务补偿方案"><a href="#4-3-柔性事务-TCC-事务补偿方案" class="headerlink" title="4.3 柔性事务-TCC 事务补偿方案"></a>4.3 柔性事务-TCC 事务补偿方案</h3><blockquote><p>补偿事务<code>TCC</code>，全称<code>Try-Confirm-Cancel</code>。</p></blockquote><ul><li><strong>什么是柔性事务</strong>？<ul><li>刚性事务：遵循 <code>ACID</code> 原则，强一致性。</li><li>柔性事务：遵循 <code>BASE</code> 理论，最终一致性。与刚性事务不同，柔性事务<strong>允许一定时间</strong>内，不同节点的数据<strong>不一致</strong>，<strong>但要求最终一致</strong>。</li></ul></li><li><strong>TCC核心思想</strong>：针对每个操作都要注册一个与其对应的确认（<code>Try</code>）和补偿（<code>Cancel</code>）。<ul><li><strong>Try阶段</strong>：做一些<strong>业务检查</strong>以及一些资源预留，它需要后续的<code>Confirm</code>一起才能构成一个完成的业务逻辑。</li><li><strong>Comfirm阶段</strong>：<strong>确认提交</strong>，<code>Try</code> 阶段所有分支事务执行成功后开始执行 <code>Confirm</code> 。</li><li><strong>Cancel阶段</strong>：业务执行出错需要<strong>回滚</strong>。</li></ul></li><li><strong>示意图</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203449.webp" alt="image-20220709082734127"></p><ul><li><p>总结</p><p>：</p><ul><li><code>2PC</code> 通常是在跨库<code>DB</code>里，而 <code>TCC</code> 是在<strong>应用层</strong>面。</li><li><code>TCC</code> 每个业务逻辑代码都要实现<code>Try</code>、<code>Confirm</code>、<code>Cacnel</code>接口，<strong>开发难度大</strong>，所以所对<strong>应用的倾入性非常强</strong>。</li></ul></li></ul><h3 id="4-4-柔性事务-最大努力通知方案"><a href="#4-4-柔性事务-最大努力通知方案" class="headerlink" title="4.4 柔性事务-最大努力通知方案"></a>4.4 柔性事务-最大努力通知方案</h3><blockquote><p>方案主要用在<strong>与第三方系统通讯</strong>时，比如：调用微信或支付宝支付后的支付结果通知。这种 方案也是结合 <code>MQ</code> 进行实现，例如：通过 <code>MQ</code> 发送 <code>http</code> 请求，<strong>设置最大通知次数</strong>，<strong>达到通知次数后即不再通知</strong>。</p></blockquote><ul><li><strong>应用场景</strong>：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对 账文件），支付宝的支付成功异步回调。</li><li><strong>案例说明</strong>：我们现在有一个大业务，调用了积分、库存和订单业务。当订单和库存都执行结束，但是在做用户积分扣减时<strong>失败</strong>了，然后订单模块就会<strong>发送一条消息</strong>给 <code>MQ</code>。接下来由订阅了消息队列的订单及库存服务接收消息，当它们都<strong>收到消息后</strong>，库存服务就会解锁库存，订单服务就会解锁订单，<strong>完成事务的回滚</strong>。既然是最大努力通知，期间就会<strong>不断发送</strong>业务处理失败的消息，<strong>直至</strong>对应业务<strong>返回处理成功</strong>的消息，<strong>就不再进行通知</strong>了。</li></ul><h3 id="4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#4-5-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>4.5 柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul><li><strong>实现</strong>：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，<strong>实时消息服务只记录消息数据</strong>，而不是真正的发送。业务处理服务在<strong>业务事务提交之后</strong>，向实时消息服务<strong>确认发送</strong>。只有在得到确认发送指令后，实时消息服务<strong>才会真正发送</strong>。</li><li><strong>关键点</strong>（防止消息丢失）：<ul><li>做好消息确认机制 <code>Publisher</code>，<code>Consumer</code> 手动 <code>ack</code>。</li><li>每一个发送的消息都在数据库做好记录，定期将失败的消息再次发送一遍。</li></ul></li><li><strong>消息记录表</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mq_message` (<br>`message_id` <span class="hljs-type">CHAR</span> ( <span class="hljs-number">32</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`content` text,<br>`to_exchane` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`routing_key` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`class_type` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`message_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">1</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,<br>`create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `message_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="五、分布式事务框架-Seata"><a href="#五、分布式事务框架-Seata" class="headerlink" title="五、分布式事务框架-Seata"></a>五、分布式事务框架-Seata</h2><blockquote><p><code>Seata</code> 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。<code>Seata</code> 将为用户提供了 <code>AT</code>、<code>TCC</code>、<code>SAGA</code> 和 <code>XA</code> 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h3 id="5-1-核心概念及原理"><a href="#5-1-核心概念及原理" class="headerlink" title="5.1 核心概念及原理"></a>5.1 核心概念及原理</h3><ul><li>TC - 事务协调者：维护全局和分支事务的状态，<strong>驱动</strong>全局事务<strong>提交或回滚</strong>。</li><li>TM - 事务管理器：<strong>定义全局</strong>事务的<strong>范围</strong>（开始全局事务、提交或回滚全局事务）。</li><li>RM - 资源管理器：<strong>管理分支</strong>事务处理的<strong>资源</strong>，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li><li><strong>工作原理</strong>：</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203454.webp" alt="image-20220709125044911"></p><ul><li><p>流程描述</p><p>：</p><ul><li>假设我们现在要执行一个大的下单业务 Business，<strong>大业务</strong>的 <code>TM</code>（事务管理器）先会告诉 <code>TC</code>（事务协调者）它要准备跨服<strong>开启</strong>一个<strong>全局事务</strong>。</li><li>开始全局事务后，接下来它调用第一个微服务的事务方法的时候，Storage 服务就会在 <code>TC</code>（事务协调者）<strong>注册</strong>一下，我们称为<strong>分支事务</strong>。相当于它的 <code>RM</code>（资源管理器）会告诉 <code>TC</code>（事务协调者），它有一个分支事务，并且它要实时<strong>汇报</strong>它的<strong>事务状态</strong>，它这个分支是提交成功还是失败回滚， <code>TC</code>（事务协调者）都能实时的知道。</li><li>接下来调我们第二个远程服务 Order，及第三个远程服务 Account也是同理注册分支事务，并且实时汇报状态。</li><li><strong>大事务只要一开启</strong>，每调一个小事务，<code>TC</code>（事务协调者）<strong>都知道</strong>这个<strong>小事务成了还是败了</strong>。</li><li>假设其中最后一个分支事务失败了，需要进行回滚。这个时候，<code>TC</code>（事务协调者）知道我们的大事务，已经调成功两个了，并且前两个事务都已经提交了，但是第三个事务给回滚了，<code>TC</code>（事务协调者）就会<strong>命令前两个事务也回滚</strong>。</li></ul></li></ul><h3 id="5-2-AT模式"><a href="#5-2-AT模式" class="headerlink" title="5.2 AT模式"></a>5.2 AT模式</h3><p><strong>5.2.1 相关概念</strong>：</p><ul><li><code>AT</code>模式（自动事务Auto Transaction）是<code>Seata</code>最<strong>主推的</strong>分布式事务解决方案，它是基于<code>XA</code>演进而来。</li><li><code>AT</code> 模式是一种<strong>无侵入</strong>的分布式事务解决方案，也就是说我们<strong>不需要再编写多余的代码来实现</strong>这个模式，<strong>只需要</strong>在方法中<strong>添加上指定的注解</strong>即可。</li><li>在 AT 模式下，用户只需关注自己的“业务 <code>SQL</code>”，用户的 “业务 <code>SQL</code>” 作为一阶段，<code>Seata</code> 框架会<strong>自动生成</strong>事务的<strong>二阶段提交和回滚</strong>操作。</li><li>AT模式支持的数据库有：<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>和 <code>TiDB</code>。</li></ul><p><strong>5.2.2 模式概述</strong>：</p><ul><li><p><strong>前提</strong>：我们如果要使用该模式，那么<strong>每一个</strong>要使用分布式事务的<strong>数据库</strong>都需要一个 <code>UNDO_LOG</code> 表（即回滚日志表）。</p></li><li><p><strong>效果</strong>：该模式下 <code>TC</code>（事务协调者） 只要调分支事务，<strong>成功</strong>之后就会<strong>提交事务</strong>，但是如果有一个分支事务<strong>失败</strong>了，失败的这个可以<strong>自己进行回滚</strong>。</p></li><li><p>处理逻辑</p><p>：</p><ul><li>某个服务除了它常规的业务表以外，我们会额外去创建一个回滚日志表。它是在<code>RM</code>（资源管理器）部分完成的，会在<strong>每一个数据库单元处理时</strong>均会生成一条<code>log</code>数据。</li><li>对于已提交的事务要进行回滚，它会利用<strong>魔改数据库进行反向补偿</strong>。比如：我们这有条加二的记录，原来它的值是八，加二以后变成十，结果被人给回滚了。</li><li>它先在 <code>UNDO_LOG</code> 里面记录了一下这条<strong>记录没改变之前的值</strong>。如果它失败回滚了，那它就回过头把我们数据库里边的这个十再改回去，改成八。所以，它相当于在我们事务执行之前，它先读取一下这个状态是几，最后再改回来。</li></ul></li></ul><h3 id="5-3-Seata-服务搭建"><a href="#5-3-Seata-服务搭建" class="headerlink" title="5.3 Seata 服务搭建"></a>5.3 Seata 服务搭建</h3><p><strong>5.3.1 组件版本关系</strong>：</p><blockquote><p>每个 <code>Spring Cloud Alibaba</code> 版本及其自身所适配的各组件对应版本如下表所示（<strong>避免版本不兼容</strong>带来未知问题）。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203640.webp" alt="image-20220708081609199"></p><p><strong>5.3.2 Docker下安装 Seata</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.下载镜像（注意：此处版本号请参考组件版本关系图！）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.启动容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name seata-server -p 8091:8091 seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.创建存放配置的文件夹。</span><br>mkdir -p /home/seata/config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.拷贝配置文件。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> seata-server:/seata-server/resources /home/seata/config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.编辑配置文件（参考下面截图）。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home/seata/config/resources</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim registry.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在registry.conf指定seata配置的位置（config &#123;<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;nacos&quot;</span>&#125;）。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以在file.conf中指定事务日志存储类型（store &#123;mode = <span class="hljs-string">&quot;db&quot;</span>&#125;），若使用mysql-8版本则需要额外修改以下两项配置，否则报错。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">driverClassName = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata?serverTimezone=UTC&quot;</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203629.webp" alt="image-20220708100915057"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">6.停止容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.移除旧容器。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> seata-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">8.启动新容器并挂载配置。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d \</span><br><span class="language-bash">--name seata-server \</span><br><span class="language-bash">-p 8091:8091 \</span><br><span class="language-bash">-e SEATA_IP=yourIp（公网IP） \</span><br><span class="language-bash">-v /home/seata/config/resources:/seata-server/resources \</span><br><span class="language-bash">seataio/seata-server:1.2.0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker update seata-server --restart=always</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.3.3 验证Seata服务启动成功</strong>：</p><ul><li>查看容器日志（Server started …）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs seata-server</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>访问注册中心后台（成功注册）：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">http://yourIp:8848/nacos<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208082203674.webp" alt="image-20220708101405016"></p><h3 id="5-4-项目整合"><a href="#5-4-项目整合" class="headerlink" title="5.4 项目整合"></a>5.4 项目整合</h3><p><strong>5.4.1 数据库添加 UNDO_LOG 表</strong>：</p><blockquote><p>每一个要使用分布式事务的数据库都需要一个 <code>UNDO_LOG</code> 表。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log` (<br>`id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`branch_id` <span class="hljs-type">BIGINT</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`xid` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`context` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`rollback_info` LONGBLOB <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_status` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_created` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`log_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`ext` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">100</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br><span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` ( `xid`, `branch_id` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li><code>branch_id</code>：分支事务ID。</li><li><code>xid</code>：全局事务ID（<code>Seata</code> 服务端地址+ ID）。</li><li><code>context</code>：回滚信息序列化和压缩格式。</li><li><code>rollback_info</code>：回滚信息。</li><li><code>log_status</code>：日志状态（<code>0</code>表示正常，<code>1</code>表示全局已完成）。</li><li><code>log_created</code>：创建时间。</li><li><code>log_modified</code>：修改时间。</li></ul><p><strong>5.4.2 依赖引入</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">        <span class="hljs-comment">&lt;!--需要分布式事务的服务引入 seata-starter--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.3 配置代理数据源</strong>：</p><blockquote><p>配置代理数据源实现分支事务，如果没有注入，事务无法成功回滚。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySeataConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    DataSourceProperties dataSourceProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要将 DataSourceProxy 设置为主数据源，否则事务无法回滚。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSourceProperties 数据源属性配置。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> DataSource&#125;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(DataSourceProperties dataSourceProperties)</span> &#123;<br><br>        <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> dataSourceProperties.initializeDataSourceBuilder()<br>                .type(HikariDataSource.class).build();<br><br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(dataSourceProperties.getName())) &#123;<br>            dataSource.setPoolName(dataSourceProperties.getName());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceProxy</span>(dataSource);<br>    &#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5.4.4 微服务中添加配置文件</strong>：</p><blockquote><p><strong>方式一</strong>（此处使用）：<strong>每个</strong>要使用分布式事务的<strong>微服务</strong>服务中（<code>src/main/resources/</code>），都要添加这两个文件（<code>registry.conf</code>、<code>file.conf</code>）。</p><p><strong>方式二</strong>：也可以将 <code>Nacos</code> 作为统一配置中心，去配置 <code>Seata</code> 的 <code>file.conf</code> 各项参数，实现集群的配置共享，并结合 <code>application.properties/yml</code> + <code>registry.conf</code> 完成微服务整合。</p></blockquote><ul><li><code>registry.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---注册中心配置---</span><br><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="hljs-comment">  # 指定类型为nacos注册中心（根据项目所使用的注册中心进行选择），默认是&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">eureka</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serviceUrl</span> = <span class="hljs-string">&quot;http://localhost:1001/eureka&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">weight</span> = <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">redis</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:6379&quot;</span><br>    <span class="hljs-attr">db</span> = <span class="hljs-string">&quot;0&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">sofa</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:9603&quot;</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">region</span> = <span class="hljs-string">&quot;DEFAULT_ZONE&quot;</span><br>    <span class="hljs-attr">datacenter</span> = <span class="hljs-string">&quot;DefaultDataCenter&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">addressWaitTime</span> = <span class="hljs-string">&quot;3000&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---配置中心---</span><br><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="hljs-comment">  # 指定seata配置的位置，默认&quot;file&quot;。</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;file&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;public&quot;</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">consul</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">apollo</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">app.id</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br>    <span class="hljs-attr">apollo.meta</span> = <span class="hljs-string">&quot;http://192.168.1.204:8801&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">zk</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span><br>    <span class="hljs-attr">session.timeout</span> = <span class="hljs-string">6000</span><br>    <span class="hljs-attr">connect.timeout</span> = <span class="hljs-string">2000</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">etcd3</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # 关联 `file.conf` 文件中配置的seata参数。</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><ul><li><code>file.conf</code></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># ---网络传输配置---</span><br><span class="hljs-attr">transport</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # tcp udt unix-domain-socket</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;TCP&quot;</span><br><span class="hljs-comment">  #NIO NATIVE</span><br>  <span class="hljs-attr">server</span> = <span class="hljs-string">&quot;NIO&quot;</span><br><span class="hljs-comment">  #enable heartbeat</span><br>  <span class="hljs-attr">heartbeat</span> = <span class="hljs-string">true</span><br><span class="hljs-comment">  #thread factory for netty</span><br>  <span class="hljs-attr">thread-factory</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">boss-thread-prefix</span> = <span class="hljs-string">&quot;NettyBoss&quot;</span><br>    <span class="hljs-attr">worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerNIOWorker&quot;</span><br>    <span class="hljs-attr">server-executor-thread-prefix</span> = <span class="hljs-string">&quot;NettyServerBizHandler&quot;</span><br>    <span class="hljs-attr">share-boss-worker</span> = <span class="hljs-string">false</span><br>    <span class="hljs-attr">client-selector-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientSelector&quot;</span><br>    <span class="hljs-attr">client-selector-thread-size</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">client-worker-thread-prefix</span> = <span class="hljs-string">&quot;NettyClientWorkerThread&quot;</span><br><span class="hljs-comment">    # netty boss thread size,will not be used for UDT</span><br>    <span class="hljs-attr">boss-thread-size</span> = <span class="hljs-string">1</span><br><span class="hljs-comment">    #auto default pin or 8</span><br>    <span class="hljs-attr">worker-thread-size</span> = <span class="hljs-string">8</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">shutdown</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # when destroy server, wait seconds</span><br>    <span class="hljs-attr">wait</span> = <span class="hljs-string">3</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">serialization</span> = <span class="hljs-string">&quot;seata&quot;</span><br>  <span class="hljs-attr">compressor</span> = <span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---当前微服务在seata服务器中注册的信息配置---</span><br><span class="hljs-attr">service</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 事务分组，默认：$&#123;spring.applicaiton.name&#125;-fescar-service-group。</span><br>  <span class="hljs-attr">vgroup_mapping.applicaiton-name-fescar-service-group</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">  # 仅支持单节点，不要配置多地址，这里的default要和事务分组的值一致。</span><br>  <span class="hljs-attr">default.grouplist</span> = <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span><br><span class="hljs-comment">  # 降级，当前不支持。</span><br>  <span class="hljs-attr">enableDegrade</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  # 禁用全局事务。</span><br>  <span class="hljs-attr">disable</span> = <span class="hljs-string">false</span><br><span class="hljs-comment">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br>  <span class="hljs-attr">max.commit.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br>  <span class="hljs-attr">max.rollback.retry.timeout</span> = <span class="hljs-string">&quot;-1&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---客户端相关工作的机制---</span><br><span class="hljs-attr">client</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">async.commit.buffer.limit</span> = <span class="hljs-string">10000</span><br>  <span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">retry.internal</span> = <span class="hljs-string">10</span><br>    <span class="hljs-attr">retry.times</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">report.retry.count</span> = <span class="hljs-string">5</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ---事务日志存储配置---</span><br><span class="hljs-comment"># 注意：该部分配置仅在seata-server中使用，如果选择db请配合seata.sql使用。</span><br><span class="hljs-comment">## transaction log store </span><br><span class="hljs-attr">store</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## store mode: file、db</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;file&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## file store</span><br>  <span class="hljs-attr">file</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br>    <span class="hljs-attr">max-branch-session-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # globe session size , if exceeded throws exceptions</span><br>    <span class="hljs-attr">max-global-session-size</span> = <span class="hljs-string">512</span><br><span class="hljs-comment">    # file buffer size , if exceeded allocate new buffer</span><br>    <span class="hljs-attr">file-write-buffer-cache-size</span> = <span class="hljs-string">16384</span><br><span class="hljs-comment">    # when recover batch read size</span><br>    <span class="hljs-attr">session.reload.read_size</span> = <span class="hljs-string">100</span><br><span class="hljs-comment">    # async, sync</span><br>    <span class="hljs-attr">flush-disk-mode</span> = <span class="hljs-string">async</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  ## database store</span><br>  <span class="hljs-attr">db</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br>    <span class="hljs-attr">datasource</span> = <span class="hljs-string">&quot;dbcp&quot;</span><br><span class="hljs-comment">    ## mysql/oracle/h2/oceanbase etc.</span><br>    <span class="hljs-attr">db-type</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br>    <span class="hljs-attr">user</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>    <span class="hljs-attr">min-conn</span> = <span class="hljs-string">1</span><br>    <span class="hljs-attr">max-conn</span> = <span class="hljs-string">3</span><br>    <span class="hljs-attr">global.table</span> = <span class="hljs-string">&quot;global_table&quot;</span><br>    <span class="hljs-attr">branch.table</span> = <span class="hljs-string">&quot;branch_table&quot;</span><br>    <span class="hljs-attr">lock-table</span> = <span class="hljs-string">&quot;lock_table&quot;</span><br>    <span class="hljs-attr">query-limit</span> = <span class="hljs-string">100</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">lock</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  ## the lock store mode: local、remote</span><br>  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;remote&quot;</span><br><br>  <span class="hljs-attr">local</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in user&#x27;s database</span><br>  <span class="hljs-attr">&#125;</span><br><br>  <span class="hljs-attr">remote</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    ## store locks in the seata&#x27;s server</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">recovery</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">asyn-committing-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">rollbacking-retry-delay</span> = <span class="hljs-string">30</span><br>  <span class="hljs-attr">timeout-retry-delay</span> = <span class="hljs-string">30</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">transaction</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">undo.data.validation</span> = <span class="hljs-string">true</span><br>  <span class="hljs-attr">undo.log.serialization</span> = <span class="hljs-string">&quot;jackson&quot;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## metrics settings</span><br><span class="hljs-attr">metrics</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">enabled</span> = <span class="hljs-string">false</span><br>  <span class="hljs-attr">registry-type</span> = <span class="hljs-string">&quot;compact&quot;</span><br><span class="hljs-comment">  # multi exporters use comma divided</span><br>  <span class="hljs-attr">exporter-list</span> = <span class="hljs-string">&quot;prometheus&quot;</span><br>  <span class="hljs-attr">exporter-prometheus-port</span> = <span class="hljs-string">9898</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">复制代码</span><br></code></pre></td></tr></table></figure><p><strong>5.4.5 添加全局事务注解</strong>：</p><ul><li><strong>主业务</strong>方法添加<strong>全局事务</strong>注解：<code>@GlobalTransactional</code></li><li><strong>分支业务</strong>方法添加<strong>本地事务</strong>注解：<code>@Transactional</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@GlobalTransactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String userId, String commodityCode, <span class="hljs-type">int</span> orderCount)</span> &#123;<br>        ......<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="5-5-更多官方示例"><a href="#5-5-更多官方示例" class="headerlink" title="5.5 更多官方示例"></a>5.5 更多官方示例</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 整合 nacos</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-nacos-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 jpa</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springcloud-jpa-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 dubbo</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-dubbo-seata</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 整合 ShardingSphere</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//github.com/seata/seata-samples/tree/master/springboot-shardingsphere-seata</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/09/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务是一种去中心化的应用架构方案。相对于单体式应用来说，微服务应用具有耦合性低、扩展性高、更灵活、能更高效交付的特点。</p><p>从名称上看。微服务的“微”涵盖了以下几层含义：</p><ul><li>服务按功能进行一定粒度的拆分，每一块都有独立的职责。</li><li>由于做了拆分，每一个微服务的开发都是独立进行的，因此这种架构的交付节奏可以更加灵活</li><li>微服务应用的部署及应用都是隔离的，这保证了整个应用架构可以按需进行扩展</li></ul><h2 id="微服务基础设施"><a href="#微服务基础设施" class="headerlink" title="微服务基础设施"></a>微服务基础设施</h2><p>微服务架构本质上是一种面向服务的分布式系统，为了解决分布式所带来的一系列管理问题，微服务通常需要依赖一些基础设施来保证架构的完整性。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在一个微服务集群中，由于服务的种类，实例数量由很多，仅通过人工配置的方式会加大工作量。而且这些服务实例的信息可能随时会发生变化，比如我们可能需要对某个服务做在线的扩容，或者因为故障处理而隔离某些节点。因此，需要由一个自动化的服务注册组件来完成这件事。服务注册通常需要记录当前可用的服务实例信息，并提供服务注册表API。服务的调用方可以通过API获得所需服务的实例信息，并实时订阅服务实例的变化。</p><p>通常服务注册的实现方式是心跳，即注册表于服务实例之间保持一个稳定的心跳检测，根据心跳的状态来判断服务实例是否存货。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>既然大量的微服务实例都记录到了服务注册表中，那么服务的调用方则应该通过服务发现组件来动态地可调用地服务实例信息。在微服务架构中，服务地发现有两种实现方式。</p><ol><li><p><strong>客户端发现</strong></p><p>客户端发现是指由调用方来完成目标服务实例信息地发现。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955546.png" alt="image-20220528195417255"></p></li><li><p><strong>服务端发现</strong></p><p>服务端发现是一种代理式地架构，即服务器间调用统一使用负载均衡器来实现。这与客户端发现的差别在于：服务实例的发现由负载均衡器来完成，并且所有的微服务接口调用都由该组件来代理</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281955537.png" alt="image-20220528195428061"></p><p>这种方式的好处是可以屏蔽被调用服务的一些内部细节，并增加一些公共的能力，比如接口鉴权、流量控制、日志记录等。但是弊端也很明显，由于所有接口调用都需要经过该负载均衡器，所以该组件很容易形成瓶颈，一旦负载均衡器故障将会产生全局的影响</p><p>服务发现的实现方法无论是客户端发现还是服务器端发现，都离不开以下两点：</p><ul><li>依赖服务注册表组件来发现可用的服务</li><li>提供包括，目标实例的路由，如何在多个实例中挑选合适的节点取决于路由的算法，常见的包括随机路由、轮询路由、动态压力路由。</li></ul></li></ol><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p>API网关是外部系统接入微服务集群的唯一入口。我们可以将微服务架构看作一个整体，其内部的微服务职责划分、服务间的交互调用对于外部来说是不可见的。那么为了对外提供体验一致的访问接口，微服务需要一个统一的API网关，所有外部系统对微服务的调用都经过API网关组件。</p><p>API网关组件通常具备的功能包括但不限于：</p><ul><li>接入鉴权</li><li>传输加密</li><li>请求路由</li><li>流量控制</li><li>灰度发布</li></ul><h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>在系统的节点实例变多后，实例故障的概率会增加。而且一旦故障发生，服务间的调用关系会导致故障大面积”传染“，通过人工进行实例故障隔离的方式效率较低，这就需要微服务能自动检测问题并自动做出应对。这种检测及应对能力通常由服务容错组件提供，一些手段如下：</p><ul><li>请求重试：在某些关键业务出现问题时，尝试进行请求的重试。</li><li>流量控制：这需要先对系统的容错做出明确的规划，然后对读物实例上的流量进行实时监控，一旦发现超过阈值则拒绝请求，这样就可以避免整个系统全面瘫痪。</li><li>服务熔断：根据一定的规则判断目标服务是否已经失效，规则的设计可以基于某个时间窗口的调用失败率进行计算，如果超过阈值则执行熔断（快速返回错误信息）</li></ul><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>对微服务实例保持足够的监控是非常重要的，而通常架构上需要对服务监控组件进行单独考虑。监控的目的是及时发现问题并采取一定的合理规避措施，以保证服务的SLA质量。通产在微服务监控服务中提供如下功能：</p><ul><li>业务日志采集：比如系统中用户注册、上下线等信息</li><li>运行指标采集：比如CPU、内存占用、JVM堆内存大小，或某些接口流量等</li><li>监控警告：对业务日志、运行指标信息进行分析、根据结果做出一定的判断和处理</li><li>调用链路跟踪：用于业务流程在分布式调用中出现问题时提供定位手段，调用链路需要借助一些特定的技术实现，比如服务埋点、跟踪树等。</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>传统的服务实例配置是通过本地文件(XML&#x2F;YAML&#x2F;PROPERTIES)实现的，比如数据库连接池的大小、接口请求流量的阈值等。对于配置的一些改动往往需要重新发布并重启服务，在存在实例时情况变得很不乐观。想象一下对于某个配置项的调整，你可能需要做几十次的发布动作。</p><p>通过将这些配置信息注册到统一的配置中心服务，微服务通过配置中心获取其所需要的配置，这样便免去了各种繁冗的发布工作。此外，如果服务实现了配置的动态感知及自动更新，则还可以实现各种平滑的动作。比如在数据库连接池的大小设置发生了变化时，实例可以自动感知而不需要重启。</p><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>微服务架构推崇采用轻量化的接口调用方式，比如使用HTTP&#x2F;REST。在项目实战中，我们还应该做出更统一的规范化定义，并形成公共的接口调用组件。这部分需要考虑的内容包括：</p><ul><li>数据的传输，比如HTTP还是TCP</li><li>数据的编码，比如JSON还是XML，或是二进制</li><li>数据的内容，比如是否采用固有的消息头定义</li><li>数据的安全，如是否使用TLS&#x2F;SSL实现加密，如何对接口权限进行校验等</li></ul><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>以Docker为代表的容器技术是微服务的最佳组合。通过使用容器作为基础设施，微服务能够实现快速部署、快速迭代的目。Kubernetes是当今容器标准化平台代表，其提供了强大的容器生命周期管理功能，可用于部署、扩展和管理所有的微服务容器。对微服务的自治、敏捷管理来说，容器的无状态、弹性伸缩能力无疑是最契合的。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282051685.png" alt="image-20220528205051510"></p><h2 id="CAP与BASE理论"><a href="#CAP与BASE理论" class="headerlink" title="CAP与BASE理论"></a>CAP与BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论又被称为CAP理论，指的是一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，三者不可兼得，而最多只能同时拥有两者</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205282106926.png" alt="image-20220528210623871"></p><p>一致性（C）：分布式系统中节点的数据，在同一时刻拥有同样的值。对于每一次读操作都能够读到最新写入的数据</p><p>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求，即保持高可用</p><p>分区容忍性（P）：在出现网络分区（中断）后，系统是否还能继续保持运作。分区相当于对于通信条件的要求，如果出现了分区的情况，则势必会影响数据的一致性，即同步出现时延。此时系统就必须在一致性和可用性上做出选择。</p><p>实际上，CAP理论中忽略了网络时延对于系统的影响，在现实中网络时延一定是真实存在的，也就是P一定是存在的。因此分布式系统如果选择了高可用（AP），那么就会造成访问节点之间的数据不一致（牺牲一致性）。如果选择了一致性（CP），那么必须淘汰数据的备用点，而只访问主节点（牺牲高可用性）。CA的场景是无法存在的，因为网络通信失败的情况一定会存在。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论可被看作是CAP理论的一个补充，主要来源对大规模互联网系统分布式实践的总结。该理论由以下几个短语组成（BASE）。</p><ul><li>Basically Available（基本可用）</li><li>Soft State（软状态）</li><li>Eventually Consistent（最终一致性）</li></ul><p>实质上，BASE是对于一致性和可用性进行权衡的结果，其主要思想是在系统无法实现强一致性的情况下，根据应用的业务特点来做出一些权衡及补充，并使系统达到最终一致性。在达到最终一致性之前，系统会处于一个中间状态，具备以下特征：</p><ol><li>基本可用：即损失部分可用性，比如响应时间变长，或者部分服务被降级</li><li>软状态：数据会存在中间状态（不一致），但该状态不会影响系统的基本使用。</li></ol><p>在经过一段时间之后，系统应该能达到最终真正一致的状态，比如数据复制经过一段时间后真正完成同步。</p><p>相比CAP理论来说，BASE理论将一致性分成了强一致性和弱一致性，并在充分考虑网络时延、系统吞吐量的情况下选择了一种基本可用（弱一致性）的处理思路，这无疑更加适用于现有分布式系统。</p><h2 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h2><blockquote><p> <strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p></blockquote><p><strong>为什么需要RPC?</strong></p><p>两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。</p><p>通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。我们不需要了解底层网络编程的具体细节。</p><p>简单讲：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272135904.png" alt="image-20220527213236293"></p><p><strong>RPC相关概念：</strong></p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong>：代理类，把调用方法、类、方法参数传递到服务端</li><li><strong>服务端 Stub（桩）</strong>：接收到客户端执行方法的请求，返回给客户端的类</li><li><strong>网络传输</strong>：提供两端的数据传输服务<ol><li>实现方式：Socket、Netty</li></ol></li></ol><p><strong>原理如下：</strong></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: RpcRequest；</li><li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。</li></ol><hr><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><ul><li><p><strong>RMI（JDK自带）</strong></p><p>JDK自带的RPC，有很多局限性，不推荐使用。</p></li><li><p><strong>Dubbo</strong></p><p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</p></li><li><p><strong>gRPC</strong></p><p>gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</p></li><li><p><strong>Hessian</strong></p><p>Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送<strong>二进制数据</strong>。</p></li><li><p><strong>Thrift</strong></p><p>Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p></li></ul><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p><strong>服务调用关系</strong></p><ul><li>服务提供者：暴露接口给其他微服务调用</li><li>服务消费者：调用其他微服务的接口</li><li>提供者和消费者是<strong>相对</strong>的</li></ul><p><strong>eureka的作用</strong></p><ul><li>消费者该如何获取服务提供者信息？<ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者如何选择？<ul><li>服务消费者利用负载均衡算法，从列表中挑选一个</li></ul></li><li>消费者如何感知服务提供者健康状态？<ul><li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被踢除</li></ul></li></ul><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205272158268.png" alt="image-20220527215852205"></p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><strong>Nacos服务分级存储模型</strong></p><ul><li>一级是服务，例如userService</li><li>二级是集群，例如杭州或上海</li><li>三级是实例：</li></ul><p><strong>NacosRule负载均衡策略</strong></p><ul><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其他集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ul><p>实例的权重控制</p><ul><li>Nacos控制台可以设置实例的权重值，0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ul><p><strong>Nacos环境隔离（namespace)</strong></p><ul><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见</li></ul><h2 id="Nacos与Eureka对比"><a href="#Nacos与Eureka对比" class="headerlink" title="Nacos与Eureka对比"></a>Nacos与Eureka对比</h2><p><strong>共同点：</strong></p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><p><strong>区别：</strong></p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><p>DataID命名规则：服务名称+环境.yaml(例如：userservice-dev.yaml)</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205280834487.png" alt="image-20220528083411388"></p><p><strong>将配置交给Nacos管理的步骤</strong></p><ul><li>在Nacos中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时nacos读取哪个文件</li></ul><p><strong>配置自动刷新</strong></p><ul><li>在需要注入配置文件中内容的类上添加注解@RefreshScope</li><li>也可以使用@ConfigurationProperties注解</li></ul><p>注：在nacos配置中，服务名.yaml文件是所有环境共享的环境</p><p>多种配置优先级如下：</p><p>服务名-profile.yaml &gt; 服务名称.yaml &gt; 本地配置</p><h2 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h2><p><strong>使用步骤：</strong></p><ul><li>引入依赖</li><li>添加@EnableFeignClients注解</li><li>编写FeignClient接口</li><li>使用FeignClient中定义的方法代替RestTemplate</li></ul><p><strong>Feign底层的客户端实现：</strong></p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>Feign性能优化主要为：</p><ul><li>使用连接池代替默认的URLConnection</li><li>日志级别最好采用basic或none</li></ul><h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><p><strong>网关功能</strong></p><ul><li>身份认证和权限校验</li><li>服务路由，将用户请求路由到微服务，并实现负载均衡</li><li>对用户请求做限流</li></ul><p>网关搭建步骤：</p><ul><li>创建项目，引入服务发现和gateway依赖</li><li>配置application.yml,包括服务基本信息、nacos地址、路由</li><li>路由配置包括：<ul><li>路由id：路由的唯一标识</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates):判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ul></li></ul><p><strong>路由过滤器GateWayFilter</strong></p><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281829903.png" alt="image-20220528182922800"></p><p>过滤器的作用：</p><ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由的请求生效</li><li>defaultFiler对所有的路由都生效</li></ul><p><strong>GlobalFIlter全局过滤器</strong></p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样，区别在于GatewayFilter通过配置定义，处理逻辑是固定的，而GlobalFilter的逻辑需要自己写代码实现。通过实现GlobalFilter接口实现。</p><p>实现全局过滤器步骤：</p><ul><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口(指定过滤器的执行顺序)</li><li>编写处理逻辑</li></ul><p><strong>过滤器执行顺序：</strong></p><p>请求进入网关会碰到三类过滤器：当前路由过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205281900990.png" alt="image-20220528190022922"></p><ul><li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li><li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><strong>雪崩问题（微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况）</strong></p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>船壁模式：限定每个业务使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离</li><li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li><p>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也就是默认的模式</p></li><li><p>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>满足下面条件可以使用关联模式</p><ul><li>两个有竞争关系的资源</li><li>一个优先级高，一个优先级低</li></ul></li><li><p>链路：统计从指定链路访问到本资源的请求，触发阈值，对指定链路限流</p></li></ul><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。默认的处理方式</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</li></ul><blockquote><p>**热点参数限流:**分别统计参数值相同的请求，之后判断是否超过QPS阈值。</p></blockquote><h3 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h3><blockquote><p>虽然限流可以尽量避免因高并发引起的服务故障，但服务还会因为其他原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了</p></blockquote><p><strong>Feign整合Sentinel的步骤：</strong></p><ul><li>在application.yml中配置：feign.sentinel.enable&#x3D;true</li><li>在FeignClient编写FallbackFactory并注册为Bean(继承FallbackFactory并指定泛型为要降级的类)</li><li>将FallbackFactory配置到FeignClient中(在FeignClient中添加注解)</li></ul><p><strong>线程隔离</strong></p><ul><li><p>线程池隔离</p><p>优点：</p><ul><li>支持主动超时</li><li>支持异步调用</li></ul><p>缺点：</p><ul><li>线程的额外开销较大</li></ul><p>场景：</p><ul><li>低扇出</li></ul></li><li><p>信号量隔离(Sentinel默认采用)</p><p>优点：</p><ul><li>轻量级、无额外开销</li></ul><p>缺点：</p><ul><li>不支持主动超时</li><li>不支持异步调用</li></ul><p>场景：</p><ul><li>高频调用</li><li>高扇出</li></ul></li></ul><h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><p>断路器熔断策略有三种：满调用、异常比例、异常数</p><ul><li>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</li><li>异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</li><li>异常数：统计只当时间内的调用，如果调用次数超过指定请求数，并且出现异常的次数达到阈值则触发熔断。</li></ul><h3 id="授权规则及规则持久化"><a href="#授权规则及规则持久化" class="headerlink" title="授权规则及规则持久化"></a>授权规则及规则持久化</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li>白名单：来源（origin）在白名单内的调用者允许访问。</li><li>黑名单：来源（origin）在黑名单内的调用者不允许访问</li></ul><p><strong>自定义异常结果</strong></p><blockquote><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口</p><p><strong>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源</strong></p></blockquote><p><strong>Sentinel有三种配置管理模式</strong></p><ul><li>原始模式：保存在内存</li><li>pull模式：保存在本地文件或数据库，定时去读取</li><li>push模式：保存在nacos，监听变更实时更新</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>解决分布式事务的思想和模型</strong></p><ul><li>全局事务：整个分布式事务</li><li>分支事务：分布式事务中包含的每个子系统的事务</li><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚</li></ul><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata事务管理中的三个重要角色：</p><ul><li>TC（Transaction Coordinator）-事务协调者：维护全局和分支事务的状态，协调全局事务或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开启全局事务、提交或回滚事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205310925047.png" alt="image-20220531092538924"></p><p><strong>Seata提供了四种不同的分布式事务解决方案：</strong></p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致性的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><blockquote><p>XA模式原理：XA规范是X&#x2F;Open 组织定义的分布式事务处理（DTP，Distribute Transaction Processing）标准，XA规范描述了全局的TM与与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311015892.png" alt="image-20220531101529812"></p><p><strong>Seata的XA模式</strong></p><p>Seata的XA模式做了一些调整，但大体相似：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311025929.png" alt="image-20220531102528868"></p><p>RM一阶段的工作：</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<ul><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ul></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p>XA模式的优点：</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用的数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源，等二阶段结束才释放，性能差</li><li>依赖关系型数据库实现事务</li></ul><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><blockquote><p>AT模式同样是分阶段提交的事务模型，不够弥补了XA模式中资源锁定周期过长的缺陷</p></blockquote><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311225992.png" alt="image-20220531122532913"></p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复到数更新前</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205311231089.png" alt="image-20220531123104030"></p><p><strong>AT模式和XA模式的区别：</strong></p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚</li><li>XA模式强一致性；AT模式最终一致性</li></ul><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>Try：资源的检测和预留</li><li>Confirm:完成资源操作业务，要求Try成功Confirm一定能成功</li><li>Cancel：预留资源释放，可以理解为try的反向操作</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206011624351.png" alt="image-20220601162444229"></p><p><strong>TCC模式的各个阶段任务：</strong></p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p><strong>TCC的优点：</strong></p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模式，无需生成快照，无需使用全局锁，性能强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p><strong>TCC缺点：</strong></p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li></ul><p><strong>TCC的空回滚和业务悬挂</strong></p><ol><li>当某分支事务的try阶段阻塞，可能导致全局事务超时而触发二阶段的cancel操作。再未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚</li><li>对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止空回滚后的try操作，避免悬挂</li></ol><h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga模式时Seata提供的长事务解决方案。也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>而阶段：成功则什么都不做，失败则通过补偿业务来回滚</li></ul><p>Saga模式优点：</p><ul><li>事务参与者可以甚至时间驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不能编写TCC中的三个阶段，实现简单</li></ul><p>Saga缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>基本概念：</p><p>生产者（Publisher）：发布消息到 RabbitMQ 中的交换机（Exchange）上。</p><p>交换机（Exchange）：和生产者建立连接并接收生产者的消息。</p><p>消费者（Consumer）：监听 RabbitMQ 中的 Queue 中的消息。</p><p>队列（Queue）：Exchange 将消息分发到指定的 Queue，Queue 和消费者进行交互。</p><p>路由（Routes）：交换机转发消息到队列的规则。</p></blockquote><p><strong>同步调用的优点：</strong></p><ul><li>时效性较强，可以立即得到结果</li></ul><p><strong>同步调用的问题：</strong></p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><p><strong>异步通信的优点：</strong></p><ul><li>耦合度低</li><li>吞吐量提升</li><li>故障隔离</li><li>流量削峰</li></ul><p><strong>异步调用的缺点：</strong></p><ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂了，业务没有明显的流程线，不好追踪管理</li></ul><p><strong>RabbiMQ结构</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290841532.png" alt="image-20220529084151441"></p><ul><li>channel：操作MQ的工具</li><li>exchange：路由消息到队列中</li><li>queue：缓存消息</li><li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li></ul><p><strong>常见消息类型：</strong></p><ul><li><p>基本消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290846599.png" alt="image-20220529084644566"></p></li><li><p>工作消息队列</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849809.png" alt="image-20220529084907773"></p></li><li><p>发布订阅，又根据交换机类型不同分为三种：</p><ul><li><p>Fanout Exchange：广播</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848092.png" alt="image-20220529084855058"></p></li><li><p>Direct Exchange：路由</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290848603.png" alt="image-20220529084840572"></p></li><li><p>Topic Exchange：主题</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205290849222.png" alt="image-20220529084938191"></p></li></ul></li></ul><h2 id="基本消息队列"><a href="#基本消息队列" class="headerlink" title="基本消息队列"></a>基本消息队列</h2><p>基本消息队列的消息发送流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ul><p>基本消息队列的消息接收流程：</p><ul><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消息行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ul><p><strong>如下代码实现：</strong></p><p>publisher如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.MessageProperties;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>       <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br><br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定对应的消息队列</span><br>        <span class="hljs-comment">//参数1：队列名称，如果队列不存在自动创建</span><br>        <span class="hljs-comment">//参数2：用来定义队列是否要持久化</span><br>        <span class="hljs-comment">//擦书3：exclusive是否独占队列</span><br>        <span class="hljs-comment">//参数4：autoDelete 是否在消费完成后自动删除队列</span><br>        <span class="hljs-comment">//参数5：额外附加参数</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//发布消息</span><br>        <span class="hljs-comment">//参数1：交换机名称，参数2队列名称，参数3：传递消息额外设置，参数4：消息的具体内容</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="hljs-string">&quot;hello rabbitmq&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        channel.close();<br>        connection.close()；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br><span class="hljs-comment">//    @Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        <span class="hljs-comment">//创建连接Mq的连接工厂对象</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">//设置连接rabbitmq主机</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        <span class="hljs-comment">//设置连接哪个端口</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//设置连接哪个虚拟主机</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        <span class="hljs-comment">//设置访问虚拟主机的用户名和密码</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//获取连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>       <span class="hljs-comment">//参数1：消费哪个队列的消息，参数2：开启消息的自动确认机制，参数3：消费时的回调接口</span><br>        channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;new StringBody=&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>        channel.close();<br>        connection.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        Consumer consumer=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>();<br>        consumer.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本消息对列SpringAMQP使用</strong></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在配置文件中添加mq连接信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">rabbitmq-springboot</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">154.253</span><span class="hljs-number">.41</span><span class="hljs-number">.2</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/ems</span><br></code></pre></td></tr></table></figure></li><li><p>在publisher服务中添加一个测试类，编写发送消息的消息提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    String queueName=<span class="hljs-string">&quot;hello&quot;</span>;<br>    String message=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    rabbitTemplate.convertAndSend(queueName,message);<span class="hljs-comment">//发送到哪个队列以及发送什么消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><span class="hljs-comment">//监听哪个队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><span class="hljs-comment">//处理监听行为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receviel</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//参数是Publisher发送的消息类型</span><br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="工作消息队列"><a href="#工作消息队列" class="headerlink" title="工作消息队列"></a>工作消息队列</h2><blockquote><p>Work queue工作队列，可以提高消息处理速度，避免队列消息堆积</p></blockquote><p>util连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>publisher如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Provider &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>get<span class="hljs-constructor">Connection()</span>;<br>        <span class="hljs-keyword">assert</span> connection != null;<br>        Channel channel=connection.create<span class="hljs-constructor">Channel()</span>;<br>        channel.queue<span class="hljs-constructor">Declare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">true</span>,<span class="hljs-params">false</span>,<span class="hljs-params">false</span>,<span class="hljs-params">null</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">21</span>;i++)<br>        channel.basic<span class="hljs-constructor">Publish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-params">null</span>,(<span class="hljs-params">i</span>+<span class="hljs-string">&quot;hello work quene&quot;</span>)</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionRabbitMq</span>.</span></span>close<span class="hljs-constructor">ConnectionAndChannel(<span class="hljs-params">channel</span>,<span class="hljs-params">connection</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//每次只能消费一个消息</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<span class="hljs-comment">//参数1：确认队列中哪个具体消息，参数2：是否开启多个消息同时确认</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.demo.workquene;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.zhang.demo.utils.ConnectionRabbitMq;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;消费者-2：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>                channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工作消息队列SpringAMQP使用</strong></p><p>前三步同上面基础消息队列，也可以指定每次取多少条消息，处理完成才继续取消息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">listener:<br>  direct:<br>    prefetch: 1 #每次只能获取一条消息，处理完成后才能获取下一个消息<br></code></pre></td></tr></table></figure><ol><li><p>发送多条消息</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;work模型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者端添加多个消费者共同处理消息</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class WorkCumstomer &#123;<br><br>    <span class="hljs-variable">@RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    public void <span class="hljs-built_in">recevi1</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-1&quot;</span>+message);<br>    &#125;<br><br>    @<span class="hljs-selector-tag">RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;work&quot;</span>))<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">recevi2</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;message-2&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Fanout-Exchange-广播"><a href="#Fanout-Exchange-广播" class="headerlink" title="Fanout Exchange(广播)"></a>Fanout Exchange(广播)</h2><blockquote><p>Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的queue</p></blockquote><p>基本使用步骤：</p><p>连接工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionRabbitMq</span> &#123;<br><br>    <span class="hljs-comment">//提供创建连接对量的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>            connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>            connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>            connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>            connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>            connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>            <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>            channel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//连接对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">//临时队列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//绑定交换机和队列</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//消费消息</span><br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span>  ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connectionFactory != <span class="hljs-literal">null</span>;<br>        Channel channel=connectionFactory.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//参数1：交换机名称，参数2：交换机类型  fanout 广播类型</span><br>        channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;fanout type message&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fanout Exchange SpringAMQP使用：</strong></p><p>前两步同基础消息队列</p><p><strong>方式一注解：</strong></p><ol><li><p>定义pulisher发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanout</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;FanOut的模型发送的消息&quot;</span>);<span class="hljs-comment">//参数一是exchange，参数二是routingKey，参数三是消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>consumer消费端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue, exchange = @Exchange(value = &quot;logs&quot;,type = &quot;fanout&quot;))</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>方式二配置类：</strong></p><p>也可以使用配置的方式声明消费者绑定的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//声明交换机</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue&quot;</span>);<span class="hljs-comment">//声明队列</span><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">fanoutBinfing</span><span class="hljs-params">(Queue fanoutQueue,FanoutExchange fanoutExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue).to(fanoutExchange);<span class="hljs-comment">//绑定队列和交换机</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>消费者使用直接指定队列即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(msg);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Direct-Exchange-路由"><a href="#Direct-Exchange-路由" class="headerlink" title="Direct Exchange(路由)"></a>Direct Exchange(路由)</h2><blockquote><p>DIrect Exchange会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）。</p></blockquote><ul><li>每一个Queue都与Exchange设置一个BindingKey（BindingKey可以指定多个）；</li><li>发布者发送消息时，指定消息的RoutingKey；</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列；</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291028289.png" alt="image-20220529102816194"></p><p>util连接工具类：</p><p>public class ConnectionRabbitMq {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">//基于rout key 绑定队列和交换机</span><br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费这-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(queue,<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;warning&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取连接对象</span><br>        Connection connection= ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;log_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">//发送消息</span><br>        String routingKey=<span class="hljs-string">&quot;warning&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;log_direct&quot;</span>,routingKey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这是direct模型发布的基于rout key:[&quot;</span>+routingKey+<span class="hljs-string">&quot;]发送的消息&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Direct Exchange SpringAMQP使用：</strong></p><p>前两部同基础消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouteCumstomer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = &quot;direct&quot;),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者1</span><br>        System.out.println(<span class="hljs-string">&quot;message-1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value=@Queue,exchange = @Exchange(value = &quot;directs&quot;,type = ExchangeTypes.DIRECT),key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warning&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-comment">//消费者2</span><br>        System.out.println(<span class="hljs-string">&quot;message-2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRoute</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;发送--info--key的信息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Topic-Exchange-主题"><a href="#Topic-Exchange-主题" class="headerlink" title="Topic Exchange(主题)"></a>Topic Exchange(主题)</h2><blockquote><p>Topic Exchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以 . 分割</p></blockquote><p>Queue与Exchange指定BindingKey时可以使用通配符：</p><ul><li>#：代表0个或多个单词</li><li>*：代表一个单词</li></ul><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291044031.png" alt="image-20220529104430167"></p><p>基础使用步骤：</p><p>util连接工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提供创建连接对量的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;154.253.41.2&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeConnectionAndChannel</span><span class="hljs-params">( Channel channel,Connection connection)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(channel!=<span class="hljs-literal">null</span>)<br>        channel.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | TimeoutException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)<br>        connection.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-1&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>consumer 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//                super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                System.out.println(<span class="hljs-string">&quot;消费者-2&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Provider</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionRabbitMq.getConnection();<br>        <span class="hljs-keyword">assert</span> connection != <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String routekey=<span class="hljs-string">&quot;user.save.all&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routekey,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;这里是topic动态类型模型[&quot;</span>+routekey+<span class="hljs-string">&quot;]&quot;</span>).getBytes(StandardCharsets.UTF_8));<br>        ConnectionRabbitMq.closeConnectionAndChannel(channel,connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Topic Exchange SpringAMQP使用</strong></p><p>前面两部同基本消息队列</p><ol><li><p>consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicCumstomer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;user.save&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive1</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br><br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(value = @Queue,exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;),key = &#123;&quot;order.#&quot;,&quot;user.*&quot;&#125;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recive2</span><span class="hljs-params">(String massage)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;massage 1= &quot;</span> + massage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>provider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopic</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;order&quot;</span>,<span class="hljs-string">&quot;user.save 路由消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>SpringAMQP中消息的序列化和反序列化是怎么实现的？</p><ul><li>利用MessageConverter实现的，默认是JDK的序列化</li><li>注意发送方与接收方必须使用相同的MessageConverter</li></ul><p><strong>RabbitMQ相关文章：</strong></p><p><a href="http://docs.javaboy.org/rabbitmq/message_push_pull/#_3-2-work-queues">江南一点雨</a></p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><blockquote><p>elasticsearch是一款非常强大的开源搜索引擎，可以帮我们从海量数据中快速找到需要的内容。</p><p>elasticsearch结合Kibana、logstash、Beats，也就是elastic stack(ELK)。被广泛应用在日志数据分析、实时监控等领域</p></blockquote><pre><code class="hljs"> ![image-20220529142245490](https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291422577.png)</code></pre><p><strong>文档和词条：</strong></p><ul><li>每一条数据就是一个文档</li><li>对文档中的内容分词，得到的词语就是词条</li></ul><p><strong>正向索引：</strong></p><ul><li>基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</li></ul><p><strong>倒排索引：</strong></p><ul><li>对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时先根据词条查询到文档id，而后获取文档。</li></ul><p><strong>索引</strong></p><ul><li>索引（index）：相同类型的文档的集合</li><li>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</li></ul><h2 id="Ik分词器安装使用"><a href="#Ik分词器安装使用" class="headerlink" title="Ik分词器安装使用"></a>Ik分词器安装使用</h2><p>下载与Elasticsearch版本相同的ik分词器</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>将下载的包解压后放到Elasticsearch中的plugins目录下，（踩坑日记–需要重新创建一个ik文件夹将解压后的ik分词器的内容复制到ik目录下才可以正常使用）</p><p><strong>Ik分词器的扩展与停用词</strong></p><p>在Ik分词器config目录下打开IKAnalyzer.cfg.xml进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br> <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205291543388.png" alt="image-20220529154352092"></p><p>在字典中添加相关词语即可</p><p><strong>IK分词器有两种模式：</strong></p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2><p>安装同IK分词器，下载解压复制到plugins目录下，重启即可</p><p><strong>自定义分词器步骤：</strong></p><ul><li>创建索引库，在settings中配置，可以包含三部分</li><li>character filter</li><li>tokenizer</li><li>filter</li></ul><p><strong>例如：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;analysis&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;py&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;py&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;pinyin&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_joined_full_pinyin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;keep_original&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;limit_first_letter_length&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">16</span><br>                    <span class="hljs-attr">&quot;remove_duplicated_term&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;none_chinese_pinyin_tokenizer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;my_analyzer&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;search_analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;standard&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单数据类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h2 id="索引库基本操作"><a href="#索引库基本操作" class="headerlink" title="索引库基本操作"></a>索引库基本操作</h2><ul><li>创建索引：PUT&#x2F;索引名称</li><li>查询索引：GET&#x2F;索引名称</li><li>删除索引：DELETE&#x2F;索引名称</li><li>添加字段：PUT&#x2F;索引库名&#x2F;_mapping</li></ul><p><strong>创建索引库</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>修改索引库</strong></p><p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br>如下示例：<br>PUT /heima/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;heima&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;aliases&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;properties&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;age&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;routing&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;allocation&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;include&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;_tier_preference&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;data_content&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;provided_name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;creation_date&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1653818826936&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;uuid&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5dw1G0dkR1CbIV1CN6-MXA&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;created&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8010299&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除索引</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /heima<br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;acknowledged&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="文档基本操作"><a href="#文档基本操作" class="headerlink" title="文档基本操作"></a>文档基本操作</h2><ul><li>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;索引库名&#x2F;文档id</li><li>修改文档:<ul><li>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id {json文档}</li><li>增量修改：POST &#x2F;索引库名&#x2F;update&#x2F;文档id {“doc”{字段}}</li></ul></li></ul><p><strong>新建文档的DSL语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值4&quot;</span><br>     <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ......<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ziyuan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;result&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;created&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>查询文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /heima/_doc/<span class="hljs-number">1</span><br><br><span class="hljs-comment">//结果如下</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;世界知名的长江，对外开放的大学&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;214324@qq.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;firstName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;lastName&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ziyuan&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>删除文档语法如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名/_doc/删除的文档id<br></code></pre></td></tr></table></figure><p><strong>修改文档</strong></p><ul><li><p>全量修改，会删除旧文档，添加新文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;值2&quot;</span>，<br>         ........<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>增量修改，修改指定字段值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;新的值&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="DSL查询分类"><a href="#DSL查询分类" class="headerlink" title="DSL查询分类"></a>DSL查询分类</h2><blockquote><p>Elasticsearch提供了基于JSON的DSL来定义查询，常见的查询类型包括如下：</p></blockquote><ul><li>查询所有：查询出所有数据，一般测试用。例如：match_all</li><li>全文检索（full text)查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>malti_match_query</li></ul></li><li>精确查询：根据精确词条查找数据，一般是查询keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li>地理(geo)查询：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li>复合(compound)查询：复合查询可以将上述各种查询条件组合起来，合并查询条件，例如：<ul><li>bool</li><li>boosting</li><li>constant_score</li><li>dis_max</li><li>function_score</li></ul></li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合可(aggregations)可以实现对文档数据的统计、分析、运算。常见的有三类：</p><ul><li>桶(Bucket)聚合：用来对文档做分组<ul><li>TermAggregation：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li>度量(Metric)聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小是</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li>管道(Pipeline)聚合：其他聚合的结果为基础的聚合</li></ul><h2 id="分词器组成"><a href="#分词器组成" class="headerlink" title="分词器组成"></a>分词器组成</h2><p>elasticsearch中分词（analyzer）的组成包括三部分：</p><ul><li>character filter：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换，同义词处理、拼音处理</li></ul><h2 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h2><p>elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配用户输入内容开头的词条并返回。为了提高补全查询效率，对于文档中字段的类型有一些约束：</p><ul><li>参数补全查询的字段必须是completion类型</li><li>字段的内容一般是用来补全的多个词条形成的数组</li></ul><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT test<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;completion&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">POST test/_doc<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;tittle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Sony&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;WH-1000XM3&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>completion suggestion查询</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /test/_search<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;tittle_suggest&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;s&quot;</span><span class="hljs-comment">//关键字,</span><br>            <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tittle&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//补全查询的字段</span><br>            <span class="hljs-attr">&quot;skip_duplicates&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//跳过重复的</span><br>            <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-comment">//获取10条结果</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零拷贝技术</title>
    <link href="/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/09/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><blockquote><p>零拷贝（zero-copy）是一种I&#x2F;O操作优化技术，可以快速高效地将数据从文件按系统移动到网络接口，而不需要将其从内核空间复制到用户空间，其在FTP或者HTTP等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用NIO和Epoll传输时才可使用该特性。需要注意，他不能用于实现了数据加密或者压缩的文件系统上，只能传输文件的原始内容。这类原始内同也包括加密了的文件内容。</p></blockquote><h2 id="传统I-x2F-O操作"><a href="#传统I-x2F-O操作" class="headerlink" title="传统I&#x2F;O操作"></a>传统I&#x2F;O操作</h2><ol><li><p>读操作</p><ol><li>应用程序发起读数据操作，触发read()系统调用。这时操作系统会进行一次上下文切换（把用户空间切换到内核空间）。</li><li>通过磁盘控制器把数据复制到内核缓冲区（页缓存）中，这里发生了一次DMA Copy。</li><li>然后内核将数据复制到用户空间的应用缓冲区中，发生了一次CPU Copy。</li><li>read调用返回后，会再进行一次上下文切换（把内核空间切换到用户空间）</li></ol><p>上述读过程，发生2次上下文切换和2次数据复制（一次是DMA Copy，一次是CPU Copy)。</p><p>DMA Copy是内核从磁盘上面读取数据，这是不消耗CPU时间的，是通过磁盘控制器完成的。</p></li><li><p>写操作</p><ol><li>应用程序发起写操作，触发write()系统调用，操作进行一次上下文切换（从用户空间到内核空间）</li><li>把数据复制到内核缓冲区Socket缓冲区，做了一次CPU Copy。</li><li>内核空间再把数据复制到磁盘或其他存储器（网卡，进行网络传输），进行了DMA Copy。</li><li>写入结束返回，又从内核空间切换到用户空间。</li></ol><p>上述写操作，也发生了2次上下文切换和2次数据复制（一次DMA Copy，一次CPU Copy）</p></li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082231556.png" alt="image-20220608223134442"></p><p><strong>总结：</strong></p><p>传统的I&#x2F;O读写操作，总共进行了4次上下文的切换，4次的数据复制动作。数据在内核空间和应用空间之间来回复制，其实并没有做任何有意义的逻辑，就是单纯的复制而已。所以这个机制太浪费时间，而且浪费CPU时间。</p><h2 id="零拷贝技术原理"><a href="#零拷贝技术原理" class="headerlink" title="零拷贝技术原理"></a>零拷贝技术原理</h2><p>零拷贝主要是用来解决操作系统在处理I&#x2F;O操作时，频繁复制数据的问题。零拷贝技术主要有mmap+write、sendfile、splice等几种方式。</p><ol><li><p><strong>虚拟内存</strong></p><p>所有的现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：</p><ul><li>多个虚拟内存可以指向同一个物理地址</li><li>虚拟内存空间可以远远大于物理内存空间</li></ul><p>利用上面的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在I&#x2F;O操作时 就不需要来回复制了。</p><p><strong>虚拟内存原理</strong></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082245288.png" alt="image-20220608224540237"></p></li><li><p>mmap&#x2F;write方式</p><p>使用mmap&#x2F;write方式替代原来的传统I&#x2F;O方式，就是利用了虚拟内存的特性。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082252877.png" alt="image-20220608225254819"></p><p>整体流程的核心区别是，把数据读取到内核缓冲区后，应用程序进行数据写入操作时，直接把内核的Read Buffer的数据复制到Socket Buffer以便写入，这次内核之间的复制也是需要CPU参与的。</p><p>上述流程就少了一个CPU Copy，提升了I&#x2F;O的速度。不过发现上下文的切换还是4次并没有减少，这是因为还是要应用程序发起write操作。</p></li><li><p>sendfile方式</p><p>从linux2.1版本开始，Linux引入了sendfile来简化操作。sendfile方式可以替换上面的mmap&#x2F;write方式来进一步优化。</p><p>sendfile将以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mmap();<br>write();<br></code></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sendfile()<br></code></pre></td></tr></table></figure><p>这样就减少了上下文切换，因为少了一个应用程序发起write操作，直接发起sendfile操作。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082305384.png" alt="image-20220608230549337"></p><p>sendfile方式只有3次数据复制（其中只有一次CPU copy）以及2次上下文切换。</p></li><li><p>带有scatter&#x2F;gather的sendfile方式</p><p>Linux2.4内核进行了优化，提供了带有scatter&#x2F;gather的sendfile操作，这个操作可以把最后一次CPU copy去除。其原理就是在内核空间Read Buffer和Socket Buffer不做数据复制，而是将Read Buffer的内存地址、偏移量记录到Socket Buffer中，这样就不需要复制，其本质和虚拟内存的解决方法思路一样，就是内存地址的记录。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202206082314110.png" alt="image-20220608231408062"></p><p>scatter&#x2F;gatter的sendfile只有2次数据复制（都是DMA Copy）以及2次上下文切换。CPU copy已经完全没有。不过这一种收集复制功能是需要硬件及驱动程序支持的。</p></li><li><p>splice方式</p><p>splice调用和sendfile非常类似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，另外一个表示输出设备。与sendfile不同的是，splice允许任意两个文件之间互相连接，而并不是文件到socket进行数据传输。对于一个文件描述符发送数据到socket这种特例来说，一直都是使用sendfile系统调用，而splice一直依赖只是一种机制，它并不仅是sendfile的功能，也就是说，sendfile只是splice的一个子集。</p></li></ol><p><strong>总结：</strong></p><p>无论是传统I&#x2F;O方式，还是引入了零拷贝之后，2次DMA Copy是都少不了的。因为两次DMA都是依赖硬件完成的。所以，所谓零拷贝，都是为了减少CPU copy及减少了上下文的切换。</p><table><thead><tr><th></th><th><strong>CPU拷贝</strong></th><th><strong>DMA拷贝</strong></th><th><strong>系统调用</strong></th><th><strong>上下文切换</strong></th></tr></thead><tbody><tr><td>传统方式</td><td>2</td><td>2</td><td>read&#x2F;write</td><td>4</td></tr><tr><td>内存映射</td><td>1</td><td>2</td><td>mmap&#x2F;write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>sendfile with dma<br> scatter&#x2F;gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单例模式的定义"><a href="#一、单例模式的定义" class="headerlink" title="一、单例模式的定义"></a>一、单例模式的定义</h1><p><strong>定义：</strong> 确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>这样做的好处是：有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。</p><h1 id="二、单例模式的设计要素"><a href="#二、单例模式的设计要素" class="headerlink" title="二、单例模式的设计要素"></a>二、单例模式的设计要素</h1><ul><li>一个私有构造函数 （确保只能单例类自己创建实例）</li><li>一个私有静态变量 （确保只有一个实例）</li><li>一个公有静态函数 （给使用者提供调用方法）</li></ul><p>简单来说就是，单例类的构造方法不让其他人修改和使用；并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一次实例。</p><h1 id="三、单例模式的6种实现及各实现的优缺点"><a href="#三、单例模式的6种实现及各实现的优缺点" class="headerlink" title="三、单例模式的6种实现及各实现的优缺点"></a>三、单例模式的6种实现及各实现的优缺点</h1><h2 id="（一）懒汉式（线程不安全）"><a href="#（一）懒汉式（线程不安全）" class="headerlink" title="（一）懒汉式（线程不安全）"></a>（一）懒汉式（线程不安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。</p><p><strong>优点：</strong> 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。</p><p><strong>缺点：</strong> 线程不安全，多线程环境下，如果多个线程同时进入了 if (uniqueInstance &#x3D;&#x3D; null) ，若此时还未实例化，也就是uniqueInstance &#x3D;&#x3D; null，那么就会有多个线程执行 uniqueInstance &#x3D; new Singleton(); ，就会实例化多个实例；</p><h2 id="（二）饿汉式（线程安全）"><a href="#（二）饿汉式（线程安全）" class="headerlink" title="（二）饿汉式（线程安全）"></a>（二）饿汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">uniqueInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。</p><p><strong>优点：</strong> 提前实例化好了一个实例，避免了线程不安全问题的出现。</p><p><strong>缺点：</strong> 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。</p><h2 id="（三）懒汉式（线程安全）"><a href="#（三）懒汉式（线程安全）" class="headerlink" title="（三）懒汉式（线程安全）"></a>（三）懒汉式（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getUinqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 实现和 线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上 加了一把 锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。</p><p><strong>优点：</strong> 延迟实例化，节约了资源，并且是线程安全的。</p><p><strong>缺点：</strong> 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方***使线程阻塞，等待时间过长。</p><h2 id="（四）双重检查锁实现（线程安全）"><a href="#（四）双重检查锁实现（线程安全）" class="headerlink" title="（四）双重检查锁实现（线程安全）"></a>（四）双重检查锁实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明:</strong> 双重检查数相当于是改进了 线程安全的懒汉式。线程安全的懒汉式 的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。</p><p><strong>为什么使用 volatile 关键字修饰了 uniqueInstance 实例变量 ？</strong></p><p>uniqueInstance &#x3D; new Singleton(); 这段代码执行时分为三步：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>正常的执行顺序当然是 1&gt;2&gt;3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。<br>单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。<br>例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getUniqueInstance()，发现 uniqueInstance 不为空，便获取 uniqueInstance 实例，但是其实此时的 uniqueInstance 还没有初始化。</p><p>解决办法就是加一个 volatile 关键字修饰 uniqueInstance ，volatile 会禁止 JVM 的指令重排，就可以保证多线程环境下的安全运行。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。</p><p><strong>缺点：</strong> volatile 关键字，对性能也有一些影响。</p><h2 id="（五）静态内部类实现（线程安全）"><a href="#（五）静态内部类实现（线程安全）" class="headerlink" title="（五）静态内部类实现（线程安全）"></a>（五）静态内部类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getUniqueInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。</p><p><strong>优点：</strong> 延迟实例化，节约了资源；且线程安全；性能也提高了。</p><h2 id="（六）枚举类实现（线程安全）"><a href="#（六）枚举类实现（线程安全）" class="headerlink" title="（六）枚举类实现（线程安全）"></a>（六）枚举类实现（线程安全）</h2><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-comment">//添加自己需要的操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeThing</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。</p><p><strong>优点：</strong> 写法简单，线程安全，天然防止反射和反序列化调用。</p><ul><li><strong>防止反序列化</strong><br><strong>序列化：</strong>把java对象转换为字节序列的过程；<br><strong>反序列化：</strong> 通过这些字节序列在内存中新建java对象的过程；<br><strong>说明：</strong> 反序列化 将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例。<br><strong>枚举类天然防止反序列化。</strong><br>其他单例模式 可以通过 重写 readResolve() 方法，从而防止反序列化，使实例唯一重写 readResolve() :</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException&#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、单例模式的应用场景"><a href="#四、单例模式的应用场景" class="headerlink" title="四、单例模式的应用场景"></a>四、单例模式的应用场景</h1><p><strong>应用场景举例：</strong></p><ul><li>网站计数器。</li><li>应用程序的日志应用。</li><li>Web项目中的配置对象的读取。</li><li>数据库连接池。</li><li>多线程池。</li><li>……</li></ul><p><strong>使用场景总结：</strong></p><ul><li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能。</li><li><strong>经常使用的对象，但实例化时耗费时间或者资源多</strong>，如数据库连接池，使用单例模式，可以提高性能，降低资源损坏。</li><li><strong>使用线程池之类的控制资源时</strong>，使用单例模式，可以方便资源之间的通信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为型设计模式</title>
    <link href="/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><h2 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h2><ol><li><p>定义：指定义一系列算法，并将每一种算法封装起来，让它们可以相互替换。策略模式能让算法独立于使用它地客户而变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172310354.png" alt="image-20220817230912880"></p></li></ol><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><ol><li><p>定义：指定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一种算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172316967.png" alt="image-20220817231640910"></p></li></ol><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ol><li><p>定义：指在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在以后将对象恢复到原先保存的状态，也叫Token模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172329323.png" alt="image-20220817232930270"></p></li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol><li><p>定义：指定义对象之间的一种一对多的依赖关系，每当一个对象状态发生变化时，其相关依赖对象都能得到通知并被自动更新，又叫发布订阅模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172341700.png" alt="image-20220817234137646"></p></li></ol><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><ol><li><p>定义：指为了避免请求发送者与接收者耦合在一起，让多个对象都有可能接收到请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到所有对象处理为止。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208172351970.png" alt="image-20220817235111917"></p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ol><li><p>定义：指提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。迭代器模式又称为游标（Cursor），属于对象行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182049174.png" alt="image-20220818204949129"></p></li></ol><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ol><li><p>定义：指将一个请求封装为一个对象，从而使用不同的请求对客户进行参数化；对请求排队或记录日志，以及支持可撤销的操作。又称为动作模式或事务模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208182042698.png" alt="image-20220818204238289"></p></li></ol><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ol><li><p>定义：允许一个对象在其内部状态发生变化的时改变其行为，使对象看起来似乎修改了它的类，状态模式又称为状态对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191851046.png" alt="image-20220819185056958"></p></li></ol><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><ol><li><p>定义：指用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立改变它们之间地交互，又称为调停者模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208191930922.png" alt="image-20220819193014879"></p></li></ol><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><ol><li><p>定义：指一个作用于某对象结构中各元素地操作，它可以在不改变各元素地类地前提下，定义作用于这些元素的新操作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327947.png" alt="image-20220819232709871"></p></li></ol><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ol><li><p>定义：指定义语言的文法，并简历一个解释器来解释该语言中的句子，这里的”句子“是指使用规定格式和语法的代码，它是一宗类行为型模式。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208192327119.png" alt="image-20220819232720065"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建型设计模式</title>
    <link href="/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><strong>简单工厂模式</strong></h3><ol><li><p>定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p></li><li><p>结构图</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171532554.png" alt="image-20220817153224447"></p></li></ol><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><ol><li><p>定义：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171542970.png" alt="image-20220817154249929"></p></li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a><strong>抽象工厂模式</strong></h3><ol><li><p>定义：提供一个创建一些列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171612449.png" alt="image-20220817161256362"></p></li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><strong>建造者模式</strong></h3><ol><li><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171621982.png" alt="image-20220817162143936"></p></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><strong>原型模式</strong></h3><ol><li><p>定义：使用原型实例指定待创建对象的类型，并通过复制这个原型来创建新的对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171628276.png" alt="image-20220817162807225"></p></li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><ol><li>定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</li><li>结构图：</li></ol><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171634647.png" alt="image-20220817163425608"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构型设计模式</title>
    <link href="/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/03/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol><li><p>定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646024.png" alt="image-20220817164417326"></p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171646005.png" alt="image-20220817164608352"></p></li></ol><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ol><li><p>定义：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171653072.png" alt="image-20220817165346023"></p></li></ol><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ol><li><p>定义：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171742358.png" alt="image-20220817174218295"></p></li></ol><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ol><li><p>定义：动态地给一个对象增加一些额外地职责。就扩展功能而言，装饰器模式提供了一种比使用子类更加灵活地替代方案。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171750349.png" alt="image-20220817175012294"></p></li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ol><li><p>定义：为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171754294.png" alt="image-20220817175427249"></p></li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ol><li><p>定义：运用共享技术有效地支持大量细粒度对象地复用。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171802090.png" alt="image-20220817180248038"></p></li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li><p>定义：给某一个对象提供一个代理或占位符，并由代理对象来控制源对象地访问。</p></li><li><p>结构图：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202208171809332.png" alt="image-20220817180918277"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种设计模式应用场景</title>
    <link href="/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/"/>
    <url>/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式应用场景"><a href="#设计模式应用场景" class="headerlink" title="设计模式应用场景"></a>设计模式应用场景</h1><ol><li>如何确保系统中一个类只有一个实例？单例模式</li><li>如何将对象的创建和对象的使用分离？简单工厂模式</li><li>如何通过不同的工厂来创建不同类型的对象？工厂方法模式</li><li>如何设计一个能够闯将一些列产品对象的工厂？抽象工厂模式</li><li>如何通过克隆来得到一个一模一样的对象？原型模式</li><li>如何一步步创建一个包含多个组成部分的复杂对象？建造者模式</li><li>如何在不修改现有系统的前提下重用没有源码的第三方类库？适配器模式</li><li>如何避免在多层继承结构中类的个数出现爆炸式增长？桥接模式</li><li>如何使用面向对象的方式来处理软件系统中的树形结构？组合模式</li><li>如何不通过继承的方式来扩展类的功能？装饰器模式</li><li>如何为复杂子系统提供一个统一的入口？外观模式</li><li>如何实现对象的多次复用以节省系统资源？享元模式</li><li>如何提供一种间接访问机制来实现对象的远程访问或受限访问？代理模式</li><li>如何让多个对象都有机会来处理同一个请求？责任链模式</li><li>如何将请求的发送者和请求的接收者完全解耦？命令模式</li><li>如何自定义一个简单的语言？解释器模式</li><li>如何遍历一个聚合对象中的元素？迭代器模式</li><li>如何协调多个对象之间复杂的相互调用？中介者模式</li><li>如何实现对象之间一对多的联动？观察者模式</li><li>如何设计和实现一个具有多个状态的对象？状态模式</li><li>如何在不修改现有代码的前提下更换一种算法？策略模式</li><li>如何为一个复杂算法的某些步骤提供多种实现方式？模板方法模式</li><li>如何操作一个包含多种类型对象的复杂结构？访问者模式</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计模式基础</title>
    <link href="/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h1><h2 id="软件设计模式定义"><a href="#软件设计模式定义" class="headerlink" title="软件设计模式定义"></a>软件设计模式定义</h2><p>软件设计模式是一套被反复使用，经过分类编目的代码设计经验的总结。使用软件设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。</p><p>软件设计模式定义有如下定义：</p><ol><li>软件设计模式是对代码设计经验的总结，且经过分类编目。</li><li>软件设计模式的根本目的是提高代码的重用性和可靠性。代码重用性是指相同功能的代码，不必多次编写。代码可靠性是指增加新功能时，对原来的功能没有影响。可靠性也体现了可扩展和可维护。</li><li>代码可读性是指编程的规范，便于其他程序员阅读和理解。</li></ol><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>软件设计模式的基本要素是指模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等。其中，软件设计模式的基本要素包括以下4个方面。</p><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ol><p>软件设计模式的基本结构由4部分构成，即问题描述、前提条件（环境或越苏条件）、解法（关联解法和其他相关设计模式）和效果（优&#x2F;缺点和已知应用），如下</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021813509.png" alt="image-20220502181256391"></p><h1 id="GoF设计模式及其分类"><a href="#GoF设计模式及其分类" class="headerlink" title="GoF设计模式及其分类"></a>GoF设计模式及其分类</h1><p>GoF的23中设计模式如下：</p><table>    <tbody style="text-align:center;vertical-align:middle;">        <tr >            <td colspan="2">创建型模式</td>            <td colspan="2">结构型模式</td>            <td colspan="2">行为型模式</td>        </tr>         <tr>            <td>类创建型模型</td>            <td>对象创建型模式</td>            <td>类结构型模式</td>            <td>对象结构型模式</td>            <td>类行为型模式</td>            <td>对象行为模式</td>        </tr>            <td>工厂方法模式</td>            <td></td>            <td>类适配器模式</td>            <td>对象适配模式</td>            <td></td>            <td>职责链模式</td>        </tr>        <tr>            <td></td>            <td>抽象工厂模式</td>            <td></td>            <td>桥接模式</td>            <td></td>            <td>命令模式</td>        </tr>        <tr>            <td></td>            <td>单例模式</td>            <td></td>            <td>代理模式</td>            <td></td>            <td>迭代器模式</td>        </tr>        <tr>            <td></td>            <td>建造者模式</td>            <td></td>            <td>组合模式</td>            <td></td>            <td>中介模式</td>        </tr>        <tr>            <td></td>            <td>原型模式</td>            <td></td>            <td>装饰模式</td>            <td></td>            <td>备忘录模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>享元模式</td>            <td></td>            <td>观察者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td>外观模式</td>            <td></td>            <td>状态模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>策略模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td></td>            <td>访问者模式</td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>模板方法模式</td>            <td></td>        </tr>        <tr>            <td></td>            <td></td>            <td></td>            <td></td>            <td>解释器模式</td>            <td></td>        </tr>    </tbody></table><h2 id="创建型设计模式、结构型设计模式和行为型设计模式"><a href="#创建型设计模式、结构型设计模式和行为型设计模式" class="headerlink" title="创建型设计模式、结构型设计模式和行为型设计模式"></a>创建型设计模式、结构型设计模式和行为型设计模式</h2><p>软件设计模式有多种分类方法。根据模式目的（模式是用来做什么的）可分为创建型、结构型和行为型3种。</p><p>根据软件设计模式的处理范围，可以分为类模式和对象模式两种。</p><ul><li>类模式处理类和子类之间的关系是通过继承在编译时刻就被确定下来的，这些关系是属于静态的。</li><li>对象模式是处理对象之间的关系，这些关系是时刻变化运行的，具有动态性。</li></ul><p>根据软件设计模式的使用级别，可以分为基本设计模式、常用设计模式和高级设计模式3种。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>使用UML表示类间的4种基本关系：</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205021924361.png" alt="image-20220502191536437"></p><ol><li><p>关联关系：是类与类之间最常见的一种关系。他是一种结构化关系，用于表示一类对象与另一类对象之间的有（has a）联系。（通俗说是将一个类的对象作为另一个类的属性），在UML类图中，关联关系用实线（或实线带箭头–指向被关联类）连接有关联对象所对应的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013167.png" alt="image-20220502200907721"></p><ol><li><p>聚合关系（聚合关系是特殊的关联关系）具有如下特征：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象可以脱离整体而独立存在；</li><li>在代码实现时，成员对象可以通过构造器或setter方法注入；</li></ul><p>UMl类图表示聚合关系时，使用待空心菱形的实线表示（指向聚合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022013175.png" alt="image-20220502201321550"></p></li><li><p>组合关系（组合关系表示类之间整体和部分的关系，其中整体类可控制成员类的声明周期，部分对象与整体对象之间具有同生共死的关系。）特征如下：</p><ul><li>当前类对象与成员对象是整体与部分的关系；</li><li>成员对象与整体对象具有统一的生存期，当整体对象消亡时，成员对象也会消亡；</li><li>代码实现时，成员对象可在整体类声明或构造方法中实例化；</li></ul><p>在UML类图中，组合关系用待实心菱形的直线表示（指向组合类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022015552.png" alt="image-20220502201549514"></p></li></ol></li><li><p>依赖关系：指两个事物之间的一种语义关系，表示一个事物发生变化时会影响另一个事物。依赖关系通常是一种使用关系，为临时性的关联。在代码中，依赖关系是通过定义被依赖类型的局部变量、方法参数及返回值类型等方式来体现。</p><p><font style="color:red;">注意：</font>关联关系使用成员变量（全局变量），而依赖关系使用局部变量。</p><p>在UML类图中依赖关系使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022017088.png" alt="image-20220502201724053"></p></li><li><p>泛化关系（即继承关系，也称”is a”关系。泛化关系用于描述父类与子类之间的关系，父类又称基类或超类，子类又称派生类。</p><p>在UML类图的泛化关系使用空心三角形的直线来表示（指向基类）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022019078.png" alt="image-20220502201917032"></p></li><li><p>实现关系（指接口与实现类之间的实现，可实现接口中声明的所有抽象方法。</p><p>在UML类图中使用待空心三角形的虚线来表示实现关系（指向接口）。</p><p><img src="https://picgo-liziyuan.oss-cn-hangzhou.aliyuncs.com/img202205022021510.png" alt="image-20220502202141469"></p></li></ol><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。设计原则也是学习软件设计模式的基础，每种设计模式都会符合若干设计原则。</p><table><thead><tr><th align="center">名称</th><th align="center">简介</th><th align="center">重要性</th></tr></thead><tbody><tr><td align="center">开闭原则</td><td align="center">软件实体对扩展是开发的，但对修改是关闭的，即在不修改软件实体的基础上扩展其功能</td><td align="center">★★★★★</td></tr><tr><td align="center">里氏替换原则</td><td align="center">所有引用基类的地方必须透明地使用其子类对象。或者说，一个可以接收基类对象的地方必然可以接受一个子类对象</td><td align="center">★★★★★</td></tr><tr><td align="center">依赖倒置原则</td><td align="center">针对抽象层编程，而不应针对具体类编程</td><td align="center">★★★★★</td></tr><tr><td align="center">合成-聚合复用原则</td><td align="center">在关系中应尽量多地使用组合和聚合的关联关系，少使用甚至不使用继承关系</td><td align="center">★★★★</td></tr><tr><td align="center">单一职责原则</td><td align="center">类的职责要单一，不能将太多的职责放在一个类中</td><td align="center">★★★★</td></tr><tr><td align="center">迪米特法则</td><td align="center">一个软件实体对其他实体的引用应越少越好。或者说，如果两个类不必彼此直接通信，那么这两个类就不因该发生直接</br>的相互作用，而是通过引入一个第三方发生间接交互</td><td align="center">★★★</td></tr><tr><td align="center">接口隔离原则</td><td align="center">使用多个专门的接口来取代一个统一的接口</td><td align="center">★★</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
